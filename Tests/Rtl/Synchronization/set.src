----------------------------------------------------------------------------------------------------
program sset =
-- Rtl library only
-- Programming Language Flex Samples.
-- Copyright (C) 2003 A && L soft, s.r.o.
----------------------------------------------------------------------------------------------------
with
     flex
    ,flex.thread
    ,flex.synchronization
    ,flex.os_api
    ,flex.memory
    --,testlib
    ,standard
    ,standard.console
    ,standard.conversions
    ;

const
    maxcount       = $40_0000;

var
    wr1            : aliased t_thread_ref;
    wr2            : aliased t_thread_ref;
    re1            : aliased t_thread_ref;
    re2            : aliased t_thread_ref;
    wa1            : aliased t_thread_ref;
    s              : aliased t_rtl_sset;
    wrcounter      : aliased t_rtl_native_signed;
    recounter      : aliased t_rtl_native_signed;
    aproxlen       : aliased t_rtl_native_signed;


----------------------------------------------------------------------------------------------------
procedure simple = 
----------------------------------------------------------------------------------------------------
var
    item           : p_rtl_native_signed;
    len            : t_rtl_native_signed;
    lastwr         : t_rtl_native_signed;
    i              : aliased t_rtl_sset_iterrator;
    j              : aliased t_rtl_sset_iterrator;
    su             : t_rtl_logical8;

begin
  --push
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);

  rtl_sset_start(s,i);
  if rtl_sset_next(s,i,t_rtl_pointer(item)) then
    while rtl_sset_remove(s,i) loop
      end loop;
    end if;
  rtl_sset_stop(s,i);

  rtl_validate_heap;

  new item;  rtl_sset_append(s,item);
  rtl_validate_heap;
  new item;  rtl_sset_append(s,item);
  rtl_validate_heap;
  new item;  rtl_sset_append(s,item);
  rtl_validate_heap;
  
  rtl_sset_start(s,i);
  rtl_validate_heap;
  if rtl_sset_next(s,i,t_rtl_pointer(item)) then
    rtl_validate_heap;
    while rtl_sset_remove(s,i) loop
    rtl_validate_heap;
    end loop;
    end if;
  rtl_sset_stop(s,i);

  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  
  rtl_sset_start(s,i);
  if rtl_sset_next(s,i,t_rtl_pointer(item)) then
    while rtl_sset_remove(s,i) loop
      end loop;
    end if;
  rtl_sset_stop(s,i);

  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  new item;  rtl_sset_append(s,item);
  
  rtl_sset_start(s,i);
  if rtl_sset_next(s,i,t_rtl_pointer(item)) then
    while rtl_sset_remove(s,i) loop
      end loop;
    end if;
  rtl_sset_stop(s,i);
  rtl_sset_start(s,i);
  if rtl_sset_next(s,i,t_rtl_pointer(item)) then
    while rtl_sset_remove(s,i) loop
      end loop;
    end if;
  rtl_sset_stop(s,i);
  rtl_validate_heap;
  end simple;

----------------------------------------------------------------------------------------------------
procedure writet:t_rtl_thread_entry =
----------------------------------------------------------------------------------------------------
var
    oldcounter     : t_rtl_native_signed;
    item           : p_rtl_native_signed;
    len            : t_rtl_native_signed;
    lastcount      : t_rtl_native_signed;

begin
  write_line('write begin');
  loop
    new item;
    rtl_interlocked_inc_out(^aproxlen,len);
    rtl_interlocked_inc_out(^wrcounter,lastcount);
    item^:=lastcount;
    rtl_sset_append(s,item);
    if lastcount>=maxcount then
      break;
      end if;

    -- chytracky zpomalovac
    while aproxlen>$1_0000 loop
      rtl_sleep(0);
      end loop;
    
    end loop;
catch 
  when others do
  write_line('write exception pending');
leave
  write_line('write end');
  end writet;

----------------------------------------------------------------------------------------------------
procedure readt:t_rtl_thread_entry =
----------------------------------------------------------------------------------------------------
var
    item           : p_rtl_native_signed;
    len            : t_rtl_native_signed;
    lastitem       : t_rtl_native_signed;
    lastcount      : t_rtl_native_signed;
    i              : aliased t_rtl_sset_iterrator;
    success        : aliased t_rtl_logical8;

begin
  write_line('read begin');
  loop
    rtl_sset_start(s,i);
    if rtl_sset_next(s,i,t_rtl_pointer(item)) then
      while rtl_sset_remove(s,i,^success) loop
        if success then
          rtl_interlocked_dec_out(^aproxlen,len);
          rtl_interlocked_inc_out(^recounter,lastcount);
          if lastcount>=maxcount then
            return;
            end if;
          end if;
        end loop;
      if success then
        rtl_interlocked_dec_out(^aproxlen,len);
        rtl_interlocked_inc_out(^recounter,lastcount);
        if lastcount>=maxcount then
          return;
          end if;
        end if;
    else
      if recounter>=maxcount then
        return;
        end if;
      --write_line('Sleep');
      if (aproxlen<5) then
        rtl_sleep(0);
        end if;
      end if;
    end loop;
catch 
  when others do
  write_line('read exception pending');
leave
  rtl_sset_stop(s,i);
  write('read end ');
  write_line(signed_to_string(lastitem,false));
  end readt;


----------------------------------------------------------------------------------------------------
procedure watcht:t_rtl_thread_entry =
----------------------------------------------------------------------------------------------------
begin
  loop
    write(signed_to_string(wrcounter,false));
    write(' ');
    write(signed_to_string(recounter,false));
    write(' ');
    write_line(signed_to_string(aproxlen,false));
    rtl_sleep(1000);
    end loop;
leave
  write('watch end ');
  write(signed_to_string(wrcounter,false));
  write(' ');
  write(signed_to_string(recounter,false));
  write(' ');
  write_line(signed_to_string(aproxlen,false));
  end watcht;


----------------------------------------------------------------------------------------------------
-- main
----------------------------------------------------------------------------------------------------

begin
  rtl_sset_new(s,^rtl_sset_free_data_discard);
  wrcounter:=0;
  recounter:=0;
  aproxlen:=0;
  simple;
  wrcounter:=0;
  recounter:=0;
  aproxlen:=0;

  rtl_start_thread(^wa1,^watcht,false,thread_priority_normal,nil);
  rtl_start_thread(^re1,^readt,false,thread_priority_normal,nil);
  rtl_start_thread(^re2,^readt,false,thread_priority_normal,nil);
  rtl_start_thread(^wr1,^writet,false,thread_priority_normal,nil);
  --rtl_start_thread(^wr2,^writet,false,thread_priority_normal,nil);
  --run
  --rtl_sleep(10000);
  rtl_wait_and_finish_thread(wr1);
  --rtl_wait_and_finish_thread(wr2);
  rtl_wait_and_finish_thread(re1);
  rtl_wait_and_finish_thread(re2);
  rtl_kill_when_need_and_finish_thread(wa1);
  rtl_sset_discard(s);
  end sset;
