----------------------------------------------------------------------------------------------------
module private exceptions =
-- Exceptions (asynchronous messages).
-- Flex Run-time Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
--
-- Subprogram stack layout
-- -----------------------
--
--    |   ...      | ^-- to higher addresses
--    +------------+
--    | Ret. value | <-- [EBP+8+Param(N):size+..+Param(1):size]
--    +------------+
--    | Param. 1   | <-- [EBP+8+Param(N):size+..+Param(2):size]
--    +------------+
--    |   ...      |
--    +------------+
--    | Param. n-1 | <-- [EBP+8+Param(N):size]
--    +------------+
--    | Param. n   | <-- [EBP+8]
--    +------------+
--    | Return EIP | <-- [EBP+4]
--    +------------+
--    | Parent EBP | <-- [EBP+0]
--    +============+                 \
--    | Nest 1 EBP | <-- [EBP-4]     |
--    +------------+                 |
--    | Nest 2 EBP | <-- [EBP-8]     |   EBPs of K nested subprograms
--    +------------+                 |   (optional)
--    | ...        |                 |
--    +------------+                 |
--    | Nest K EBP | <-- [EBP-4*K]   /
--    +------------+                 \
--    | Uplink     | <-- [EBP-4]     |
--    +------------+                 |
--    | Handler    | <-- [EBP-8]     |
--    +------------+                 |
--    | CurrExc    | <-- [EBP-12]    |
--    +------------+                 |
--    | CurrTag    | <-- [EBP-16]    |   Exception frame (optional)
--    +------------+                 |
--    | CurrPar    | <-- [EBP-20]    |
--    +------------+                 |
--    | FrameEBP   | <-- [EBP-24]    |
--    +------------+                 |
--    | FrameESP   | <-- [EBP-28]    /
--    +------------+                 \
--    | Action     | <-- [EBP-32]    |
--    +------------+                 |   Return-control frame (optional)
--    | Destination| <-- [EBP-36]    |
--    +============+                 /
--    | Loc. var 1 | <-- [EBP-28[-8]-Locvar(1):size]
--    +------------+
--    |   ...      |
--    +------------+
--    | Loc. var n | <-- [EBP-28[-8]-Locvar(1):size-...-Locvar(n-1):size]
--    +------------+
--    |   ...      | v-- to lower addresses
--
--
-- Note: Param(i):size and Locvar(i):size are aligned to the nearest greater
-- 4-byte boundary
--
--
-- Exception frame purpose and semantics
-- -------------------------------------
--
-- Fields of the Exception frame:
--   Uplink   -- pointer to the innermost enclosing exception handler
--   Handler  -- address of the current (local) exception handler
--   CurrExc  -- currently raised exception (0=no exception raised)
--   CurrTag  -- tag of the currently raised exception's type
--   CurrPar  -- pointer to currently raised exception's parameters
--   FrameEBP -- equal to EBP
--   FrameESP -- equal to EBP+28+locvar(1):size+...+locvar(n-1):size
--
-- For a Block statement, another exception-frame is generated on the stack.
-- It is placed somewhere to the local-variables area. Its position is
-- determined during code-generation.
--
--
-- Return-control frame purpose and semantics
-- ------------------------------------------
--
-- The Return-control frame is generated for nested begin..end blocks only. For the top 
-- level block, there is no need for a Return-control frame. It is used during the execution
-- of jump statements to allow execution of all LEAVE parts between the source statement
-- and the target label. In the top-level block, jump statements behave as commonly expected, 
-- because there can't be any LEAVE parts between the source and the target.
--
-- Fields of the Return-control frame:
--   Action   -- type of action to be performed upon block exit. One of:
--                 -- 0 = Continue -- continue normal execution
--                 -- 1 = Jump n   -- control shall be transferred to the label specified
--                                    in the Destination field
--                 -- 2..n         -- control shall be transferred to the end (to the leave
--                                    part respectively) of the enclosing block
--               Before the action is performed, Action's value shall be decreased by one.
--   Destination -- address of the destionation label
--
--
-- Code templates
-- --------------
--
-- Subprogram code template:
--
--   1. with a leave part:
--
--     1: begin
--     2:   ...
--     3: leave
--     4:   ...
--     5:   end
--
--     1: begin:      push  ebp
--                    mov   ebp,esp
--                    sub   esp,<>
--                    ... set locvars to nil
--                    mov   [ebp-8],@1             -- set handler
--                    call  rtl_init_xframe
--                    ... initialize locvars
--                    mov   [ebp-8],@2             -- set handler
--     2:   ...:      ... statements
--     3: leave:  @2: mov   [ebp-8],@1             -- set handler
--     4:   ...:      ... statements
--     5:   end:  @1: mov   [ebp-8],@3             -- set handler
--                    ... finalize locvars
--                @3: call  rtl_end_xframe         -- also handle pending exceptions
--                    mov   esp,ebp
--                    ret   <paramsize>
--
--   2. with a catch part:
--
--     1: begin
--     2:   ...
--     3: catch
--     4:   when x1 do
--     5:       ...
--     6:   when x2 do
--     7:       ...
--        [ -- optional
--     8:   when others do
--     9:       ...
--        ]
--    10:   end
--
--     1: begin:      push  ebp
--                    mov   ebp,esp
--                    sub   esp,<>
--                    ... set locvars to nil
--                    mov   [ebp-8],@1             -- set handler
--                    call  rtl_init_xframe
--                    ... initialize locvars
--                    mov   [ebp-8],@2             -- set handler
--     2:   ...:      ... statements
--    10:   end:  @1: mov   [ebp-8],@3             -- set handler
--                    ... finalize locvars
--                @3: call  rtl_end_xframe
--                    mov   esp,ebp
--                    ret   <paramsize>
--     3: catch:  @2: mov   [ebp-8],@1             -- set handler
--     4:    x1:      push  <code of x1>
--                    call  rtl_check_code
--                    jc    @5                     -- handle exception x1
--     6:    x2:      push  <code of x2>
--                    call  rtl_check_code
--                    jc    @7                     -- handle exception x2
--        [
--     8: others:     jmp   @9                     -- handle other exceptions
--        | -- else
--                    jmp   @1                     -- continue processing
--        ]
--                @4: call  rtl_discard_exception  -- reset exception
--                    jmp   @1
--     5:   ...:  @5: ... statements
--                    jmp   @4                     -- reset exception
--
--     7:   ...:  @7: ... statements
--                    jmp   @4                     -- reset exception
--        [ -- optional
--     9:   ...:  @9: ... statements
--                    jmp   @4                     -- reset exception
--        ]
--
-- Raise statement:
--   [ -- optional
--       push      <size of message's parameters>
--       call      rtl_init_msg_params
--       pop       eax
--       mov       [eax+0],parameter(1)
--       ...
--       mov       [eax+k],parameter(n)
--   ]
--       push      <exception code>
--       push      <exception tag>
--       push      [ eax | 0 ]
--       call      rtl_raise_exception
--
----------------------------------------------------------------------------------------------------

with 
  messages;

{
----------------------------------------------------------------------------------------------------
procedure tlsalloc return int32;
#pragma convention(tlsalloc,stdcall);
#pragma import(tlsalloc,'TlsAlloc','KERNEL32.DLL');
----------------------------------------------------------------------------------------------------
procedure tlssetvalue (index : int32; value : uint32) return bool32;
#pragma convention(tlssetvalue,stdcall);
#pragma import(tlssetvalue,'TlsSetValue','KERNEL32.DLL');
----------------------------------------------------------------------------------------------------
procedure tlsgetvalue (index : int32) return uint32;
#pragma convention(tlsgetvalue,stdcall);
#pragma import(tlsgetvalue,'TlsGetValue','KERNEL32.DLL');
----------------------------------------------------------------------------------------------------
}

var
  estack           : {%%TODO(task)} t_rtl_pointer;-- per-task exception-frame stack

----------------------------------------------------------------------------------------------------
procedure rtl_init_xframe (
    frameptr       : in t_rtl_pointer);          -- pointer to expcetion frame
#pragma stackframe(rtl_init_xframe,stack_pointer_relative);                        
procedure rtl_init_xframe =
-- Initialization of the calling subprogram's exception-frame.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    mov    edi,[esp+4]    -- exception-frame address
    mov    eax,estack
    mov    edx,0
    mov    [edi+24],eax   -- uplink
 -- set by the compiler
 -- mov    [edi+20],edx   -- handler
    mov    [edi+16],edx   -- currexc
  #if rtl_debug then;
    mov    [edi+12],edx   -- currtag
    mov    [edi+8],edx    -- currpar
  #end if;
    mov    [edi+4],ebp    -- frameebp
    lea    eax,[esp+8]    -- EIP and xframe addr. is pushed on the stack now
    mov    [edi+0],eax    -- frameesp
    mov    estack,edi     -- update exception-frame stack
    #end asm;
  end rtl_init_xframe;


                                                                              
----------------------------------------------------------------------------------------------------
procedure rtl_end_xframe; 
#pragma stackframe(rtl_end_xframe,stack_pointer_relative);
procedure rtl_end_xframe =
-- Destroys the calling subprogram's exception-frame and propagates
-- any pending exception.
----------------------------------------------------------------------------------------------------
var
  msg              : static const string 20 of t_syschar := 'Double Exception'\0;

begin
  #syntax asm;
    -- restore previous exception handler
    mov    esi,estack
    mov    edi,[esi+24]
    mov    estack,edi

    -- any exception pending ?
    mov    eax,[esi+16]
    cmp    eax,0
    jne    @1
    ret    
    
@1:
  #if rtl_debug then;
    -- check handler
    cmp    edi,0
    je     @2
  #end if;

    -- check for double exception
    mov    edx,[edi+16]
    cmp    edx,0
    jne    @3

    -- copy pending exception info
    mov    ebx,[esi+12]
    mov    ecx,[esi+8]
    mov    [edi+16],eax
    mov    [edi+12],ebx
    mov    [edi+8],ecx

    -- restore ESP and EBP
    mov    ebp,[edi+4]
    mov    esp,[edi+0]

    -- jump to the handler
    mov    eax,[edi+20]
    jmp    eax

@3: -- double exception

@2: -- no exception-frame found => unhandled exception
    #end asm;
  rtl_error_write(msg);
  rtl_terminate(10);
  end rtl_end_xframe;



----------------------------------------------------------------------------------------------------
procedure rtl_raise_exception; 
#pragma stackframe(rtl_raise_exception,stack_pointer_relative);
procedure rtl_raise_exception =
-- Raises an exception.
----------------------------------------------------------------------------------------------------
var
  msg              : static const string 20 of t_syschar := 'Raise Error'\0;

begin
  #syntax asm;
    -- check handler
    mov    eax,estack
  #if rtl_debug then;
    cmp    eax,0
    je     @1
  #end if;

    -- set the current exception to the exception-frame
    mov    ebx,[esp+8]         -- exception code
    mov    ecx,[esp+4]         -- exception tag
    mov    edx,[esp+12]        -- exception parameters
    mov    [eax+16],ebx
    mov    [eax+12],ecx
    mov    [eax+8],edx

    -- restore ESP and EBP
    mov    ebp,[eax+4]
    mov    esp,[eax+0]

    -- jump to the handler
    mov    ebx,[eax+20]
    jmp    ebx

@1: -- no exception-frame found => unhandled exception
    #end asm;
  rtl_error_write(msg);
  rtl_terminate(10);
  end rtl_raise_exception;



----------------------------------------------------------------------------------------------------
procedure rtl_discard_exception; 
#pragma stackframe(rtl_discard_exception,stack_pointer_relative);
procedure rtl_discard_exception =
-- Discards currently raised exception.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    mov    edx,0
    mov    eax,estack

    -- reset exception code
    mov    [eax+16],edx        -- exception code
  #if rtl_debug then;
    mov    [eax+12],edx        -- exception tag
  #end if;

    -- free parameters

    #end asm;
  end rtl_discard_exception;



----------------------------------------------------------------------------------------------------
procedure rtl_check_code;
#pragma stackframe(rtl_check_code,stack_pointer_relative);
procedure rtl_check_code =
-- Tests if the given exception code matches the currently raise exception.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    mov    edx,estack
    cmp    [edx+16],eax        -- input in EAX, output in EFLAGS.ZF
    #end asm;
  end rtl_check_code;



----------------------------------------------------------------------------------------------------
procedure rtl_unhandled_exception =
-- Unhandled exception handler.
----------------------------------------------------------------------------------------------------
var
  msg : static const string 20 of t_syschar := 'Unhandled Exception'\0;

begin
  rtl_error_write(msg);
  rtl_terminate(10);
  end rtl_unhandled_exception;



----------------------------------------------------------------------------------------------------
procedure rtl_init_exceptions =
-- Initializes exception handling (cannot use ENTRY).
----------------------------------------------------------------------------------------------------
begin
  -- allocate per-task exception stack
  -- estack:=tlsalloc;
  -- if estack<0 then rtl_terminate(3) end if;
  estack:=nil
  end rtl_init_exceptions;



---- Compiler magic --------------------------------------------------------------------------------
#pragma assign(init_xframe        ,flex.exceptions.rtl_init_xframe);
#pragma assign(end_xframe         ,flex.exceptions.rtl_end_xframe);
#pragma assign(raise_exception    ,flex.exceptions.rtl_raise_exception);
#pragma assign(discard_exception  ,flex.exceptions.rtl_discard_exception);
#pragma assign(check_code         ,flex.exceptions.rtl_check_code);
#pragma assign(unhandled_exception,flex.exceptions.rtl_unhandled_exception);
#pragma assign(init_exceptions    ,flex.exceptions.rtl_init_exceptions);
----------------------------------------------------------------------------------------------------



end exceptions;
