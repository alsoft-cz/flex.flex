----------------------------------------------------------------------------------------------------
module private synchronization =
-- Flex Run-time Library
-- Synchronization Manager
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------


type THANDLE = t_rtl_pointer;
type DWORD   = t_rtl_unsigned32;
type BOOL    = t_rtl_logical8;
type CRITICAL_SECTION = record
    DebugInfo      : t_rtl_pointer;
    LockCount      : t_rtl_unsigned32;
    RecursionCount : t_rtl_unsigned32;
    OwningThread   : THANDLE;
    LockSemaphore  : THANDLE;
    SpinCount      : t_rtl_unsigned32;
    end record;
type LPCRITICAL_SECTION = ^CRITICAL_SECTION;

procedure CreateMutexA(
    lpMutexAttributes : in t_rtl_pointer; 
    bInitialOwner   : in BOOL; 
    lpName          : in t_rtl_pointer)
                      return THANDLE;
#pragma convention(CreateMutexA,system);
#pragma import(CreateMutexA,'CreateMutexA','kernel32.dll');


procedure ReleaseMutex(
    hMutex          : in THANDLE)
                      return BOOL;
#pragma convention(ReleaseMutex,system);
#pragma import(ReleaseMutex,'ReleaseMutex','kernel32.dll');

procedure WaitForSingleObject(
    hHandle         : in THANDLE; 
    dwMilliseconds  : in DWORD)
                      return DWORD;
#pragma convention(WaitForSingleObject,system);
#pragma import(WaitForSingleObject,'WaitForSingleObject','kernel32.dll');


procedure CreateEventA(
    lpEventAttributes : in t_rtl_pointer; 
    bManualReset    : in BOOL; 
    bInitialState   : in BOOL; 
    lpName          : in t_rtl_pointer)
                      return THANDLE;
#pragma convention(CreateEventA,system);
#pragma import(CreateEventA,'CreateEventA','kernel32.dll');

procedure SetEvent(
    hEvent          : in THANDLE)
                      return BOOL;
#pragma convention(SetEvent,system);
#pragma import(SetEvent,'SetEvent','kernel32.dll');


procedure CloseHandle(
    hObject         : in THANDLE)
                      return BOOL;
#pragma convention(CloseHandle,system);
#pragma import(CloseHandle,'CloseHandle','kernel32.dll');

procedure InitializeCriticalSection(
    lpCriticalSection : in LPCRITICAL_SECTION);
#pragma convention(InitializeCriticalSection,system);
#pragma import(InitializeCriticalSection,'InitializeCriticalSection','kernel32.dll');

procedure EnterCriticalSection(
    lpCriticalSection : in LPCRITICAL_SECTION);
#pragma convention(EnterCriticalSection,system);
#pragma import(EnterCriticalSection,'EnterCriticalSection','kernel32.dll');

procedure LeaveCriticalSection(
    lpCriticalSection : in LPCRITICAL_SECTION);
#pragma convention(LeaveCriticalSection,system);
#pragma import(LeaveCriticalSection,'LeaveCriticalSection','kernel32.dll');

procedure DeleteCriticalSection(
    lpCriticalSection : in LPCRITICAL_SECTION);
#pragma convention(DeleteCriticalSection,system);
#pragma import(DeleteCriticalSection,'DeleteCriticalSection','kernel32.dll');

const 
    INFINITE       : t_rtl_unsigned32 = $FFFFFFFF;
    WAIT_FAILED    : t_rtl_unsigned32 = $FFFFFFFF;
    INVALID_HANDLE : t_rtl_unsigned32 = $FFFFFFFF;

----------------------------------------------------------------------------------------------------
procedure rtl_mutex_new =
-- Create and initialize mutex object.
----------------------------------------------------------------------------------------------------
begin
  mutex_object:unchecked:=CreateMutexA(nil,false,nil);
  if t_rtl_unsigned32(mutex_object:unchecked)=INVALID_HANDLE then 
    raise tasking_error;
    end if;
  end rtl_mutex_new;


----------------------------------------------------------------------------------------------------
procedure rtl_mutex_discard =
-- Discard mutex object.
----------------------------------------------------------------------------------------------------
begin
  if not CloseHandle(mutex_object) then 
    raise tasking_error;
    end if;
  t_rtl_unsigned32(mutex_object:unchecked):=INVALID_HANDLE;
  end rtl_mutex_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_mutex_lock =
-- Lock mutex.
----------------------------------------------------------------------------------------------------
begin
  if WaitForSingleObject(THANDLE(mutex_object),INFINITE)=WAIT_FAILED then
    raise tasking_error;
    end if;
  end rtl_mutex_lock;



----------------------------------------------------------------------------------------------------
procedure rtl_mutex_unlock =
-- Unlock mutex.
----------------------------------------------------------------------------------------------------
begin
  if not ReleaseMutex(THANDLE(mutex_object)) then 
    raise tasking_error;
    end if;
  end rtl_mutex_unlock;


----------------------------------------------------------------------------------------------------
procedure rtl_event_new =
-- new event
----------------------------------------------------------------------------------------------------
begin 
  event_object:unchecked:=CreateEventA(nil,false,false,nil);
  if t_rtl_unsigned32(event_object:unchecked)=INVALID_HANDLE then 
    raise tasking_error;
    end if;
  end rtl_event_new;


----------------------------------------------------------------------------------------------------
procedure rtl_event_discard =
-- discard event
----------------------------------------------------------------------------------------------------
begin 
  if not CloseHandle(THANDLE(event_object)) then 
    raise tasking_error;
    end if;
  t_rtl_unsigned32(event_object:unchecked):=INVALID_HANDLE;
  end rtl_event_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_event_wait =
-- wait for event and reset event
----------------------------------------------------------------------------------------------------
begin 
  if WaitForSingleObject(THANDLE(event_object),INFINITE)=WAIT_FAILED then
    raise tasking_error;
    end if;
  end rtl_event_wait;


----------------------------------------------------------------------------------------------------
procedure rtl_event_set =
-- sets event
----------------------------------------------------------------------------------------------------
begin 
  if not SetEvent(THANDLE(event_object)) then 
    raise tasking_error;
    end if;
  end rtl_event_set;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_new =
-- Create and initialize critical object.
----------------------------------------------------------------------------------------------------
begin
  new LPCRITICAL_SECTION(critical_object:unchecked);
  InitializeCriticalSection(LPCRITICAL_SECTION(critical_object:unchecked));
  end rtl_critical_new;

----------------------------------------------------------------------------------------------------
procedure rtl_critical_discard =
-- Discard critical object.
----------------------------------------------------------------------------------------------------
begin
  DeleteCriticalSection(LPCRITICAL_SECTION(critical_object:unchecked));
  discard LPCRITICAL_SECTION(critical_object:unchecked);
  end rtl_critical_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_lock =
-- Lock critical.
----------------------------------------------------------------------------------------------------
begin
  EnterCriticalSection(LPCRITICAL_SECTION(critical_object:unchecked));
  end rtl_critical_lock;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_unlock =
-- Unlock critical.
----------------------------------------------------------------------------------------------------
begin
  LeaveCriticalSection(LPCRITICAL_SECTION(critical_object:unchecked));
  end rtl_critical_unlock;

end synchronization;