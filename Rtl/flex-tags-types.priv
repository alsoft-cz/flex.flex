----------------------------------------------------------------------------------------------------
module private types =
-- Tagged types.
-- Flex Run-time Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
--
-- Type descriptor layout:
--
--     +---------------+                                                          
--     | :size         | +0         \                                             
--     +---------------+            |                                             
--     | data type     | +4         |                                             
--     +---------------+            |                                             
--     | ancestor :tag | +8         |                                             
--     +---------------+            |                                             
--     | ^@init     *) | +12        | all data types                              
--     +---------------+            |                                             
--     | ^entry        | +16        |                                             
--     +---------------+            |                                             
--     | ^exit         | +20        |                                             
--     +---------------+            |                                             
--     | ^adjust       | +24        /                                             
--     +---------------+                                                          
--     | ^virtual_1    | +28        \                                             
--     |    ...        |            | classes only
--     | ^virtual_n    | +28 + 4*n  /                                             
--     +---------------+          
--
--     *) always NIL for classes
--
----------------------------------------------------------------------------------------------------

const
  type_size     = 0;
  type_datatype = 4;
  type_ancestor = 8;
  type_init     = 12;
  type_entry    = 16;
  type_exit     = 20;
  type_adjust   = 24;

type
  -- type descriptor
  t_type_descriptor = {%%TODO with t_entity_descriptor} record
      size         : t_rtl_unsigned32;
      data_type    : t_rtl_unsigned32;
      ancestor     : t_rtl_tag;
      spec_init    : t_rtl_pointer;
      spec_entry   : t_rtl_pointer;
      spec_exit    : t_rtl_pointer;
      spec_adjust  : t_rtl_pointer;
      end record;
  p_type_descriptor = ^t_type_descriptor;



----------------------------------------------------------------------------------------------------
procedure rtl_call_init (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_call_init,stack_pointer_relative);
procedure rtl_call_init =
-- Calls the INIT method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load :TAG
    mov    eax,[eax]
    -- load ^INIT
@2: mov    edx,[eax+12]
    cmp    edx,0
    je     @1
    -- call INIT
    jmp    edx
@1: -- load parent :TAG
    mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    jmp    @2
@3:
    #end asm;
  end rtl_call_init;



----------------------------------------------------------------------------------------------------
procedure rtl_call_entry (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_call_entry,stack_pointer_relative);
procedure rtl_call_entry =
-- Calls the ENTRY method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load :TAG
    mov    eax,[eax]
    -- load ^ENTRY
@2: mov    edx,[eax+16]
    cmp    edx,0
    je     @1
    -- call ENTRY
    jmp    edx
@1: -- load parent :TAG
    mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    jmp    @2
@3:
    #end asm;
  end rtl_call_entry;



----------------------------------------------------------------------------------------------------
procedure rtl_call_exit (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_call_exit,stack_pointer_relative);
procedure rtl_call_exit =
-- Calls the EXIT method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load :TAG
    mov    eax,[eax]
    -- load ^EXIT
@2: mov    edx,[eax+20]
    cmp    edx,0
    je     @1
    -- call EXIT
    jmp    edx
@1: -- load parent :TAG
    mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    jmp    @2
@3:
    #end asm;
  end rtl_call_exit;



----------------------------------------------------------------------------------------------------
procedure rtl_call_adjust (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_call_adjust,stack_pointer_relative);
procedure rtl_call_adjust =
-- Calls the adjust method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load :TAG
    mov    eax,[eax]
    -- load ^ADJUST
@2: mov    edx,[eax+24]
    cmp    edx,0
    je     @1
    -- call ADJUST
    jmp    edx
@1: -- load parent :TAG
    mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    jmp    @2
@3:
    #end asm;
  end rtl_call_adjust;



----------------------------------------------------------------------------------------------------
procedure rtl_ancestor_init (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_ancestor_init,stack_pointer_relative);
procedure rtl_ancestor_init =
-- Calls the INIT method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load ancestor :TAG
@1: mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    -- load ^INIT
@2: mov    edx,[eax+12]
    cmp    edx,0
    je     @1
    -- call INIT
    jmp    edx
@3:
    #end asm;
  end rtl_ancestor_init;



----------------------------------------------------------------------------------------------------
procedure rtl_ancestor_entry (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_ancestor_entry,stack_pointer_relative);
procedure rtl_ancestor_entry =
-- Calls the ENTRY method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load ancestor :TAG
@1: mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    -- load ^ENTRY
@2: mov    edx,[eax+16]
    cmp    edx,0
    je     @1
    -- call ENTRY
    jmp    edx
@3:
    #end asm;
  end rtl_ancestor_entry;



----------------------------------------------------------------------------------------------------
procedure rtl_ancestor_exit (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_ancestor_exit,stack_pointer_relative);
procedure rtl_ancestor_exit =
-- Calls the EXIT method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load ancestor :TAG
@1: mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    -- load ^EXIT
@2: mov    edx,[eax+20]
    cmp    edx,0
    je     @1
    -- call EXIT
    jmp    edx
@3:
    #end asm;
  end rtl_ancestor_exit;



----------------------------------------------------------------------------------------------------
procedure rtl_ancestor_adjust (
    instance       : in t_rtl_pointer);
#pragma stackframe(rtl_ancestor_adjust,stack_pointer_relative);
procedure rtl_ancestor_adjust =
-- Calls the ADJUST method.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- class address
    mov    eax,[esp+4]
    -- load ancestor :TAG
@1: mov    eax,[eax+8]
    -- don't care about non-tagged types
    cmp    eax,0
    je     @3
    -- load ^ADJUST
@2: mov    edx,[eax+24]
    cmp    edx,0
    je     @1
    -- call ADJUST
    jmp    edx
@3:
    #end asm;
  end rtl_ancestor_adjust;



#if #declared ondra; then;
----------------------------------------------------------------------------------------------------
procedure rtl_is_ancestor (
    A              : in t_rtl_tag;
    _B             : in t_rtl_tag)
    return t_rtl_logical32 =
-- Checks whether A is an ancestor of B (A < B).
----------------------------------------------------------------------------------------------------
var
  B                : t_rtl_tag;

begin
  B:=_B;
  while B<>nil loop
    B:=p_type_descriptor(B:unchecked)^.ancestor;
    if A=B then 
      break;
      end if;
    end loop;
  result:=B<>nil;
  end rtl_is_ancestor;



----------------------------------------------------------------------------------------------------
procedure rtl_is_ancestor_or_equal (
    A              : in t_rtl_tag;
    B              : in t_rtl_tag)
    return t_rtl_logical32 =
-- Checks whether A is an ancestor of B or they are equal (A <= B).
----------------------------------------------------------------------------------------------------
var
  B                : t_rtl_tag;

begin
  B:=_B;
  while B<>nil and then A<>B loop
    B:=p_type_descriptor(B:unchecked)^.ancestor;
    end loop;
  result:=B<>nil;
  end rtl_is_ancestor_or_equal;



----------------------------------------------------------------------------------------------------
procedure rtl_is_descendant (
    _A             : in t_rtl_tag;
    B              : in t_rtl_tag)
    return t_rtl_logical32 =
-- Checks whether A is a descendant of B (A > B).
----------------------------------------------------------------------------------------------------
var
  _A               : t_rtl_tag;

begin
  A:=_A;
  while A<>nil loop
    A:=p_type_descriptor(A:unchecked)^.ancestor;
    if A=B then 
      break;
      end if;
    end loop;
  result:=A<>nil;
  end rtl_is_descendant;



----------------------------------------------------------------------------------------------------
procedure rtl_is_descendant_or_equal (
    _A             : in t_rtl_tag;
    B              : in t_rtl_tag)
    return t_rtl_logical32 =
-- Checks whether A is a descendant of B or they are equal (A >= B).
----------------------------------------------------------------------------------------------------
var
  A                : t_rtl_tag;

begin
  A:=_A;
  while A<>nil and then A<>B loop
    A:=p_type_descriptor(A:unchecked)^.ancestor;
    end loop;
  result:=A<>nil;
  end rtl_is_descendant_or_equal;
#end if;



---- Compiler magic --------------------------------------------------------------------------------
#pragma assign(call_init             ,flex.tags.types.rtl_call_init             );
#pragma assign(call_entry            ,flex.tags.types.rtl_call_entry            );
#pragma assign(call_exit             ,flex.tags.types.rtl_call_exit             );
#pragma assign(call_adjust           ,flex.tags.types.rtl_call_adjust           );
#pragma assign(ancestor_init         ,flex.tags.types.rtl_ancestor_init         );
#pragma assign(ancestor_entry        ,flex.tags.types.rtl_ancestor_entry        );
#pragma assign(ancestor_exit         ,flex.tags.types.rtl_ancestor_exit         );
#pragma assign(ancestor_adjust       ,flex.tags.types.rtl_ancestor_adjust       );
#if #declared ondra; then;
#pragma assign(is_ancestor           ,flex.tags.types.rtl_is_ancestor           );
#pragma assign(is_ancestor_or_equal  ,flex.tags.types.rtl_is_ancestor_or_equal  );
#pragma assign(is_descendant         ,flex.tags.types.rtl_is_descendant         );
#pragma assign(is_descendant_or_equal,flex.tags.types.rtl_is_descendant_or_equal);
#end if;
----------------------------------------------------------------------------------------------------



end types;