----------------------------------------------------------------------------------------------------
module private ca_type =
-- P©eklada‡ Flexu.
-- Generov n¡ podprogram– pro inicializaci a finalizaci typ–.
----------------------------------------------------------------------------------------------------
-- Ondra : 18.06.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_var,
  cc_base,
  cc_base.cc_sym,
  cc_base.cc_type,
  cc_attr,
  cd_decl,
  cd_decl.cd_create,
  cd_decl.cd_util,
  cb_block,
  cb_block.cb_make,
  cx_expr,
  cx_expr,cx_expr.cx_make,
  ca_util;

----------------------------------------------------------------------------------------------------
procedure a_make_subprogram (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    ptype          : in tentitytype;             -- typ symbolu
    id_proc        : in pentityident;            -- identifik tor procedury
    id_param       : in pentityident;            -- identifik tor parametru
    pproc          : out pentity_subprogram;     -- vytvo©en  procedura
    pproc_context  : out tcontext) =             -- kontext vytvo©en‚ procedury
-- Vytvo©¡ proceduru s jedn¡m in out parametrem zadan‚ho typu.
----------------------------------------------------------------------------------------------------
var
  pproctyp         : pentity_type;               -- typ procedury
  pproctyp_context : tcontext;                   -- kontext typu procedury
  pparam           : pentity_param;              -- parametr procedury
  pparam_context   : tcontext;                   -- kontext parametru procedury

begin
  -- vytvo©it proceduru
  d_create_internal(sym_primary_context(typ),pentity(pproc),pproc_context,ptype,id_proc);

  -- typ procedury
  d_create_internal(pproc_context,pentity(pproctyp),pproctyp_context,et_type,nil);

  -- doplnit z kladn¡ £daje
  pproctyp^.tkind:=tk_singular;
  pproctyp^.stype:=dt_procedure;
  pproctyp^.parcount:=1;

  -- asociovat s procedurou
  pproc^.typ.settype(pproctyp);

  -- parametr
  d_create_internal(pproctyp_context,pentity(pparam),pparam_context,et_param,id_param);

  -- doplnit z kladn¡ £daje
  pparam^.mode:=pm_inout;
  pparam^.pass:=pp_ref;
  pparam^.typ.settype(^typ);

  -- konec deklarace parametru
  d_end_internal(pparam^,true);

  -- konec deklarace typu procedury
  d_end_internal(pproctyp^,true);

  -- dal¨¡ ‡ st deklarace
  d_next_internal(pproc^);

  -- vygenerovat podle parametr– lok ln¡ promˆnn‚
  p_genlocvar(pproc^);
  end a_make_subprogram;



----------------------------------------------------------------------------------------------------
procedure a_type_prepare (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype;               -- typ speci ln¡ metody
    ancestor       : in t_logical;               -- T-volat odpov¡daj¡c¡ metodu p©edka
    binfo          : out blinfo;                 -- kontext generov n¡ p©¡kaz–
    xinfo          : out expinfo;                -- kontext generov n¡ v˜razu
    pproc          : out pentity_special;        -- vygenerovan  procedura
    pproc_context  : out tcontext;               -- kontext vytvo©en‚ procedury
    pvar           : out pentity_var;            -- parametr procedury
    bl             : out pblblock;               -- blok p©¡kaz–
    initvars       : out t_logical) =            -- T-inicializovat jednotliv‚ prom.
-- P©iprav¡ speci ln¡ metodu
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;      -- hled tko

begin
  if typ.derive=td_private_extension then
    unimplemented(193);
    end if;

  -- vytvo©it podprogram
  a_make_subprogram(typ,et_special,tspectypeid[tst],^id_int_param,pentity_subprogram(pproc),pproc_context);

  -- ur‡it typ objektu, ke kter‚mu se metoda vztahuje
  pproc^.specobj:=tso_type;

  -- za©adit do tabulky speci ln¡ch metod
  typ.stable[tst].setentity(pproc);

  -- dohledat promˆnnou odpov¡daj¡c¡ parametru
  srch.find_local_all(pproc_context,id_int_param);
  verify(561,(srch.psym=nil) or (srch.psym^.etype<>et_var));
  pvar:=pentity_var(srch.psym);

  -- inicializovat kontexty generov n¡ p©¡kaz– a v˜raz–
  a_prepare_info(binfo,xinfo);

  -- vytvo©it pr zdn˜ blok
  bl:=b_make_block(pproc_context,binfo);

  -- asociovat s procedurou
  pproc^.bl.setblock(bl);

  -- zavolat odpov¡daj¡c¡ metodu p©edka
  if ancestor and typ.ancestor.isset and pentity_type(typ.ancestor.getcentity)^.stable[tst].isset then
    a_list_append(bl^.sub,
      a_type_make_call(pproc_context,binfo,xinfo,tst,pentity_type(typ.ancestor.getcentity)^,
        x_make_component_var(pproc_context,xinfo,pvar)
        )
      );
    end if;

  -- nen¡ k dispozici po‡ te‡n¡ hodnota pro cel˜ typ ?
  if tst=tst_init and typ.init.isset

    -- ano => pou‘¡t
    then
      -- p©i©adit
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            x_make_component_var(pproc_context,xinfo,pvar),
            x_make_imm(pproc_context,xinfo,^typ,typ.init.getimm^,iek_none)
            )
          )
        );

      -- jednotliv‚ promˆnn‚ u‘ nebudeme inicializovat
      initvars:=false;

    -- ne => nechat to tak a pou‘¡t hodnoty jednotliv˜ch promˆnn˜ch
    else 
      initvars:=true;
      end if;
  end a_type_prepare;



----------------------------------------------------------------------------------------------------
procedure a_type_class_entry =
-- Inicializace instance t©¡dy a vol n¡ ENTRY.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko
  ptag             : pentity_var;                -- slo‘ka @TAG
  pstatus          : pentity_var;                -- slo‘ka @STATUS

begin
  verify(563,ptyp^.etype<>et_class);

  -- naj¡t intern¡ slo‘ky @TAG a @STATUS
  srch.find_local(sym_primary_context(ptyp^),id_int_tag   ,etvs_all); ptag   :=pentity_var(srch.psym);
  srch.find_local(sym_primary_context(ptyp^),id_int_status,etvs_all); pstatus:=pentity_var(srch.psym);
  verify(564,(ptag=nil) or (pstatus=nil));

  -- Instance.@TAG := typ:tag
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_op_assign(curr,xinfo,
        x_make_component_selector(curr,xinfo,ptag,
          prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)}
          ),
        x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag{ata_expr_tag},inttype_tag,
          x_make_component_type(curr,xinfo,ptyp)
          )
        )
      )
    );

  -- Instance.ENTRY
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_spec(curr,xinfo,tst_entry,nil,
        prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)},
        nil
        )
      )
    );

  -- Instance.@STATUS := STATUS_INITED
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_op_assign(curr,xinfo,
        x_make_component_selector(curr,xinfo,pstatus,
          prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)}
          ),
        x_make_imm_uniint(curr,xinfo,cpu^.status_inited)
        )
      )
    );
  end a_type_class_entry;



----------------------------------------------------------------------------------------------------
procedure a_type_class_exit =
-- Finalizace instance t©¡dy - vol n¡ EXIT.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko
  pstatus          : pentity_var;                -- slo‘ka @STATUS

begin
  verify(569,ptyp^.etype<>et_class);

  -- naj¡t intern¡ slo‘ku @STATUS
  srch.find_local(sym_primary_context(ptyp^),id_int_status,etvs_all); pstatus:=pentity_var(srch.psym);
  verify(570,pstatus=nil);

  -- if Instance.@STATUS = STATUS_INITED then
  --   Instance.EXIT;
  --   end if;
  a_list_append(list,
    b_make_if(curr,binfo,
      b_make_list(
        b_make_if_cond(curr,binfo,
          x_make_op_eq(curr,xinfo,
            x_make_component_selector(curr,xinfo,pstatus,
              prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)}
              ),
            x_make_imm_uniint(curr,xinfo,cpu^.status_inited)
            ),
          b_make_list(
            b_make_cmd(curr,binfo,
              x_make_call_spec(curr,xinfo,tst_exit,nil,
                prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)},
                nil
                )
              ),
            nil
            )
          ),
        nil
        )
      )
    );
  end a_type_class_exit;



----------------------------------------------------------------------------------------------------
procedure a_type_class_adjust =
-- Adjust instance t©¡dy - vol n¡ ADJUST.
----------------------------------------------------------------------------------------------------
begin
  --unimplemented(198);

  -- Instance.ADJUST
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_spec(curr,xinfo,tst_adjust,nil,
        prefix^(curr,data,ptyp,xinfo) {x_make_component_var(curr,xinfo,pvar)},
        nil
        )
      )
    );
  end a_type_class_adjust;



----------------------------------------------------------------------------------------------------
procedure a_make_action_on_prefix (
    pproc          : in pentity_special;         -- mate©sk  speci ln¡ metoda
    pproc_context  : in tcontext;                -- kontext mate©sk‚ speci ln¡ metody
    ptyp           : in pentity_type;            -- typ prefixu
    tst            : in tspectype;               -- typ speci ln¡ metody
    destbl         : in out bllist;              -- blok, do kter‚ho p©¡kaz za©adit
    prefix         : in pprefixproc;             -- konstruktor prefixu
    data           : in unchecked;               -- dopl¤uj¡c¡ £daje
    binfo          : in blinfo;                  -- kontext generov n¡ p©¡kaz–
    xinfo          : in expinfo) =               -- kontext generov n¡ v˜razu
-- Pro zadan˜ prefix a vygeneruje akci vol n¡ po‘adovan‚ speci ln¡ metody.
----------------------------------------------------------------------------------------------------
begin
  -- vygenerovat vlastn¡ akci v z vislosti na typu speci ln¡ metody
  case tst
    -- inicializace - p©i©azen¡ po‡ te‡n¡ hodnoty
    when tst_init do
        -- nic nedˆlat, proto‘e p©i©azen¡ po‡ te‡n¡ hodnoty ji‘ probˆhlo
        -- mimo tuto proceduru

    -- entry/exit/adjust - vol n¡ speci ln¡ metody
    when tst_entry, tst_exit, tst_adjust do
        -- nen¡ slo‘ka dokonce sama instanc¡ t©¡dy ?
        if ptyp^.stype=dt_class then
          case tst
            when tst_entry  do a_type_class_entry (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_exit   do a_type_class_exit  (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_adjust do a_type_class_adjust(pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when others do verify(568,true);
            end case;

        -- pokud obsahuje t©¡du a p©¡slu¨nou metodu, zavolat ji (pokud neobsahuje t©¡du, ale
        -- m  p©¡slu¨nou metodu, nen¡ nutn‚ ji volat, proto‘e stejnˆ obsahuje jen p©i©azen¡
        -- po‡ te‡n¡ hodnoty, kter‚ jsme provedli p©ed chv¡l¡ (mimo tuto proceduru).
        elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
          -- Instance.Item:entry()
          a_list_append(destbl,
            a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,
              prefix^(pproc_context,data,ptyp,xinfo)
              )
            );
          end if;

    when others do verify(567,true);
    end case;
  end a_make_action_on_prefix;



type
  -- dopl¤uj¡c¡ parametry pro gener tor prefixu slo‘ky recordu
  tprefixrecord    = record
      pvar         : pentity_var;            -- promˆnn 
      pitem        : pentity_var;            -- slo‘ka recordu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_record : tprefixproc =
-- Generov n¡ prefixu slo‘ky recordu.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_selector(curr,xinfo,pentity_var(tprefixrecord(_data).pitem),
            x_make_component_var(curr,xinfo,tprefixrecord(_data).pvar)
            );
  end a_make_prefix_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype) =             -- typ speci ln¡ metody
-- Vygeneruje pro zadan˜ typ po‘adovanou speci ln¡ metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovan  procedura
  pproc_context    : tcontext;                   -- kontext vygenerovan‚ procedury
  ptyp             : pentity_type;               -- typ slo‘ky
  binfo            : blinfo;                     -- kontext generov n¡ p©¡kaz–
  xinfo            : expinfo;                    -- kontext generov n¡ v˜razu
  bl               : pblblock;                   -- blok p©¡kaz–
  initvars         : t_logical;                  -- T-inicializovat jednotliv‚ prom.
  x_imm            : pexpimm;                    -- po‡ te‡n¡ hodnota promˆnn‚
  data             : tprefixrecord;              -- data pro generov n¡ prefixu
  srch             : tentitysearch;              -- hled tko

begin
  verify(565,typ.stype<>dt_record);

  -- p©ipravit speci ln¡ metodu
  a_type_prepare(typ,tst,true,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- prol‚zt v¨echny slo‘ky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou slo‘ku
    data.pitem:=srch.psym;

    -- pro zjednodu¨en¡ zjistit typ slo‘ky
    ptyp:=pentity_var(data.pitem)^.typ.getctype;

    -- analyzovat typ slo‘ky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- p©i©adit po‡ te‡n¡ hodnotu
    if tst=tst_init and then initvars and then (data.pitem^.init.isset or ptyp^.init.isset) then
      -- p©ipravit p©¡mou hodnotu p©¡kaz
      if data.pitem^.init.isset

        -- p©ednost m  po‡ te‡n¡ hodnota promˆnn‚
        then 
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pitem^.init.getimm^,iek_none)

        -- po‡ te‡n¡ promˆnn‚ typu
        else
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_none)
          end if;

      -- Instance.Item := <imm>
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            a_make_prefix_record(pproc_context,data,ptyp,xinfo),
            x_imm
            )
          )
        );
      end if;

    -- zavolat speci ln¡ metodu
    a_make_action_on_prefix(pproc,pproc_context,ptyp,tst,bl^.sub,^a_make_prefix_record,data,binfo,xinfo);

{  Ondra 23.1.2003 : P–vodn¡ verze kombinuj¡c¡ p©i©azen¡ po‡ te‡n¡ hodnoty
   a voln n¡ speci ln¡ metody. Rozdˆleno, zobecnˆno a oddˆleno do
   [a_make_action_on_prefix] pou‘iteln‚ho i z a_type_array a dal¨¡ch procedur.

    -- vygenerovat vlastn¡ akci v z vislosti na typu speci ln¡ metody
    case tst
      -- inicializace - p©i©azen¡ po‡ te‡n¡ hodnoty
      when tst_init do
          -- p©i©adit po‡ te‡n¡ hodnotu
          if initvars and (data.pvar^.init.isset or ptyp^.init.isset) then
            -- p©ipravit p©¡mou hodnotu p©¡kaz
            if data.pvar^.init.isset

              -- p©ednost m  po‡ te‡n¡ hodnota promˆnn‚
              then 
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pvar^.init.getimm^,iek_none)

              -- po‡ te‡n¡ promˆnn‚ typu
              else
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_none)
                end if;

            -- Instance.Item := <imm>
            a_list_append(bl^.sub,
              b_make_cmd(pproc_context,binfo,
                x_make_op_assign(pproc_context,xinfo,
                  a_make_prefix_record(pproc_context,data,ptyp,xinfo),
                  x_imm
                  )
                )
              );
            end if;

      -- entry/exit/adjust - vol n¡ speci ln¡ metody
      when tst_entry, tst_exit, tst_adjust do
          -- nen¡ slo‘ka dokonce sama instanc¡ t©¡dy ?
          if ptyp^.stype=dt_class then
            case tst
              when tst_entry  do a_type_class_entry (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_exit   do a_type_class_exit  (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_adjust do a_type_class_adjust(pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo)
              when others do verify(568,true);
              end case;

          -- pokud obsahuje t©¡du a p©¡slu¨nou metodu, zavolat ji (pokud neobsahuje t©¡du, ale
          -- m  p©¡slu¨nou metodu, nen¡ nutn‚ ji volat, proto‘e stejnˆ obsahuje jen p©i©azen¡
          -- po‡ te‡n¡ hodnoty, kter‚ jsme provedli p©ed chv¡l¡.
          elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
            -- Instance.Item:entry()
            a_list_append(bl^.sub,
              a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,
                a_make_prefix_record(pproc_context,data,ptyp,xinfo)
                )
              );
            end if;

      when others do verify(567,true);
      end case;
}
    -- dal¨¡ slo‘ka
    srch.find_et_next;
    end loop;

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovan˜ symbol
-- Vyhodnot¡, zda je pot©eba pro zadan˜ typ komplexn¡ inicializace.
-- P©i t‚ p©¡le‘itosti sou‡asnˆ analyzuje typy v¨ech slo‘ek recordu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko
  pitem            : pentity_var;                -- slo‘ka recordu
  ptyp             : pentity_type;               -- typ slo‘ky
  complex          : t_logical;                  -- syntetick˜ p©¡znak komplexn¡ inicializace
                                                 -- vypo‡ten˜ z £daj– o slo‘k ch recordu

begin
  -- prol‚zt v¨echny slo‘ky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou slo‘ku
    pitem:=srch.psym;

    -- pro zjednodu¨en¡ zjistit typ slo‘ky
    ptyp:=pitem^.typ.getctype;

    -- analyzovat typ slo‘ky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- komplexn¡ inicializace je vy‘adov na, jestli‘e alespo¤ jedna slo‘ka nebo jej¡ typ m  
    -- po‡ te‡n¡ hodnotu nebo je komplexn¡ inicializace vy‘adov na pro jej¡ typ
    complex or pitem^.init.isset or ptyp^.tinit=ti_complex or ptyp^.init.isset;

    -- dal¨¡ slo‘ka
    srch.find_et_next;
    end loop;

  -- komplexn¡ inicializace recordu je vy‘adov na, je-li vy‘adov na alespo¤ pro jednu slo‘ku nebo
  -- m  record po‡ te‡n¡ hodnotu
  if complex or typ.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_record_resolve_complex;



type
  -- dopl¤uj¡c¡ parametry pro gener tor prefixu slo‘ky pole
  tprefixarray     = record
      pvar         : pentity_var;                -- promˆnn 
      for_var      : pentity_var;                -- ©¡d¡c¡ promˆnn  cyklu
      for_region   : pregion;                    -- region ©¡d¡c¡ promˆnn‚ cyklu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_array : tprefixproc =
-- Generov n¡ prefixu slo‘ky pole.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_index(curr,xinfo,
            x_make_component_var(curr,xinfo,tprefixarray(_data).pvar),
            x_make_component_var(curr,xinfo,tprefixarray(_data).for_var)
            );
  end a_make_prefix_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype) =             -- typ speci ln¡ metody
-- Vygeneruje pro zadan˜ typ po‘adovanou speci ln¡ metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovan  procedura
  pproc_context    : tcontext;                   -- kontext vygenerovan‚ procedury
  ptyp             : pentity_type;               -- typ b ze pole
  binfo            : blinfo;                     -- kontext generov n¡ p©¡kaz–
  xinfo            : expinfo;                    -- kontext generov n¡ v˜razu
  bl               : pblblock;                   -- blok p©¡kaz–
  blfor            : pblfor;                     -- for cyklus
  initvars         : t_logical;                  -- T-inicializovat jednotliv‚ prom.
  data             : tprefixarray;               -- data pro generov n¡ prefixu
  for_loop_context : tcontext;                   -- kontext FOR cyklu
  for_var_context  : tcontext;                   -- kontext ©¡d¡c¡ promˆnn‚ cyklu

begin
  verify(566,typ.stype not in tdatatypeset:[dt_array,dt_uarray]);

  -- p©ipravit speci ln¡ metodu
  a_type_prepare(typ,tst,false,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- zjistit si b zov˜ typ pole
  ptyp:=typ.base.getctype;

{ Tohle za n s ji‘ udˆlalo [a_type_array_resolve_complex].
  -- analyzovat b zov˜ typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;
}
  -- vznikl nov˜ deklarativn¡ region
  d_create_region(pproc_context,data.for_region,for_loop_context);

  -- zalo‘it ©¡d¡c¡ promˆnnou cyklu
  d_create_internal(for_loop_context,pentity(data.for_var),for_var_context,et_var,^id_int_forvar);
  data.for_var^.typ.settype(typ.srange.getctype);
  data.for_var^.mclass:=mc_auto;
  data.for_var^.vmode:=vm_direct;
  data.for_var^.vaccess:=va_const;
  d_end_internal(data.for_var^,true);

  -- for @I in @PARAM:range loop
  blfor:=b_make_for(for_loop_context,binfo,data.for_var,data.for_region,bfo_normal,
    x_make_component_type(for_loop_context,xinfo,typ.srange.getctype)
    );
  a_list_append(bl^.sub,blfor);

  -- zavolat speci ln¡ metodu
  a_make_action_on_prefix(pproc,for_loop_context,ptyp,tst,blfor^.sub,^a_make_prefix_array,data,binfo,xinfo);

  --unimplemented(199);

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovan˜ symbol
-- Vyhodnot¡, zda je pot©eba pro zadan˜ typ komplexn¡ inicializace.
-- P©i t‚ p©¡le‘itosti sou‡asnˆ analyzuje b zov˜ typ pole.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;               -- typ b ze pole

begin
  -- zjistit si b zov˜ typ pole
  ptyp:=typ.base.getctype;

  -- analyzovat b zov˜ typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;

  -- komplexn¡ inicializaci se prov d¡ v p©¡padˆ, ‘e m  typ pole nebo jeho b ze po‡ te‡n¡ hodnotu
  if typ.init.isset or ptyp^.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_array_resolve_complex;



----------------------------------------------------------------------------------------------------
procedure a_type =
-- Anal˜za typu. Pokud je to pot©eba, tak vygeneruje podprogramy pro
-- inicializaci, finalizaci a adjustment zadan‚ho typu.
----------------------------------------------------------------------------------------------------
with
  standard,console;

begin
  verify(576,typ.etype<>et_type);

  -- analyzovat jen dosud neanalyzovan‚ symboly
  if typ.analyzed<>as_none then return; end if;

  -- symbol je pr vˆ analyzov n
  typ.analyzed:=as_analyzing;

  -- analyzovat p©edka
  if typ.ancestor.isset then
    -- analyzovat p©edka
    a_type(pentity_type(typ.ancestor.getcentity)^);

    -- p©evz¡t p©¡znak komplexn¡ inicializace (t¡mto zp–sobem se zajist¡
    -- komplexn¡ inicializace nap©¡klad pro jednoduch‚ typy odvozen‚ jako
    -- private extension od komplexn¡ch typ–)
    if pentity_type(typ.ancestor.getcentity)^.tinit<>ti_normal then
      typ.tinit:=pentity_type(typ.ancestor.getcentity)^.tinit;
      end if;
    end if;

  -- vygenerovat speci ln¡ metody tohoto typu
  case typ.stype
    -- pole, neomezen‚ pole
    when dt_array, dt_uarray do
        -- vyhodnotit, jestli je pro tento typ po‘adov na komplexn¡ inicializace
        a_type_array_resolve_complex(typ);

        -- INIT
        if typ.tinit=ti_complex then
          a_type_array(typ,tst_init);
          end if;

        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_array(typ,tst_entry);

          -- EXIT
          a_type_array(typ,tst_exit);

          -- ADJUST
          a_type_array(typ,tst_adjust);
          end if;

    -- ©etˆzec, neomezen˜ ©etˆzec
    when dt_string, dt_ustring do
        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          write_line(sym_get_qid(^typ));

          --unimplemented(200);
      {
          -- INIT
          a_type_string(typ,tst_init);

          -- ENTRY se negeneruje, proto‘e ©etˆzec t©¡d vznik  v‘dy pr zdn˜ a jin˜ p©¡pad nenastane
          v ‘nˆ??? a co vno©en‚ t©¡dy?
          a_type_string(typ,tst_entry);

          -- EXIT
          a_type_string(typ,tst_exit);

          -- ADJUST
          a_type_string(typ,tst_adjust);
      }
          end if;

    -- record
    when dt_record do
        -- vyhodnotit, jestli je pro tento typ po‘adov na komplexn¡ inicializace
        a_type_record_resolve_complex(typ);

        -- INIT
        if typ.tinit=ti_complex then
          a_type_record(typ,tst_init);
          end if;

        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_record(typ,tst_entry);

          -- EXIT
          a_type_record(typ,tst_exit);

          -- ADJUST
          a_type_record(typ,tst_adjust);
          end if;

    -- t©¡da
    when dt_class     do -- nic nedˆlat, to se ©e¨¡ p©¡mo

    -- v¨echny ostatn¡ typy
    when others do
    {
        -- INIT
        a_type_others(typ,tst_init);

        -- ENTRY
        a_type_others(typ,tst_entry);

        -- EXIT
        a_type_others(typ,tst_exit);

        -- ADJUST
        a_type_others(typ,tst_adjust);
    }

    end case;

  -- symbol byl analyzov n
  typ.analyzed:=as_analyzed;
  end a_type;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_qualified =
-- Sestav¡ kvalifikovan‚ vol n¡ podprogramu pro inicializace, finalizace nebo
-- adjustment zadan‚ho typu/t©¡dy.
----------------------------------------------------------------------------------------------------
var
  x_param          : pexpitem;
  srch             : tentitysearch;
  typ_context      : tcontext;

begin
  verify(562,not typ.stable[tst].isset);

  -- pro zjednodu¨en¡ si sestavit kontext typu
  typ_context:=sym_primary_context(typ);

  -- budou nˆjak‚ parametry ?
  if instance<>nil

    -- hodnotu m me k dispozici => dohledat parametr
    then
      -- dohledat parametr
      srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_param);
      verify(579,(srch.psym=nil) or (srch.psym^.etype<>et_param));

      -- sestavit v˜raz
      x_param:=x_make_param(typ_context,xinfo,instance,pentity_param(srch.psym));

    -- ‘ dn‚ parametry nebudou
    else
      x_param:=nil;
      end if;

  -- sestavit p©¡kaz
  result:=b_make_cmd(typ_context,binfo,
    x_make_call_spec(typ_context,xinfo,tst,pentity_special(typ.stable[tst].getcentity),
      prefix,
      x_param
      )
    );
  end a_type_make_call_qualified;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call =
-- Sestav¡ vol n¡ podprogramu pro inicializace, finalizace nebo adjustment
-- zadan‚ho typu.
----------------------------------------------------------------------------------------------------
begin
  verify(623,typ.stype=dt_class);

  -- zavolat
  result:=a_type_make_call_qualified(typ,binfo,xinfo,tst,nil,instance);
  end a_type_make_call;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_ancestor =
-- Sestav¡ vol n¡ podprogramu pro inicializace, finalizace nebo adjustment
-- p©edka zadan‚ho typu. Dohled  prvn¡ speci ln¡ metodu v hierarchii p©edk–.
-- Pokud ‘ dnou nenalezne, ‘ dn‚ vol n¡ nevygeneruje.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity_type;               -- p©edek

begin
  verify(622,typ.stype<>dt_class);

  -- dohledat metodu p©edka
  ancestor:=pentity_type(typ.ancestor.getuentity);
  while (ancestor<>nil) and then not ancestor^.stable[tst].isset loop 
    ancestor:=pentity_type(ancestor^.ancestor.getuentity);
    end loop;

  -- nenalezlo-li se, tak se nic generovat nebude
  if ancestor=nil then
    result:=nil;
    return;
    end if;

  -- zavolat
  result:=a_type_make_call_qualified(ancestor^,binfo,xinfo,tst,x_make_this(sym_primary_context(typ),xinfo,^typ),nil);
  end a_type_make_call_ancestor;



end ca_type;