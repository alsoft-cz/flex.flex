----------------------------------------------------------------------------------------------------
module private cl_ia32 =
-- P©eklada‡ Flexu.
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private linkresolver_ia32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------

    with
      cx_expr,
      cx_expr.cx_def,
      cc_def.cc_var,
      cc_base,
      cc_base.cc_sym,
      cc_base.cc_util,
      cg_gen,
      cg_gen.cg_ia32,
      cg_gen.cg_ia32.ci_struct,
    #if debug2 then;
      cl_link.cl_debug,
      cl_link.cl_debug.cl_codeview,
    #end if;
      cl_map;

    var
      -- v˜pl¤: NOPy
      fill_nops    : static const array t_unsigned8 of t_unsigned8 := [for others use $90];

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    var
      s                : tsegment;

    begin
      imagebase:=_ibase;
      gran:=_gran;
      calign:=_calign;
      dalign:=_dalign;
      for s in tsegment loop
        seg[s].start:=_start;
        seg[s].len:=0;
        end loop;
      seg[tseg_code].start:=_ibase+_start;
      compi:=_compi;
      end init;



    ------------------------------------------------------------------------------------------------
    override trace =
    -- Projde tabulku relokac¡ symbolu CURR a pro ka‘d˜ symbol zavol¡ MARK.
    ------------------------------------------------------------------------------------------------
    var
      zarad            : t_logical;                  -- T-zaradit na vyhodnocen¡ relokac¡
      pi               : picodeinst;
      i                : t_unsigned;

    begin
      if curr^.codegen=nil then return; end if;

      -- proj¡t v¨echny instance
      pi:=picodegen_subprog(curr^.codegen)^.ifirst;
      zarad:=false;
      while pi<>nil loop
        if pi^.r<>nil and then pi^.r^:length>0 then
          -- za©adit na vyhodnocen¡ relokac¡
          zarad:=true;

          -- ozna‡it symboly
          for i in pi^.r^:range loop
            case pi^.r^[i].rtype
              when irt_none   do {nic nedˆlat};
              when irt_symbol do if pi^.r^[i].psym<>curr then mark(pentity(pi^.r^[i].psym)); end if;
              when irt_imm    do
                  if pexpimm(pi^.r^[i].pexpr)^.linked=ls_undef then
                    pexpimm(pi^.r^[i].pexpr)^.linked:=ls_used;
                    cdata.add(^pexpimm(pi^.r^[i].pexpr)^.imm,pexpimm(pi^.r^[i].pexpr)^.t.getctype);
                    end if;
              when others do verify(202,true);
              end case;
            end loop;
          end if;
        pi:=pi^.next;
        end loop;
      if zarad then reloc.add(curr); end if;
      end trace;



    ------------------------------------------------------------------------------------------------
    static assignvaraddr =
    -- P©idˆl¡ adresy promˆnn˜m.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu,
      cp_cpu.cp_32,
      cp_cpu.cp_32.cp_def;

    var
      pvar             : pentity_var;                -- promˆnn 
      size             : t_unsigned32;               -- velikost promˆnn‚
      ud               : tunidata_addr;              
      i                : list.list^:range:type;

    begin
      for i in list.list^:range loop
        -- pro zjednodu¨en¡
        pvar:=pentity_var(list.list^[i]);
        verify(387,pvar^.linked<>ls_used or pvar^.etype<>et_var);

        -- alokovat pamˆŸ
        new picodegen_var(pvar^.codegen);

        -- p©idˆlit adresu
        picodegen_var(pvar^.codegen)^.addr:=addr;
        size:=unidata_size_to_unsigned(pvar^.typ.getctype^.size);
        addalign(addr,addr,size,dalign);

        -- ozna‡it symbol jako vyhodnocen˜
        pvar^.linked:=ls_linked;

        -- zapsat do map filu
        ud:=prg32_to_unidata_addr(picodegen_var(pvar^.codegen)^.addr);
        map_static_variable(sym_get_qid(pvar),ud,pvar^.typ.getctype^.size);
        end loop;
      end assignvaraddr;



    ------------------------------------------------------------------------------------------------
    static buildtypedesc =
    -- Sestaven¡ deskriptor– typ–.
    ------------------------------------------------------------------------------------------------
    type
      -- machine pointery pro alokaci fyzick‚ struktury
      x_pointer    = ^unchecked for machine_pointer use true;
      x_piclassdesc= ^iclassdesc for machine_pointer use true;
      x_pitypedesc = ^itypedesc for machine_pointer use true;

    var
      xclass       : x_piclassdesc;              -- fyzick  struktura popisuj¡c¡ t©¡du
      xtype        : x_pitypedesc;               -- fyzick  struktura popisuj¡c¡ typ

    var
      ptyp         : pentity_type;               -- typ
      ptyp_vt      : pentity_type;               -- typ ‡i jeho p©edek s virtu ln¡ tabulkou
      ptyp_vtx     : pentity_type;               -- je¨tˆ star¨¡ p©edek
      pmethod      : pentity_subprogram;         -- implementace virtu ln¡ metody
    --size         : uint32;       -- velikost promˆnn‚
      ancestor     : pentity_type;               -- p©edek
      srch         : tentitysearch;              -- hled tko
      i            : list.list^:range:type;
      j            : t_unsigned;

    begin
      for i in list.list^:range loop
        -- pro zjednodu¨en¡
        ptyp:=pentity_type(list.list^[i]);
        verify(386,(ptyp^.linked<>ls_used) or (ptyp^.etype not in ets_type) or (ptyp^.codegen<>nil));

        -- nal‚zt v hierarchii t©¡d vhodn‚ho p©edka s virtu ln¡ tabulkou
        if ptyp^.stype=dt_class then
          ptyp_vt:=ptyp;
          while (ptyp_vt^.vtable=nil or else ptyp_vt^.vtable^:length=0) and then (ptyp_vt^.ancestor.isset) loop
            ptyp_vt:=pentity_type(ptyp_vt^.ancestor.getcentity);
            end loop;
          end if;

        -- alokovat pamˆŸ
        new picodegen_type(ptyp^.codegen);

        -- alokovat deskriptor
        if ptyp^.stype=dt_class
          -- pro t©¡du
          then 
            -- vypo‡¡tat velikost
            picodegen_type(ptyp^.codegen)^.size:=iclassdesc:size;
            if ptyp_vt^.vtable<>nil then 
              picodegen_type(ptyp^.codegen)^.size+4*ptyp_vt^.vtable^:length;
              end if;

            -- alokovat
            new x_pointer(xclass) range picodegen_type(ptyp^.codegen)^.size;

            -- p©i©adit do typu
            picodegen_type(ptyp^.codegen)^.desc:=xclass;

          -- pro oby‡ejn˜ typ
          else 
            -- vypo‡¡tat velikost
            picodegen_type(ptyp^.codegen)^.size:=itypedesc:size;

            -- alokovat
            new xtype;

            -- p©i©adit do typu
            picodegen_type(ptyp^.codegen)^.desc:=xtype;
            end if;

      {
        if ptyp^.stype=dt_class
          then 
            picodegen_type(ptyp^.codegen)^.size:=iclassdesc:size;
            if ptyp^.vtable<>nil then 
              picodegen_type(ptyp^.codegen)^.size+4*ptyp_vt^.vtable^:length;
              end if;
          else picodegen_type(ptyp^.codegen)^.size:=itypedesc:size;
          end if;
        c_alloc(cmem_block,picodegen_type(ptyp^.codegen)^.desc,picodegen_type(ptyp^.codegen)^.size);
      }

        -- p©idˆlit adresu
        picodegen_type(ptyp^.codegen)^.addr:=addr;
        addalign(addr,addr,picodegen_type(ptyp^.codegen)^.size,dalign);

        -- atribut :size
        picodegen_type(ptyp^.codegen)^.desc^.size:=unidata_size_to_unsigned(ptyp^.size);

        -- datov˜ typ
        picodegen_type(ptyp^.codegen)^.desc^.datatype:=idatatypecodetab[ptyp^.stype];

        -- :tag p©edka
        if ptyp^.ancestor.isset then
          pentity(ancestor):=ptyp^.ancestor.getcentity;

          -- na to aby mohl m¡t tag, mus¡ b˜t tagged
          if tf_tagged in ancestor^.tflags then
            verify(389,ancestor^.linked<>ls_linked or ancestor^.codegen=nil);
            picodegen_type(ptyp^.codegen)^.desc^.ancestor:=picodegen_type(ancestor^.codegen)^.addr;
            end if;
          end if;

        -- adresy speci ln¡ch metod
        srch.find_et_first(ptyp,rc_primary,et_special,[]);
        while srch.psym<>nil loop
          verify(412,(pentity_special(srch.psym)^.linked<>ls_linked)
                  or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst=nil) 
                  or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst
                    <>picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ilast));

          -- doplnit adresu instance do deskriptoru typu
          pitypedesc(picodegen_type(ptyp^.codegen)^.desc)^.specptr[pentity_special(srch.psym)^.spectype]:=picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst^.cstart;
          --picodegen_addr(pdefspecial(srch.psym)^.codegen)^.addr;
          
          -- dal¨¡ speci ln¡ metoda
          srch.find_et_next;
          end loop;

        -- dosadit adresy virtu ln¡ch metod
        if ptyp^.stype=dt_class and then ptyp_vt^.vtable<>nil then
          -- vygenerovat virtu ln¡ tabulku
          for j in ptyp_vt^.vtable^:range loop
            -- naj¡t implementaci virtu ln¡ metody
            pmethod:=ptyp_vt^.vtable^[j];
            ptyp_vtx:=ptyp_vt;
            while pmethod=nil loop
              -- kouknout se k p©edkovi
              ptyp_vtx:=pentity_type(ptyp_vtx^.ancestor.getcentity);

              -- je-li u tohoto p©edka nˆco ve virtu ln¡ tabulce, tak zkusit naj¡t na¨i metodu
              if ptyp_vtx^.vtable<>nil and then ptyp_vtx^.vtable^:length<>0 then
                verify(596,j>ptyp_vtx^.vtable^:length);
                pmethod:=ptyp_vtx^.vtable^[j];
                end if;
              end loop;

            verify(528,(pmethod^.linked<>ls_linked)
                    or (picodegen_subprog(pmethod^.codegen)^.ifirst=nil)
                    or (picodegen_subprog(pmethod^.codegen)^.ifirst
                      <>picodegen_subprog(pmethod^.codegen)^.ilast));

            -- doplnit adresu
            piclassdescv(picodegen_type(ptyp^.codegen)^.desc)^.vptr[j-ptyp_vt^.vtable^:first]:=picodegen_subprog(pmethod^.codegen)^.ifirst^.cstart;
            end loop;
          end if;

        -- ozna‡it symbol jako vyhodnocen˜
        ptyp^.linked:=ls_linked;
        end loop;
      end buildtypedesc;



    ------------------------------------------------------------------------------------------------
    static resolvereloc =
    -- Vyhodnot¡ relokace dan‚ho symbolu.
    ------------------------------------------------------------------------------------------------
    with
      cg_gen.cg_ia32.ci_code,
      cg_gen.cg_ia32.ci_code.ci_instr;

    var
      i                : inst.r^:range:type;

    begin
      --return;
      
      if inst.r=nil then return end if;

      for i in inst.r^:range loop -- with inst.r^[i] loop
        case inst.r^[i].rtype
          -- pr zdn  relokace
          when irt_none     do { nic nedˆlat };

          -- symbol
          when irt_symbol do
              case pentity(inst.r^[i].psym)^.etype
                -- promˆnn 
                when et_var  do 
                    verify(590,not inst.r^[i].absolute);
                    setfield(inst,inst.r^[i].disp,picodegen_var(pentity(inst.r^[i].psym)^.codegen)^.addr);

                -- procedura
                when et_procedure do
                    if pentity_procedure(inst.r^[i].psym)^.import<>nil
                      
                      -- extern¡ symbol
                      then 
                        verify(591,not inst.r^[i].absolute);
                        setfield(inst,inst.r^[i].disp,getindirect(pentity_procedure(inst.r^[i].psym)));
                      
                      -- norm ln¡ symbol }{%%X A kter  instance to je ?
                      else
                        if not inst.r^[i].absolute
                          then setfield(inst,inst.r^[i].disp,picodegen_subprog(pentity(inst.r^[i].psym)^.codegen)^.ifirst^.cstart-(inst.r^[i].nextip+inst.cstart));
                          else setfield(inst,inst.r^[i].disp,picodegen_subprog(pentity(inst.r^[i].psym)^.codegen)^.ifirst^.cstart);
                          end if;
                        end if;

                -- program, metoda, speci ln  metoda, kompila‡n¡ jednotka
                when et_program, et_static, et_virtual, et_override, et_special, et_compile do
                    {%%X A kter  instance to je ? }
                    if not inst.r^[i].absolute
                      then setfield(inst,inst.r^[i].disp,picodegen_subprog(pentity(inst.r^[i].psym)^.codegen)^.ifirst^.cstart-(inst.r^[i].nextip+inst.cstart));
                      else setfield(inst,inst.r^[i].disp,picodegen_subprog(pentity(inst.r^[i].psym)^.codegen)^.ifirst^.cstart);
                      end if;

                -- ‡¡slo zpr vy
                when et_message do
                    verify(592,not inst.r^[i].absolute);
                    setfield(inst,inst.r^[i].disp,unimsg_to_unsigned(pentity_message(inst.r^[i].psym)^.num));

                -- tag typu/t©¡dy
                when et_type,et_class do
                    verify(593,not inst.r^[i].absolute);
                    setfield(inst,inst.r^[i].disp,picodegen_type(pentity_type(inst.r^[i].psym)^.codegen)^.addr);

                when others do verify(33,true);
                end case;


          -- p©¡m  hodnota
          when irt_imm do
              verify(307,not inst.r^[i].absolute);
              setfield(inst,inst.r^[i].disp,picodegen_imm(pexpimm(inst.r^[i].pexpr)^.imm.codegen)^.addr);

          when others do verify(203,true);
          end case;
        end loop;
      end resolvereloc;



    ------------------------------------------------------------------------------------------------
    override link =
    -- Sestaven¡.
    ------------------------------------------------------------------------------------------------
    with
      standard,standard.console,
      cc_base,cc_base.cc_sym;

    var
      pimm             : pimm_value;                 -- ukl dan  p©¡m  hodnota
      bin              : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      binsize          : tunidata_size;              -- velikost bin rn¡ho tvaru
      i                : code.list^:range:type; 
      j                : t_unsigned; 
      p                : picodeinst;
      k                : t_unsigned32;               -- aktu ln¡ adresa
      ud_addr          : tunidata_addr;              -- adresa objektu
      ud_size          : tunidata_size;              -- velikost objektu
      avail            : t_logical;                  -- T-automatick  promˆnn  m  p©i©azenu adresu
      srch             : tentitysearch;
      block            : pimemblock;                 -- p©idˆlen˜ blok pamˆti

    begin
      ----- F ze 1: vypo‡¡tat adresy k¢du -----
      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Code');

      -- p©idˆlit adresy v¨em instanc¡m
      k:=seg[tseg_code].start;
      if code.list<>nil then
        for i in code.list^:range loop
          verify(594,code.list^[i]^.linked<>ls_used);

          --write_line(sym_get_qid(code.list^[i]));

          -- p©idˆlit adresy v¨em instanc¡m
          p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;
          loop
            -- p©idˆlit adresu
            p^.cstart:=k;

            -- dal¨¡ ‡ st adresn¡ho prostoru obsazena
            addalign(k,k,p^.c^:length,calign);

            -- zapsat do listingu
            ud_addr:=unsigned_to_unidata_addr(p^.cstart);
            map_start_subprogram(sym_get_qid(code.list^[i]),ud_addr);

            -- vypsat parametry
            if p^.profile.par<>nil then
              for j in p^.profile.par^:range loop
                ud_addr:=signed_to_unidata_addr(p^.profile.par^[j].ofs);
                ud_size:=unsigned_to_unidata_size(p^.profile.par^[j].size);
                map_automatic_variable(sym_get_qid(p^.profile.par^[j].pparam),ud_addr,ud_size);
                end loop;
              end if;

            -- vypsat lok ln¡ promˆnn‚
            block:=p^.layout.first;
            while block<>nil loop
              ud_addr:=signed_to_unidata_addr(block^.ofs);
              ud_size:=unsigned_to_unidata_size(block^.size);
              if block^.pvar<>nil
                then map_automatic_variable(sym_get_qid(block^.pvar),ud_addr,ud_size);
                else map_automatic_variable('<temporary>',ud_addr,ud_size);
                end if;
              block:=block^.next;
              end loop;
            {
            findtfirst(code.list^[i],et_var,[],srch);
            while srch.psym<>nil loop
              if pentity_var(srch.psym)^.mclass=mc_auto then
                -- zjistit adresu
                checkvaraddr(p^,pentity_var(srch.psym),avail,ud_addr,ud_size);

                -- m -li p©idˆlenu adresu, tak vypsat
                if avail then
                  map_automatic_variable(srch.psym^.id^,ud_addr,ud_size);
                  end if;
                end if;
              findtnext(srch);
              end loop;
            }
            -- © dkov‚ informace
            ud_addr:=unsigned_to_unidata_addr(p^.cstart);
            map_subprogram_lineinfo(ud_addr,p^.di);

            -- konec
            map_end_subprogram;

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;

          -- ozna‡it za slinkovan‚
          code.list^[i]^.linked:=ls_linked;
          end loop;
        end if;

      -- vypo‡¡tat d‚lku k¢du
      seg[tseg_code].len:=k-seg[tseg_code].start;

      -- konec segmentu
      map_end_segment;

      ----- F ze 2: p©idˆlit adresy promˆnn˜ch, konstant a deskriptor– -----
      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Type Descriptors');

      -- 1. deskriptory typ–
      addalign(seg[tseg_typedesc].start,seg[tseg_code].start,seg[tseg_code].len,gran);
      k:=seg[tseg_typedesc].start;
      buildtypedesc(typedesc,k);

      -- vypo‡¡tat d‚lku deskriptor– typ–
      seg[tseg_typedesc].len:=k-seg[tseg_typedesc].start;

      -- konec segmentu
      map_end_segment;

      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Constants');

      -- 2. konstanty
      addalign(seg[tseg_const].start,seg[tseg_typedesc].start,seg[tseg_typedesc].len,gran);
      k:=seg[tseg_const].start;
      if cdata.list<>nil then
        for i in cdata.list^:range loop
          -- pro zjednodu¨en¡
          pimm:=cdata.list^[i].pimm;
          if pimm^.codegen=nil then
            -- alokovat pamˆŸ
            new picodegen_imm(pimm^.codegen);

            -- p©idˆlit adresu
            picodegen_imm(pimm^.codegen)^.addr:=k;

            -- vypo‡¡tat po‘adovanou velikost pamˆti
            cpu^.getimmstoragesize(pimm^,cdata.list^[i].ptyp,binsize);

            -- vypo‡¡tat dal¨¡ zarovnanou adresu
            addalign(k,k,unidata_size_to_unsigned(binsize),dalign);
            end if;
          end loop;
        end if;

      -- vypo‡¡tat d‚lku konstant
      seg[tseg_const].len:=k-seg[tseg_const].start;

      -- konec segmentu
      map_end_segment;

      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Initialized Variables');

      -- 3. inicializovan‚ promˆnn‚
      addalign(seg[tseg_init].start,seg[tseg_const].start,seg[tseg_const].len,gran);
      k:=seg[tseg_init].start;
      assignvaraddr(idata,k);

      -- konec segmentu
      map_end_segment;

      -- vypo‡¡tat d‚lku inicializovan˜ch promˆnn˜ch
      seg[tseg_init].len:=k-seg[tseg_init].start;

      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Uninitialized Variables');

      -- 4. neinicializovan‚ promˆnn‚
      addalign(seg[tseg_data].start,seg[tseg_init].start,seg[tseg_init].len,gran);
      k:=seg[tseg_data].start;
      assignvaraddr(data,k);

      -- vypo‡¡tat d‚lku neinicializovan˜ch promˆnn˜ch
      seg[tseg_data].len:=k-seg[tseg_data].start;

      -- konec segmentu
      map_end_segment;

      ----- F ze 3.1 : p©ipravit importovan‚ funkce -----
      -- zapsat do listingu za‡ tek segmentu
      map_start_segment('Import');

      -- sestavit tabulku importovan˜ch funkc¡
      addalign(seg[tseg_import].start,seg[tseg_data].start,seg[tseg_data].len,gran);
      linkimport;

      -- konec segmentu
      map_end_segment;

      ----- F ze 3.2 : vyhodnotit odkazy v k¢du -----
      if reloc.list<>nil then
        for i in reloc.list^:range loop
          p:=picodegen_subprog(reloc.list^[i]^.codegen)^.ifirst;
          loop
            -- vyhodnotit
            resolvereloc(p^);

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;
          end loop;
        end if;

      ----- F ze 4 : debug informace -----
    #if debug2 then;
      -- jaky typ debug informaci budeme generovat
      case debug_mode

        -- CodeView debug inforation
        when tdit_codeview do ;
            new p_codeview(debug_info);

        -- nejaky neznamy typ
        when others do ;
        end case;

      -- generujeme nejake debug informace ?
      if debug_info<>nil then
        -- inicializace debug informaci
        debug_info^.init;

        -- sestavime strom s debug informacemi
        debug_info^.linkdebuginfo(compi,p_linkres(^this));
        end if;
    #end if;
      end link;



    ------------------------------------------------------------------------------------------------
    override info =
    -- V˜pis souhrnn˜ch informac¡ do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;



    ------------------------------------------------------------------------------------------------
    override getaddrbase =
    -- Adresa, ke kter‚ se vztahuj¡ relokace.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(imagebase);
      end getaddrbase;



    ------------------------------------------------------------------------------------------------
    override getentrypoint =
    -- Entrypoint programu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(picodegen_subprog(compi^.codegen)^.ifirst^.cstart);
      end getentrypoint;



    ------------------------------------------------------------------------------------------------
    override checkseg =
    -- True, pokud se m  zadan˜ segment zahrnout do EXE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=seg[_seg].len>0;
      end checkseg;



    ------------------------------------------------------------------------------------------------
    override getsegbase =
    -- B zov  adresa segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(seg[_seg].start);
      end getsegbase;



    ------------------------------------------------------------------------------------------------
    override getsegtotal =
    -- Celkov  velikost segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unidata_size(seg[_seg].len);
      end getsegtotal;



    ------------------------------------------------------------------------------------------------
    override writesegment =
    -- Do v˜stupn¡ho souboru zap¡¨e zadan˜ segment.
    ------------------------------------------------------------------------------------------------
    var
      bin          : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      allocsize    : tunidata_size;              -- velikost alokovan‚ pamˆti

        --------------------------------------------------------------------------------------------
        procedure writeimm (
            imm    : in timm_value;              -- p©¡m  hodnota
            ptyp   : in pentity_type;            -- typ
            full   : in t_logical) =             -- T-ulo‘it v d‚lce typu, F-v min. d‚lce
        -- Zap¡¨e do souboru p©¡mou hodnotu.
        --------------------------------------------------------------------------------------------
        with
          advanced,
          advanced.low_level;

        use
          advanced.low_level.unchecked_memory_access;

        var
          binsize  : tunidata_size;              -- velikost bin rn¡ho tvaru
          fill     : t_unsigned32;               -- velikost zarovn n¡
          x        : t_unsigned32;
          ud       : tunidata_size;

        begin
          -- ur‡it velikost bin rn¡ho tvaru
          cpu^.getimmstoragesize(imm,ptyp,binsize);

          -- realokovat pamˆŸ
          {%%X Nekompatibiln¡ s 64-bitovou implementac¡ }
          if binsize>allocsize

            -- alokovat nov˜ blok
            then
              discard bin;
              allocsize:=binsize;
              new bin range unidata_size_to_unsigned(allocsize);

            -- jinak jen fillznout ten star˜
            else
              unchecked_memory_access.memory_fill_zero(bin^,unidata_size_to_unsigned(allocsize))
              end if;

          -- sestavit bin rn¡ tvar
          cpu^.immtobinary(imm,ptyp,bin^,binsize);

          -- zapsat
          os^.writex(bin^,unidata_size_to_unsigned(binsize));

          -- vypo‡¡tat d‚lku zarovn n¡
          if full
            -- (+v˜pl¤ za konstantou krat¨¡ ne‘ je typ)
            then
              x:=unidata_size_to_unsigned(ptyp^.size);
              fill:=unidata_size_to_unsigned(ptyp^.size-binsize);
              if x mod dalign<>0 then 
                fill+(dalign-(x mod dalign)); 
                end if;
            -- (nezarovn v  se na velikost typu ale na velikost konstanty)
            else
              fill:=unidata_size_to_unsigned(binsize);
              if fill mod dalign<>0
                then fill:=dalign-(fill mod dalign);
                else fill:=0;
                end if;
              end if;

          -- zarovnat
          ffillz(os,fill);
          end writeimm;

    var
      pvar             : pentity_var;                -- promˆnn 
      size             : t_unsigned32;               -- velikost promˆnn‚
      fill             : t_unsigned32;               -- velikost dodate‡n‚ v˜plnˆ
      imm              : pimm_value;                 -- p©¡m  hodnota
      pcodegen         : picodegen_type;
      i                : code.list^:range:type;
      p                : picodeinst;

    begin
      case _seg
        -- k¢d
        when tseg_code do
            for i in code.list^:range loop
              p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;

              -- zapsat v¨echny instance
              loop
                -- zapsat instrukce
                os^.writex(p^.c^[p^.c^:first],p^.c^:length);

                -- zarovnat
                if p^.c^:length mod calign<>0 then 
                  os^.writex(fill_nops,calign-(p^.c^:length mod calign)); 
                  end if;

                -- dal¨¡ instance
                p:=p^.next;
                until p=nil;
              end loop;


        -- deskriptory typ–
        when tseg_typedesc  do
            for i in typedesc.list^:range loop
              -- pro zjednodu¨en¡
              pcodegen:=picodegen_type(pentity_type(typedesc.list^[i])^.codegen);

              -- zapsat deskriptor
              os^.writex(pcodegen^.desc^,pcodegen^.size);

              -- zarovnat
              if pcodegen^.size mod dalign<>0 then 
                os^.writex(fill_nops,dalign-(pcodegen^.size mod dalign)); 
                end if;
              end loop;


        -- konstanty
        when tseg_const     do
            allocsize:=uds_0;
            bin:=nil;
            for i in cdata.list^:range loop
              writeimm(cdata.list^[i].pimm^,cdata.list^[i].ptyp,false);
              end loop;
            discard bin;


        -- inicializovan  data
        when tseg_init do
            allocsize:=uds_0;
            bin:=nil;
            for i in idata.list^:range loop 
              writeimm(pentity_var(idata.list^[i])^.init.getimm^,pentity_var(idata.list^[i])^.typ.getctype,true); 
              end loop;
            discard bin;

        -- neinicializovan  data
        when tseg_data do { nen¡ co zapisovat };

        -- importy
        when tseg_import do { nev¡m jak zapsat };

        when others do verify(204,true);
        end case;
      end writesegment;



    ------------------------------------------------------------------------------------------------
    virtual getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=0;
      end getindirect;

    end linkresolver_ia32;



----------------------------------------------------------------------------------------------------
class private linkresolver_ia32_win32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: Win32 na IA-32.
----------------------------------------------------------------------------------------------------

    with
      cp_cpu,
      cp_cpu.cp_32,
      cp_cpu.cp_32.cp_def,
      cp_os,
      cp_os.cp_win32;

    ------------------------------------------------------------------------------------------------
    override linkimport =
    -- P©¡prava pro linkov n¡ importovan˜ch funkc¡.
    ------------------------------------------------------------------------------------------------
    var
      zmena            : t_logical;
      psym             : pentity;
      i                : import.list^:range:type;
      j                : import.list^:range:type;
      addr             : t_unsigned32;

    begin
      -- nen¡ co ©e¨it
      if import.list^:length=0 then return; end if;

      -- set©¡dit importovan‚ funkce
      i:=import.list^:length;
      loop
        zmena:=false;
        for j in 1..i-1 loop
          if pimportinfo(pentity_procedure(import.list^[j])^.import)^.libname>pimportinfo(pentity_procedure(import.list^[j+1])^.import)^.libname then
            psym:=import.list^[j];
            import.list^[j]:=import.list^[j+1];
            import.list^[j+1]:=psym;
            zmena:=true;
            end if;
          end loop;
        pred i;
        until not zmena or (i=1);

      -- p©i©adit adresy na adresy procedur
      addr:=seg[tseg_import].start;
      for i in import.list^:range loop
        -- mezera p©i zmˆnˆ knihovny
        if (i>import.list^:first) and (pimportinfo(pentity_procedure(import.list^[i-1])^.import)^.libname<>pimportinfo(pentity_procedure(import.list^[i])^.import)^.libname) then 
          addr+lprg32; 
          end if;

        -- adresa
        pimportinfo(pentity_procedure(import.list^[i])^.import)^.addr:=addr;
    {
        if opt_dump in info.compv.opts then
          with pimportinfo(pentity_subprogram(import.list^[i])^.import)^ loop dump(libname+' '+extname+' '+addr); end loop;
          end if;
    }
        -- dal¨¡ adresa
        addr+lprg32;
        end loop;

      -- mezera za posledn¡ knihovnou
      addr+lprg32;

      -- velikost tabulek adres
      seg[tseg_import].len:=addr-seg[tseg_import].start;
      end linkimport;



    ----------------------------------------------------------------------------------------------------
    override getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ----------------------------------------------------------------------------------------------------
    begin
      result:=pimportinfo(proc^.import)^.addr;
      end getindirect;
    
    end linkresolver_ia32_win32;



end cl_ia32;