----------------------------------------------------------------------------------------------------
class private cp_osspecific =
-- P©eklada‡ Flexu.
-- Vlastnosti specifick‚ pro konkr‚tn¡ opera‡n¡ syst‚m.
----------------------------------------------------------------------------------------------------
-- Ondra : 13.01.2003 : Vytvo©il.
----------------------------------------------------------------------------------------------------

with
  cc_var,cc_codes;

----------------------------------------------------------------------------------------------------
override importproc =
-- Import procedury z extern¡ knihovny.
----------------------------------------------------------------------------------------------------
var
  info             : pimportinfo;                -- informace pro import

begin
  --%%X um¡m importovat jen procedury, ne metody
  if proc^.etype<>et_procedure then
    ce^.seterror({CCERR=}000315,ce_cantimport);
    {%%POS}
    ce^.raiseerror;
    end if;

  -- alokovat pamˆŸ
  new info;

  -- doplnit £daje
  for i in 1..extname:length loop info^.extname & t_char8(extname[i]) end loop;
  for i in 1..libname:length loop info^.libname & t_char8(libname[i]) end loop;

  -- poznamenat do procedury
  proc^.import:=info;
  end importproc;



----------------------------------------------------------------------------------------------------
override setconvention =
-- Nastav¡ volac¡ konvenci procedury.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_sym,
  {%%TODO(?) Tahle z vistost se mi nel¡b¡}cp_cpu,cp_cpu.cp_ia32,cp_cpu.cp_ia32.ci_abi;

var
  call             : icallconvention;  -- volac¡ konvence

begin
  -- nem  ji‘ p©i©azenu volac¡ konvenci ?
  if i_get_convention^(proc^)<>icc_default then
    ce^.seterror({CCERR=}000316,ce_conventionset);
    ce^.setparam(sym_get_qid(proc));
    {%%POS}
    ce^.raiseerror;
    end if;

  -- ur‡it volac¡ konvenci
  i_id_to_convention(id,call);
  if call=icc_default then
    ce^.seterror({CCERR=}000317,ce_i_convention);
    ce^.setparam(entityident_to_string(id));
    {%%POS}
    ce^.raiseerror;
    end if;

  -- p©i©adit konvenci
  i_set_convention^(proc^,call);
  end setconvention;



#if #declared hynek; #and then; hynek then;
----------------------------------------------------------------------------------------------------
override setlibrary =
-- Nastav¡ typ knihovny pro modul
----------------------------------------------------------------------------------------------------
var
  lib              : tlibrarytype;
  res              : t_logical;

begin
  -- chybny parametr?
  if modl=nil then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.raiseerror;
    end if;
  
  -- ma modul jiz definovanou informaci pro knihovnu?
  if modl^.lib_info<>nil then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.resumeerror;
    return;
    end if;

  lib:=tlt_system;
  res:=id_to_librarytype(id,lib);

  -- je platny identifikator id?
  if not res then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.setparam(entityident_to_string(id));
    ce^.resumeerror;
    return;
    end if;

  new plibraryinfo(modl^.lib_info);

  -- vytvoren?
  if modl^.lib_info=nil then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.raiseerror;
    end if;

  plibraryinfo(modl^.lib_info)^.lib_type:=lib;
  --plibraryinfo(modl^.lib_info)^.compi:=nil;

  end setlibrary;



----------------------------------------------------------------------------------------------------
override exportproc =
-- Export procedury do extern¡ knihovny.
----------------------------------------------------------------------------------------------------
begin
  -- chybny parametr?
  if proc=nil then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.raiseerror;
    end if;

  -- ma procedura jiz definovanou informaci pro export?
  if proc^.export_info<>nil then
    ce^.seterror({CCERR=}000777,ce_internal);
    ce^.resumeerror;
    return;
    end if;

  new pexportinfo(proc^.export_info);

  end exportproc;



----------------------------------------------------------------------------------------------------
override genlibentry =
-- Vygeneruje entry proceduru pro knihovnu [modl], entry procedura se prida do [context]
----------------------------------------------------------------------------------------------------
var
  pentry           : pentity_procedure;
  pentry_context   : ^tcontext; 
  pentrytyp        : pentity_type;
  pentrytyp_context : tcontext;
  pparam           : pentity_param;              -- parametr procedury
  pparam_context   : tcontext;                   -- kontext parametru procedury
  pparamtyp        : pentity_type;
  pparamtyp_context : tcontext;


begin
  -- vytvo©it entry proceduru
  d_create_internal(context,pentity(pentry),pentry_context,et_procedure,'DllMain');

  -- typ entry procedury
  d_create_internal(pentry_context,pentity(pentrytyp),pentrytyp_context,et_type,nil);

  -- doplnit z kladn¡ £daje
  pentrytyp^.tkind:=tk_singular;
  pentrytyp^.stype:=dt_procedure;
  pentrytyp^.parcount:=3;
  pentrytyp^.mode:=pm_out;

  -- asociovat s procedurou
  pentry^.typ.settype(pentrytyp);

  -- 1. parametr
  d_create_internal(pentrytyp_context,pentity(pparam),pparam_context,et_param,'hinstdll');

  -- typ 1.ho parametru
  d_create_internal(pparam_context,pentity(pparamtyp),pparamtyp_context,et_type,'HINSTANCE');
  pparamtyp^.tkind:=tk_singular;
  pparamtyp^.stype:=dt_unsigned;
  cpu^.getdefaultord(dt_unsigned,pparamtyp^.bits,pparamtyp^.size,pparamtyp^.lval,pparamtyp^.hval);
  
  -- konec deklarace typu 1. parametru
  d_end_internal(pparamtyp^,true);

  -- doplnit z kladn¡ £daje 1. parametru
  pparam^.mode:=pm_in;
  pparam^.pass:=pp_value;
  pparam^.typ.settype(pparamtyp);
  pparam^.num:=0;

  -- konec deklarace 1. parametru
  d_end_internal(pparam^,true);

  -- 2. parametr
  d_create_internal(pentrytyp_context,pentity(pparam),pparam_context,et_param,'reason');

  -- typ 2.ho parametru
  d_create_internal(pparam_context,pentity(pparamtyp),pparamtyp_context,et_type,'DWORD');
  pparamtyp^.tkind:=tk_singular;
  pparamtyp^.stype:=dt_unsigned;
  cpu^.getdefaultord(dt_unsigned,pparamtyp^.bits,pparamtyp^.size,pparamtyp^.lval,pparamtyp^.hval);
  
  -- konec deklarace typu 2. parametru
  d_end_internal(pparamtyp^,true);

  -- doplnit z kladn¡ £daje 2. parametru
  pparam^.mode:=pm_in;
  pparam^.pass:=pp_value;
  pparam^.typ.settype(pparamtyp);
  pparam^.num:=1;

  -- konec deklarace 2. parametru
  d_end_internal(pparam^,true);

  -- 3. parametr
  d_create_internal(pentrytyp_context,pentity(pparam),pparam_context,et_param,'reserved');

  -- typ 3.ho parametru
  d_create_internal(pparam_context,pentity(pparamtyp),pparamtyp_context,et_type,'DWORD');
  pparamtyp^.tkind:=tk_singular;
  pparamtyp^.stype:=dt_unsigned;
  cpu^.getdefaultord(dt_unsigned,pparamtyp^.bits,pparamtyp^.size,pparamtyp^.lval,pparamtyp^.hval);
  
  -- konec deklarace typu 3. parametru
  d_end_internal(pparamtyp^,true);

  -- doplnit z kladn¡ £daje 3. parametru
  pparam^.mode:=pm_in;
  pparam^.pass:=pp_value;
  pparam^.typ.settype(pparamtyp);
  pparam^.num:=2;

  -- konec deklarace 3. parametru
  d_end_internal(pparam^,true);

  -- return parametr
  d_create_internal(pentrytyp_context,pentity(pparam),pparam_context,et_param,^id_result);

  -- typ return parametru
  d_create_internal(pparam_context,pentity(pparamtyp),pparamtyp_context,et_type,'DWORD');
  pparamtyp^.tkind:=tk_singular;
  pparamtyp^.stype:=dt_unsigned;
  cpu^.getdefaultord(dt_unsigned,pparamtyp^.bits,pparamtyp^.size,pparamtyp^.lval,pparamtyp^.hval);
  
  -- konec deklarace typu return parametru
  d_end_internal(pparamtyp^,true);

  -- doplnit z kladn¡ £daje return parametru
  pparam^.mode:=pm_out;
  pparam^.pass:=pp_value;
  pparam^.typ.settype(pparamtyp);

  -- konec deklarace return parametru
  d_end_internal(pparam^,true);

  -- priradit navratovy parametr typu entry
  pentrytyp^.result:=pparam;

  -- konec deklarace typu procedury
  d_end_internal(pentrytyp^,true);

  -- dal¨¡ ‡ st deklarace
  d_next_internal(pentry^);

  -- vygenerovat podle parametr– lok ln¡ promˆnn‚
  p_genlocvar(pentry^);

  
  -- vratit vytvorenou entry proceduru
  result:=pentry;
  end genlibentry;
#end if;


end cp_osspecific;