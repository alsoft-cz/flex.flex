----------------------------------------------------------------------------------------------------
module private ci_oper =
-- P©eklada‡ Flexu.
-- Sestavov n¡ operand–.
----------------------------------------------------------------------------------------------------
-- Ondra : 05.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with 
  ci_reg,ci_abi,ci_stack,ci_relo;

----------------------------------------------------------------------------------------------------
procedure nullop =
-- Nulov n¡ operandu.
----------------------------------------------------------------------------------------------------
begin
  op.optype:=optype;
  end nullop;




----------------------------------------------------------------------------------------------------
procedure newopreg =
-- Nov˜ operand typu IO_REG s alokac¡ registru.
----------------------------------------------------------------------------------------------------
begin
  nullop(op,io_reg);
  op.size:=size;

  -- zkusit pou‘¡t registr z dodan‚ho operandu
  if (oldop.optype=io_reg) and (resizereg(oldop.reg.reg,size)<>ir_none) then
    i_use(inst,info,context,oldop.reg.reg,op.reg,size);
  elsif (oldop.optype=io_mem) and (oldop.base.reg<>ir_none) and (resizereg(oldop.base.reg,size)<>ir_none) then
    i_use(inst,info,context,oldop.base.reg,op.reg,size);
  elsif (oldop.optype=io_mem) and (oldop.index.reg<>ir_none) and (resizereg(oldop.index.reg,size)<>ir_none) then
    i_use(inst,info,context,oldop.index.reg,op.reg,size);

  -- ned  se nic nˆlat, alokovat nov˜ registr
  else 
    i_alloc(inst,info,context,op.reg,size,mode);
    end if;
  end newopreg;



----------------------------------------------------------------------------------------------------
procedure newopuse =
-- Nov˜ operand typu IO_REG s pou‘it¡m dodan‚ho registru.
----------------------------------------------------------------------------------------------------
begin
  nullop(op,io_reg);
  op.size:=size;
  i_use(inst,info,context,reg,op.reg,size);
  end newopuse;



----------------------------------------------------------------------------------------------------
procedure newoptemp =
-- Vyalokuje pracovn¡ prostor na stacku a sestav¡ odpov¡daj¡c¡ operand.
----------------------------------------------------------------------------------------------------
begin
  nullop(op,io_mem);
  op.base.reg:=istackframereg[inst.frame];
  alloctemp(inst,info,size,op.disp);
  op.size:=size;
  end newoptemp;



----------------------------------------------------------------------------------------------------
procedure newopstack =
-- Nov˜ operand typu IO_STACK.
----------------------------------------------------------------------------------------------------
begin
  nullop(op,io_stack);
  op.size:=size;
  end newopstack;



----------------------------------------------------------------------------------------------------
procedure shiftop =
-- P©i‡te k adresn¡mu operandu zadan˜ posuv (displacement).
----------------------------------------------------------------------------------------------------
begin
  verify(482,op.optype<>io_mem);
  op.disp+signed_to_imm32(disp);
  end shiftop;



----------------------------------------------------------------------------------------------------
procedure shiftopindex =
-- P©i‡te k adresn¡mu operandu zadan˜ posuv (registr*scale).
----------------------------------------------------------------------------------------------------
begin
  verify(525,(op.optype<>io_mem) or (op.index.reg<>ir_none));
  i_use(inst,info,context,iunitoreg[ireg,4],op.index,4);
  op.scale:=iscale;
  end shiftopindex;



----------------------------------------------------------------------------------------------------
procedure unshiftop =
-- Ode‡te od adresn¡ho operandu zadan˜ posuv (displacement).
----------------------------------------------------------------------------------------------------
begin
  verify(497,op.optype<>io_mem);
  op.disp-signed_to_imm32(disp);
  end unshiftop;



----------------------------------------------------------------------------------------------------
procedure adjustoprel =
-- Uprav¡ velikost operandu skokov‚ instrukce tak, aby se pou‘il p©ednostnˆ
-- short jump (8bitov  relativn¡ adresa) a teprve v p©¡padech, kdy je to
-- vylo‘enˆ nutn‚, se pou‘il near jump (32bitov  relativn¡ adresa). Nen¡
-- pou‘iteln‚ nap©¡klad pro vol n¡ procedury, kter‚ se v‘dy chov  jako near
-- jump.
----------------------------------------------------------------------------------------------------
var
  addr             : t_unsigned32;               -- c¡lov  adresa

begin
  -- c¡lov  adresa (pro zjednodu¨en¡)
  gettarget(info,op.disptarget,addr);

  -- m me adresu ?
  if addr<>iunknownaddr

    -- adresa je ji‘ zn ma => zpˆtn˜ skok
    then
      -- %%X zde se p©¡mo po‡¡t  s d‚lkou instrukce, kterou budu teprve p©id vat.
      -- nemohlo by to v budoucnu p©in‚st probl‚my ?

      -- lze to zapakovat na short jump ?
      if addr+127>=inst.c^:length+2

        -- ano
        then
          op.size:=1;
          op.rel:=signed_to_imm32(t_signed32(addr)-t_signed32(inst.c^:length+2));

        -- ne, mus¡ to b˜t near jump
        else
          op.size:=4;
          op.rel:=signed_to_imm32(t_signed32(addr)-t_signed32(inst.c^:length+5+(cond<>ic_ucond):ord));
          end if;

      -- c¡l skoku ji‘ nepot©ebujeme
      op.target:=iunknowntarget;

    -- adresa je¨tˆ nen¡ zn ma => dop©edn˜ skok
    else
      -- operand
      op.target:=op.disptarget;

      -- velikost
      if cond in icondset:[ic_cxz,ic_ecxz]
        -- v˜jimka pro (E)CXZ: v‘dy je to jen short jump
        then op.size:=1
        -- v ostatn¡ch p©¡padech zvol¡me implicitnˆ near jump
        else op.size:=4;
        end if;
      end if;
  end adjustoprel;



----------------------------------------------------------------------------------------------------
procedure getavailregs =
-- Vr t¡ mno‘inu v¨ech voln˜ch registr–.
----------------------------------------------------------------------------------------------------
var
  uni              : iunireg;

begin
  availregs:=iuniregset:[in_first..in_last]-context.active;
{ %%OLD
  availregs:=[];
  for uni in in_first..in_last loop
    if info.reginfo[uni].used=0 then availregs+[uni]; end if;
    end loop;
}
  end getavailregs;



----------------------------------------------------------------------------------------------------
procedure reserveavailregs =
-- Vr t¡ mno‘inu v¨ech voln˜ch registr–, kromˆ registr– z EXCLUSION.
-- Pokud nen¡ k dispozici alespo¤ MINREGS registr–, alokuje nˆjak‚ pou‘it‚.
----------------------------------------------------------------------------------------------------
with
  standard.console,
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

    ------------------------------------------------------------------------------------------------
    procedure card (
        s          : in iuniregset) 
        return t_unsigned =
    -- Kardinalita mno‘iny.
    ------------------------------------------------------------------------------------------------
    begin
      result:=0;
      for i in in_first..in_last loop 
        if i in s then succ result end if;
        end loop;
      end card;

var
  mapping          : iregnum;                    -- pro kompatibilitu parametru
  bit8             : t_logical;                  -- T-bude pot©eba 8-mi bitov˜ reg.
  uni_free         : iunireg;

begin
  bit8:=_bit8;

  -- jak‚ registry jsou teƒ voln‚ ?
  getavailregs(context,availregs);

  -- vynechat zak zan‚ registry
  availregs:=availregs-exclusion;

  -- doplnit na minim ln¡ po‘adovan˜ po‡et
  while card(availregs{+exclusion})<minregs loop
    -- nal‚zt registr
    if bit8 and (availregs-in_no8bit=iuniregset:[])
      -- vy©¡dit po‘adavek na 8mi bitov˜ registr
      then
        i_finduni(context,uni_free,1,irm_int,false,availregs+exclusion);
        bit8:=false;
      -- nal‚zt libovoln˜ registr
      else 
        i_finduni(context,uni_free,4,irm_int,false,availregs+exclusion);
        end if;
    verify(337,uni_free=in_none);

    -- zahrnout mezi voln‚ registry
    --%%TODO availregs+iuniregset:[uni_free];
    bit_set(availregs,t_bit_index(uni_free:ord));
    end loop;

  -- pou‘¡t v¨echny registry
  for uni in in_first..in_last loop
    if uni in availregs then 
      i_useuni(inst,info,context,uni,mapping); 
      end if;
    end loop;

{ %%OLD
  -- doplnit na minim ln¡ po‘adovan˜ po‡et
  while card(availregs{+exclusion})<minregs loop
    -- nal‚zt registr
    if bit8 and (availregs-in_no8bit=[])
      -- vy©¡dit po‘adavek na 8mi bitov˜ registr
      then
        findunireg(info,uni,1,irm_int,availregs+exclusion);
        bit8:=false;
      -- nal‚zt libovoln˜ registr
      else findunireg(info,uni,4,irm_int,availregs+exclusion);
    verify(337,uni=in_none);

    -- zahrnout mezi voln‚ registry
    availregs+[uni];
    end loop;

  -- pou‘¡t v¨echny registry
  for uni in in_first..in_last loop
    if uni in availregs then useunireg(inst,info,uni); end if;
    end loop;
}
  end reserveavailregs;



----------------------------------------------------------------------------------------------------
procedure freeavailregs =
-- Uvoln¡ mno‘inu voln˜ch registr–.
----------------------------------------------------------------------------------------------------
begin
  -- uvolnit v¨echny registry
  for uni in in_first..in_last loop
    if uni in availregs then i_freeuni(info,context,uni); end if;
    end loop;
{ %%OLD
  -- uvolnit v¨echny registry
  for uni in in_first..in_last loop
    if uni in availregs then freeunireg(info,uni); end if;
    end loop;
}
  availregs:=[];
  end freeavailregs;



----------------------------------------------------------------------------------------------------
procedure areavailregs =
-- True, je-li k dispozici alespo¤ jeden N-bytov˜ registr.
----------------------------------------------------------------------------------------------------
begin
  result:=false;
  for uni in in_first..in_last loop
    if not (uni in context.active) and (iunitoreg[uni,n]<>ir_none) then
      result:=true;
      return;
      end if;
    end loop;
  end areavailregs;



----------------------------------------------------------------------------------------------------
procedure regcount =
-- Spo‡¡t , kolik je n-bytov˜ch registr– v REGS.
----------------------------------------------------------------------------------------------------
begin
  -- kolik m me n-bytov˜ch registr– ?
  result:=0;
  for uni in in_first..in_last loop
    if (uni in regs) and (iunitoreg[uni,n]<>ir_none) then succ result; end if;
    end loop;
  end regcount;



----------------------------------------------------------------------------------------------------
procedure getopregs =
-- Mno‘ina registr– pou‘it˜ch operandem.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

begin
  result:=[];
  --%%TODO(UNION) if op.optype=io_reg then
  --  result+iuniregset:[iregtouni[op.reg.reg]];
  --elsif op.optype=io_mem then
  --  if op.base.reg<>ir_none then result+iuniregset:[iregtouni[op.base.reg]]; end if;
  --  if op.index.reg<>ir_none then result+iuniregset:[iregtouni[op.index.reg]]; end if;
  --  end if;
  if op.optype=io_reg then
    bit_set(result,t_bit_index(iregtouni[op.reg.reg]:ord));
  elsif op.optype=io_mem then
    if op.base.reg<>ir_none then bit_set(result,t_bit_index(iregtouni[op.base.reg]:ord)); end if;
    if op.index.reg<>ir_none then bit_set(result,t_bit_index(iregtouni[op.index.reg]:ord)); end if;
    end if;
  end getopregs;



----------------------------------------------------------------------------------------------------
procedure composeop =
-- Vytvo©¡ OP2 podle OP1 a vhodnˆ roz¨¡©¡ o registr REG.
----------------------------------------------------------------------------------------------------
begin
  verify(340,(op1.optype<>io_mem) or (opreg.optype<>io_reg) or ((op1.base.reg<>ir_none) and (op1.index.reg<>ir_none)));
  op2:=op1;
  if op1.index.reg<>ir_none
    -- znovu pou‘¡t registr indexu
    then 
      i_use(inst,info,context,op1.index.reg,op2.index,idefregsize)
    -- nebo (je-li b ze obsazen ) za©adit dodan˜ registr
    else
      if op1.base.reg<>ir_none then
        i_use(inst,info,context,opreg.reg.reg,op2.index,idefregsize);
        op2.scale:=1;
        end if;
      end if;
  if op1.base.reg<>ir_none
    -- znovupou‘¡t registr b ze
    then i_use(inst,info,context,op1.base.reg,op2.base,idefregsize)
    -- nebo za©adit dodan˜ registr
    else i_use(inst,info,context,opreg.reg.reg,op2.base,idefregsize);
    end if;
{ %%OLD
  op2:=op1;
  if op2.base.reg=ir_none then op2.base.reg:=reg
  elsif op2.index.reg=ir_none then
    op2.index.reg:=reg;
    op2.scale:=1;
  else verify(340,true);
}
  end composeop;



----------------------------------------------------------------------------------------------------
procedure opregtomem =
-- Operand typu IO_IMM nebo IO_REG zmˆn¡ na IO_MEM.
----------------------------------------------------------------------------------------------------
begin
  case op.optype
    when io_imm do op.disp:=op.imm; --op.imm:=nil;
    when io_reg do op.base:=op.reg; --op.reg:=nil;
    when others do verify(549,true);
    end case;
  op.optype:=io_mem;
  end opregtomem;



----------------------------------------------------------------------------------------------------
procedure cloneop =
-- OP2 := OP1.
----------------------------------------------------------------------------------------------------
begin
  op2:=op1;
  -- znovupou‘¡t v¨echny registry
  if op1.optype=io_reg then
    i_use(inst,info,context,op1.reg.reg,op2.reg,op1.size);
  elsif op2.optype=io_mem then
    if op1.base.reg<>ir_none then i_use(inst,info,context,op1.base.reg,op2.base,idefregsize); end if;
    if op1.index.reg<>ir_none then i_use(inst,info,context,op1.index.reg,op2.index,idefregsize); end if;
    end if;
  end cloneop;



----------------------------------------------------------------------------------------------------
procedure separateopreg =
-- Z OP1 vyseparuje b zov˜ nebo indexn¡ registr.
-- OP1 mus¡ b˜t IO_MEM s b zov˜m nebo indexn¡m registrem.
----------------------------------------------------------------------------------------------------
begin
  verify(345,(op1.optype<>io_mem) or (op1.base.reg not in ir_r32 and op1.index.reg not in ir_r32));

  nullop(op2,io_reg);
  op2.size:=idefregsize;
  if op1.base.reg in ir_r32
    then i_use(inst,info,context,op1.base.reg,op2.reg,idefregsize)
    else i_use(inst,info,context,op1.index.reg,op2.reg,idefregsize)
    end if;
{ %%OLD
  op2.reg.reg:=op1.base.reg;
  op2.size:=4;
}
  end separateopreg;



----------------------------------------------------------------------------------------------------
procedure resizereg =
-- P©evede registr na zadanou velikost.
----------------------------------------------------------------------------------------------------
begin
  result:=iunitoreg[iregtouni[reg],size];
  end resizereg;



----------------------------------------------------------------------------------------------------
procedure saveregs =
-- Ulo‘¡ na stack v¨echny pou‘it‚ registry.
----------------------------------------------------------------------------------------------------
var
  mapping          : iregnum;                    -- pro kompatibilitu parametru

begin
  for uni in in_first..in_last loop
    if context.reginfo[uni].status in iregstatusset:[irs_used,irs_pushed] then
      i_useuni(inst,info,context,uni,mapping);
      end if;
    end loop;
  end saveregs;



end ci_oper;