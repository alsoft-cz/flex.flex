----------------------------------------------------------------------------------------------------
module private ci_gen =
-- P©eklada‡ Flexu.
-- Generov n¡ cel‚ kompila‡n¡ jednotky.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_var,
  cc_base,
  cc_base.cc_debug,
  cc_base.cc_rtl,
  cc_base.cc_sym,
  ci_def,
  ci_code,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_code.ci_instr,
  ci_block,
  cp_cpu.cp_32.cp_def,
  cp_cpu.cp_ia32.ci_abi;

----------------------------------------------------------------------------------------------------
procedure i_gen (
    curr           : in pentity;                 -- generovan˜ symbol
    count          : in out t_unsigned);         -- po‡et ji‘ vygenerovan˜ch entit
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure addcall (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o p©ekladu
    psym           : in pentity_code) =           -- volan˜ podprogram
-- P©id  vol n¡ podprogramu.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addcall], kter  si sama p©iprav¡ kontext v˜razu.
----------------------------------------------------------------------------------------------------
with
  ci_context;
  
var
  context          : iexprcontext;

begin
  -- p©ipravit pr zdn˜ kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skute‡n˜ [addjump]
  ci_instr.addcall(inst,info,context,psym);
  end addcall;



----------------------------------------------------------------------------------------------------
procedure addcallrtl (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o p©ekladu
    rtl            : in trtlproc) =              -- volan˜ intern¡ podprogram
-- P©id  vol n¡ intern¡ho podprogramu.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addcallrtl], kter  si sama p©iprav¡ kontext v˜razu.
----------------------------------------------------------------------------------------------------
with
  ci_context;

var
  context          : iexprcontext;

begin
  -- p©ipravit pr zdn˜ kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skute‡n˜ [addjump]
  ci_instr.addcallrtl(inst,info,context,rtl);
  end addcallrtl;



----------------------------------------------------------------------------------------------------
procedure i_instance (
    curr           : in out tentity_code;        -- generovan˜ symbol
    inst           : in out picodeinst) =        -- instance
-- Alokuje novou instanci.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  -- p©ipravit instanci na generov n¡
  i_prepare(curr);

  -- p©ipravit instanci
  new inst;
  if picodegen_subprog(curr.codegen)^.ifirst=nil
    then picodegen_subprog(curr.codegen)^.ifirst:=inst;
    else picodegen_subprog(curr.codegen)^.ilast^.next:=inst;
    end if;
  picodegen_subprog(curr.codegen)^.ilast:=inst;

  -- default volac¡ konvence
  if picodegen_subprog(curr.codegen)^.def_call=icc_default
    then inst^.profile.call:=icc_flex;
    else inst^.profile.call:=picodegen_subprog(curr.codegen)^.def_call;
    end if;

  -- zvolit stack-frame
  if picodegen_subprog(curr.codegen)^.def_frame=isf_default
    then inst^.frame:=isf_fptr;
    else inst^.frame:=picodegen_subprog(curr.codegen)^.def_frame;
    end if;

  -- vytvo©it seznam vno©en˜ch podprogram–
  if curr.nesting<>0 then
    -- jestli‘e to nen¡ top-level podprogram, pak sestavit seznam nad©azen˜ch podprogram–
    if curr.nesting-1>0 then
      -- alokovat pamˆŸ
      new inst^.nested.nlist range curr.nesting-1;

      -- sestavit seznam
      psym:=curr.context.entity;
      inst^.nested.nlist^:length:=curr.nesting-1;
      for i in reverse inst^.nested.nlist^:range loop
        verify(500,(psym=nil) or not (psym^.etype in ets_subprogram) or (pentity_code(psym)^.nesting<>i));
        inst^.nested.nlist^[i]:=pentity_code(psym);
        psym:=psym^.context.entity;
        end loop;
      end if;
    end if;
  end i_instance;



----------------------------------------------------------------------------------------------------
procedure i_gen_compile (
    curr           : in out tentity_compile) =   -- kompila‡n¡ jednotka
-- Vygeneruje k¢d kompila‡n¡ jednotky.
----------------------------------------------------------------------------------------------------
var
  inst             : picodeinst;                 -- instance
  info             : igeninfo;                   -- informace o generov n¡
  srch             : tentitysearch;              -- hled tko
  framehandler     : timm32;                     -- adresa polo‘ky HANDLER v exception-frame
  tg_unhandled     : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  p                : pentity;

begin
  if opt_dump_code in curr.compv.opts then
    debug_dump('-------- Kompilacni jednotka --------------------------------------------------');
    end if;

  -- p©ipravit instanci
  i_instance(curr,inst);

  -- p©ipravit informace o generov n¡
  initinfo(curr,info);

  -- alokovat n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  newtarget(info,tg_unhandled);

  -- vytvo©it stack-frame
  i_gen_entry(curr,inst^,info);

  -- inicializovat task control block pro hlavn¡ task
  if not cfg_no_runtime then 
    addcallrtl(inst^,info,rtl_init_main_task); 
    end if;

  -- vytvo©it exception-frame
  i_create_xframe(inst^,info,framehandler,tg_unhandled);

  -- zavolat ENTRY v¨ech modul–
  for i in 1..entrylist.count loop
    -- vyhledat ENTRY
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_entry);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  -- zavolat program
  srch.find_et_first(^curr,rc_primary,et_program,[]);
  if srch.psym<>nil then 
    addcall(inst^,info,pentity_code(srch.psym)); 
    end if;

  -- zavolat EXIT v¨ech modul–
  for i in reverse 1..entrylist.count loop
    -- vyhledat EXIT
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_exit);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  --deinicializovat task control block pro hlavn¡ task
  if not cfg_no_runtime then 
    addcallrtl(inst^,info,rtl_deinit_main_task); 
    end if;

  -- zru¨it stack-frame (na exception-frame ka¨lem)
  i_gen_exit(curr,inst^,info);

  -- ukon‡it program
  if not cfg_no_runtime then 
    addcallrtl(inst^,info,rtl_terminate); 
    end if;

  -- adresa obsluhy neobslou‘en˜ch v˜jimek
  settarget(info,tg_unhandled,getaddr(inst^));

  -- zavolat osbluhu neobslou‘en˜ch v˜jimek
  if not cfg_no_runtime then 
    addcallrtl(inst^,info,rtl_unhandled_exception); 
    end if;

  -- vyhodnotit lok ln¡ relokace
  localresolve(curr,inst^,info);
  end i_gen_compile;



----------------------------------------------------------------------------------------------------
procedure i_gen_context (
    context        : in tcontext;                -- generovan˜ symbol
    count          : in out t_unsigned) =        -- po‡et ji‘ vygenerovan˜ch entit
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;                    -- zpracov van  entita
  region           : pregion;                    -- zpracov van˜ region

begin
  -- vygenerovat k¢d pro v¨echny entity
  entity:=context.region^.entities.first;
  while entity<>nil loop
    -- vygenerovat
    i_gen(entity,count);

    -- dal¨¡ entita
    entity:=entity^.next;
    end loop;

  -- a pro v¨echny podregiony
  region:=context.region^.regions.first;
  while region<>nil loop
    -- vygenerovat
    i_gen_context(sym_build_context(context.entity,region),count);

    -- dal¨¡ region
    region:=region^.next;
    end loop;
  end i_gen_context;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------
with
  standard.console,
  cc_def.cc_codes;

var
  inst             : picodeinst;                 -- instance
--p                : pentity;

begin
  -- vygenerovat k¢d pro tento symbol
  if curr^.etype in ets_body then
    --write_line(sym_get_qid(curr));

    if opt_dump_code in curr^.compv.opts then
      debug_dump('-------- ' & sym_get_qid(curr) & ' --------');
      end if;

    begin
      -- p©ipravit instanci
      i_instance(pentity_code(curr)^,inst);

      -- vygenerovat blok p©¡kaz–
      i_gen_block(pentity_code(curr)^,inst^);

    catch
      when compiler_error do 
          write_line(sym_get_qid(curr));
      {%%X ??? nem  tu b˜t INTERNAL_ERROR ? } -- nic nedˆlat
      end;

    -- zapo‡¡tat a zobrazit voltmetr
    succ count;
    --showvoltmetr(v,count);
    end if;

  -- zpracovat v¨echny regiony
  for rcategory in tregioncategory loop
    if curr^.regions[rcategory]<>nil then 
      i_gen_context(sym_build_context(curr,curr^.regions[rcategory]),count);
      end if;
    end loop;

{
  -- vygenerovat k¢d pro v¨echny podsymboly
  p:=curr^.symtab;
  while p<>nil loop

    -- vygenerovat k¢d
    {if p^.etype in ets_enclosed then}
      i_gen(p,count{,v});
      --end if;

    -- dal¨¡ symbol
    p:=p^.next;
    end loop;
}
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_estimate (
    curr           : in pentity;                 -- generovan˜ symbol
    total          : in out t_unsigned);         -- po‡et generovan˜ch entit
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_estimate_context (
    context        : in tcontext;                -- generovan˜ symbol
    total          : in out t_unsigned) =        -- po‡et ji‘ vygenerovan˜ch entit
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;                    -- zpracov van  entita
  region           : pregion;                    -- zpracov van˜ region

begin
  -- vygenerovat k¢d pro v¨echny entity
  entity:=context.region^.entities.first;
  while entity<>nil loop
    -- zpracovat
    i_estimate(entity,total);

    -- dal¨¡ entita
    entity:=entity^.next;
    end loop;

  -- a pro v¨echny podregiony
  region:=context.region^.regions.first;
  while region<>nil loop
    -- vygenerovat
    i_estimate_context(sym_build_context(context.entity,region),total);

    -- dal¨¡ region
    region:=region^.next;
    end loop;
  end i_estimate_context;



----------------------------------------------------------------------------------------------------
procedure i_estimate =
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------
begin
  -- zapo‡¡tat tuto entitu
  if curr^.etype in ets_body then
    succ total;
    end if;

  -- zpracovat v¨echny regiony
  for rcategory in tregioncategory loop
    if curr^.regions[rcategory]<>nil then 
      i_estimate_context(sym_build_context(curr,curr^.regions[rcategory]),total);
      end if;
    end loop;
{
  -- zapo‡¡tat podentity
  p:=curr^.symtab;
  while p<>nil loop

    -- vygenerovat k¢d
    --if p^.etype in pts_enclosed then
      i_estimate(p,total);
      --end if;

    -- dal¨¡ symbol
    p:=p^.next;
    end loop;
}
  end i_estimate;



----------------------------------------------------------------------------------------------------
procedure i_codegen =
-- Hlavn¡ smy‡ka gener toru k¢du.
----------------------------------------------------------------------------------------------------
var
  total            : t_unsigned;
  count            : t_unsigned;
--v                : tvoltmetr;

begin
  -- odhadnout d‚lku generov n¡, aby se dal zobrazit voltmetr
  total:=0;
  i_estimate(compi,total);

  -- vygenerovat k¢d v¨ech prvk–
  count:=0;
--initvoltmetr(v,total);
  i_gen(compi,count{,v});
--deletevoltmetr(v);

  -- vygenerovat kod kompila‡n¡ jednotky
  i_gen_compile(compi^);
  end i_codegen;



end ci_gen;