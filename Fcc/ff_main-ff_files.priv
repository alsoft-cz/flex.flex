----------------------------------------------------------------------------------------------------
module private ff_files =
-- P©eklada‡ Flexu.
-- Seznam jmen soubor–.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.02.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  standard.files;

const
  -- extenze soubor–
  ext_source       = 'src';
  ext_public       = 'pub';
  ext_private      = 'priv';

----------------------------------------------------------------------------------------------------
class private c_file_source_external_files =
-- Poskytovatel jmen soubor– a jejich input stream–.
----------------------------------------------------------------------------------------------------

    with
      standard.classes,
      standard.classes.lists,
      standard.strings;

    var
      -- seznamy jmen soubor– oddˆlenˆ podle logick‚ ‡ sti
      files        : array t_part of c_names;    

    ------------------------------------------------------------------------------------------------
    static add_name (
        folder_name: in c_name;                  -- jm‚no folderu
        file_name  : in c_name;                  -- jm‚no souboru
        part       : in t_part) =                -- logick  ‡ st
    -- P©id  zadan‚ jm‚no do seznamu jmen soubor–.
    ------------------------------------------------------------------------------------------------
    {
    with
      standard.console;
    }
    var
      full_name    : p_name;                     -- pln‚ jm‚no souboru v‡etnˆ cesty
    {
      text_name    : p_text_name;
    }
    begin
      -- sestavit pln‚ jm‚no souboru v‡etnˆ cesty
      new full_name;
      full_name^.join(folder_name,file_name);
    {
      full_name^.compose_name(text_name);
      write_line(text_name^);
      discard text_name;
    }
      -- doplnit do p©¡slu¨n‚ho seznamu
      files[part].insert(full_name);
      end add_name;



    ------------------------------------------------------------------------------------------------
    static trace_search_path (
        folder     : in c_folder;                -- prohled van˜ folder
        recursive  : in t_logical) =             -- T-rekurzivnˆ trasovat podadres ©e
    -- Prohled  zadan˜ folder a dopln¡ do seznamu jmen soubor– v¨echny vyhovuj¡c¡ soubory. Je-li
    -- [recursive] nastaveno na [true], projde pot‚ i v¨echny podadres ©e.
    ------------------------------------------------------------------------------------------------
    var
      file_name    : p_name;                     -- jm‚no nalezen‚ho souboru
      file_name_component : p_name_component_file_or_folder; -- jedin  komponenta jm‚na souboru
      part         : t_part;                     -- o jakou logickou ‡ st se jedn 
      matches      : t_logical;                  -- T-jm‚no souboru vyhovuje podm¡nk m pro za©azen¡
      iterator     : c_list_iterator;            -- iter tor pro proch zen¡ seznamu jmen soubor–
      sub_folder_name : p_name;                  -- jm‚no podadres ©e
      sub_folder   : c_name;                     -- podadres ©
      extension    : p_name_subcomponent_extension; -- p©¡pona jm‚na souboru

    begin
      -- zpracovat v¨echny soubory
      iterator.init({%%TODO(TAG)}p_list(^folder.files)^,tlwd_forward);
      while iterator.get(p_item(file_name)) loop
        -- jedinou komponentou jm‚na nalezen‚ho souboru je pr vˆ jeho jm‚no, ale pro jistotu
        -- vezmeme tu posledn¡
        file_name_component:=file_name^.components.get_last;
        
        -- zjistit, zda jm‚nou souboru kon‡¡ nˆkterou z na¨ich extenz¡ a odvodit p©i tom logickou ‡ st
        if file_name_component^.check_last_extension(ext_source) then part:=part_all; matches:=true;
        elsif file_name_component^.check_last_extension(ext_public) then part:=part_public; matches:=true;
        elsif file_name_component^.check_last_extension(ext_private) then part:=part_private; matches:=true;
        else  
          matches:=false;
          end if;

        -- kon‡¡-li soubor nˆkterou z na¨ich extenz¡, za©adit ho do seznamu dostupn˜ch soubor–
        if matches then
          -- zjistit, jestli i ostatn¡ extenze vyhovuj¡ konfiguraci aktu ln¡ c¡lov‚ platformy
          if file_name_component^.subcomponents.count>2 then
            {%%FLEX}
            extension:=file_name_component^.subcomponents.get_next(file_name_component^.subcomponents.get_first);
            matches:=str_compare_case_insensitive(extension^.name^,'win32');
            end if;

          -- p©idat do seznamu jmen
          if matches then
            add_name(folder.name,file_name^,part);
            end if;
          end if;
        end loop;

      -- a nyn¡, je-li to po‘adov no, je¨tˆ zpracovat v¨echny podadres ©e
      if recursive then
        iterator.init({%%TODO(TAG)}p_list(^folder.folders)^,tlwd_forward);
        while iterator.get(p_item(sub_folder_name)) loop
          trace_search_path(folder.get_sub_folder(sub_folder_name^),recursive);
          end loop;
        end if;
      end trace_search_path;



    ------------------------------------------------------------------------------------------------
    static add_search_path =
    -- Dopln¡ do seznamu jmen soubor– v¨echny soubory dostupn‚ na zadan‚ vyhled vac¡ cestˆ.
    ------------------------------------------------------------------------------------------------
    var
      folder       : c_folder;                   -- folder, ve kter‚m se hledaj¡ soubory

    begin
      -- p©ipravit folder
      folder.init_text_name(search_path);

      -- prohledat
      trace_search_path(folder,recursive);
      end add_search_path;


    
    ------------------------------------------------------------------------------------------------
    override get_source_file_name =
    -- Podle zadan˜ch £daj– nalezne pln‚ jm‚no souboru.
    ------------------------------------------------------------------------------------------------
    var
      iterator     : c_list_iterator;            -- iter tor pro proch zen¡ seznamu jmen soubor–
      file_name    : p_name;                     -- jm‚no souboru ze seznamu dostupn˜ch soubor–
      file_name_component : p_name_component_file_or_folder; -- jedin  komponenta jm‚na souboru
      base_name    : p_name_subcomponent_base_name;          -- b zov‚ jm‚no souboru
      text_name    : p_text_name;

    begin
      -- proj¡t seznam v¨ech soubor–
      iterator.init(p_list(^files[part])^,tlwd_forward);
      while iterator.get(p_item(file_name)) loop
        -- zaj¡m  n s jm‚no souboru
        file_name_component:=file_name^.components.get_last;

        -- a z nˆj jen z klad jm‚na
        base_name:=file_name_component^.subcomponents.get_first;

        -- pokud souhlas¡ se zadan˜m, m me n ¨ soubor
        if str_compare_case_insensitive(base_name^.name^,base) then
          begin
            {%%FLEX}
            file_name^.compose_name(text_name);
            result:=text_name^;
            return;
          leave
            discard text_name;
            end;
          end if;
        end loop;
      end get_source_file_name;



    ------------------------------------------------------------------------------------------------
    override get_included_file_name =
    -- Sestav¡ absolutn¡ jm‚no includovan‚ho souboru. Je-li zad no relativn¡ jm‚no, vzt hne ho 
    -- k uveden‚ b zi. Absolutn¡ jm‚no ponech  beze zmˆny.
    ------------------------------------------------------------------------------------------------
    var
      base_name    : c_name;                     -- b zov‚ jm‚no
      inc_name     : c_name;                     -- includovan‚ jm‚no
      full_name    : c_name;                     -- cel‚ includovan‚ jm‚no
      text_name    : p_text_name;

    begin
      -- analyzovat dodan  jm‚na
      inc_name.decompose_name(name,tnt_unspecified);

      -- je to absolutn¡ nebo relativn¡ jm‚no ?
      if inc_name.name_type=tnt_relative

        -- relativn¡
        then 
          -- analyzovat b zi
          --base_name.decompose_name(base,tnt_unspecified);

          -- zkop¡rovat zadanou b zi, zbavit se jm‚na souboru a ponechat jen adres ©
          begin
            base.compose_name(text_name);
            base_name.decompose_name(text_name^,tnt_unspecified);
            base_name.components.delete_last; --%%TODO(LIB) jen je-li to c_name_component_file
          leave
            discard text_name;
            end;

          -- slou‡it s b z¡
          full_name.join(base_name,inc_name);

          -- p©ev‚st na textov‚ jm‚no
          full_name.compose_name(text_name);

        -- absolutn¡
        else
          -- p©ev‚st zase zp tky na textov‚ jm‚no
          inc_name.compose_name(text_name);
          end if;

      -- p©edat ven
      result:=text_name^;

    leave
      discard text_name;
      end get_included_file_name;

    end c_file_source_external_files;



----------------------------------------------------------------------------------------------------
procedure replace_source_extension =
-- Pokud jm‚no souboru kon‡¡ p©¡ponou typickou pro zdroj k, tak ji nahrad¡ uvedenou p©¡ponou
----------------------------------------------------------------------------------------------------
var
  file_name_component : p_name_component_file_or_folder; -- jedin  komponenta jm‚na souboru

begin
  -- posledn¡ komponenta je vlastn¡ jm‚no souboru
  file_name_component:=source_name.components.get_last;

  -- m -li jm‚no souboru nˆjakou p©¡ponu
  if file_name_component^.subcomponents.count>=2 and then
  -- a je to p©¡pona typick  pro zdroj k
    (file_name_component^.check_last_extension(ext_source) 
  or file_name_component^.check_last_extension(ext_public) 
  or file_name_component^.check_last_extension(ext_private))

    -- tak ji nahradit uvedenou p©¡ponou
    then
      file_name_component^.replace_last_extension(extension);

    -- jinak p©idat na konec
    else
      file_name_component^.append_extension(extension);
      end if;
  end replace_source_extension;

end ff_files;