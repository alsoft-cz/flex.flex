---------------------------------------------------------------------------------------------------
module private thread =
-- Flex Run-time Library
-- Thread variables
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
with
    os_api,
    synchronization,
    flex.exceptions,
    flex.exceptions.seh,
    stack;
    

type
    t_thread_sysTIBuservalue;
    p_thread_sysTIBuservalue = ^t_thread_sysTIBuservalue;
    t_thread_sysTIBuservalue = record
      value        : t_rtl_native_unsigned;
      prev         : p_thread_sysTIBuservalue;
      end record;

    t_thread_physical = record
      threadid     : t_rtl_unsigned32;
      threadhandle : THANDLE;
      end record;

    t_thread_header = record
      exceptions   : t_rtl_exceptions;
      osthread     : t_thread_physical;
      stackheader  : t_rtl_stack_header;
      parentthread : p_thread_header;
      variables    : vars.t_thread_vars;
      usagecount   : t_rtl_native_unsigned;
      TIBusrval    : t_thread_sysTIBuservalue;
      knownstart   : t_rtl_logical8;
      listnext     : p_thread_header;
      listprev     : p_thread_header;
      locker       : t_rtl_critical;
      ref_count    : t_rtl_native_unsigned;
      ref_first    : p_thread_ref;
      flexreserve  : array 0..15 of t_rtl_native_unsigned;
      userreserve  : array 0..15 of t_rtl_native_unsigned;
      end record;

var
{system TSL}
    sthread_header : t_rtl_unsigned32;
-- main thread task control block
    mainthreadheader : t_thread_header;
    thread_list_first : p_thread_header;
    thread_list_lock  : t_rtl_critical;
    thread_list_count : t_rtl_native_unsigned;
    

type
    t_threadvar_id = t_rtl_native_unsigned;

----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_safe return p_thread_header;
----------------------------------------------------------------------------------------------------
procedure rtl_suspend_thread_internal(
    threadheader   : in p_thread_header);
----------------------------------------------------------------------------------------------------
procedure rtl_resume_thread_internal(
    threadheader   : in p_thread_header);
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
#separate private vars;
#separate private exceptions;
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
procedure rtl_thread_list_add(
    threadheader   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_list_lock);
  threadheader^.listprev:=nil;
  threadheader^.listnext:=thread_list_first;
  if thread_list_first<>nil then
    thread_list_first^.listprev:=threadheader;
    end if;
  thread_list_first:=threadheader;
  thread_list_count + 1;
  rtl_critical_unlock(thread_list_lock);
  end rtl_thread_list_add;

----------------------------------------------------------------------------------------------------
procedure rtl_thread_list_del(
    threadheader   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_list_lock);
  if threadheader^.listprev=nil then
    thread_list_first:=threadheader^.listnext;
    if thread_list_first<>nil then
      thread_list_first^.listprev:=nil;
      end if;
    threadheader^.listnext:=nil;
  else
    if threadheader^.listnext<>nil then
      threadheader^.listnext^.listprev:=threadheader^.listprev;
      end if;
    threadheader^.listprev^.listnext:=threadheader^.listnext;
    threadheader^.listprev:=nil;
    threadheader^.listnext:=nil;
    end if;
  thread_list_count - 1;
  rtl_critical_unlock(thread_list_lock);
  end rtl_thread_list_del;

----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_safe =
----------------------------------------------------------------------------------------------------
begin 
  result:unchecked:=TlsGetValue(sthread_header);
  end rtl_get_current_thread_safe;

----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread =
----------------------------------------------------------------------------------------------------
begin 
  #syntax asm;
      mov    eax,fs:[t_winnt_tib.aruserpointer]
      mov    result,eax
      #end asm;
  end rtl_get_current_thread;

----------------------------------------------------------------------------------------------------
procedure rtl_suspend_thread_internal =
----------------------------------------------------------------------------------------------------
begin 
  if SuspendThread(threadheader^.osthread.threadhandle)=$FFFFFFFF then 
    raise tasking_error;
    end if;
  end rtl_suspend_thread_internal;

----------------------------------------------------------------------------------------------------
procedure rtl_resume_thread_internal =
----------------------------------------------------------------------------------------------------
begin 
  if ResumeThread(threadheader^.osthread.threadhandle)=$FFFFFFFF then 
    raise tasking_error;
    end if;
  end rtl_resume_thread_internal;


----------------------------------------------------------------------------------------------------
procedure rtl_create_thread_ref(
    threadheader   : in p_thread_header;
    outthread_ref  : in out ref t_thread_ref)=
----------------------------------------------------------------------------------------------------
begin
  outthread_ref.threadheader:=threadheader;
  outthread_ref.next_ref:=threadheader^.ref_first;
  outthread_ref.prev_ref:=nil;
  if threadheader^.ref_first<>nil then
    threadheader^.ref_first^.prev_ref:=^outthread_ref;
    end if;
  threadheader^.ref_first:=^outthread_ref;
  threadheader^.ref_count + 1; 
  end rtl_create_thread_ref;

----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_ref =
----------------------------------------------------------------------------------------------------
var
    threadheader   : p_thread_header;
begin
  threadheader:=rtl_get_current_thread;
  rtl_critical_lock(threadheader^.locker);
  rtl_create_thread_ref(threadheader,thread_ref);
  rtl_critical_unlock(threadheader^.locker);
  end rtl_get_current_thread_ref;


----------------------------------------------------------------------------------------------------
procedure rtl_copy_thread_ref =
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(inthread_ref.threadheader^.locker);
  rtl_create_thread_ref(inthread_ref.threadheader,outthread_ref);
  rtl_critical_unlock(inthread_ref.threadheader^.locker);
  end rtl_copy_thread_ref;


----------------------------------------------------------------------------------------------------
procedure rtl_discard_thread_ref =
----------------------------------------------------------------------------------------------------
begin
  if thread_ref.threadheader<>nil then
    rtl_critical_lock(thread_ref.threadheader^.locker);
    if ^thread_ref=thread_ref.threadheader^.ref_first then
      thread_ref.threadheader^.ref_first:=thread_ref.next_ref;
      if thread_ref.next_ref<>nil then
        thread_ref.next_ref^.prev_ref:=nil;
        thread_ref.next_ref:=nil;
        end if;
    else
      if thread_ref.next_ref<>nil then
        thread_ref.next_ref^.prev_ref:=thread_ref.prev_ref;
        end if;
      thread_ref.prev_ref^.next_ref:=thread_ref.next_ref;
      thread_ref.next_ref:=nil;
      thread_ref.prev_ref:=nil;
      end if;
    thread_ref.threadheader^.ref_count - 1; 
    rtl_critical_unlock(thread_ref.threadheader^.locker);
    thread_ref.threadheader:=nil;
    end if;
  end rtl_discard_thread_ref;


----------------------------------------------------------------------------------------------------
procedure rtl_discard_all_thread_ref (
    threadheader   : in p_thread_header)=
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(threadheader^.locker);
  while(threadheader^.ref_first<>nil) loop
    rtl_discard_thread_ref(threadheader^.ref_first^);
    end loop;
  rtl_critical_unlock(threadheader^.locker);
  end rtl_discard_all_thread_ref;


----------------------------------------------------------------------------------------------------
procedure rtl_init_task_header(
    knownstart     : in t_rtl_logical8;
    initvars       : in t_rtl_logical8;
    threadheader   : in p_thread_header;
    parentthread   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
    threadheader^.parentthread:=parentthread;
    threadheader^.variables:=nil;
    threadheader^.flexreserve:=nil;
    threadheader^.userreserve:=nil;
    threadheader^.usagecount:=1;
    threadheader^.listnext:=nil;
    threadheader^.listprev:=nil;
    threadheader^.knownstart:=knownstart;
    rtl_critical_new(threadheader^.locker);
    threadheader^.ref_count:=0;
    threadheader^.ref_first:=nil;
    if knownstart then
      if initvars then
        vars.rtl_initialize_all_threadvars(threadheader,parentthread);
        end if;
      rtl_thread_list_add(threadheader);
      end if;
  end rtl_init_task_header;

----------------------------------------------------------------------------------------------------
procedure rtl_deinit_task_header(
    threadheader   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
  vars.rtl_discard_all_threadvars(threadheader);
  if threadheader^.knownstart then
    rtl_thread_list_del(threadheader);
    end if;
  end rtl_deinit_task_header;

----------------------------------------------------------------------------------------------------
procedure rtl_init_task_helper(
    thread_header  : p_thread_header)=
----------------------------------------------------------------------------------------------------
#if #environment compiler_version;='4.0.3.3' then;
begin
  -- nastavit jako systemovou threadovou promennou
  if not TlsSetValue(sthread_header,LPVOID(thread_header:unchecked)) then
    raise tasking_error;
    end if;
  thread_header^.osthread.threadid:=t_thread_id(GetCurrentThreadId);
  thread_header^.osthread.threadhandle:=OpenThread(THREAD_ALL_ACCESS,false,thread_header^.osthread.threadid);
  if thread_header^.osthread.threadhandle=nil then 
    raise tasking_error;
    end if;
#else;
var
  prochandle   : THANDLE;
  threadhandle : THANDLE;
  dupresult    : BOOL;

begin
  -- nastavit jako systemovou threadovou promennou
  if not TlsSetValue(sthread_header,LPVOID(thread_header:unchecked)) then
    raise tasking_error;
    end if;
  prochandle:=GetCurrentProcess;
  dupresult:=DuplicateHandle(prochandle,GetCurrentThread,prochandle,^threadhandle:unchecked,0,false,DUPLICATE_SAME_ACCESS);
  thread_header^.osthread.threadhandle:=threadhandle;
    if not dupresult or thread_header^.osthread.threadhandle=nil then 
    raise tasking_error;
    end if;
#end if;
  end rtl_init_task_helper;

----------------------------------------------------------------------------------------------------
procedure rtl_deinit_task_helper(
    thread_header  : p_thread_header)=
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_header^.locker);
  if not CloseHandle(THANDLE(thread_header^.osthread.threadhandle)) then
    raise tasking_error;
    end if;
  thread_header^.osthread.threadhandle:=INVALID_HANDLE;
  thread_header^.osthread.threadid:=INVALID_HANDLE;
  if not TlsSetValue(sthread_header,nil) then
    raise tasking_error;
    end if;
  rtl_critical_discard(thread_header^.locker);
  end rtl_deinit_task_helper;


type 
    t_thread_starter = record
      userdata     : t_rtl_pointer;
      thread_entry : p_rtl_thread_entry;
      threadheader : p_thread_header;
      suspended    : t_rtl_logical8;
      wait_event   : t_rtl_event;
      end record;
    p_thread_starter = ^t_thread_starter for machine_pointer use true;



----------------------------------------------------------------------------------------------------
procedure thread_entry_internal:t_rtl_thread_entry_win32= 
----------------------------------------------------------------------------------------------------
var
    stacpy         : t_thread_starter;
    threadheader   : p_thread_header;
    tibvalptr      : ^ t_rtl_native_unsigned;
    sys_except_handler : t_rtl_exceptions_handler;
    unhandledx     : t_rtl_except_row;
begin
  stacpy:=p_thread_starter(starter)^;
  threadheader:=stacpy.threadheader;

  --nastavim svuj TIB
  threadheader^.TIBusrval.prev:=nil;
  tibvalptr:=^threadheader^.TIBusrval.value;
  #syntax asm;
    --backup old value of TIB user val
    mov    eax,fs:[t_winnt_tib.aruserpointer]
    mov    edx,tibvalptr
    mov    [edx],eax  {%%TODO(asm) mov mainthreadheader.TIBusrval.value,eax }
    --set new value
    mov    eax,threadheader
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;

  -- nastavit jako systemovou threadovou promennou
  if not TlsSetValue(sthread_header,LPVOID(threadheader:unchecked)) then
    raise tasking_error;
    end if;

  -- inicializovat threadove vlastnosti
  rtl_init_task_exceptions(^threadheader^.exceptions);
  rtl_init_task_exceptions_win32(^sys_except_handler);
  rtl_init_task_header(true,true,threadheader,threadheader^.parentthread);

  -- allow parent run
  rtl_event_set(p_thread_starter(starter)^.wait_event);

  --suspend if need
  if stacpy.suspended then
    rtl_suspend_thread_internal(stacpy.threadheader);
    end if;

  --vytvorit prvni exception frame
  begin
    begin
      -- volat uzivatelsky kod
      stacpy.thread_entry^(stacpy.userdata);
    leave
      -- odinicializovat threadove vlastnosti
      rtl_deinit_task_header(stacpy.threadheader);
      if not TlsSetValue(sthread_header,nil) then
        raise tasking_error;
        end if;
      end;
    -- odinicializovat threadove vlastnosti
    rtl_deinit_task_exceptions(^threadheader^.exceptions);
    rtl_deinit_task_exceptions_win32(^sys_except_handler);
    rtl_terminate_thread;
  catch
    when others do
      rtl_get_exception(unhandledx.ecode,unhandledx.etag,unhandledx.edata);
      rtl_raise_unhandled_exception(unhandledx.ecode,unhandledx.etag,unhandledx.edata);
    end;
  end thread_entry_internal;
#pragma convention(thread_entry_internal,system);



----------------------------------------------------------------------------------------------------
procedure rtl_start_thread =
----------------------------------------------------------------------------------------------------
var
  starter          : t_thread_starter;
  i                : DWORD;
  threadheader     : p_thread_header;
begin 
  new threadheader;
  starter.userdata:=userdata;
  starter.thread_entry:=thread_entry;
  starter.threadheader:=threadheader;
  starter.suspended:=suspended;
  threadheader^.parentthread:=rtl_get_current_thread;
  rtl_event_new(starter.wait_event);
  starter.threadheader^.osthread.threadhandle:=CreateThread(nil,64*1024{%%TODO remove when dynamic stack}*8{},^thread_entry_internal,^starter,STACK_SIZE_PARAM_IS_A_RESERVATION,starter.threadheader^.osthread.threadid);
  if starter.threadheader^.osthread.threadhandle=0 then
    discard threadheader;
    rtl_event_discard(starter.wait_event);
    raise tasking_error;
    end if;
  rtl_event_wait(starter.wait_event);
  rtl_event_discard(starter.wait_event);
  rtl_create_thread_ref(threadheader,thread_ref);
  end rtl_start_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_register_task =
----------------------------------------------------------------------------------------------------
var
  threadheader     : p_thread_header;
  tibvalptr        : ^ t_rtl_native_unsigned;
  TBIPrev          : p_thread_sysTIBuservalue;
  unknown          : t_rtl_logical8:=true;
  ismain           : t_rtl_logical8:=true;
begin
  threadheader:=rtl_get_current_thread_safe;
  if threadheader<>nil then
    unknown:=false;
    threadheader^.usagecount + 1;
    --zalohuju posledni TIB
    new TBIPrev;
    TBIPrev^.prev:=threadheader^.TIBusrval.prev;
    TBIPrev^.value:=threadheader^.TIBusrval.value;
    threadheader^.TIBusrval.prev:=TBIPrev;
  else
    if ismain then
      rtl_critical_new(thread_list_lock);
      sthread_header:=TlsAlloc;
      thread_list_count:=0;
      threadheader:=^mainthreadheader;
    else
      new threadheader;
      end if;
    threadheader^.TIBusrval.prev:=nil;
    threadheader^.parentthread:=nil;
    if not TlsSetValue(sthread_header,threadheader) then
      raise tasking_error;
      end if;
    end if;

  --nastavim(obnovim) svuj TIB
  tibvalptr:=^threadheader^.TIBusrval.value;
  #syntax asm;
    --backup old value of TIB user val
    mov    eax,fs:[t_winnt_tib.aruserpointer]
    mov    edx,tibvalptr
    mov    [edx],eax  {%%TODO(asm) mov mainthreadheader.TIBusrval.value,eax }
    --set new value
    mov    eax,threadheader
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;
  if unknown then
    -- inicializovat
    rtl_init_task_exceptions(^threadheader^.exceptions);
    rtl_init_task_helper(threadheader);
    rtl_init_task_header(ismain,false,threadheader,nil);
#if #environment compiler_version;='4.0.3.3' then;
    rtl_init_task_exceptions_win32_inject;
#else;
    threadheader^.stackheader.seh_handler:=p_rtl_exceptions_handler(topstackspace);
    rtl_init_task_exceptions_win32(threadheader^.stackheader.seh_handler);
#end if;
    end if;
  end rtl_register_task;

-- compiler magic
#pragma assign(register_task,rtl_register_task);


----------------------------------------------------------------------------------------------------
procedure rtl_unregister_task =
----------------------------------------------------------------------------------------------------
var
  threadheader     : p_thread_header;
  tibval           : t_rtl_native_unsigned;
  tibptr           : p_thread_sysTIBuservalue;
  dodiscard        : t_rtl_logical8:=false;
  ismain           : t_rtl_logical8:=false;

begin
  threadheader:=rtl_get_current_thread_safe;
  if threadheader=nil then
    raise tasking_error;
    end if;
  if threadheader=^mainthreadheader then
    ismain:=true;
    end if;
  threadheader^.usagecount - 1;
  tibval:=threadheader^.TIBusrval.value;
  tibptr:=threadheader^.TIBusrval.prev;
  if tibptr<>nil then
    threadheader^.TIBusrval.value:=tibptr^.value;
    threadheader^.TIBusrval.prev:=tibptr^.prev;
    discard tibptr;
    end if;
  if threadheader^.usagecount=0 then
    rtl_deinit_task_header(threadheader);
    rtl_discard_all_thread_ref(threadheader);
    rtl_deinit_task_helper(threadheader);
    rtl_deinit_task_exceptions(^threadheader^.exceptions);
    dodiscard:=true;
    if ismain then
      rtl_critical_discard(thread_list_lock);
      if not TlsFree(sthread_header) then
#if #environment compiler_version;='4.0.3.3' then;
        raise tasking_error;
#else;
        -- %%HYNEK - TlsFree vzdy vraci chybu v DLL. Vyresi az vlastni inicializacni rutiny knihoven.
        -- raise tasking_error;
#end if;
        end if;
    else
      discard threadheader;
      end if;
    end if;
  #syntax asm;
    --restore prev value
    mov    eax,tibval
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;
  if dodiscard then
#if #environment compiler_version;='4.0.3.3' then;
    rtl_deinit_task_exceptions_win32_inject;
#else;
    rtl_deinit_task_exceptions_win32(threadheader^.stackheader.seh_handler);
#end if;
    end if;
  end rtl_unregister_task;

-- compiler magic
#pragma assign(unregister_task,rtl_unregister_task);

----------------------------------------------------------------------------------------------------
procedure rtl_wait_and_finish_thread =
----------------------------------------------------------------------------------------------------
var
  threadheader : p_thread_header;
begin 
  threadheader:=thread_ref.threadheader;
  if WaitForSingleObjectEx(threadheader^.osthread.threadhandle,INFINITE,true)=WAIT_FAILED then
    raise tasking_error;
    end if;
  if SleepEx(0,true)=0 then
    end if;
  rtl_critical_lock(threadheader^.locker);
  rtl_discard_all_thread_ref(threadheader);
  if not CloseHandle(THANDLE(threadheader^.osthread.threadhandle)) then
    raise tasking_error;
    end if;
  threadheader^.osthread.threadhandle:=INVALID_HANDLE;
  threadheader^.osthread.threadid:=INVALID_HANDLE;
  rtl_critical_discard(threadheader^.locker);
  discard threadheader;
  end rtl_wait_and_finish_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_kill_and_finish_thread =
----------------------------------------------------------------------------------------------------
var
  threadheader : p_thread_header;
begin
  threadheader:=thread_ref.threadheader;
  exceptions.rtl_raise_external_exception(threadheader,0,6,0);
  --%% TODO stale bezi ... na vyjimku nereaguje ? kill ?
  {
  if not TerminateThread(THANDLE(thread_ref.threadheader^.threadhandle),0) then 
    raise tasking_error;
    end if;
  }
  rtl_wait_and_finish_thread(thread_ref);
  end rtl_kill_and_finish_thread;

----------------------------------------------------------------------------------------------------
procedure rtl_wait_for_finish_thread =
----------------------------------------------------------------------------------------------------
begin 
  if thread_ref.threadheader<>nil then
    if WaitForSingleObjectEx(thread_ref.threadheader^.osthread.threadhandle,INFINITE,true)=WAIT_FAILED then
      raise tasking_error;
      end if;
    end if;
  end rtl_wait_for_finish_thread;


----------------------------------------------------------------------------------------------------
procedure rtl_terminate_thread =
----------------------------------------------------------------------------------------------------
begin
  ExitThread(0);
  end rtl_terminate_thread;

end thread;
