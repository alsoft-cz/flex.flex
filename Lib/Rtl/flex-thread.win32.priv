---------------------------------------------------------------------------------------------------
module private thread =
-- Flex Run-time Library
-- Thread variables
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
with
  os_api,
  rtl_init,
  synchronization,
  flex.exceptions,
  flex.exceptions.seh,
  stack;
    
type
  t_thread_sysTIBuservalue;
  p_thread_sysTIBuservalue = ^t_thread_sysTIBuservalue;
  t_thread_sysTIBuservalue = record
      value        : aliased t_rtl_native_unsigned;
      prev         : p_thread_sysTIBuservalue;
      end record;

  t_thread_physical= record
      threadid     : t_rtl_unsigned32;
      threadhandle : t_handle;
      priority     : t_thread_priority;
      end record;

  t_thread_header  = record
      exceptions   : aliased t_rtl_exceptions;
      osthread     : t_thread_physical;
      stackheader  : t_rtl_stack_header;
      parentthread : p_thread_header;
      variables    : vars.t_thread_vars;
      usagecount   : t_rtl_native_unsigned;
      TIBusrval    : t_thread_sysTIBuservalue;
      knownstart   : t_rtl_logical8;
      threadpooled : t_rtl_logical8;
      logicalswitch: t_rtl_logical8;
      reserve      : t_rtl_logical8;
      isrunning    : t_rtl_logical32;
      locker       : t_rtl_critical;
      listnext     : p_thread_header;
      listprev     : p_thread_header;
      ref_count    : t_rtl_native_unsigned;
      ref_first    : p_thread_ref;
      flexreserve  : array 0..15 of t_rtl_native_unsigned;
      userreserve  : array 0..15 of t_rtl_native_unsigned;
      end record;

var
{system TSL}
  sthread_header   : t_rtl_unsigned32;
-- main thread task control block
  mainthreadheader : aliased t_thread_header;
  thread_list_first: p_thread_header;
  thread_list_lock : t_rtl_critical;
  thread_list_count: t_rtl_native_unsigned;
    
type
  t_threadvar_id   = t_rtl_native_unsigned;

----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_safe return p_thread_header;
----------------------------------------------------------------------------------------------------
procedure rtl_suspend_thread_internal(
    threadheader   : in p_thread_header);
----------------------------------------------------------------------------------------------------
procedure rtl_resume_thread_internal(
    threadheader   : in p_thread_header);
----------------------------------------------------------------------------------------------------
procedure rtl_set_thread_priority(
    threadheader   : in p_thread_header;
    priority       : in t_thread_priority);
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
#separate private vars;
#separate private exceptions;
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure rtl_thread_list_add(
    threadheader   : in p_thread_header) =
-- zaradi hlavicku threadu do seznamu znamych threadu
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_list_lock);
  threadheader^.listprev:=nil;
  threadheader^.listnext:=thread_list_first;
  if thread_list_first<>nil then
    thread_list_first^.listprev:=threadheader;
    end if;
  thread_list_first:=threadheader;
  thread_list_count + 1;
  rtl_critical_unlock(thread_list_lock);
  end rtl_thread_list_add;



----------------------------------------------------------------------------------------------------
procedure rtl_thread_list_del(
    threadheader   : in p_thread_header) =
-- vyradi hlavicku threadu ze seznamu znamych threadu
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_list_lock);
  if threadheader^.listprev=nil then
    thread_list_first:=threadheader^.listnext;
    if thread_list_first<>nil then
      thread_list_first^.listprev:=nil;
      end if;
    threadheader^.listnext:=nil;
  else
    if threadheader^.listnext<>nil then
      threadheader^.listnext^.listprev:=threadheader^.listprev;
      end if;
    threadheader^.listprev^.listnext:=threadheader^.listnext;
    threadheader^.listprev:=nil;
    threadheader^.listnext:=nil;
    end if;
  thread_list_count - 1;
  rtl_critical_unlock(thread_list_lock);
  end rtl_thread_list_del;



----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_safe =
-- vrati hlavicku threadu
----------------------------------------------------------------------------------------------------
begin 
  result:unchecked:=TlsGetValue(sthread_header);
  end rtl_get_current_thread_safe;



----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread =
-- vrati hlavicku threadu
-- rychlejsi varianta 
----------------------------------------------------------------------------------------------------
begin 
  #syntax asm;
      mov    eax,fs:[t_winnt_tib.aruserpointer]
      mov    result,eax
      #end asm;
  end rtl_get_current_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_suspend_thread_internal =
-- uspi thread
----------------------------------------------------------------------------------------------------
begin 
  if SuspendThread(threadheader^.osthread.threadhandle)=$FFFFFFFF then 
    raise tasking_error;
    end if;
  end rtl_suspend_thread_internal;



----------------------------------------------------------------------------------------------------
procedure rtl_resume_thread_internal =
-- probudi thread
----------------------------------------------------------------------------------------------------
begin 
  if ResumeThread(threadheader^.osthread.threadhandle)=$FFFFFFFF then 
    raise tasking_error;
    end if;
  end rtl_resume_thread_internal;



----------------------------------------------------------------------------------------------------
procedure rtl_set_thread_priority =
-- nastavi prioritu threadu
----------------------------------------------------------------------------------------------------
var
  prio             : TPRIO;

begin
  case priority
    when thread_priority_idle          do prio:=winnt_thread_priority_idle;
    when thread_priority_lowest        do prio:=winnt_thread_priority_lowest;
    when thread_priority_below_normal  do prio:=winnt_thread_priority_below_normal;
    when thread_priority_normal        do prio:=winnt_thread_priority_normal;
    when thread_priority_above_normal  do prio:=winnt_thread_priority_above_normal;
    when thread_priority_highest       do prio:=winnt_thread_priority_highest;
    when thread_priority_time_critical do prio:=winnt_thread_priority_time_critical;
    end case;
  
  if SetThreadPriority(threadheader^.osthread.threadhandle,prio)=0 then
    raise tasking_error;
    end if;
  end rtl_set_thread_priority;



----------------------------------------------------------------------------------------------------
procedure rtl_create_thread_ref(
    threadheader   : in p_thread_header;
    outthread_ref  : in out t_thread_ref)=
----------------------------------------------------------------------------------------------------
begin
  outthread_ref.threadheader:=threadheader;
  outthread_ref.next_ref:=threadheader^.ref_first;
  outthread_ref.prev_ref:=nil;
  if threadheader^.ref_first<>nil then
    threadheader^.ref_first^.prev_ref:=^outthread_ref;
    end if;
  threadheader^.ref_first:=^outthread_ref;
  threadheader^.ref_count + 1; 
  end rtl_create_thread_ref;



----------------------------------------------------------------------------------------------------
procedure rtl_get_current_thread_ref =
----------------------------------------------------------------------------------------------------
var
    threadheader   : p_thread_header;
begin
  threadheader:=rtl_get_current_thread;
  rtl_critical_lock(threadheader^.locker);
  rtl_create_thread_ref(threadheader,thread_ref);
  rtl_critical_unlock(threadheader^.locker);
  end rtl_get_current_thread_ref;



----------------------------------------------------------------------------------------------------
procedure rtl_copy_thread_ref =
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(inthread_ref.threadheader^.locker);
  rtl_create_thread_ref(inthread_ref.threadheader,outthread_ref);
  rtl_critical_unlock(inthread_ref.threadheader^.locker);
  end rtl_copy_thread_ref;



----------------------------------------------------------------------------------------------------
procedure rtl_discard_thread_ref =
----------------------------------------------------------------------------------------------------
begin
  if thread_ref.threadheader<>nil then
    rtl_critical_lock(thread_ref.threadheader^.locker);
    if ^thread_ref=thread_ref.threadheader^.ref_first then
      thread_ref.threadheader^.ref_first:=thread_ref.next_ref;
      if thread_ref.next_ref<>nil then
        thread_ref.next_ref^.prev_ref:=nil;
        thread_ref.next_ref:=nil;
        end if;
    else
      if thread_ref.next_ref<>nil then
        thread_ref.next_ref^.prev_ref:=thread_ref.prev_ref;
        end if;
      thread_ref.prev_ref^.next_ref:=thread_ref.next_ref;
      thread_ref.next_ref:=nil;
      thread_ref.prev_ref:=nil;
      end if;
    thread_ref.threadheader^.ref_count - 1; 
    rtl_critical_unlock(thread_ref.threadheader^.locker);
    thread_ref.threadheader:=nil;
    end if;
  end rtl_discard_thread_ref;



----------------------------------------------------------------------------------------------------
procedure rtl_discard_all_thread_ref (
    threadheader   : in p_thread_header)=
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(threadheader^.locker);
  while(threadheader^.ref_first<>nil) loop
    rtl_discard_thread_ref(threadheader^.ref_first^);
    end loop;
  rtl_critical_unlock(threadheader^.locker);
  end rtl_discard_all_thread_ref;



----------------------------------------------------------------------------------------------------
procedure rtl_init_task_header(
    knownstart     : in t_rtl_logical8;
    initvars       : in t_rtl_logical8;
    threadheader   : in p_thread_header;
    parentthread   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
    threadheader^.parentthread:=parentthread;
    threadheader^.variables:=nil;
    threadheader^.flexreserve:=nil;
    threadheader^.userreserve:=nil;
    threadheader^.usagecount:=1;
    threadheader^.listnext:=nil;
    threadheader^.listprev:=nil;
    threadheader^.isrunning:=true;
    threadheader^.knownstart:=knownstart;
    rtl_critical_new(threadheader^.locker);
    threadheader^.ref_count:=0;
    threadheader^.ref_first:=nil;
    if knownstart then
      if initvars then
        vars.rtl_initialize_all_threadvars(threadheader,parentthread);
        end if;
      rtl_thread_list_add(threadheader);
      end if;
  end rtl_init_task_header;



----------------------------------------------------------------------------------------------------
procedure rtl_deinit_task_header(
    threadheader   : in p_thread_header) =
----------------------------------------------------------------------------------------------------
begin
  vars.rtl_discard_all_threadvars(threadheader);
  if threadheader^.knownstart then
    rtl_thread_list_del(threadheader);
    end if;
  end rtl_deinit_task_header;



----------------------------------------------------------------------------------------------------
procedure rtl_init_task_helper(
    thread_header  : p_thread_header)=
----------------------------------------------------------------------------------------------------
var
  prochandle   : t_handle;
  threadhandle : aliased t_handle;
  dupresult    : BOOL;

begin
  -- nastavit jako systemovou threadovou promennou
  if TlsSetValue(sthread_header,LPVOID(thread_header:unchecked))=0 then
    raise tasking_error;
    end if;
  prochandle:=GetCurrentProcess;
  dupresult:=DuplicateHandle(prochandle,GetCurrentThread,prochandle,^threadhandle:unchecked,0,false,DUPLICATE_SAME_ACCESS);
  thread_header^.osthread.threadhandle:=threadhandle;
    if dupresult=0 or thread_header^.osthread.threadhandle=nil then 
    raise tasking_error;
    end if;
  end rtl_init_task_helper;



----------------------------------------------------------------------------------------------------
procedure rtl_deinit_task_helper(
    thread_header  : p_thread_header)=
----------------------------------------------------------------------------------------------------
begin
  rtl_critical_lock(thread_header^.locker);
  if CloseHandle(t_handle(thread_header^.osthread.threadhandle))=0 then
    raise tasking_error;
    end if;
  thread_header^.osthread.threadhandle:=INVALID_HANDLE;
  thread_header^.osthread.threadid:=INVALID_HANDLE;
  if TlsSetValue(sthread_header,nil)=0 then
    raise tasking_error;
    end if;
  rtl_critical_discard(thread_header^.locker);
  end rtl_deinit_task_helper;



type 
  t_thread_starter = record
      userdata     : t_rtl_pointer;
      thread_entry : p_rtl_thread_entry;
      threadheader : p_thread_header;
      suspended    : t_rtl_logical8;
      wait_event   : t_rtl_event;
      end record;
  p_thread_starter = ^t_thread_starter for machine_pointer use true;



----------------------------------------------------------------------------------------------------
procedure thread_entry_internal:t_rtl_thread_entry_win32= 
----------------------------------------------------------------------------------------------------
var
    stacpy         : t_thread_starter;
    threadheader   : p_thread_header;
    tibvalptr      : ^ t_rtl_native_unsigned;
    sys_except_handler : aliased t_rtl_exceptions_handler;
    unhandledx     : t_rtl_except_row;
begin
  stacpy:=p_thread_starter(starter)^;
  threadheader:=stacpy.threadheader;

  --nastavim svuj TIB
  threadheader^.TIBusrval.prev:=nil;
  tibvalptr:=^threadheader^.TIBusrval.value;
  #syntax asm;
    --backup old value of TIB user val
    mov    eax,fs:[t_winnt_tib.aruserpointer]
    mov    edx,tibvalptr
    mov    [edx],eax  {%%TODO(asm) mov mainthreadheader.TIBusrval.value,eax }
    --set new value
    mov    eax,threadheader
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;

  -- nastavit jako systemovou threadovou promennou
  if TlsSetValue(sthread_header,LPVOID(threadheader:unchecked))=0 then
    raise tasking_error;
    end if;

  -- inicializovat threadove vlastnosti
  rtl_init_task_exceptions(^threadheader^.exceptions);
  rtl_init_task_exceptions_win32(^sys_except_handler);
  rtl_init_task_header(true,true,threadheader,threadheader^.parentthread);

  -- set priority
  rtl_set_thread_priority(threadheader,threadheader^.osthread.priority);

  -- allow parent run
  rtl_event_set(p_thread_starter(starter)^.wait_event);
  
  --suspend if need
  if stacpy.suspended then
    rtl_suspend_thread_internal(stacpy.threadheader);
    end if;

  --vytvorit prvni exception frame
  begin
    begin
      -- volat uzivatelsky kod
      stacpy.thread_entry^(stacpy.userdata);
    catch
      when task_abort do ;
    leave
      -- odinicializovat threadove vlastnosti
      rtl_critical_lock(stacpy.threadheader^.locker);
      stacpy.threadheader^.isrunning:=false;
      rtl_deinit_task_header(stacpy.threadheader);
      if TlsSetValue(sthread_header,nil)=0 then
        raise tasking_error;
        end if;
      rtl_critical_unlock(stacpy.threadheader^.locker);
      end;
    -- odinicializovat threadove vlastnosti
    rtl_deinit_task_exceptions(^threadheader^.exceptions);
    rtl_deinit_task_exceptions_win32(^sys_except_handler);
    rtl_terminate_thread;
  catch
    when others do
    #if #environment compiler_version;='4.0.3.7' then;
      rtl_get_exception(unhandledx.ecode,unhandledx.etag,unhandledx.edata);
      rtl_raise_unhandled_exception(unhandledx.ecode,unhandledx.etag,unhandledx.edata);
    #else;
      rtl_get_exception(unhandledx.etag,unhandledx.edata);
      rtl_raise_unhandled_exception(unhandledx.etag,unhandledx.edata);
    #end if;
    end;
  end thread_entry_internal;
#pragma convention(thread_entry_internal,system);



#if rtl_advanced_threads_pooled then;
#separate private pool;
----------------------------------------------------------------------------------------------------
procedure rtl_start_pool_task =
----------------------------------------------------------------------------------------------------
begin
  pool.rtl_start_pool_task(thread_entry,priority,userdata);
  end rtl_start_pool_task;
#else;
----------------------------------------------------------------------------------------------------
procedure rtl_start_pool_task =
----------------------------------------------------------------------------------------------------
begin
  rtl_start_thread(nil,thread_entry,false,priority,userdata);
  end rtl_start_pool_task;
#end if;



----------------------------------------------------------------------------------------------------
procedure rtl_start_thread =
----------------------------------------------------------------------------------------------------
var
  starter          : aliased t_thread_starter;
  i                : DWORD;
  threadheader     : p_thread_header;

begin 
  new threadheader;
  starter.userdata:=userdata;
  starter.thread_entry:=thread_entry;
  starter.threadheader:=threadheader;
  starter.suspended:=suspended;
  threadheader^.parentthread:=rtl_get_current_thread;
  threadheader^.osthread.priority:=priority;
  rtl_event_new(starter.wait_event);
  starter.threadheader^.osthread.threadhandle:=CreateThread(nil,64*1024{%%TODO remove when dynamic stack}*8{},^thread_entry_internal,^starter,STACK_SIZE_PARAM_IS_A_RESERVATION,starter.threadheader^.osthread.threadid);
  if starter.threadheader^.osthread.threadhandle=0 then
    discard threadheader;
    rtl_event_discard(starter.wait_event);
    raise tasking_error;
    end if;
  rtl_event_wait(starter.wait_event);
  rtl_event_discard(starter.wait_event);
  if thread_ref<>nil then
    rtl_create_thread_ref(threadheader,thread_ref^);
    end if;
  end rtl_start_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_register_task =
----------------------------------------------------------------------------------------------------
var
  threadheader     : p_thread_header;
  tibvalptr        : ^ t_rtl_native_unsigned;
  TBIPrev          : p_thread_sysTIBuservalue;
  unknown          : t_rtl_logical8:=true;
  ismain           : t_rtl_logical8:=true;

begin
  threadheader:=rtl_get_current_thread_safe;
  if threadheader<>nil then
    unknown:=false;
    threadheader^.usagecount + 1;
    --zalohuju posledni TIB
    new TBIPrev;
    TBIPrev^.prev:=threadheader^.TIBusrval.prev;
    TBIPrev^.value:=threadheader^.TIBusrval.value;
    threadheader^.TIBusrval.prev:=TBIPrev;
  else
    if ismain then
      sthread_header:=TlsAlloc;
      thread_list_count:=0;
      threadheader:=^mainthreadheader;
      -- prvni inicializace
      rtl_init_runtime_phase_zero;

      rtl_critical_new(thread_list_lock);
    else
      new threadheader;
      end if;
    threadheader^.TIBusrval.prev:=nil;
    threadheader^.parentthread:=nil;
    if TlsSetValue(sthread_header,threadheader)=0 then
      raise tasking_error;
      end if;
    end if;

  --nastavim(obnovim) svuj TIB
  tibvalptr:=^threadheader^.TIBusrval.value;
  #syntax asm;
    --backup old value of TIB user val
    mov    eax,fs:[t_winnt_tib.aruserpointer]
    mov    edx,tibvalptr
    mov    [edx],eax  {%%TODO(asm) mov mainthreadheader.TIBusrval.value,eax }
    --set new value
    mov    eax,threadheader
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;
  if unknown then
    -- inicializovat
    rtl_init_task_exceptions(^threadheader^.exceptions);
    rtl_init_task_helper(threadheader);
    rtl_init_task_header(ismain,false,threadheader,nil);
    threadheader^.stackheader.seh_handler:=p_rtl_exceptions_handler(topstackspace);
    rtl_init_task_exceptions_win32(threadheader^.stackheader.seh_handler);
    end if;
  end rtl_register_task;

-- compiler magic
#pragma assign(register_task,rtl_register_task);



----------------------------------------------------------------------------------------------------
procedure rtl_unregister_task =
----------------------------------------------------------------------------------------------------
var
  threadheader     : p_thread_header;
  tibval           : t_rtl_native_unsigned;
  tibptr           : p_thread_sysTIBuservalue;
  dodiscard        : t_rtl_logical8:=false;
  ismain           : t_rtl_logical8:=false;

begin
  threadheader:=rtl_get_current_thread_safe;
  if threadheader=nil then
    raise tasking_error;
    end if;
  if threadheader=^mainthreadheader then
    ismain:=true;
    end if;
  threadheader^.usagecount - 1;
  tibval:=threadheader^.TIBusrval.value;
  tibptr:=threadheader^.TIBusrval.prev;
  if tibptr<>nil then
    threadheader^.TIBusrval.value:=tibptr^.value;
    threadheader^.TIBusrval.prev:=tibptr^.prev;
    discard tibptr;
    end if;
  if threadheader^.usagecount=0 then
    rtl_critical_lock(threadheader^.locker);
    threadheader^.isrunning:=false;
    rtl_deinit_task_header(threadheader);
    rtl_discard_all_thread_ref(threadheader);
    rtl_deinit_task_helper(threadheader);
    rtl_deinit_task_exceptions(^threadheader^.exceptions);
    rtl_critical_discard(threadheader^.locker);
    dodiscard:=true;
    if ismain then
      rtl_critical_discard(thread_list_lock);
      if TlsFree(sthread_header)=0 then
#if #environment compiler_version;='4.0.3.3' then;
        raise tasking_error;
#else;
        -- %%HYNEK - TlsFree vzdy vraci chybu v DLL. Vyresi az vlastni inicializacni rutiny knihoven.
        -- raise tasking_error;
#end if;
        end if;
    else
      discard threadheader;
      end if;
    end if;
  #syntax asm;
    --restore prev value
    mov    eax,tibval
    mov    fs:[t_winnt_tib.aruserpointer],eax
    #end asm;
  if dodiscard then
    rtl_deinit_task_exceptions_win32(threadheader^.stackheader.seh_handler);
  #syntax asm;
    mov    eax,0
    #end asm;
    end if;
  end rtl_unregister_task;

-- compiler magic
#pragma assign(unregister_task,rtl_unregister_task);



----------------------------------------------------------------------------------------------------
procedure rtl_wait_and_finish_thread =
----------------------------------------------------------------------------------------------------
var
  threadheader : p_thread_header;
begin 
  threadheader:=thread_ref.threadheader;
  if WaitForSingleObjectEx(threadheader^.osthread.threadhandle,t_rtl_wait_infinite,true)=WAIT_FAILED then
    raise tasking_error;
    end if;
  if SleepEx(0,true)=0 then
    end if;
  rtl_critical_lock(threadheader^.locker);
  rtl_discard_all_thread_ref(threadheader);
  if CloseHandle(t_handle(threadheader^.osthread.threadhandle))=0 then
    raise tasking_error;
    end if;
  threadheader^.osthread.threadhandle:=INVALID_HANDLE;
  threadheader^.osthread.threadid:=INVALID_HANDLE;
  rtl_critical_discard(threadheader^.locker);
  discard threadheader;
  end rtl_wait_and_finish_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_kill_when_need_and_finish_thread =
----------------------------------------------------------------------------------------------------
var
  threadheader : p_thread_header;

begin
  threadheader:=thread_ref.threadheader;
  begin
  #if #environment compiler_version;='4.0.3.7' then;
    exceptions.rtl_raise_external_exception(threadheader,0,task_abort:tag,0);
  #else;
    exceptions.rtl_raise_external_exception(threadheader,task_abort:tag,0);
  #end if;
  catch
    when tasking_task_not_running do ;
    end;

  --%% TODO stale bezi ... na vyjimku nereaguje ? kill ?
  {
  if not TerminateThread(t_handle(thread_ref.threadheader^.threadhandle),0) then 
    raise tasking_error;
    end if;
  }

  rtl_wait_and_finish_thread(thread_ref);
  end rtl_kill_when_need_and_finish_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_wait_for_finish_thread =
----------------------------------------------------------------------------------------------------
begin 
  if thread_ref.threadheader<>nil then
    if WaitForSingleObjectEx(thread_ref.threadheader^.osthread.threadhandle,t_rtl_wait_infinite,true)=WAIT_FAILED then
      raise tasking_error;
      end if;
    end if;
  end rtl_wait_for_finish_thread;



----------------------------------------------------------------------------------------------------
procedure rtl_terminate_thread =
----------------------------------------------------------------------------------------------------
begin
  ExitThread(0);
  end rtl_terminate_thread;

end thread;
