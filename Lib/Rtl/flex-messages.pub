----------------------------------------------------------------------------------------------------
module public messages =
-- Messages.
-- Flex Run-time Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
with references;

type
  -- message code
  t_rtl_message_tag = t_rtl_tag;
  
  -- pointer to message data
  t_trl_message_data = array 0..$FFFF_FFFF of t_rtl_unsigned8;
  p_trl_message_data   = ^t_trl_message_data for machine_pointer use true;

  -- reference to flex message queue
  t_rtl_queue_ref_local = private t_rtl_ref_local;
  p_rtl_queue_ref_local = ^t_rtl_queue_ref_local for machine_pointer use true;

  -- flex message
  t_rtl_message = record
    code           : t_rtl_message_tag;
    timeout        : t_rtl_timeout;
    replyto        : t_rtl_queue_ref_local;
    data           : t_trl_message_data;
    end record;
  p_rtl_message = ^t_rtl_message for machine_pointer use true;

  -- message filtering callback
  t_rtl_message_filter_proc = procedure (
    msg            : in t_rtl_message)
    return t_rtl_logical;

  -- message filter
  t_rtl_message_filter = string of t_rtl_message_filter_proc;

  -- queue type
  t_rtl_queue_type = enum
    rtl_queue_type_blocking_fifo;
    rtl_queue_type_lockfree_fifo;
    rtl_queue_type_blocking_heap;
    rtl_queue_type_lockfree_heap;
    end enum;

----------------------------------------------------------------------------------------------------
procedure rtl_queue_create(
    que            : out t_rtl_queue_ref_local);
-- create flex queue
----------------------------------------------------------------------------------------------------
procedure rtl_queue_discard(
    que            : in out t_rtl_queue_ref_local);
-- discard flex queue
----------------------------------------------------------------------------------------------------
procedure rtl_message_create(
    code           : in t_rtl_message_tag;
    recipient      : in ref t_rtl_queue_ref_local;
    repltyto       : in ref t_rtl_queue_ref_local;
    msg            : out p_rtl_message);
-- create new message, retuns address for data
----------------------------------------------------------------------------------------------------
procedure rtl_message_answer(
    code           : in t_rtl_message_tag;
    msg            : in out p_rtl_message);
-- create answer message, discarding old message, retuns address for data
----------------------------------------------------------------------------------------------------
procedure rtl_message_send(
    msg            : in p_rtl_message);
-- send message to recipient
----------------------------------------------------------------------------------------------------
procedure rtl_message_discard(
    msg            : in out p_rtl_message);   
-- discard message
----------------------------------------------------------------------------------------------------
procedure rtl_message_accept(
    recipient      : in ref t_rtl_queue_ref_local;
    filter         : in ref t_rtl_message_filter;
    msg            : out p_rtl_message);
-- return true when msg accepted
----------------------------------------------------------------------------------------------------
procedure rtl_message_try_accept(
    recipient      : in ref t_rtl_queue_ref_local;
    msg            : out p_rtl_message;
    filter         : in ref t_rtl_message_filter;
    milisec        : in t_rtl_timeout)
    return t_rtl_logical;
-- return true when msg accepted
----------------------------------------------------------------------------------------------------

end messages;