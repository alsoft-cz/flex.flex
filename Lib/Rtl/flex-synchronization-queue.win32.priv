type
  t_rtl_squeue = t_rtl_ref_fifo with record      -- struktura stacku
    freedata       : p_rtl_ref_free_resource;    -- uvolnovaci callback
    waitable       : t_rtl_logical32;            -- priznak zda se ma cekat
    --is waitable
      critisem     : t_rtl_critisem;             -- semafor pro cekani na prazdny stack
                                                 -- pro pocet prvku mensi nez pocet ctecich 
                                                 -- threadu blokujici ve smyslu prvku ktere se 
                                                 -- jiz zacali cist
    -- else
      count        : aliased t_rtl_native_signed -- inverzni pocitadlo prvku
                     for position use 24;        -- na stejnem offsxetu jako pocitadlo critisemu
    -- end if waitable
    end record;


----------------------------------------------------------------------------------------------------
procedure rtl_squeue_draw_out_now (
    squeue         : in out ref t_rtl_squeue;
    data           : out t_rtl_pointer)
    return t_rtl_logical8;
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure rtl_squeue_new =
----------------------------------------------------------------------------------------------------
var
    temp           : t_rtl_ref_local;

begin
  squeue:=nil;
  squeue.waitable:=waitable;
  squeue.freedata:=freedata;
  if waitable then
    rtl_critisem_new_owned(squeue.critisem,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
    end if;

  rtl_ref_create_local(temp,nil,freedata);
  rtl_ref_local_to_local_shared(temp,squeue.head);
  rtl_ref_local_to_local_shared(temp,squeue.tail);
  rtl_ref_discard_local(temp);
  end rtl_squeue_new;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_discard =
----------------------------------------------------------------------------------------------------
begin
  rtl_squeue_reset(squeue);
  squeue.tail:=nil;
  squeue.head:=nil;
  rtl_critisem_discard(squeue.critisem);
  end rtl_squeue_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_reset =
----------------------------------------------------------------------------------------------------
begin
  end rtl_squeue_reset;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_move =
----------------------------------------------------------------------------------------------------
begin
  end rtl_squeue_move; 



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_append =
----------------------------------------------------------------------------------------------------
var
  zero             : t_rtl_ref_snapshot;
  oldtail          : aliased t_rtl_ref_snapshot;
  wrktail          : t_rtl_ref_snapshot;
  newnode          : t_rtl_ref_local;
  prevnode         : t_rtl_ref_local;

label
  restart
  ;

begin
  rtl_ref_create_local(newnode,data,squeue.freedata);

restart:
  rtl_ref_shared_to_snapshot(squeue.tail,oldtail);

  -- zkopiruju si pointer na "posledni prvek"
  if not rtl_ref_shared_to_local(squeue.tail,prevnode,oldtail) then
    goto restart; 
    end if;

  --hledam jestli je opravdu posledni
  rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
  while wrktail.node<>nil loop

    -- neni posledni takze si posunu ukazatel na posledni
    if not rtl_ref_shared_to_local(prevnode.node^.next,prevnode,wrktail) then
      goto restart; 
      end if;

    -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
    if not rtl_ref_local_to_shared(prevnode,squeue.tail,oldtail,^oldtail) then
      goto restart; 
      end if;
    -- podarilo se udelam si novy snapshot
    rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
    end loop;

  -- mam docasneho reprezentanta posledniho prvku
  -- zkusim do nej nakopirovat novy node za predpokladu ze je opravdu posledni
  if not rtl_ref_local_to_shared(newnode,prevnode.node^.next,zero) then
    goto restart; 
    end if;

  -- podarilo se mi 
  -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
  if not rtl_ref_local_to_shared(newnode,squeue.tail,oldtail) then
    -- pokud se nepodarilo tak to asi udelal nekdo jiny a mne to nevadi
    end if;

  -- uvolnim predchozi prvek
  rtl_ref_discard_local(prevnode);

  -- uvolnim novy prvek
  rtl_ref_discard_local(newnode);

  -- zvednu pocet prvku ve fronte a nebo povolim dalsimu threadu cteni
  if squeue.waitable then
    rtl_critisem_unlock(squeue.critisem);
  else
    rtl_interlocked_dec(^squeue.count);
    end if;
  end rtl_squeue_append;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_draw_out_now =
----------------------------------------------------------------------------------------------------
var
  temp             : t_rtl_ref_snapshot;
  nextsnap         : t_rtl_ref_snapshot;
  oldtail          : t_rtl_ref_snapshot;
  dumbnode         : t_rtl_ref_local;
  nextnode         : t_rtl_ref_local;

label
  restart;

begin
restart:
  rtl_ref_shared_to_snapshot(squeue.head,temp);

  -- zkopiruju si pointer na prvni "dumb" node
  if not rtl_ref_shared_to_local(squeue.head,dumbnode,temp) then
    goto restart; 
    end if;

  -- otestuju jestli neni fronta prazdna
  rtl_ref_shared_to_snapshot(dumbnode.node^.next,nextsnap);
  if nextsnap.node=nil then
    -- je prazdna, uklidim
    data:=nil;
    result:=false;
    rtl_ref_discard_local(nextnode);
    rtl_ref_discard_local(dumbnode);
    return;
    end if;
  
  -- z dumb node zkopiruju pointer na dalsi
  if not rtl_ref_shared_to_local(dumbnode.node^.next,nextnode,nextsnap) then
    goto restart; 
    end if;

  -- ujistim se ze tail neukazuje na predchozi prvek
  rtl_ref_shared_to_snapshot(squeue.tail,oldtail);
  if oldtail.node=dumbnode.node then
    if not rtl_ref_local_to_shared(nextnode,squeue.tail,oldtail) then
      -- ignoruju vysledek
      end if;
    end if;


  -- zkusim ten dalsi nastavit jako prvni
  if not rtl_ref_local_to_shared(nextnode,squeue.head,temp) then
    goto restart; 
    end if;

  --podarilo se, prectu si data
  data:=nextnode.node^.data;
  nextnode.node^.data:=nil;

  -- uvolnim pointer na dalsi prvek
  if not rtl_ref_discard_shared(dumbnode.node^.next,nextsnap) then
    raise synchronization_error;
    end if;

  rtl_ref_discard_local(nextnode);

  -- uvolnim dumb
  rtl_ref_discard_local(dumbnode);
  result:=true;
  end rtl_squeue_draw_out_now;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_draw_out =
----------------------------------------------------------------------------------------------------
begin
  if squeue.waitable then
    result:=rtl_squeue_try_draw_out(squeue,data,t_rtl_wait_infinite);
    if not result then
      raise synchronization_error;
      end if;
  else
    result:=rtl_squeue_draw_out_now(squeue,data);
    end if;
  end rtl_squeue_draw_out;




----------------------------------------------------------------------------------------------------
procedure rtl_squeue_try_draw_out =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;

begin
  -- reknu ze si beru jeden prvek
  if squeue.waitable then
    rtl_critisem_force_lock(squeue.critisem);
  else
    rtl_interlocked_inc(^squeue.count);
    end if;

  -- zkusim si ho opravdu vzit
  result:=rtl_squeue_draw_out_now(squeue,data);

  -- pokud neumi cekani tak uz na nic necekam
  if not squeue.waitable or milisec=t_rtl_wait_immediate or result then
    if not result then
      --uklidit po neuspesnem pokusu
      if squeue.waitable then
        rtl_critisem_force_unlock(squeue.critisem);
      else
        rtl_interlocked_dec(^squeue.count);
        end if;
      end if;
    return;
    end if;

  -- pokud je potreba pocitat cas tak zjistim start
  timeout:=milisec;
  if milisec>0 then
    start:=GetTickCount();
    end if;

  -- nepodarilo se mi vzit si prvek na prvni pokus bez blokovani a zarovem mam cekat
  rtl_critisem_force_unlock(squeue.critisem);
  loop
    -- pockam az nekdo signalizuje ze je tam alespon jeden prvek
    if not rtl_critisem_try_lock(squeue.critisem,timeout) then
      -- timeout
      result:=false;
      return;
      end if;

    -- zkusim jestli mne nekdo nepredbehne
    result:=rtl_squeue_draw_out_now(squeue,data);

    -- podarilo se sebrat prvek, koncim
    if result then return; end if;

    -- pokus se nezdaril vratim pocitadlo itemu
    rtl_critisem_force_unlock(squeue.critisem);

    -- pokud je potreba pocitat cas tak zjistim kolik ubehlo
    if milisec>0 then
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then
        -- timeout
        result:=false;
        return;
        end if;
      end if;
    end loop;
  end rtl_squeue_try_draw_out;


{
----------------------------------------------------------------------------------------------------
procedure rtl_squeue_try_pin =
----------------------------------------------------------------------------------------------------
begin
  end rtl_squeue_try_pin;
 


----------------------------------------------------------------------------------------------------
procedure rtl_squeue_try_get_pinned =
----------------------------------------------------------------------------------------------------
begin
  end rtl_squeue_try_get_pinned;



----------------------------------------------------------------------------------------------------
procedure rtl_squeue_drop_pin =
----------------------------------------------------------------------------------------------------
begin
  end rtl_squeue_drop_pin;
}