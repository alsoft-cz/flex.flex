----------------------------------------------------------------------------------------------------
module private synchronization =
-- Flex Run-time Library
-- Synchronization Manager
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------

--%%TODO kriticka sekce byla docasne nahrazena mutexem
--  - protoze kriticka sekce windows nepodporuje alertable cekani
--  - protoze je systemova kriticka sekce obcas pomalejsi nez mutex
--    - viz http://world.std.com/~jmhart/topform.htm
--  - protoze nemam cas napsat vlastni implementaci

with os_api;

type 
  t_kernel_object  = THANDLE;
  t_rtl_mutex      = t_kernel_object;
  t_rtl_event      = t_kernel_object;
  t_rtl_critical   = t_kernel_object; --%%TODO t_winnt_critical_section;

----------------------------------------------------------------------------------------------------
procedure rtl_kernel_try (
    kernel_object  : in out t_kernel_object;
    milisec        : in t_rtl_native_signed)
    return         t_rtl_logical8 =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_native_signed;
begin
  if milisec>0 then 
    timeout:=milisec;
    start:=GetTickCount();
    loop
      case WaitForSingleObjectEx(kernel_object,t_rtl_native_unsigned(timeout),true)
        when WAIT_OBJECT_0 do
          result:=true;
          return;
        when WAIT_TIMEOUT do
          result:=false;
          return;
        when WAIT_IO_COMPLETION do
          elapsed:=GetTickCount()-start;
          timeout - t_rtl_native_signed(elapsed);
          if timeout<1 then
            timeout:=0;
            end if;
        when WAIT_FAILED do
          raise tasking_error;
        when WAIT_ABANDONED do
          raise tasking_error;
        end case;
      end loop;
  else
    loop
      case WaitForSingleObjectEx(kernel_object,t_rtl_native_unsigned(milisec),true)
        when WAIT_OBJECT_0 do
          result:=true;
          return;
        when WAIT_TIMEOUT do
          result:=false;
          return;
        when WAIT_IO_COMPLETION do
          ;
        when WAIT_FAILED do
          raise tasking_error;
        when WAIT_ABANDONED do
          raise tasking_error;
        end case;
      end loop;
    end if;
  end rtl_kernel_try;


----------------------------------------------------------------------------------------------------
procedure rtl_sleep =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_native_signed;
begin
  if milisec>0 then 
    timeout:=milisec;
    start:=GetTickCount();
    loop
      case SleepEx(t_rtl_native_unsigned(timeout),true)
        when WAIT_OBJECT_0 do
          return;
        when WAIT_IO_COMPLETION do
          elapsed:=GetTickCount()-start;
          timeout - t_rtl_native_signed(elapsed);
          if timeout<1 then
            return;
            end if;
        end case;
      end loop;
  else
    loop
      if SleepEx(t_rtl_native_unsigned(milisec),true)=WAIT_OBJECT_0 then
        return;
        end if;
      end loop;
    end if;
  end rtl_sleep;

----------------------------------------------------------------------------------------------------
procedure rtl_mutex_new =
-- Create and initialize mutex object.
----------------------------------------------------------------------------------------------------
begin
  mutex_object:unchecked:=CreateMutexA(nil,false,nil);
  if t_rtl_unsigned32(mutex_object:unchecked)=INVALID_HANDLE then 
    raise tasking_error;
    end if;
  end rtl_mutex_new;


----------------------------------------------------------------------------------------------------
procedure rtl_mutex_discard =
-- Discard mutex object.
----------------------------------------------------------------------------------------------------
begin
  if not CloseHandle(mutex_object) then 
    raise tasking_error;
    end if;
  t_rtl_unsigned32(mutex_object:unchecked):=INVALID_HANDLE;
  end rtl_mutex_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_mutex_lock =
-- Lock mutex.
----------------------------------------------------------------------------------------------------
begin
  if not rtl_kernel_try(t_kernel_object(mutex_object),t_rtl_wait_infinite) then
    raise tasking_error;
    end if;
  end rtl_mutex_lock;

----------------------------------------------------------------------------------------------------
procedure rtl_mutex_try_lock =
----------------------------------------------------------------------------------------------------
begin
  result:=rtl_kernel_try(t_kernel_object(mutex_object),milisec);
  end rtl_mutex_try_lock;


----------------------------------------------------------------------------------------------------
procedure rtl_mutex_unlock =
-- Unlock mutex.
----------------------------------------------------------------------------------------------------
begin
  if not ReleaseMutex(mutex_object) then 
    raise tasking_error;
    end if;
  end rtl_mutex_unlock;


----------------------------------------------------------------------------------------------------
procedure rtl_event_new =
-- new event
----------------------------------------------------------------------------------------------------
begin 
  event_object:unchecked:=CreateEventA(nil,false,false,nil);
  if t_rtl_unsigned32(event_object:unchecked)=INVALID_HANDLE then 
    raise tasking_error;
    end if;
  end rtl_event_new;


----------------------------------------------------------------------------------------------------
procedure rtl_event_discard =
-- discard event
----------------------------------------------------------------------------------------------------
begin 
  if not CloseHandle(event_object) then 
    raise tasking_error;
    end if;
  t_rtl_unsigned32(event_object:unchecked):=INVALID_HANDLE;
  end rtl_event_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_event_wait =
-- wait for event and reset event
----------------------------------------------------------------------------------------------------
begin 
  if not rtl_kernel_try(t_kernel_object(event_object),t_rtl_wait_infinite) then
    raise tasking_error;
    end if;
  end rtl_event_wait;



----------------------------------------------------------------------------------------------------
procedure rtl_event_try =
-- test if event is set & try grab it
----------------------------------------------------------------------------------------------------
begin 
  result:=rtl_kernel_try(t_kernel_object(event_object),milisec);
  end rtl_event_try;



----------------------------------------------------------------------------------------------------
procedure rtl_event_set =
-- sets event
----------------------------------------------------------------------------------------------------
begin 
  if not SetEvent(event_object) then 
    raise tasking_error;
    end if;
  end rtl_event_set;

----------------------------------------------------------------------------------------------------
procedure rtl_event_reset =
-- sets event
----------------------------------------------------------------------------------------------------
begin 
  if not ResetEvent(event_object) then 
    raise tasking_error;
    end if;
  end rtl_event_reset;

----------------------------------------------------------------------------------------------------
procedure rtl_critical_new =
-- Create and initialize critical object.
----------------------------------------------------------------------------------------------------
begin
  --%%TODO kriticka sekce byla docasne nahrazena mutexem
  --InitializeCriticalSection(^critical_object);
  critical_object:unchecked:=CreateMutexA(nil,false,nil);
  if t_rtl_unsigned32(critical_object:unchecked)=INVALID_HANDLE then 
    raise tasking_error;
    end if;
  end rtl_critical_new;

----------------------------------------------------------------------------------------------------
procedure rtl_critical_discard =
-- Discard critical object.
----------------------------------------------------------------------------------------------------
begin
  --%%TODO kriticka sekce byla docasne nahrazena mutexem
  --DeleteCriticalSection(^critical_object);
  if not CloseHandle(critical_object) then 
    raise tasking_error;
    end if;
  t_rtl_unsigned32(critical_object:unchecked):=INVALID_HANDLE;
  end rtl_critical_discard;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_lock =
-- Lock critical.
----------------------------------------------------------------------------------------------------
begin
  --%%TODO kriticka sekce byla docasne nahrazena mutexem
  --EnterCriticalSection(^critical_object);
  if not rtl_kernel_try(t_kernel_object(critical_object),t_rtl_wait_infinite) then
    raise tasking_error;
    end if;
  end rtl_critical_lock;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_try_lock =
----------------------------------------------------------------------------------------------------
begin
  result:=rtl_kernel_try(t_kernel_object(critical_object),milisec);
  end rtl_critical_try_lock;


----------------------------------------------------------------------------------------------------
procedure rtl_critical_unlock =
-- Unlock critical.
----------------------------------------------------------------------------------------------------
begin
  --%%TODO kriticka sekce byla docasne nahrazena mutexem
  --LeaveCriticalSection(^critical_object);
  if not ReleaseMutex(critical_object) then 
    raise tasking_error;
    end if;
  end rtl_critical_unlock;

end synchronization;