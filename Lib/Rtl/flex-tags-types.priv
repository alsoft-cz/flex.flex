----------------------------------------------------------------------------------------------------
module private types =
-- Type tags and type tag-specific operations.
-- Flex Run-time Library
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
--
-- Type descriptor layout:
--
--     +---------------+                                                          
--     | :size         | +0         \                                             
--     +---------------+            |                                             
--     | data type     | +4         |                                             
--     +---------------+            |                                             
--     | ancestor :tag | +8         |                                             
--     +---------------+            |                                             
--     | ^@init     *) | +12        |
--     +---------------+            |                                             
--     | ^entry        | +16        | all data types
--     +---------------+            |
--     | ^exit         | +20        |                                             
--     +---------------+            |                                             
--     | ^adjust       | +24        |                                             
--     +---------------+            |                                             
--     | ^rollback     | +28        |                                             
--     +---------------+            |                                             
--     | ^commit       | +32        /
--     +---------------+
--     | ^virtual_1    | +36        \
--     |    ...        |            | classes only
--     | ^virtual_n    | +36 + 4*n  /
--     +---------------+
--
--     *) always NIL for classes
--
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
#template generate_rtl_call_special_method_priv (
    rtl_name,                                    -- desired name of the [rtl_call_*] method
    ptr_offset);                                 -- offset of the pointer to the method within the
                                                 -- type descritor
-- Generates a [rtl_call_*] method used to call the appropriate special method.
----------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  procedure rtl_name =
  -- Calls the <special> method.
  --------------------------------------------------------------------------------------------------
  begin
    #syntax asm;
      -- class address
      mov    eax,[esp+4]
      -- load :TAG
      mov    eax,[eax]
      -- load ^<special>
  @2: mov    edx,[eax+ptr_offset]
      cmp    edx,0
      je     @1
      -- call <special>
      jmp    edx
  @1: -- load parent :TAG
      mov    eax,[eax+t_desc_type.ancestor_tag]
      -- don't care about non-tagged types
      cmp    eax,0
      jne    @2
      #end asm;
    end rtl_name;

  #end generate_rtl_call_special_method_priv;



----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_init
  #for ptr_offset use; t_desc_type.spec_init
  #end generate_rtl_call_special_method_priv;
-- Calls the INIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_entry
  #for ptr_offset use; t_desc_type.spec_entry
  #end generate_rtl_call_special_method_priv;
-- Calls the ENTRY method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_exit
  #for ptr_offset use; t_desc_type.spec_exit
  #end generate_rtl_call_special_method_priv;
-- Calls the EXIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_adjust
  #for ptr_offset use; t_desc_type.spec_adjust
  #end generate_rtl_call_special_method_priv;
-- Calls the ADJUST method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_commit
  #for ptr_offset use; t_desc_type.spec_commit
  #end generate_rtl_call_special_method_priv;
-- Calls the COMMIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_call_special_method_priv;
  #for rtl_name   use; rtl_call_rollback
  #for ptr_offset use; t_desc_type.spec_rollback
  #end generate_rtl_call_special_method_priv;
-- Calls the ROLLBACK method.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
#template generate_rtl_ancestor_special_method (
    rtl_name,                                    -- desired name of the [rtl_ancestor_*] method
    ptr_offset);                                 -- offset of the pointer to the method within the
                                                 -- type descritor
-- Generates a [rtl_ancestor_*] method used to call the appropriate inherited special method.
----------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  procedure rtl_name (
      instance       : in t_rtl_pointer);
  #pragma stackframe(rtl_name,stack_pointer_relative);
  procedure rtl_name =
  -- Calls the <special> method.
  --------------------------------------------------------------------------------------------------
  begin
    #syntax asm;
      -- class address
      mov    eax,[esp+4]
      -- load ancestor :TAG
  @1: mov    eax,[eax+t_desc_type.ancestor_tag]
      -- don't care about non-tagged types
      cmp    eax,0
      je     @3
      -- load ^<special>
  @2: mov    edx,[eax+ptr_offset]
      cmp    edx,0
      je     @1
      -- call <special>
      jmp    edx
  @3:
      #end asm;
    end rtl_name;

  #end generate_rtl_ancestor_special_method;



----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_init
  #for ptr_offset use; t_desc_type.spec_init
  #end generate_rtl_ancestor_special_method;
-- Calls the INIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_entry
  #for ptr_offset use; t_desc_type.spec_entry
  #end generate_rtl_ancestor_special_method;
-- Calls the ENTRY method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_exit
  #for ptr_offset use; t_desc_type.spec_exit
  #end generate_rtl_ancestor_special_method;
-- Calls the EXIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_adjust
  #for ptr_offset use; t_desc_type.spec_adjust
  #end generate_rtl_ancestor_special_method;
-- Calls the ADJUST method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_commit
  #for ptr_offset use; t_desc_type.spec_commit
  #end generate_rtl_ancestor_special_method;
-- Calls the COMMIT method.
----------------------------------------------------------------------------------------------------
#expand generate_rtl_ancestor_special_method;
  #for rtl_name   use; rtl_ancestor_rollback
  #for ptr_offset use; t_desc_type.spec_rollback
  #end generate_rtl_ancestor_special_method;
-- Calls the ROLLBACK method.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure rtl_get_size_from_tag (
    data_ptr       : t_rtl_pointer;              -- pointer to the data
    data_tag       : t_rtl_tag)                  -- dynamic :tag of the data
    return t_type_size =                         -- dynamic :size of the data
-- Determines the dynamic :size attribute of the data specified by [data_ptr] using its :tag 
-- [data_tag]. If the data type is unconstrained, then the :size is determined from the memory 
-- manager.
----------------------------------------------------------------------------------------------------
with
  memory;

begin
  -- is the data type unconstrained ?
  if p_desc_type(data_tag:unchecked)^.dtype=dt_ustring or p_desc_type(data_tag:unchecked)^.dtype=dt_uarray

    -- yes => query the memory manager
    then 
      --%%X result:=rtl_memmgr_get_block_size(data_ptr);

    -- no => use the static size
    else
      result:=p_desc_type(data_tag:unchecked)^.size;
      end if;
  end rtl_get_size_from_tag;



----------------------------------------------------------------------------------------------------
procedure rtl_get_last_from_tag (
    data_ptr       : t_rtl_pointer;              -- pointer to the data
    data_tag       : t_rtl_tag)                  -- dynamic :tag of the data
    return t_type_size =                         -- dynamic :last of the data
-- Determines the dynamic :last attribute of the data specified by [data_ptr] using its :tag 
-- [data_tag]. If the data type is unconstrained, then the :last is determined from the memory 
-- manager.
----------------------------------------------------------------------------------------------------
begin
  result:=rtl_get_size_from_tag(data_ptr,data_tag) div p_desc_type(p_desc_type_indexed(data_tag:unchecked)^.range_tag:unchecked)^.size;
  end rtl_get_last_from_tag;



---- Compiler magic --------------------------------------------------------------------------------
#pragma assign(call_init             ,flex.tags.types.rtl_call_init             );
#pragma assign(call_entry            ,flex.tags.types.rtl_call_entry            );
#pragma assign(call_exit             ,flex.tags.types.rtl_call_exit             );
#pragma assign(call_adjust           ,flex.tags.types.rtl_call_adjust           );
#pragma assign(call_rollback         ,flex.tags.types.rtl_call_rollback         );
#pragma assign(call_commit           ,flex.tags.types.rtl_call_commit           );
#pragma assign(ancestor_init         ,flex.tags.types.rtl_ancestor_init         );
#pragma assign(ancestor_entry        ,flex.tags.types.rtl_ancestor_entry        );
#pragma assign(ancestor_exit         ,flex.tags.types.rtl_ancestor_exit         );
#pragma assign(ancestor_adjust       ,flex.tags.types.rtl_ancestor_adjust       );
#pragma assign(ancestor_rollback     ,flex.tags.types.rtl_ancestor_rollback     );
#pragma assign(ancestor_commit       ,flex.tags.types.rtl_ancestor_commit       );
#if #declared ondra; then;
#pragma assign(is_ancestor           ,flex.tags.types.rtl_is_ancestor           );
#pragma assign(is_ancestor_or_equal  ,flex.tags.types.rtl_is_ancestor_or_equal  );
#pragma assign(is_descendant         ,flex.tags.types.rtl_is_descendant         );
#pragma assign(is_descendant_or_equal,flex.tags.types.rtl_is_descendant_or_equal);
#end if;
#pragma assign(get_size_from_tag     ,flex.tags.types.rtl_get_size_from_tag     );
#pragma assign(get_last_from_tag     ,flex.tags.types.rtl_get_last_from_tag     );
----------------------------------------------------------------------------------------------------

end types;