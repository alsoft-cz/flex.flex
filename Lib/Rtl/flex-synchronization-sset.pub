----------------------------------------------------------------------------------------------------
procedure rtl_sset_new(
    sset           : out ref t_rtl_sset;
    style          : in t_rtl_concurency_style;
    freedata       : in p_rtl_ref_free_resource:=nil); -- userdata free procedure
-- Create new synchronized dynamic set
----------------------------------------------------------------------------------------------------
procedure rtl_sset_discard(
    sset           : in out ref t_rtl_sset);
-- Discard synchronized dynamic set
----------------------------------------------------------------------------------------------------
procedure rtl_sset_reset(
    sset           : in out ref t_rtl_sset);
-- clean ssset
----------------------------------------------------------------------------------------------------
procedure rtl_sset_append(
    sset           : in out ref t_rtl_sset;
    data           : in t_rtl_pointer;
    iterator       : in p_rtl_sset_iterator:=nil); --can be nil, task private
-- insert item into set
----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    winner         : in p_rtl_logical:=nil;
    immediate      : in t_rtl_logical:=false)
    return         t_rtl_logical;
-- remove item, iterator to next item, or return false
----------------------------------------------------------------------------------------------------
procedure rtl_sset_start(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    data           : out t_rtl_pointer);
-- create iterator, retuns first item, wait until nonempty set
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_start(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    data           : out t_rtl_pointer;
    milisec        : in t_rtl_timeout)
    return         t_rtl_logical;
-- try create iterator, retuns first item, wait (milisec) or until nonempty set
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_next_now(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    data           : out t_rtl_pointer)
    return         t_rtl_logical;
-- next item, or return false
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_wait_next(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    data           : out t_rtl_pointer;
    milisec        : in t_rtl_timeout)
    return         t_rtl_logical;
-- wait for next item, or return false
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_find_now(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    filter         : in p_rtl_expression)
    return         t_rtl_logical;
-- find item (from start), or return false
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_wait_find(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator; --task private
    data           : in t_rtl_pointer;
    milisec        : in t_rtl_timeout;
    filter         : in p_rtl_expression)
    return         t_rtl_logical;
-- wait and find item (from start) wich satify filter, returns data and iterator
-- iterator must be always discarded using rtl_sset_stop
----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop(
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterator); --task private
-- discard iterator
----------------------------------------------------------------------------------------------------
procedure rtl_sset_free_data_discard : t_rtl_ref_free_resource;
-- procedure implements freedata parameter, discarding data
----------------------------------------------------------------------------------------------------
