----------------------------------------------------------------------------------------------------
procedure rtl_sstack_new =
----------------------------------------------------------------------------------------------------
begin
  sstack.freedata:=freedata;
  rtl_doubly_list_create(sstack.list);
  rtl_critical_new(sstack.lock);
  rtl_critisem_new(sstack.first,rtl_max_semaphore,rtl_max_semaphore);
  rtl_critisem_new(sstack.next,rtl_max_semaphore,rtl_max_semaphore);
  rtl_critievt_new(sstack.empty,true);
  end rtl_sstack_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_discard =
----------------------------------------------------------------------------------------------------
begin
  rtl_sstack_reset(sstack);
  rtl_doubly_list_discard(sstack.list);
  rtl_critical_discard(sstack.lock);
  rtl_critisem_discard(sstack.first);
  rtl_critisem_discard(sstack.next);
  rtl_critievt_discard(sstack.empty);
  end rtl_sstack_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_reset =
----------------------------------------------------------------------------------------------------
var
  data             :  t_rtl_pointer;

begin
 while rtl_sstack_try_pop(sstack,data,t_rtl_wait_immediate) loop
    if sstack.freedata<>nil then
      sstack.freedata^(data);
      end if;
    end loop;
  end rtl_sstack_reset;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop =
----------------------------------------------------------------------------------------------------
begin
  if not rtl_sstack_try_pop(sstack,data,t_rtl_wait_infinite,filter) then
    raise tasking_error;
    end if;
  end rtl_sstack_pop;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_wait_empty =
----------------------------------------------------------------------------------------------------
begin
  result:=rtl_critievt_try_wait(sstack.empty,milisec);
  end rtl_sstack_wait_empty;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_try_pop =
----------------------------------------------------------------------------------------------------
var
    listitem       : p_rtl_doubly_p_item;
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;

begin
  rtl_init_timeout;
  loop
    result:=rtl_critisem_try_lock(sstack.first,timeout);
    if not result then
      return;
      end if;

    -- zkusim zamknout
    rtl_adjust_timeout;
    result:=rtl_critical_try_lock(sstack.lock,timeout);
    if result then
      rtl_doubly_list_first(p_rtl_doubly_item(listitem:unchecked),sstack.list);

      if filter<>nil then
        result:=rtl_expr_evaluate(filter,listitem^.data);
      --else
        --result:=true;
        end if;
      
      -- vyhovuje filtru, vyndam ven
      if result then
        rtl_doubly_list_remove(p_rtl_doubly_item(listitem:unchecked),sstack.list);
        data:=listitem^.data;
        discard listitem;

        -- zmensim pocet prvku ve fronte
        pred sstack.count;
        if sstack.count=0 then
          rtl_critievt_set(sstack.empty);
        else
          rtl_critisem_unlock_all_waiting(sstack.next);
          end if;
        end if;

      --odemknu
      rtl_critical_unlock(sstack.lock);

      -- pokud cekam na dalsi
      if not result then
        -- vratim firsta ktereho jsem vybral
        rtl_critisem_unlock(sstack.first);

        -- cekam na next
        rtl_adjust_timeout;
        result:=rtl_critisem_try_lock(sstack.next,timeout);
        if not result or timeout=0 then
          return;
          end if;
      else
        -- nalezeno koncim
        return;
        end if;
    else
      if timeout=0 then
        return;
        end if;
      end if;
    end loop;
  end rtl_sstack_try_pop;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_push =
----------------------------------------------------------------------------------------------------
var
    listitem       : p_rtl_doubly_p_item;

begin
  -- vytvorim prvek
  new listitem;
  listitem^.data:=data;

  -- zamknu
  rtl_critical_lock(sstack.lock);

    -- vlozim prvek
    rtl_doubly_list_append(p_rtl_doubly_item(listitem:unchecked),sstack.list);

    -- zvednu pocet prvku ve fronte
    succ sstack.count;
    if sstack.count=1 then
      rtl_critievt_reset(sstack.empty);
      end if;
    rtl_critisem_unlock(sstack.first);
    rtl_critisem_unlock_all_waiting(sstack.next);

  -- odemknu
  rtl_critical_unlock(sstack.lock);
  end rtl_sstack_push;



