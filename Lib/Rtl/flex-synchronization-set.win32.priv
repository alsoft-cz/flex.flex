----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid (
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterrator) --thread private
    return t_rtl_logical8;
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure rtl_sset_new =
----------------------------------------------------------------------------------------------------
var
    success        : t_rtl_logical8;

begin
  sset.freedata:=freedata;
  rtl_abaref_new(sset.tail);
  rtl_abaref_copy_pointer_none(sset.head,sset.tail,sset.freedata,success);
  end rtl_sset_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_discard =
----------------------------------------------------------------------------------------------------
begin
  rtl_sset_reset(sset);
  sset.tail:=nil;
  sset.head:=nil;
  end rtl_sset_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_reset =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sset_reset;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_move =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sset_move;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_append =
----------------------------------------------------------------------------------------------------
var
  zero             : aliased t_rtl_abaref_pointer;
  oldtail          : aliased t_rtl_abaref_pointer;
  newnode          : aliased t_rtl_abaref_pointer;
  prevnode         : t_rtl_abaref_pointer;
  success          : t_rtl_logical8;

label
  restart
  ;

begin

  rtl_abaref_new(newnode);
  newnode.ptr^.data:=data;
  zero:=nil;

restart:
  oldtail:=sset.tail;

  -- zkopiruju si pointer na "posledni prvek"
  rtl_abaref_copy_pointer_source(prevnode,sset.tail,^oldtail,sset.freedata,success);
  if not success then goto restart; end if;

  --hledam jestli je opravdu posledni
  while prevnode.ptr^.next.ptr<>nil loop

    -- neni posledni takze si posunu ukazatel na posledni
    rtl_abaref_copy_pointer_source(prevnode,prevnode.ptr^.next,nil,sset.freedata,success);
    if not success then goto restart; end if;

    -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
    rtl_abaref_copy_pointer_target(sset.tail,^oldtail,prevnode,^oldtail,sset.freedata,success);
    if not success then goto restart; end if;
    end loop;

  -- mam docasneho reprezentanta posledniho prvku
  -- zkusim do nej nakopirovat novy node za predpokladu ze je opravdu posledni
  rtl_abaref_copy_pointer_target(prevnode.ptr^.next,^zero,newnode,^newnode,sset.freedata,success);
  if not success then goto restart; end if;

  -- podarilo se mi 
  -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
  rtl_abaref_copy_pointer_target(sset.tail,^oldtail,newnode,nil,sset.freedata,success);
  -- pokud se nepodarilo tak to asi udelal nekdo jiny a mne to nevadi


  -- uvolnim nebo predam iterator prvek
  if iterator=nil then
    rtl_abaref_discard(prevnode,sset.freedata,success);
    rtl_abaref_discard(newnode,sset.freedata,success);
  else
    iterator^.prev:=prevnode;
    iterator^.data:=newnode;
    end if;
  end rtl_sset_append;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove =
----------------------------------------------------------------------------------------------------
var
    oldinvalid     : t_rtl_native_signed;

begin
  -- testuju validitu iteratoru
  if iterator.data.ptr=nil then
    raise synchronization_error;
    end if;
  
  -- oznacim jako invalid
  rtl_interlocked_inc_out(^iterator.data.ptr^.invalid,oldinvalid);
  if winner<>nil then
    winner^:=(oldinvalid=0);
    end if;

  -- necham najit prvni dalsi validni a zaroven upravit zastaraly pointer
  result:=rtl_sset_find_valid(sset,iterator);
  end rtl_sset_remove;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid =
----------------------------------------------------------------------------------------------------
var
    next           : aliased t_rtl_abaref_pointer; 
    data           : aliased t_rtl_abaref_pointer; 
    prev           : t_rtl_abaref_pointer; 
    temp           : aliased t_rtl_abaref_pointer; 
    firsttemp      : aliased t_rtl_abaref_pointer; 
    success        : t_rtl_logical8;

begin
  -- trivialni pripad
  if iterator.data.ptr=nil then
    result:=false;
    return;
    end if;
  if iterator.data.ptr^.invalid=0 then
    result:=true;
    return;
    end if;

  next:=nil;
  rtl_abaref_copy_pointer_none(prev,iterator.prev,sset.freedata,success);
  rtl_abaref_copy_pointer_none(data,iterator.data,sset.freedata,success);
  firsttemp:=data;
  loop
    -- zjistuju next, dokud se to nestabilizuje
    loop
      rtl_abaref_copy_pointer_source(next,data.ptr^.next,nil,sset.freedata,success);
      until success;
    
    -- jestli neni konec
    if next.ptr<>nil then
      -- kopiruju prubeznou upravu pointeru
      temp:=data;
      rtl_abaref_copy_pointer_target(prev.ptr^.next,^temp,next,^next,sset.freedata,success);
      
      -- jestli je to poprve, zapamatuju si to
      if data.ptr=iterator.data.ptr then
        firsttemp:=next;
      else
        rtl_abaref_copy_pointer_target(iterator.prev.ptr^.next,^firsttemp,next,^firsttemp,sset.freedata,success);
        end if;


      -- rotuju pointery
      rtl_abaref_discard(prev,sset.freedata,success);
      prev:=data;
      data:=next;
      next:=nil;

      -- nasel jsem validni prvek, aspon ted se tak tvari
      if data.ptr^.invalid=0 then
        result:=true;
        rtl_abaref_discard(iterator.data,sset.freedata,success);
        iterator.data:=data;
        rtl_abaref_discard(prev,sset.freedata,success);
        break;
        end if;

    else
      result:=false;
      -- uvolnim vsecko
      rtl_abaref_discard(prev,sset.freedata,success);
      rtl_abaref_discard(data,sset.freedata,success);
      rtl_abaref_discard(next,sset.freedata,success);
      rtl_abaref_discard(iterator.prev,sset.freedata,success);
      rtl_abaref_discard(iterator.data,sset.freedata,success);
      break;
      end if;
    end loop;
  end rtl_sset_find_valid;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_start =
----------------------------------------------------------------------------------------------------
var
  success          : t_rtl_logical8;

begin
  -- zrusim prev
  rtl_abaref_discard(iterator.prev,sset.freedata,success);

  -- zkopiruju pointer na first
  loop
    rtl_abaref_copy_pointer_source(iterator.data,sset.head,nil,sset.freedata,success);
    until success;
  end rtl_sset_start;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_next =
----------------------------------------------------------------------------------------------------
var
  success          : t_rtl_logical8;
  next             : t_rtl_abaref_pointer; 

begin
  -- testuju validitu iteratoru
  if iterator.prev.ptr=nil and iterator.data.ptr=nil then
    raise synchronization_error;
    end if;

  -- zjistuju next
  loop
    rtl_abaref_copy_pointer_source(next,iterator.data.ptr^.next,nil,sset.freedata,success);
    -- dokud se to nestabilizuje
    until success;

  -- rotuju pointery
  rtl_abaref_discard(iterator.prev,sset.freedata,success);
  iterator.prev:=iterator.data;
  iterator.data:=next;
  next:=nil;
  
  -- najdu prvni platny
  result:=rtl_sset_find_valid(sset,iterator);
  if result then
    data:=iterator.data.ptr^.data;
    end if;
  end rtl_sset_next;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop =
----------------------------------------------------------------------------------------------------
var
  success          : t_rtl_logical8;

begin
  -- drop iterator
  rtl_abaref_discard(iterator.prev,sset.freedata,success);
  rtl_abaref_discard(iterator.data,sset.freedata,success);
  end rtl_sset_stop;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_free_data_discard =
----------------------------------------------------------------------------------------------------
begin
  discard data;
  end rtl_sset_free_data_discard;
