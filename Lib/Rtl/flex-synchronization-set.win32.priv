type
  t_rtl_sset = t_rtl_ref_fifo with record      -- struktura stacku
    freedata       : p_rtl_ref_free_resource;    -- uvolnovaci callback
    waitable       : t_rtl_logical32;            -- priznak zda se ma cekat
    --is waitable
      critisem     : t_rtl_critisem;             -- semafor pro cekani na prazdny stack
                                                 -- pro pocet prvku mensi nez pocet ctecich 
                                                 -- threadu blokujici ve smyslu prvku ktere se 
                                                 -- jiz zacali cist
    -- else
      count        : aliased t_rtl_native_signed -- inverzni pocitadlo prvku
                     for position use 24;        -- na stejnem offsxetu jako pocitadlo critisemu
    -- end if waitable
    end record;

type
  t_rtl_sset_iterrator = record                  -- iterator
    prev           : t_rtl_ref_shared;
    data           : t_rtl_ref_shared;
    end record;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid (
    sset           : in out ref t_rtl_sset;
    iterator       : in out ref t_rtl_sset_iterrator) --thread private
    return t_rtl_logical8;
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure rtl_sset_new =
----------------------------------------------------------------------------------------------------
var
    temp           : t_rtl_ref_local;

begin
  sset.freedata:=freedata;
  rtl_ref_create_local(temp,nil,freedata);
  rtl_ref_local_to_local_shared(temp,sset.head);
  rtl_ref_local_to_local_shared(temp,sset.tail);
  rtl_ref_discard_local(temp);
  end rtl_sset_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_discard =
----------------------------------------------------------------------------------------------------
begin
  rtl_sset_reset(sset);
  sset.tail:=nil;
  sset.head:=nil;
  end rtl_sset_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_reset =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sset_reset;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_move =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sset_move;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_append =
----------------------------------------------------------------------------------------------------
var
  zero             : t_rtl_ref_snapshot;
  oldtail          : aliased t_rtl_ref_snapshot;
  wrktail          : t_rtl_ref_snapshot;
  newtemp          : aliased t_rtl_ref_snapshot;
  newnode          : t_rtl_ref_local;
  prevnode         : t_rtl_ref_shared;

label
  restart
  ;

begin
  rtl_ref_create_local(newnode,data,sset.freedata);

restart:
  rtl_ref_shared_to_snapshot(sset.tail,oldtail);

  -- zkopiruju si pointer na "posledni prvek"
  if not rtl_ref_shared_to_local_shared(sset.tail,prevnode,oldtail) then
    goto restart; 
    end if;

  --hledam jestli je opravdu posledni
  rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
  while wrktail.node<>nil loop

    -- neni posledni takze si posunu ukazatel na posledni
    if not rtl_ref_shared_to_local_shared(prevnode.node^.next,prevnode,wrktail) then
      goto restart; 
      end if;

    -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
    if not rtl_ref_local_shared_to_shared(prevnode,sset.tail,oldtail,^oldtail) then
      goto restart; 
      end if;
    -- podarilo se udelam si novy snapshot
    rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
    end loop;

  -- mam docasneho reprezentanta posledniho prvku
  -- zkusim do nej nakopirovat novy node za predpokladu ze je opravdu posledni
  if not rtl_ref_local_to_shared(newnode,prevnode.node^.next,zero) then
    goto restart; 
    end if;

  -- podarilo se mi 
  -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
  if not rtl_ref_local_to_shared(newnode,sset.tail,oldtail) then
    -- pokud se nepodarilo tak to asi udelal nekdo jiny a mne to nevadi
    end if;


  -- uvolnim nebo predam iterator prvek
  if iterator=nil then
    rtl_ref_discard_local_shared(prevnode);
    rtl_ref_discard_local(newnode);
  else
    iterator^.prev:=prevnode;
    iterator^.data.node:=newnode.node;
    iterator^.data.softcount:=0;
    iterator^.data.abacount:=newtemp.abacount;
    end if;
  end rtl_sset_append;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove =
----------------------------------------------------------------------------------------------------
var
  oldinvalid       : t_rtl_native_signed;
  oldtail          : t_rtl_ref_snapshot;

begin
  -- testuju validitu iteratoru
  if iterator.data.node=nil then
    raise synchronization_error;
    end if;
  
  -- oznacim jako invalid
  rtl_interlocked_inc_out(^iterator.data.node^.invalid,oldinvalid);
  if winner<>nil then
    winner^:=(oldinvalid=0);
    end if;

  -- necham najit prvni dalsi validni a zaroven upravit zastaraly pointer
  result:=rtl_sset_find_valid(sset,iterator);
  end rtl_sset_remove;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid =
----------------------------------------------------------------------------------------------------
var
    temp           : t_rtl_ref_snapshot; 
    nexttemp       : aliased t_rtl_ref_snapshot; 
    firsttemp      : aliased t_rtl_ref_snapshot; 
    next           : t_rtl_ref_shared; 
    data           : t_rtl_ref_shared; 
    prev           : t_rtl_ref_shared; 

begin
  -- trivialni pripad
  if iterator.data.node=nil then 
    rtl_ref_discard_local_shared(iterator.prev);
    result:=false;
    return;
    end if;

  if iterator.data.node^.invalid=0 then
    result:=true;
    return;
    end if;

  rtl_ref_local_shared_to_local_shared(iterator.prev,prev);
  rtl_ref_local_shared_to_local_shared(iterator.data,data);

  loop
    -- zjistuju next, dokud se to nestabilizuje
    loop
      rtl_ref_shared_to_snapshot(data.node^.next,nexttemp);
      until rtl_ref_shared_to_local_shared(data.node^.next,next,nexttemp);
    
    -- jestli neni konec
    if next.node<>nil then
      -- kopiruju prubeznou upravu pointeru
      rtl_ref_shared_to_snapshot(data,temp);

      if rtl_ref_local_shared_to_shared(next,prev.node^.next,temp,^nexttemp) then 
        next.abacount:=nexttemp.abacount;
        end if;
      
      -- jestli je to poprve, zapamatuju si to
      if data.node=iterator.data.node then
        rtl_ref_shared_to_snapshot(next,firsttemp);
      else
        -- ignoruju jak to dopadlo 
        if rtl_ref_local_shared_to_shared(next,iterator.prev.node^.next,firsttemp,^firsttemp) then end if;
        end if;


      -- rotuju pointery
      rtl_ref_discard_local_shared(prev);
      prev:=data;
      data:=next;
      next:=nil;

      -- nasel jsem validni prvek, aspon ted se tak tvari
      if data.node^.invalid=0 then
        result:=true;
        rtl_ref_discard_local_shared(iterator.data);
        iterator.data:=data;
        rtl_ref_discard_local_shared(prev);
        break;
        end if;

    else
      result:=false;
      -- uvolnim vsecko
      rtl_ref_discard_local_shared(prev);
      rtl_ref_discard_local_shared(data);
      rtl_ref_discard_local_shared(iterator.prev);
      rtl_ref_discard_local_shared(iterator.data);
      break;
      end if;
    end loop;
  end rtl_sset_find_valid;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_start =
----------------------------------------------------------------------------------------------------
var
  temp             : t_rtl_ref_snapshot;

begin
  -- zrusim prev
  rtl_ref_discard_local_shared(iterator.prev);

  -- zkopiruju pointer na first
  loop
    rtl_ref_shared_to_snapshot(sset.head,temp);
    until rtl_ref_shared_to_local_shared(sset.head,iterator.data,temp);
  end rtl_sset_start;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_next =
----------------------------------------------------------------------------------------------------
var
  temp             : t_rtl_ref_snapshot;
  next             : t_rtl_ref_shared; 

begin
  -- testuju validitu iteratoru
  if iterator.prev.node=nil and iterator.data.node=nil then
    raise synchronization_error;
    end if;

  -- zjistuju next
  loop
    rtl_ref_shared_to_snapshot(iterator.data.node^.next,temp);
    until rtl_ref_shared_to_local_shared(iterator.data.node^.next,next,temp);

  -- rotuju pointery
  rtl_ref_discard_local_shared(iterator.prev);
  iterator.prev:=iterator.data;
  iterator.data:=next;
  next:=nil;
  
  -- najdu prvni platny
  result:=rtl_sset_find_valid(sset,iterator);
  if result then
    data:=iterator.data.node^.data;
    end if;
  end rtl_sset_next;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop =
----------------------------------------------------------------------------------------------------
var
  success          : t_rtl_logical8;

begin
  -- drop iterator
  rtl_ref_discard_local_shared(iterator.prev);
  rtl_ref_discard_local_shared(iterator.data);
  end rtl_sset_stop;


----------------------------------------------------------------------------------------------------
procedure rtl_sset_free_data_discard =
----------------------------------------------------------------------------------------------------
begin
  discard resource;
  end rtl_sset_free_data_discard;
