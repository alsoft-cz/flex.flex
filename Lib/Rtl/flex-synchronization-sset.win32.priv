----------------------------------------------------------------------------------------------------
procedure rtl_sset_append_cr(
    sset           : in out ref t_rtl_sset_cr;
    data           : in t_rtl_pointer;
    btrynext       : in t_rtl_logical;
    iterator       : in p_rtl_sset_iterator_cr:=nil) =
----------------------------------------------------------------------------------------------------
var
    newnode        : p_rtl_doubly_pc_item;

begin
  -- vytvorim prvek
  new newnode;
  newnode^.data:=data;
  newnode^.refcount:=1;
  
  -- zamknu
  rtl_critical_lock(sset.lock);

    -- vlozim prvek
    rtl_doubly_list_append(p_rtl_doubly_item(newnode:unchecked),sset);

    if iterator<>nil then
      if iterator^.data<>nil then
        pred iterator^.data^.refcount;
        if iterator^.data^.refcount=1 and iterator^.data^.invalid then
          pred sset.lcounter;
          rtl_doubly_list_remove(p_rtl_doubly_item(iterator^.data:unchecked),sset);
          if sset.freedata<>nil then
            sset.freedata^(iterator^.data^.data);
            end if;
          discard iterator^.data;
          end if;
        end if;
      iterator^.data:=newnode;
      succ newnode^.refcount;
      end if;
    
    -- zvednu pocet prvku ve fronte
    succ sset.lcounter;
    if sset.lcounter=1 then
      -- povolim dalsimu tasku cteni
      if btrynext then
        rtl_critisem_unlock_all(sset.trynext);
        end if;
      rtl_critisem_unlock(sset.counter);
      end if;

  -- odemknu
  rtl_critical_unlock(sset.lock);
  end rtl_sset_append_cr;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_start_cr(
    sset           : in out ref t_rtl_sset_cr;
    iterator       : in out ref t_rtl_sset_iterator_cr; --task private
    data           : out t_rtl_pointer;
    milisec        : in t_rtl_timeout)
    return         t_rtl_logical =
----------------------------------------------------------------------------------------------------
var
    next           : p_rtl_doubly_pc_item;

begin
  --cekam dokud tam neco neni
  result:=rtl_critisem_try_lock(sset.counter,milisec);
  if not result then
    return;
    end if;

  -- zamknu
  rtl_critical_lock(sset.lock);

    rtl_doubly_list_first(p_rtl_doubly_item(next:unchecked),sset);
    result:=(next<>nil);
    if result then
      succ next^.refcount;
      end if;

    if iterator.data<>nil then
      pred iterator.data^.refcount;
      if iterator.data^.refcount=1 and iterator.data^.invalid then
        pred sset.lcounter;
        rtl_doubly_list_remove(p_rtl_doubly_item(iterator.data:unchecked),sset);
        if sset.freedata<>nil then
          sset.freedata^(iterator.data^.data);
          end if;
        discard iterator.data;
        end if;
      end if;
    iterator.data:=next;

    if sset.lcounter>0 then
      -- povolim dalsimu tasku cteni
      rtl_critisem_unlock(sset.counter);
      end if;
  
  -- odemknu
  rtl_critical_unlock(sset.lock);
  end rtl_sset_try_start_cr;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove_cr(
    sset           : in out ref t_rtl_sset_cr;
    iterator       : in out ref t_rtl_sset_iterator_cr; --task private
    winner         : in p_rtl_logical:=nil;
    immediate      : in t_rtl_logical:=false)
    return         t_rtl_logical =
----------------------------------------------------------------------------------------------------
var
    next           : p_rtl_doubly_pc_item;

begin
  if iterator.data=nil then
    raise synchronization_error;
    end if;

  --cekam dokud tam neco neni
  if not rtl_critisem_try_lock(sset.counter,t_rtl_wait_infinite) then
    raise synchronization_error;
    end if;

  -- zamknu
  rtl_critical_lock(sset.lock);
    next:=iterator.data;
    rtl_doubly_list_next(p_rtl_doubly_item(next:unchecked),sset);
    result:=(next<>nil);
    if result then
      succ next^.refcount;
      end if;

    pred iterator.data^.refcount;
    if winner<>nil then
      winner^:=not iterator.data^.invalid;
      end if;
    iterator.data^.invalid:=true;
    if immediate or (iterator.data^.refcount=1 and iterator.data^.invalid) then
      pred sset.lcounter;
      rtl_doubly_list_remove(p_rtl_doubly_item(iterator.data:unchecked),sset);
      if sset.freedata<>nil then
        sset.freedata^(iterator.data^.data);
        end if;
      discard iterator.data;
      end if;
    iterator.data:=next;

    if sset.lcounter>0 then
      -- povolim dalsimu tasku cteni
      rtl_critisem_unlock(sset.counter);
      end if;
  
  -- odemknu
  rtl_critical_unlock(sset.lock);
  end rtl_sset_remove_cr;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_next_now_cr(
    sset           : in out ref t_rtl_sset_cr;
    iterator       : in out ref t_rtl_sset_iterator_cr; --task private
    data           : out t_rtl_pointer)
    return         t_rtl_logical =
----------------------------------------------------------------------------------------------------
var
    next           : p_rtl_doubly_pc_item;

begin
  if iterator.data=nil then
    raise synchronization_error;
    end if;

  --cekam dokud tam neco neni
  if not rtl_critisem_try_lock(sset.counter,t_rtl_wait_infinite) then
    raise synchronization_error;
    end if;

  -- zamknu
  rtl_critical_lock(sset.lock);
    next:=iterator.data;
    rtl_doubly_list_next(p_rtl_doubly_item(next:unchecked),sset);
    result:=(next<>nil);
    if result then
      succ next^.refcount;

      pred iterator.data^.refcount;
      if iterator.data^.refcount=1 and iterator.data^.invalid then
        pred sset.lcounter;
        rtl_doubly_list_remove(p_rtl_doubly_item(iterator.data:unchecked),sset);
        if sset.freedata<>nil then
          sset.freedata^(iterator.data^.data);
          end if;
        discard iterator.data;
        end if;
      iterator.data:=next;
      end if;

    if sset.lcounter>0 then
      -- povolim dalsimu tasku cteni
      rtl_critisem_unlock(sset.counter);
      end if;
  
  -- odemknu
  rtl_critical_unlock(sset.lock);
  end rtl_sset_next_now_cr;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop_cr(
    sset           : in out ref t_rtl_sset_cr;
    iterator       : in out ref t_rtl_sset_iterator_cr) =
----------------------------------------------------------------------------------------------------
begin
  if iterator.data=nil then
    return;
    end if;

  --cekam dokud tam neco neni
  if not rtl_critisem_try_lock(sset.counter,t_rtl_wait_infinite) then
    raise synchronization_error;
    end if;

  -- zamknu
  rtl_critical_lock(sset.lock);

    if iterator.data<>nil then
      pred iterator.data^.refcount;
      if iterator.data^.refcount=1 and iterator.data^.invalid then
        pred sset.lcounter;
        rtl_doubly_list_remove(p_rtl_doubly_item(iterator.data:unchecked),sset);
        if sset.freedata<>nil then
          sset.freedata^(iterator.data^.data);
          end if;
        discard iterator.data;
        end if;
      iterator.data:=nil;
      end if;

    if sset.lcounter>0 then
      -- povolim dalsimu tasku cteni
      rtl_critisem_unlock(sset.counter);
      end if;

  -- odemknu
  rtl_critical_unlock(sset.lock);
  end rtl_sset_stop_cr;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid_nb (
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb) --task private
    return t_rtl_logical;
----------------------------------------------------------------------------------------------------
procedure rtl_sset_start_now_nb(
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb; --task private
    data           : out t_rtl_pointer)
    return         t_rtl_logical;
----------------------------------------------------------------------------------------------------
procedure rtl_sset_append_internal_nb(
    newnode        : in out ref t_rtl_ref_local;
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in p_rtl_sset_iterator_nb:=nil); --can be nil, task private
----------------------------------------------------------------------------------------------------
procedure rtl_clean_internal_nb(
    sset           : in out ref t_rtl_sset_nb);
----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_start_nb(
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb; --task private
    data           : out t_rtl_pointer;
    milisec        : in t_rtl_timeout)
    return         t_rtl_logical;
----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop_nb(
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb); --task private
----------------------------------------------------------------------------------------------------
procedure rtl_sset_append_nb(
    sset           : in out ref t_rtl_sset_nb;
    data           : in t_rtl_pointer;
    btrynext       : in t_rtl_logical;
    iterator       : in p_rtl_sset_iterator_nb:=nil); --can be nil, task private
----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove_nb(
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb; --task private
    winner         : in p_rtl_logical:=nil;
    immediate      : in t_rtl_logical:=false)
    return         t_rtl_logical;
----------------------------------------------------------------------------------------------------
procedure rtl_sset_next_now_nb(
    sset           : in out ref t_rtl_sset_nb;
    iterator       : in out ref t_rtl_sset_iterator_nb; --task private
    data           : out t_rtl_pointer)
    return         t_rtl_logical;
----------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------
procedure rtl_sset_append_internal_nb =
----------------------------------------------------------------------------------------------------
var
  zero             : t_rtl_ref_snapshot;
  oldtail          : aliased t_rtl_ref_snapshot;
  wrktail          : t_rtl_ref_snapshot;
  newtemp          : aliased t_rtl_ref_snapshot;
  prevnode         : t_rtl_ref_shared;

label
  restart
  ;

begin
restart:
  rtl_ref_shared_to_snapshot(sset.tail,oldtail);

  -- zkopiruju si pointer na "posledni prvek"
  if not rtl_ref_shared_to_local_shared(sset.tail,prevnode,oldtail) then
    pause_nop;
    goto restart; 
    end if;

  --hledam jestli je opravdu posledni
  rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
  while wrktail.node<>nil loop

    -- neni posledni takze si posunu ukazatel na posledni
    if not rtl_ref_shared_to_local_shared(prevnode.node^.next,prevnode,wrktail) then
      pause_nop;
      goto restart; 
      end if;

    -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
    if not rtl_ref_local_shared_to_shared(prevnode,sset.tail,oldtail,^oldtail) then
      pause_nop;
      goto restart; 
      end if;
    -- podarilo se udelam si novy snapshot
    rtl_ref_shared_to_snapshot(prevnode.node^.next,wrktail);
    end loop;

  -- mam docasneho reprezentanta posledniho prvku
  -- zkusim do nej nakopirovat novy node za predpokladu ze je opravdu posledni
  if not rtl_ref_local_to_shared(newnode,prevnode.node^.next,zero) then
    pause_nop;
    goto restart; 
    end if;

  -- podarilo se mi 
  -- zkusim prehodit pointer na "posledni prvek" na tenhle prvek
  if not rtl_ref_local_to_shared(newnode,sset.tail,oldtail) then
    -- pokud se nepodarilo tak to asi udelal nekdo jiny a mne to nevadi
    end if;


  -- uvolnim nebo predam iterator prvek
  if iterator=nil then
    rtl_ref_discard_local_shared(prevnode);
    rtl_ref_discard_local(newnode);
  else
    rtl_ref_discard_local_shared(iterator^.prev);
    rtl_ref_discard_local_shared(iterator^.data);
    iterator^.prev:=prevnode;
    iterator^.data.node:=newnode.node;
    iterator^.data.softcount:=0;
    iterator^.data.abacount:=newtemp.abacount;
    end if;
  end rtl_sset_append_internal_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_clean_internal_nb =
----------------------------------------------------------------------------------------------------
var
  cleaner          : t_rtl_sset_iterator_nb;
  temp             : t_rtl_pointer;

begin
  if rtl_sset_start_now_nb(sset,cleaner,temp) then
    end if;
  rtl_sset_stop_nb(sset,cleaner);
  end rtl_clean_internal_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_append_nb =
----------------------------------------------------------------------------------------------------
var
  newnode          : t_rtl_ref_local;
  old_count        : t_rtl_native_signed;

begin
  rtl_ref_create_local(newnode,data,sset.freedata,t_rtl_ref_ns_full);
  rtl_sset_append_internal_nb(newnode,sset,iterator);
  -- zvednu pocet prvku ve listu a nebo povolim dalsimu tasku cteni
  if btrynext then
    rtl_critisem_unlock_out(sset.counter,old_count);
    -- jestli je tam prave jeden prvek probudim cekatele na dalsi prvek
    if old_count=0 then
        rtl_critisem_unlock_all(sset.trynext);
      end if;
  else
    rtl_interlocked_dec(p_rtl_native_signed(^sset.counter:unchecked));
    end if;

  
  -- %%TODO maybe ??
  --rtl_clean_internal_nb(sset);
  end rtl_sset_append_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove_nb =
----------------------------------------------------------------------------------------------------
var
  oldinvalid       : t_rtl_native_signed;
  dumbnode         : t_rtl_ref_local;

begin
  -- testuju validitu iteratoru
  if iterator.data.node=nil then
    raise synchronization_error;
    end if;
  
  -- oznacim jako invalid
  rtl_interlocked_inc_out(^iterator.data.node^.invalid,oldinvalid);
  if winner<>nil then
    winner^:=(oldinvalid=0);
    end if;

  if oldinvalid=0 then
    -- reknu ze si beru jeden prvek
    rtl_critisem_force_lock(sset.counter);
   
    -- osetrim uvolneni posledniho v seznamu
    if iterator.data.node^.next.node=nil then
      rtl_ref_create_local(dumbnode,nil,nil,t_rtl_ref_ns_full);
      dumbnode.node^.invalid:=1;
      rtl_sset_append_internal_nb(dumbnode,sset,nil);
      end if;
    if immediate then
      rtl_ref_local_shared_free_data(iterator.data);
      end if;
    end if;

  -- necham najit prvni dalsi validni a zaroven upravit zastaraly pointer
  result:=rtl_sset_find_valid_nb(sset,iterator);
  rtl_clean_internal_nb(sset);
  end rtl_sset_remove_nb;




----------------------------------------------------------------------------------------------------
procedure rtl_sset_find_valid_nb =
----------------------------------------------------------------------------------------------------
var
    temp           : t_rtl_ref_snapshot; 
    nexttemp       : aliased t_rtl_ref_snapshot; 
    firsttemp      : aliased t_rtl_ref_snapshot; 
    next           : t_rtl_ref_shared; 
    data           : t_rtl_ref_shared; 
    prev           : t_rtl_ref_shared; 

begin
  -- trivialni pripad
  if iterator.data.node=nil then 
    rtl_ref_discard_local_shared(iterator.prev);
    result:=false;
    return;
    end if;

  if iterator.data.node^.invalid=0 then
    result:=true;
    return;
    end if;

  rtl_ref_local_shared_to_local_shared(iterator.prev,prev);
  rtl_ref_local_shared_to_local_shared(iterator.data,data);

  loop
    -- zjistuju next, dokud se to nestabilizuje
    loop
      rtl_ref_shared_to_snapshot(data.node^.next,nexttemp);
      until rtl_ref_shared_to_local_shared(data.node^.next,next,nexttemp);
    
    -- jestli neni konec
    if next.node<>nil then
      -- kopiruju prubeznou upravu pointeru
      rtl_ref_shared_to_snapshot(data,temp);

      if rtl_ref_local_shared_to_shared(next,prev.node^.next,temp,^nexttemp) then 
        next.abacount:=nexttemp.abacount;
        end if;
      
      -- jestli je to poprve, zapamatuju si to
      if data.node=iterator.data.node then
        rtl_ref_shared_to_snapshot(next,firsttemp);
      else
        -- ignoruju jak to dopadlo 
        if rtl_ref_local_shared_to_shared(next,iterator.prev.node^.next,firsttemp,^firsttemp) then end if;
        end if;


      -- rotuju pointery
      rtl_ref_discard_local_shared(prev);
      prev:=data;
      data:=next;
      next:=nil;

      -- nasel jsem validni prvek, aspon ted se tak tvari
      if data.node^.invalid=0 then
        result:=true;
        break;
        end if;

    else
      result:=false;
      break;
      end if;
    end loop;
  rtl_ref_discard_local_shared(iterator.prev);
  rtl_ref_discard_local_shared(iterator.data);
  iterator.data:=data;
  iterator.prev:=prev;
  end rtl_sset_find_valid_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_start_now_nb =
----------------------------------------------------------------------------------------------------
var
  temp             : t_rtl_ref_snapshot;

begin
  -- zrusim prev
  rtl_ref_discard_local_shared(iterator.prev);

  -- zkopiruju pointer na first
  loop
    rtl_ref_shared_to_snapshot(sset.head,temp);
    until rtl_ref_shared_to_local_shared(sset.head,iterator.data,temp);
  result:=rtl_sset_next_now_nb(sset,iterator,data);
  end rtl_sset_start_now_nb;




----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_start_nb =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;

begin

  -- zkusim si ho opravdu vzit
  result:=rtl_sset_start_now_nb(sset,iterator,data);

  -- pokud neumi cekani tak uz na nic necekam
  if milisec=t_rtl_wait_immediate or result then
    return;
    end if;

  -- pokud je potreba pocitat cas tak zjistim start
  timeout:=milisec;
  if milisec>0 then
    start:=GetTickCount();
    end if;

  -- neni tam prvek takze mam cekat
  loop
    -- pockam az nekdo signalizuje ze je tam alespon jeden prvek
    if not rtl_critisem_wait_only(sset.counter,timeout) then
      -- timeout
      result:=false;
      return;
      end if;

    -- zkusim jestli mne nekdo nepredbehne
    result:=rtl_sset_start_now_nb(sset,iterator,data);

    -- podarilo se sebrat prvek, koncim
    if result then return; end if;

    -- pokud je potreba pocitat cas tak zjistim kolik ubehlo
    if milisec>0 then
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then
        -- timeout
        result:=false;
        return;
        end if;
      end if;
    end loop;
  end rtl_sset_try_start_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_next_now_nb =
----------------------------------------------------------------------------------------------------
var
  temp             : t_rtl_ref_snapshot;
  next             : t_rtl_ref_shared; 

begin
  -- testuju validitu iteratoru
  if iterator.prev.node=nil and iterator.data.node=nil then
    raise synchronization_error;
    end if;

  -- zjistuju next
  loop
    rtl_ref_shared_to_snapshot(iterator.data.node^.next,temp);
    until rtl_ref_shared_to_local_shared(iterator.data.node^.next,next,temp);

  -- rotuju pointery
  rtl_ref_discard_local_shared(iterator.prev);
  iterator.prev:=iterator.data;
  iterator.data:=next;
  next:=nil;
  
  -- najdu prvni platny
  result:=rtl_sset_find_valid_nb(sset,iterator);
  if result then
    data:=iterator.data.node^.data;
    end if;
  end rtl_sset_next_now_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop_nb =
----------------------------------------------------------------------------------------------------
var
  success          : t_rtl_logical;

begin
  -- drop iterator
  rtl_ref_discard_local_shared(iterator.prev);
  rtl_ref_discard_local_shared(iterator.data);
  end rtl_sset_stop_nb;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_start =
----------------------------------------------------------------------------------------------------
begin
  if not rtl_sset_try_start(sset,iterator,data,t_rtl_wait_infinite) then
    raise synchronization_error;
    end if;
  end rtl_sset_start;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_wait_next =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;

begin
  timeout:=milisec;
  if milisec>0 then 
    start:=GetTickCount();
    end if;

  loop
    result:=rtl_sset_next_now(sset,iterator,data);
    if result or milisec=t_rtl_wait_immediate then
      return;
      end if;

    if sset.style in t_rtl_concurency_style_set:[rtl_cst_nonkernel,rtl_cst_critical] then
      return;
      end if;

    if milisec>0 then 
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then timeout:=0; end if;
      end if;

    -- cekam na dalsi prvek
    if sset.style = rtl_cst_nonblocking then
      if not rtl_critisem_try_lock(sset.nonblocking.trynext,timeout) then
        return;
        end if;
    else
      if not rtl_critisem_try_lock(sset.critical.trynext,timeout) then
        return;
        end if;
      end if;

    if milisec>0 then 
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then timeout:=0; end if;
      end if;
    end loop;  
  end rtl_sset_try_wait_next;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_find_now =
----------------------------------------------------------------------------------------------------
var
    test           : t_rtl_pointer;
    su             : t_rtl_logical;

begin
  result:=rtl_sset_try_start(sset,iterator,test,t_rtl_wait_immediate);
  if result then
    if filter=nil or else rtl_expr_evaluate(filter,test) then
      result:=true;
      return;
      end if;

    loop
      su:=rtl_sset_next_now(sset,iterator,test);
      if su and rtl_expr_evaluate(filter,test) then
        result:=true;
        return;
        end if;
      until su;
    end if;
  end rtl_sset_try_find_now;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_wait_find =
----------------------------------------------------------------------------------------------------
var
    test           : t_rtl_pointer;
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;
    su             : t_rtl_logical;

begin
  timeout:=milisec;
  if milisec>0 then 
    start:=GetTickCount();
    end if;

  result:=rtl_sset_try_start(sset,iterator,test,timeout);
  if result then
    if filter=nil or else rtl_expr_evaluate(filter,test) then
      result:=true;
      return;
      end if;

    loop
      su:=rtl_sset_next_now(sset,iterator,test);
      if su and rtl_expr_evaluate(filter,test) then
        result:=true;
        return;
        end if;
      until su;
    end if;

  loop
    -- zatim nenalezeno
    if milisec>0 then 
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then timeout:=0; end if;
      end if;
    
    if rtl_sset_try_wait_next(sset,iterator,test,timeout) then
      if rtl_expr_evaluate(filter,test) then
        result:=true;
        return
        end if;
    else
      -- timeout
      result:=false;
      return;
      end if;
    end loop;
  end rtl_sset_try_wait_find;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_free_data_discard =
----------------------------------------------------------------------------------------------------
begin
  discard resource;
  end rtl_sset_free_data_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_append =
----------------------------------------------------------------------------------------------------
begin
  if sset.style in t_rtl_concurency_style_set:[rtl_cst_nonkernel,rtl_cst_nonblocking] then
    rtl_sset_append_nb(sset.nonblocking,data,sset.style=rtl_cst_nonblocking,^iterator^.nonblocking);
  else
    rtl_sset_append_cr(sset.critical,data,sset.style=rtl_cst_waitable,^iterator^.critical);
    end if;
  end rtl_sset_append;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_remove =
----------------------------------------------------------------------------------------------------
begin
  if sset.style in t_rtl_concurency_style_set:[rtl_cst_nonkernel,rtl_cst_nonblocking] then
    result:=rtl_sset_remove_nb(sset.nonblocking,iterator.nonblocking,winner,immediate);
  else
    result:=rtl_sset_remove_cr(sset.critical,iterator.critical,winner,immediate);
    end if;
  end rtl_sset_remove;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_try_start =
----------------------------------------------------------------------------------------------------
begin
  case sset.style
    when rtl_cst_nonkernel do
      result:=rtl_sset_start_now_nb(sset.nonblocking,iterator.nonblocking,data);
    when rtl_cst_nonblocking do
      result:=rtl_sset_try_start_nb(sset.nonblocking,iterator.nonblocking,data,milisec);
    when rtl_cst_critical,rtl_cst_waitable do
      result:=rtl_sset_try_start_cr(sset.critical,iterator.critical,data,milisec);
    end case;
  end rtl_sset_try_start;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_next_now =
----------------------------------------------------------------------------------------------------
begin
  if sset.style in t_rtl_concurency_style_set:[rtl_cst_nonkernel,rtl_cst_nonblocking] then
    result:=rtl_sset_next_now_nb(sset.nonblocking,iterator.nonblocking,data);
  else
    result:=rtl_sset_next_now_cr(sset.critical,iterator.critical,data);
    end if;
  end rtl_sset_next_now;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_stop =
----------------------------------------------------------------------------------------------------
begin
  if sset.style in t_rtl_concurency_style_set:[rtl_cst_nonkernel,rtl_cst_nonblocking] then
    rtl_sset_stop_nb(sset.nonblocking,iterator.nonblocking);
  else
    rtl_sset_stop_cr(sset.critical,iterator.critical);
    end if;
  end rtl_sset_stop;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_new =
----------------------------------------------------------------------------------------------------
var
    temp           : t_rtl_ref_local;

begin
  sset.style:=style;
  case sset.style
    when rtl_cst_nonkernel do
      sset.nonblocking.freedata:=freedata;
      rtl_ref_create_local(temp,nil,freedata,t_rtl_ref_ns_full);
      rtl_ref_local_to_local_shared(temp,sset.nonblocking.head);
      rtl_ref_local_to_local_shared(temp,sset.nonblocking.tail);
      rtl_ref_discard_local(temp);
    when rtl_cst_nonblocking do
      rtl_critisem_new_owned(sset.nonblocking.counter,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
      rtl_critisem_new_owned(sset.nonblocking.trynext,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
      sset.nonblocking.freedata:=freedata;
      rtl_ref_create_local(temp,nil,freedata,t_rtl_ref_ns_full);
      rtl_ref_local_to_local_shared(temp,sset.nonblocking.head);
      rtl_ref_local_to_local_shared(temp,sset.nonblocking.tail);
      rtl_ref_discard_local(temp);
    when rtl_cst_critical do
      sset.critical.freedata:=freedata;
      rtl_doubly_list_create(sset.critical);
      rtl_critisem_new_owned(sset.critical.counter,1,1);
      rtl_critical_new(sset.critical.lock);
      sset.critical.lcounter:=0;
    when rtl_cst_waitable do
      sset.critical.freedata:=freedata;
      rtl_doubly_list_create(sset.critical);
      rtl_critisem_new_owned(sset.critical.counter,1,1);
      rtl_critisem_new_owned(sset.critical.trynext,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
      rtl_critical_new(sset.critical.lock);
      sset.critical.lcounter:=0;
    end case;
  end rtl_sset_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_discard =
----------------------------------------------------------------------------------------------------
begin
  rtl_sset_reset(sset);
  case sset.style
    when rtl_cst_nonkernel do
      rtl_ref_discard_local_shared(sset.nonblocking.head);
      rtl_ref_discard_local_shared(sset.nonblocking.tail);
    when rtl_cst_nonblocking do
      rtl_ref_discard_local_shared(sset.nonblocking.head);
      rtl_ref_discard_local_shared(sset.nonblocking.tail);
      rtl_critisem_discard(sset.nonblocking.counter);
      rtl_critisem_discard(sset.nonblocking.trynext);
    when rtl_cst_critical do
      rtl_critisem_discard(sset.critical.counter);
      rtl_critical_discard(sset.critical.lock);
      rtl_doubly_list_discard(sset.critical);
    when rtl_cst_waitable do
      rtl_critisem_discard(sset.critical.counter);
      rtl_critical_discard(sset.critical.lock);
      rtl_critisem_discard(sset.critical.trynext);
      rtl_doubly_list_discard(sset.critical);
    end case;
  end rtl_sset_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sset_reset =
----------------------------------------------------------------------------------------------------
var
  i                : t_rtl_sset_iterator;
  data             : t_rtl_pointer;

begin
  if rtl_sset_try_start(sset,i,data,t_rtl_wait_immediate) then
    while rtl_sset_remove(sset,i) loop
      end loop;
    end if;
  rtl_sset_stop(sset,i);
  end rtl_sset_reset;
