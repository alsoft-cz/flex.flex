type
  t_rtl_sstack = t_rtl_ref_lifo with record      -- struktura stacku
    freedata       : p_rtl_ref_free_resource;    -- uvolnovaci callback
    waitable       : t_rtl_logical32;            -- priznak zda se ma cekat
    --is waitable
      critisem     : t_rtl_critisem;             -- semafor pro cekani na prazdny stack
                                                 -- pro pocet prvku mensi nez pocet ctecich 
                                                 -- threadu blokujici ve smyslu prvku ktere se 
                                                 -- jiz zacali cist
    -- else
      count        : aliased t_rtl_native_signed -- inverzni pocitadlo prvku
                     for position use 16;        -- na stejnem offsxetu jako pocitadlo critisemu
    -- end if waitable
    end record;


----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop_now (
    stack          : in out ref t_rtl_sstack;
    data           : out t_rtl_pointer)
    return t_rtl_logical8;
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure rtl_sstack_new =
----------------------------------------------------------------------------------------------------
begin 
  stack:=nil;
  stack.waitable:=waitable;
  stack.freedata:=freedata;
  if waitable then
    rtl_critisem_new_owned(stack.critisem,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
    end if;
  stack.first:=nil;
  end rtl_sstack_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_discard =
----------------------------------------------------------------------------------------------------
begin 
  rtl_sstack_reset(stack);
  rtl_critisem_discard(stack.critisem);
  end rtl_sstack_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_reset =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sstack_reset;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_move =
----------------------------------------------------------------------------------------------------
begin
  end rtl_sstack_move; 



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_push =
-- vlozi prvek na stack
----------------------------------------------------------------------------------------------------
var
  newnode          : t_rtl_ref_local;
  temp             : t_rtl_ref_snapshot;

label
  restart;

begin 
  -- vytvorim novy nod
  rtl_ref_create_local(newnode,data,stack.freedata);

restart:
  rtl_ref_shared_to_snapshot(stack.first,temp);

  -- cosi
  if not rtl_ref_shared_to_local_shared(stack.first,newnode.node^.next,temp) then
    goto restart; 
    end if;

  -- zkusim nahradit stack.first svym novym nodem
  if not rtl_ref_local_to_shared(newnode,stack.first,temp) then
    goto restart; 
    end if;

  -- podarilo se uvolnim novy nod
  rtl_ref_discard_local(newnode);

  -- zvednu pocet prvku ve stacku a nebo povolim dalsimu threadu cteni
  if stack.waitable 
    then rtl_critisem_unlock(stack.critisem);
    else rtl_interlocked_dec(^stack.count)
    end if;
  end rtl_sstack_push;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop_now  =
----------------------------------------------------------------------------------------------------
var
  mynode           : t_rtl_ref_local;
  temp             : t_rtl_ref_snapshot;
  nexttemp         : t_rtl_ref_snapshot;

label
  restart;

begin
restart:
  rtl_ref_shared_to_snapshot(stack.first,temp);

  -- zkusim jestli neni stack prazdny
  if temp.node=nil then
    data:=nil;

    --uvolnim posledni zkopirovany pointer
    rtl_ref_discard_local(mynode);
    result:=false;
    return;
    end if;

  -- zkopiruju si pointer na prvni prvek
  if not rtl_ref_shared_to_local(stack.first,mynode,temp) then
    goto restart; 
    end if;

  -- zkusim jestli se mi podari prehodit stack.first na dalsi prvek
  rtl_ref_shared_to_snapshot(mynode.node^.next,nexttemp);
  if not rtl_ref_shared_to_shared(mynode.node^.next,stack.first,nexttemp,temp) then
    goto restart; 
    end if;

  -- podarilo se mi to, vezmu si data
  data:=mynode.node^.data;
  mynode.node^.data:=nil;

  -- uvolnim pointer na dalsi prvek
  if not rtl_ref_discard_shared(mynode.node^.next,nexttemp) then
    raise synchronization_error;
    end if;

  -- uvolnim tento prvek
  --rtl_ref_discard_local_shared(mynode);
  rtl_ref_discard_local(mynode);
  result:=true;
  end rtl_sstack_pop_now;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop =
----------------------------------------------------------------------------------------------------
begin
  if stack.waitable then
    result:=rtl_sstack_try_pop(stack,data,t_rtl_wait_infinite);
    if not result then
      raise synchronization_error;
      end if;
  else
    result:=rtl_sstack_pop_now(stack,data);
    end if;
  end rtl_sstack_pop;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_try_pop =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_timeout;

begin
  -- reknu ze si beru jeden prvek
  if stack.waitable then
    rtl_critisem_force_lock(stack.critisem);
  else
    rtl_interlocked_inc(^stack.count);
    end if;

  -- zkusim si ho opravdu vzit
  result:=rtl_sstack_pop_now(stack,data);

  -- pokud neumi cekani tak uz na nic necekam
  if not stack.waitable or milisec=t_rtl_wait_immediate or result then
    if not result then
      --uklidit po neuspesnem pokusu
      if stack.waitable then
        rtl_critisem_force_unlock(stack.critisem);
      else
        rtl_interlocked_dec(^stack.count);
        end if;
      end if;
    return;
    end if;

  -- pokud je potreba pocitat cas tak zjistim start
  timeout:=milisec;
  if milisec>0 then
    start:=GetTickCount();
    end if;

  -- nepodarilo se mi vzit si prvek na prvni pokus bez blokovani a zarovem mam cekat
  rtl_critisem_force_unlock(stack.critisem);
  loop
    -- pockam az nekdo signalizuje ze je tam alespon jeden prvek
    if not rtl_critisem_try_lock(stack.critisem,timeout) then
      -- timeout
      result:=false;
      return;
      end if;

    -- zkusim jestli mne nekdo nepredbehne
    result:=rtl_sstack_pop_now(stack,data);

    -- podarilo se sebrat prvek, koncim
    if result then return; end if;

    -- pokus se nezdaril vratim pocitadlo itemu
    rtl_critisem_force_unlock(stack.critisem);

    -- pokud je potreba pocitat cas tak zjistim kolik ubehlo
    if milisec>0 then
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_timeout(elapsed);
      if timeout<1 then
        -- timeout
        result:=false;
        return;
        end if;
      end if;
    end loop;
  end rtl_sstack_try_pop;



