----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop_now (
    stack          : in out ref t_rtl_sstack;
    data           : out t_rtl_pointer)
    return t_rtl_logical8;
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure rtl_sstack_new =
----------------------------------------------------------------------------------------------------
begin 
  stack:=nil;
  stack.waitable:=waitable;
  stack.freedata:=freedata;
  if waitable then
    rtl_critisem_new_owned(stack.critisem,t_rtl_native_signed:last-2,t_rtl_native_signed:last-2);
    end if;
  stack.first:=nil;
  end rtl_sstack_new;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_discard =
----------------------------------------------------------------------------------------------------
begin 
  rtl_sstack_reset(stack);
  rtl_critisem_discard(stack.critisem);
  end rtl_sstack_discard;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_reset =
----------------------------------------------------------------------------------------------------
var
  oldstack         : t_rtl_sstack;
  data             : t_rtl_pointer;

begin
  rtl_sstack_move(stack,oldstack);
  -- projizdim cely stack a zahazuju vsechno
  loop
    if rtl_sstack_pop_now(oldstack,data) then
      if stack.freedata<>nil then
        stack.freedata^(data);
        end if;
    else
      break;
      end if;
    end loop;
  end rtl_sstack_reset;


----------------------------------------------------------------------------------------------------
procedure rtl_sstack_move =
----------------------------------------------------------------------------------------------------
var
  oldstack         : t_rtl_sstack;

begin
  rtl_sstack_new(tostack,fromstack.waitable,fromstack.freedata);

  -- pocitadlo
  oldstack.critisem:=fromstack.critisem;
  fromstack.critisem:=tostack.critisem;
  tostack.critisem:=oldstack.critisem;

  -- hlavicku
  loop
    oldstack:=fromstack;
    rtl_interlocked_abaref_compare_exchange(^fromstack.first,
                                            tostack.first,
                                            oldstack.first,
                                            tostack.first);
    -- dokud se to nepodari
    if tostack.first=oldstack.first then
      break;
      end if;
    end loop;
  end rtl_sstack_move; 

----------------------------------------------------------------------------------------------------
procedure rtl_sstack_push =
-- vlozi prvek na stack
----------------------------------------------------------------------------------------------------
var
  newnode          : t_rtl_abaref_pointer;
  temp             : aliased t_rtl_abaref_pointer;
  success          : t_rtl_logical8;

label
  restart;

begin 
  -- vytvorim novy nod
  rtl_abaref_new(newnode);
  newnode.ptr^.data:=data;

restart:
  temp:=stack.first;

  -- zkopiruju si prvni nod jako svuj dalsi
  rtl_abaref_copy_pointer_source(newnode.ptr^.next,stack.first,^temp,stack.freedata,success);
  if not success then goto restart; end if;

  -- zkusim nahradit stack.first svym novym nodem
  rtl_abaref_copy_pointer_target(stack.first,^temp,newnode,nil,stack.freedata,success);
  if not success then goto restart; end if;

  -- podarilo se uvolnim novy nod
  rtl_abaref_discard(newnode,stack.freedata,success);

  -- zvednu pocet prvku ve stacku a nebo povolim dalsimu threadu cteni
  if stack.waitable 
    then rtl_critisem_unlock(stack.critisem);
    else rtl_interlocked_dec(^stack.count)
    end if;
  end rtl_sstack_push;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop_now  =
----------------------------------------------------------------------------------------------------
var
  mynode           : t_rtl_abaref_pointer;
  temp             : aliased t_rtl_abaref_pointer;
  success          : t_rtl_logical8;

label
  restart;

begin
restart:
  temp:=stack.first;

  -- zkusim jestli neni stack prazdny
  if temp.ptr=nil then
    data:=nil;

    --uvolnim posledni zkopirovany pointer
    rtl_abaref_discard(mynode,stack.freedata,success);
    result:=false;
    return;
    end if;

  -- zkopiruju si pointer na prvni prvek
  rtl_abaref_copy_pointer_source(mynode,stack.first,^temp,stack.freedata,success);
  if not success then goto restart; end if;

  -- zkusim jestli se mi podari prehodit stack.first na dalsi prvek
  rtl_abaref_copy_pointer_target(stack.first,^temp,mynode.ptr^.next,nil,stack.freedata,success);
  if not success then goto restart; end if;

  -- podarilo se mi to, vezmu si data
  data:=mynode.ptr^.data;

  -- uvolnim pointer na dalsi prvek
  rtl_abaref_discard(mynode.ptr^.next,stack.freedata,success);

  -- uvolnim tento prvek
  rtl_abaref_discard(mynode,stack.freedata,success);
  result:=true;
  end rtl_sstack_pop_now;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_pop =
----------------------------------------------------------------------------------------------------
begin
  if stack.waitable then
    result:=rtl_sstack_try_pop(stack,data,t_rtl_wait_infinite);
    if not result then
      raise synchronization_error;
      end if;
  else
    result:=rtl_sstack_pop_now(stack,data);
    end if;
  end rtl_sstack_pop;



----------------------------------------------------------------------------------------------------
procedure rtl_sstack_try_pop =
----------------------------------------------------------------------------------------------------
var
    start          : t_system_ticks;
    elapsed        : t_system_ticks;
    timeout        : t_rtl_native_signed;

begin
  -- reknu ze si beru jeden prvek
  if stack.waitable then
    rtl_critisem_force_lock(stack.critisem);
  else
    rtl_interlocked_inc(^stack.count);
    end if;

  -- zkusim si ho opravdu vzit
  result:=rtl_sstack_pop_now(stack,data);

  -- pokud neumi cekani tak uz na nic necekam
  if not stack.waitable or milisec=t_rtl_wait_immediate or result then
    if not result then
      --uklidit po neuspesnem pokusu
      if stack.waitable then
        rtl_critisem_force_unlock(stack.critisem);
      else
        rtl_interlocked_dec(^stack.count);
        end if;
      end if;
    return;
    end if;

  -- pokud je potreba pocitat cas tak zjistim start
  timeout:=milisec;
  if milisec>0 then
    start:=GetTickCount();
    end if;

  -- nepodarilo se mi vzit si prvek na prvni pokus bez blokovani a zarovem mam cekat
  rtl_critisem_force_unlock(stack.critisem);
  loop
    -- pockam az nekdo signalizuje ze je tam alespon jeden prvek
    if not rtl_critisem_try_lock(stack.critisem,timeout) then
      -- timeout
      result:=false;
      return;
      end if;

    -- zkusim jestli mne nekdo nepredbehne
    result:=rtl_sstack_pop_now(stack,data);

    -- podarilo se sebrat prvek, koncim
    if result then return; end if;

    -- pokus se nezdaril vratim pocitadlo itemu
    rtl_critisem_force_unlock(stack.critisem);

    -- pokud je potreba pocitat cas tak zjistim kolik ubehlo
    if milisec>0 then
      elapsed:=GetTickCount()-start;
      timeout - t_rtl_native_signed(elapsed);
      if timeout<1 then
        -- timeout
        result:=false;
        return;
        end if;
      end if;
    end loop;
  end rtl_sstack_try_pop;



