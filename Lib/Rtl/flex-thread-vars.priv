---------------------------------------------------------------------------------------------------
module private vars =
-- Flex Run-time Library
-- Thread variables
-- Copyright (C) 1999-2003 A && L soft
----------------------------------------------------------------------------------------------------
with
    synchronization;

type
  --%%TODO copy of unchecked array 
  -- fuj
  t_rtl_unsigned8array_not_unchecked = array 0..1023 of t_rtl_unsigned8;
  p_rtl_unsigned8array_not_unchecked = ^t_rtl_unsigned8array_not_unchecked;
  -- /fuj

type
    t_tv_type;
    p_tv_type = ^ t_tv_type;

    t_tv_type = record
      threadvarid  : t_threadvar_id;
      inheritable  : t_rtl_logical8;
      immediate    : t_rtl_logical8;
      next         : p_tv_type;
      size         : t_rtl_native_unsigned;
      tv_entry     : p_rtl_threadvar_entry;
      tv_adjust    : p_rtl_threadvar_adjust;
      tv_exit      : p_rtl_threadvar_exit;
      end record;


var 
  maxtvid          : t_rtl_native_unsigned;
  var_lock         : t_rtl_mutex;
  hash_tv_type     : array 0..tv_hash_size-1 of p_tv_type;


----------------------------------------------------------------------------------------------------
procedure rtl_alloc_threadvarid =
----------------------------------------------------------------------------------------------------
var
  tv_type          : p_tv_type;
  h                : t_rtl_native_unsigned;

begin
  --alokace
  new tv_type;     --%%TODO chain memory
  tv_type^:=nil;

  --zamek
  rtl_mutex_lock(var_lock);
  threadvarid:=maxtvid;
  tv_type^.threadvarid:=threadvarid;
  tv_type^.tv_entry:=tv_entry;
  tv_type^.tv_adjust:=tv_adjust;
  tv_type^.tv_exit:=tv_exit;
  tv_type^.inheritable:=inheritable;
  tv_type^.immediate:=immediate;
  tv_type^.size:=size;
  h:=threadvarid mod tv_hash_size;
  
  --zvednu pocitadlo
  maxtvid + 1;

  --zaradim do hashe
  tv_type^.next:=hash_tv_type[h];
  hash_tv_type[h]:=tv_type;

  --pokud je immediate tak udelam instanci do vsech threadu
  if immediate then
    os.rtl_initialize_threads_immediate_threadvar(threadvarid);
    end if;

  --zamek
  rtl_mutex_unlock(var_lock);
  end rtl_alloc_threadvarid;

----------------------------------------------------------------------------------------------------
procedure rtl_free_threadvarid =
----------------------------------------------------------------------------------------------------
var
  tv_type          : p_tv_type;
  tv_typeprev      : p_tv_type;
  h                : t_rtl_native_unsigned;

begin
  h:=threadvarid mod tv_hash_size;

  --zamek
  rtl_mutex_lock(var_lock);

  tv_type:=hash_tv_type[h];
  tv_typeprev:=nil;
  while (tv_type<>nil) loop
    if tv_type^.threadvarid=threadvarid then
      break;
      end if;
    tv_typeprev:=tv_type;
    tv_type:=tv_type^.next;
    end loop;

  -- jestli neexistuje typ tak je to problem
  if tv_type=nil then
    raise tasking_threadvar_error;
    end if;

  --zrusit vsechny instance
  os.rtl_deinitialize_threads_threadvar(threadvarid);
  
  if tv_type=hash_tv_type[h] then
    hash_tv_type[h]:=tv_type^.next;
  else
    tv_typeprev^.next:=tv_type^.next;
    end if;
 
  --zamek
  rtl_mutex_unlock(var_lock);

  --pamet
  discard tv_type;

  threadvarid:=$FFFFFFFF;
  end rtl_free_threadvarid;


----------------------------------------------------------------------------------------------------
procedure rtl_create_threadvar =
----------------------------------------------------------------------------------------------------
var
  tv_var           : p_tv_var;
  tv_type          : p_tv_type;
  h                : t_rtl_native_unsigned;
  origdata         : t_rtl_pointer;
  inherit          : t_rtl_logical8;
begin
  --vyhledam jestli existuje tento typ
  --zamek
  rtl_mutex_lock(var_lock);

  h:=threadvarid mod tv_hash_size;
  tv_type:=hash_tv_type[h];
  while (tv_type<>nil) loop
    if tv_type^.threadvarid=threadvarid then
      break;
      end if;
    tv_type:=tv_type^.next;
    end loop;

  --zamek
  rtl_mutex_unlock(var_lock);

  -- jestli neexistuje typ tak je to problem
  if tv_type=nil then
    raise tasking_threadvar_error;
    end if;
  
  
  new tv_var;    --%%TODO chain memory ?
  new tv_var^.data range tv_type^.size;

  -- zaregistrovat
  tv_var^.next_var:=threadhead^.variables.hash_tv_var[h];
  threadhead^.variables.hash_tv_var[h]:=tv_var;

  result:=tv_var^.data;
  inherit:=false;
  if (origthreadhead<>nil) then
    origdata:=rtl_get_threadvar_other(threadvarid,origthreadhead);
    end if;
  if (inherit) then
    -- volam entry ?? myslim ze ne
    --if tv_type^.tv_entry<>nil then
    --  tv_type^.tv_entry^(tv_var^.data,tv_type^.threadvarid,threadhead);
    --  end if;

    if origdata<>nil then 
      if tv_type^.tv_adjust<>nil then
        tv_type^.tv_adjust^(tv_var^.data,origdata,tv_type^.threadvarid,threadhead,origthreadhead);
      else
        --%%TODO copy of unchecked array 
        -- fuj
        for i in 0..(tv_type^.size-1) loop
          p_rtl_unsigned8array_not_unchecked(tv_var^.data)^[i]:=p_rtl_unsigned8array_not_unchecked(origdata)^[i];
          end loop;
        --t_rtl_native_unsigned(tv_var^.data^):=t_rtl_native_unsigned(origdata^);
        end if;
      end if;

  else
    tv_var^.inheritable=tv_type^.inheritable;
  
    -- volam entry
    if tv_type^.tv_entry<>nil then
      tv_type^.tv_entry^(tv_var^.data,tv_type^.threadvarid,threadhead);
      end if;
    end if;

  end rtl_create_threadvar;

----------------------------------------------------------------------------------------------------
procedure rtl_get_threadvar =
----------------------------------------------------------------------------------------------------
var
  threadhead       : p_thread_header;
  h                : t_rtl_native_unsigned;
  tv_var           : p_tv_var;
begin
  threadhead:=rtl_get_current_thread;
  -- zkusim najit jestli existuje hodnota pro tento threadvarid v tomto threadu
  h:=threadvarid mod tv_hash_size;
  tv_var:=threadhead^.variables.hash_tv_var[h];
  while(tv_var<>nil) loop
    if tv_var^.threadvarid=threadvarid then
      break;
      end if;
    tv_var:=tv_var^.next_var;
    end loop;

  if tv_var=nil then
    result:=rtl_create_threadvar(threadvarid,threadhead,nil);
  else
    result:=tv_var^.data;
    end if;
  end rtl_get_threadvar;

----------------------------------------------------------------------------------------------------
procedure rtl_get_threadvar_other =
----------------------------------------------------------------------------------------------------
var
  h                : t_rtl_native_unsigned;
  tv_var           : p_tv_var;

begin
  -- zkusim najit jestli existuje hodnota pro tento threadvarid v tomto threadu
  h:=threadvarid mod tv_hash_size;
  tv_var:=threadhead^.variables.hash_tv_var[h];
  while(tv_var<>nil) loop
    if tv_var^.threadvarid=threadvarid then
      break;
      end if;
    tv_var:=tv_var^.next_var;
    end loop;

  if tv_var=nil then
    result:=nil;
  else
    result:=tv_var^.data;
    end if;
  end rtl_get_threadvar_other;


----------------------------------------------------------------------------------------------------
procedure rtl_free_threadvar =
----------------------------------------------------------------------------------------------------
var
  tv_type          : p_tv_type;
  tv_var           : p_tv_var;
  tv_var_prev      : p_tv_var;
  h                : t_rtl_native_unsigned;
  threadhead       : p_thread_header;

begin
  if currthreadhead=nil then
    threadhead:=rtl_get_current_thread;
  else
    threadhead:=currthreadhead;
    end if;

  -- najdu
  h:=threadvarid mod tv_hash_size;
  tv_var_prev:=nil;
  tv_var:=threadhead^.variables.hash_tv_var[h];
  while(tv_var<>nil) loop
    if tv_var^.threadvarid=threadvarid then
      break;
      end if;
    tv_var_prev:=tv_var;
    tv_var:=tv_var^.next_var;
    end loop;

  --jestli tu neni tak je hotovo
  if tv_var=nil then
    return;
    end if;


  --najdu typ
  --zamek
  rtl_mutex_lock(var_lock);

  h:=threadvarid mod tv_hash_size;
  tv_type:=hash_tv_type[h];
  while (tv_type<>nil) loop
    if tv_type^.threadvarid=threadvarid then
      break;
      end if;
    tv_type:=tv_type^.next;
    end loop;

  --zamek
  rtl_mutex_unlock(var_lock);

  -- jestli neexistuje typ tak je to problem
  if tv_type=nil then
    raise tasking_threadvar_error;
    end if;
  
  -- vyradim
  if tv_var=threadhead^.variables.hash_tv_var[h] then
    threadhead^.variables.hash_tv_var[h]:=tv_var^.next_var;
  else
    tv_var_prev^.next_var:=tv_var^.next_var;
    end if;

  -- volam exit
  if tv_type^.tv_exit<>nil then
    tv_type^.tv_exit^(tv_var^.data,threadvarid,threadhead);
    end if;

  --pamet
  discard tv_var^.data;
  discard tv_var;
  
  end rtl_free_threadvar;

----------------------------------------------------------------------------------------------------
procedure rtl_set_threadvar_inheritance =
----------------------------------------------------------------------------------------------------
var
  tv_var           : p_tv_var;
  h                : t_rtl_native_unsigned;
  threadhead       : p_thread_header;

begin
  threadhead:=rtl_get_current_thread;

  -- zkusim najit jestli existuje hodnota pro tento threadvarid v tomto threadu
  h:=threadvarid mod tv_hash_size;
  tv_var:=threadhead^.variables.hash_tv_var[h];
  while(tv_var<>nil) loop
    if tv_var^.threadvarid=threadvarid then
      break;
      end if;
    tv_var:=tv_var^.next_var;
    end loop;

  if tv_var=nil then
    raise tasking_threadvar_error;
    end if;

  tv_var^.inheritable:=inheritable;
  end rtl_set_threadvar_inheritance;

----------------------------------------------------------------------------------------------------
procedure rtl_initialize_all_threadvars =
----------------------------------------------------------------------------------------------------
var
  tv_type          : p_tv_type;

begin
  --zamek
  rtl_mutex_lock(var_lock);

  for h in 0 .. tv_hash_size-1 loop
    tv_type:=hash_tv_type[h];
    while (tv_type<>nil) loop
      if tv_type^.immediate or tv_type^.inheritable then
        if rtl_create_threadvar(tv_type^.threadvarid,threadhead,origthreadhead)=nil then
          raise tasking_threadvar_error;
          end if;
        end if;
      tv_type:=tv_type^.next;
      end loop;
    end loop;

  --zamek
  rtl_mutex_unlock(var_lock);
  
  end rtl_initialize_all_threadvars;


----------------------------------------------------------------------------------------------------
procedure rtl_discard_all_threadvars =
----------------------------------------------------------------------------------------------------
begin
  --%%TODO
  end rtl_discard_all_threadvars;


----------------------------------------------------------------------------------------------------
#separate private os;
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
entry =
----------------------------------------------------------------------------------------------------
begin
  maxtvid:=0;
  rtl_mutex_new(var_lock);
  hash_tv_type:=nil;
  end entry;

----------------------------------------------------------------------------------------------------
exit =
----------------------------------------------------------------------------------------------------
begin
  rtl_mutex_discard(var_lock);
  end exit;

end vars;