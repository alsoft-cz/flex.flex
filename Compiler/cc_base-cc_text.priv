----------------------------------------------------------------------------------------------------
module private cc_text =
-- P©eklada‡ Flexu.
-- €ten¡ zdroj ku.
----------------------------------------------------------------------------------------------------
-- Ondra : 25.04.2000 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_profile;
#end if;
  standard.console,
  standard.conversions,
  standard.files,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_lex;

---- %%TECH Upozornˆn¡ na nestandardn¡ optimalizace ------------------------------------------------
-- Pozor: Tento k¢d obsahuje vzl ¨Ÿ slizk‚ c‚‡ka©sk‚ optimalizace na rychlost, proto‘e [getchar]
-- a spol. je kritick  rutina cel‚ho p©eklada‡e. V¨e je na direktivu [fast_getchar]. Vypnut¡m se
-- aktivuje ‡istˆ naprogramovan  verze, kter  nen¡ tak v˜konn .
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
class private c_source_text = 
-- Reprezentace textov‚ho souboru. 
-- Poskytuje z kladn¡ primitiva pro ‡ten¡ textu po znac¡ch.
----------------------------------------------------------------------------------------------------

    var
      num          : lexfilenum;                 -- ‡¡slo souboru
    
      -- unget buffer na znaky (ji‘ konvertovan‚ na intern¡ reprezentaci LEXCHAR)
      znpos        : t_unsigned;                 -- kursor do unget bufferu
    #if #declared fast_getchar; #and then; fast_getchar then;
      znbuf_line   : lexline;                    -- ‡¡slo aktu ln¡ho © dku
    #else;
      znbuf        : array 0..maxungetchar-1 of aliased lexinputunget; -- znakov˜ buffer
    #end if;
    
      -- vstupn¡ buffer
      buf          : pinputchararray;            -- buffer pro ‡ten¡ ze souboru
      bufsize      : t_unsigned;                 -- velikost bufferu %%TODO(STRING) BUFSIZE nahradit atributem BUF^:LENGTH
    #if #declared fast_getchar; #and then; fast_getchar then;
      bufptr       : ^tinputchar;                -- urychlov tko: na hrub˜ pytel c‚‡kov  z plata
      buflinebegin : ^tinputchar;                -- urychlov tko: na hrub˜ pytel c‚‡kov  z plata
      bufend       : ^tinputchar;                -- urychlov tko: na hrub˜ pytel c‚‡kov  z plata
    #else;
      bufpos       : t_unsigned;                 -- pozice aktu ln¡ho znaku v bufferu
    #end if;

    ------------------------------------------------------------------------------------------------
    static init =
    -- Otev©e soubor a p©iprav¡ ho pro ‡ten¡.
    ------------------------------------------------------------------------------------------------
    begin
      -- otev©¡t soubor
      f.init_text_name(name);
      if cfg_sharing
        then f.open(t_fs_object_mode_set:[tfm_read],tfa_sequential,tfss_shared_read,false);
        else f.open(t_fs_object_mode_set:[tfm_read],tfa_sequential,tfss_not_shared,false);
        end if;
      if f.res<>tfe_ok then
        ce^.seterror({CCERR=}000061,ce_f_open);
        ce^.setparam(name);
        ce^.raiseerror;
        end if;

      -- alokovat buffer
      -- %%TECH Trik: alokujeme o byte v¡ce, kter˜ nech me nulov˜. Zajist¡ se tak, ‘e posledn¡
      -- p©e‡ten˜ znak bude v‘dy nula a ve spojen¡ s [is_eof] se spr vnˆ detekuje konec souboru.
      -- U¨et©¡ se tak jeden IF v [getchar], co‘ je dost d–le‘it‚, proto‘e je to v˜konovˆ
      -- kritick  procedura.
      bufsize:=f.get_size+1;
      new buf range bufsize;
    #if #declared fast_getchar; #and then; fast_getchar then;
      bufptr:=^(buf^[0]);
      bufend:=^(buf^[bufsize]);
    #end if;

      -- doplnit dal¨¡ £daje
      this.include:=include;

      -- prvn¡ © dek m  ‡¡slo 1 (‡¡slo sloupce na 1 se nastav¡ p©e‡ten¡m prvn¡ho znaku)
    #if #declared fast_getchar; #and then; fast_getchar then;
      znbuf_line:=1;
      buflinebegin:=bufptr;
    #else;
      znbuf[0].line:=1;
    #end if;

      -- zaregistrovat jm‚no otev©en‚ho souboru a poznamenat si jeho p©idˆlen‚ identifika‡n¡ ‡¡slo
      used_files^.add_file_name(name,num);

      -- na‡¡st ve¨ker  data ze souboru
      -- %%TECH Pozor, ze souboru se mus¡ ‡¡st o byte m‚nˆ, ne‘ m me velk˜ buffer. Viz popis
      -- triku s nulou na konci v˜¨e.
      f.read(0,buf^,bufsize-1);
    #if not #declared fast_getchar; #or else; not fast_getchar then;
      bufpos:=0;
    #end if;

      -- povedlo se ?
      if f.res<>tfe_ok then
        ce^.seterror({CCERR=}000000,ce_f_read);
        ce^.setparam(name);
        ce^.raiseerror;
        end if;
      end init;



    ------------------------------------------------------------------------------------------------
    static getchar =
    -- P©e‡te znak ze vstupu. Na konci vstupu vr t¡ \0, p©¡padn‚ znaky \0 v souboru nijak 
    -- neo¨et©uje, tak‘e se u‘ivatel mus¡ je¨tˆ ujistit vol n¡m [is_eof].
    -- Po p©e‡ten¡ nov‚ho znaku ze vstupu inkrementuje po‡¡tadlo sloupc–. Nijak neo¨et©uje konce
    -- © dk–. Aktualizace po‡¡tadla © dk– je ponech na na u‘ivateli.
    ------------------------------------------------------------------------------------------------
  #if #declared fast_getchar; #and then; fast_getchar then;
    var
      backbuf      : bufptr:type;
  #else;
    label
      output;
  #end if;

    begin
    #if #declared profiler_lex; #and then; profiler_lex then;
      rdtsc_start;
      succ _getchar;
    #end if;

    #if #declared fast_getchar; #and then; fast_getchar then;
      -- jak jsme na tom se stavem unget bufferu ?
      if znpos>0 then
        case znpos
          when 1 do t_unsigned32(backbuf:unchecked):=t_unsigned32(bufptr:unchecked)-tinputchar:size;
          when 2 do t_unsigned32(backbuf:unchecked):=t_unsigned32(bufptr:unchecked)-2*tinputchar:size;
          end case;
        c:=lexchar(backbuf^);
        pred znpos;
        return;
        end if;

      -- na‡¡st znak z bufferu a zkonvertovat do intern¡ reprezentace
      c:=lexchar(bufptr^);

      -- p©ipravit pointer na dal¨¡ znak
      t_unsigned32(bufptr:unchecked)+tinputchar:size;
    #else;
      -- pokud nen¡ v unget bufferu ‘ dn˜ znak, p©e‡¡st jeden ze vstupu
      if znpos=0 then
        -- posledn¡ znak ulo‘it coby p©edposledn¡
        znbuf[1]:=znbuf[0];

        -- %%TECH Nemus¡me se starat o to, jestli nejsme na konci bufferu, proto‘e p©i po‡ te‡n¡m
        -- naplnˆn¡ bufferu se na konec doplnil znak \0 a ve spojen¡ s [is_eof] se tak korektnˆ 
        -- signalizuje konec souboru.

        -- na‡¡st znak z bufferu a zkonvertovat do intern¡ reprezentace
        znbuf[0].zn:=lexchar(buf^[bufpos]);
        succ bufpos;

        -- posunout ‡¡ta‡ sloupce
        succ znbuf[0].col;

        -- v bufferu je ted prave jeden znak
        znpos:=1;
        end if;

      -- nyn¡ je aspo¤ jeden znak v bufferu => p©edat ho ven
      pred znpos;
      c:=znbuf[znpos].zn;
    #end if;

    #if #declared profiler_lex; #and then; profiler_lex then;
      rdtsc_stop(_getchar_t);
    #end if;
      end getchar;



    ------------------------------------------------------------------------------------------------
    static ungetchar =
    -- Vr t¡ naposledy p©e‡ten˜ znak do vstupu.
    ------------------------------------------------------------------------------------------------
    begin
    #if #declared profiler_lex; #and then; profiler_lex then;
      rdtsc_start;
      succ _ungetchar;
    #end if;

      succ znpos;

    #if #declared profiler_lex; #and then; profiler_lex then;
      rdtsc_stop(_ungetchar_t);
    #end if;
      end ungetchar;



    ------------------------------------------------------------------------------------------------
    static next_line =
    -- Posune po‡¡tadlo © dk– o jedni‡ku a zresetuje po‡¡tadlo sloupc–.
    ------------------------------------------------------------------------------------------------
    begin
      -- posunout ‡¡ta‡ © dk–
    #if #declared fast_getchar; #and then; fast_getchar then;
      succ znbuf_line;
      buflinebegin:=bufptr;
    #else;
      succ znbuf[znpos].line;
      znbuf[znpos].col:=0;
    #end if;

      -- p©ibyl jeden zpracovan˜ © dek
      succ total_lines;

      -- postarat se t‚‘ o ‡¡ta‡ efektivn¡ch (nepr zdn˜ch, nekoment ©ov˜ch) © dk–
      effective_lines+effective:ord;
      effective:=false;
      end next_line;



    ------------------------------------------------------------------------------------------------
    static check_meta_statements =
    -- Zkontroluje, zda jsou uzav©eny v¨echny blokov‚ metap©¡kazy.
    ------------------------------------------------------------------------------------------------
    begin
      if metastack:length>0 then
        for i in metastack:range loop
          ce^.seterror({CCERR=}000083,ce_meta_no_end);
          ce^.setpos(metastack[i].pos);
          end loop;
        metastack:=nil;
        end if;
      end check_meta_statements;



    ------------------------------------------------------------------------------------------------
    static is_eof =
    -- True, jestli‘e ji‘ byl p©e‡ten cel˜ soubor.
    ------------------------------------------------------------------------------------------------
    begin
    #if #declared fast_getchar; #and then; fast_getchar then;
      result:=znpos=0 and t_unsigned32(bufptr:unchecked)=t_unsigned32(bufend:unchecked){bufpos=buflen};
    #else;
      result:=znpos=0 and bufpos=bufsize;
    #end if;
      end is_eof;



    ------------------------------------------------------------------------------------------------
    static get_lines =
    -- Dosud zpracovan˜ po‡et © dk– souboru.
    ------------------------------------------------------------------------------------------------
    begin
    #if #declared fast_getchar; #and then; fast_getchar then;
      result:=znbuf_line;
    #else;
      result:=znbuf[0].line;
    #end if;
      end get_lines;



    ------------------------------------------------------------------------------------------------
    static get_position =
    -- Zjist¡ aktu ln¡ pozici ve zdroj ku.
    ------------------------------------------------------------------------------------------------
    begin
    #if #declared fast_getchar; #and then; fast_getchar then;
      pos.line:=znbuf_line;
      pos.col:=t_unsigned32(bufptr:unchecked)-t_unsigned32(buflinebegin:unchecked){+1}-znpos;
    #else;
      pos.line:=znbuf[0].line;
      pos.col:=znbuf[0].col;
    #end if;
      pos.num:=num;
      end get_position;



    ------------------------------------------------------------------------------------------------
    static get_length =
    -- Podle zapamatovan‚ pozice dopo‡¡t  d‚lku lexik ln¡ho elementu.
    ------------------------------------------------------------------------------------------------
    begin
    #if #declared fast_getchar; #and then; fast_getchar then;
      if pos.line=znbuf_line then
        pos.len:=t_unsigned32(bufptr:unchecked)-t_unsigned32(buflinebegin:unchecked){+1}-znpos-pos.col+1;
        end if;
    #else;
      if pos.line=znbuf[0].line then
        pos.len:=znbuf[0].col-pos.col+1;
        end if;
    #end if;
      end get_length;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalizace.
    ------------------------------------------------------------------------------------------------
    begin
      -- soubor zase zav©¡t
      f.close;

      -- uvolnit buffer
      discard buf;
      end exit;

    end c_source_text;



----------------------------------------------------------------------------------------------------
procedure text_open =
-- Otev©e nov˜ soubor zadan‚ho jm‚na a um¡st¡ ho na vrchol z sobn¡ku otev©en˜ch soubor–.
----------------------------------------------------------------------------------------------------
#if #environment compiler_version;='4.0.3.6' then;
with
#else;
use
#end if;
  supervised c_source_text;

var
  text             : p_source_text;
  s                : t_char32str;

begin
  -- poznamenat do listingu
  s:='Compiling ' & name; -- %%TODO(RTATTRIB:LAST)
  listing^.write_line(s);
  listing^.start_indent;

  -- alokovat pamˆŸ
  new text;

  -- inicializovat
  text^.init(name,include);

  -- za©adit na stack
  text^.next:=lex_input;
  lex_input:=text;

  -- zalo‘it implicitn¡ lexik ln¡ analyz tor
  lex_set_default_lexer;

rollback
  -- p©i chybˆ poslat do h je
  discard text;
  end text_open;



----------------------------------------------------------------------------------------------------
procedure text_close =
-- Zav©e soubor na vrcholu z sobn¡ku otev©en˜ch soubor– a p©ejde k nad©azen‚mu.
-- P©ed zav©en¡m zkontroluje ukon‡en¡ v¨ech blokov˜ch metap©¡kaz– v aktu ln¡m souboru.
----------------------------------------------------------------------------------------------------
#if #environment compiler_version;='4.0.3.6' then;
with
#else;
use
#end if;
  supervised c_source_text;

var
  text             : p_source_text;

begin
  -- konec odsazen¡ v listingu
  listing^.end_indent;

  -- je ukon‡en podm¡nˆn˜ p©eklad ?
  lex_input^.check_meta_statements;

  -- zru¨it lexik ln¡ analyz tor
  lex_pop_default_lexer;

  -- vyjmout ze stacku vrchn¡ soubor
  text:=lex_input;
  lex_input:=text^.next;

  begin
    -- ozn mit dokon‡en¡ p©ekladu tohoto souboru
    if cfg_verbosity>=vl_default then
      output^.write('Compiled ');
      declare var
        text_name    : p_text_name;                -- plain-text jm‚no souboru
      begin
        text^.f.name.compose_name(text_name);
        output^.write(text_name^);
      leave
        discard text_name;
        end declare;
      output^.write(' (');
      output^.write(unsigned_to_string(text^.get_lines));
      output^.write('/');
      output^.write(unsigned_to_string(total_lines));
      output^.write_line(')');
      end if;

  leave
    -- uvolnit soubor
    discard text;
    end;
  end text_close;



end cc_text;
