----------------------------------------------------------------------------------------------------
class private cp_osspecific =
-- Překladač Flexu.
-- Vlastnosti specifické pro konkrétní operační systém.
----------------------------------------------------------------------------------------------------
-- Ondra : 13.01.2003 : Vytvořil.
----------------------------------------------------------------------------------------------------

with
  cc_var,cc_codes;

----------------------------------------------------------------------------------------------------
override importproc =
-- Import procedury z externí knihovny.
----------------------------------------------------------------------------------------------------
var
  info             : pimportinfo;                -- informace pro import

begin
  --%%X umím importovat jen procedury, ne metody
  if proc^.etype<>et_procedure then
    ce^.seterror({CCERR=}000388,ce_cantimport);
    {%%POS}
    ce^.raiseerror;
    end if;

  -- alokovat paměť
  new info;

  -- doplnit údaje
  for i in 1..extname:length loop info^.extname & t_char8(extname[i]) end loop;
  for i in 1..libname:length loop info^.libname & t_char8(libname[i]) end loop;

  -- poznamenat do procedury
  proc^.import_info:=info;
  end importproc;



----------------------------------------------------------------------------------------------------
override setconvention =
-- Nastaví volací konvenci procedury.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_sym,
  {%%TODO(?) Tahle závistost se mi nelíbí}cp_cpu,cp_cpu.cp_ia32,cp_cpu.cp_ia32.ci_abi;

var
  call             : icallconvention;  -- volací konvence

begin
  
  verify({VERIFY=}000939,proc=nil);

  -- podprogram?
  if proc^.etype in ets_subprogram then
    -- nemá již přiřazenu volací konvenci ?
    if i_get_convention_subprogram^(pentity_subprogram(proc)^)<>icc_default or
       i_get_convention_proctype^(pentity_subprogram(proc)^.typ.getctype^)<>icc_default then

      ce^.seterror({CCERR=}000389,ce_conventionset);
      ce^.setparam(sym_get_qid(proc));
      {%%POS}
      ce^.raiseerror;
      end if;

    -- určit volací konvenci
    i_id_to_convention(id,call);
    if call=icc_default then
      ce^.seterror({CCERR=}000390,ce_i_convention);
      ce^.setparam(entityident_to_string(id));
      {%%POS}
      ce^.raiseerror;
      end if;

    -- přiřadit konvenci
    i_set_convention_subprogram^(pentity_subprogram(proc)^,call);
  
  -- proceduralni typ?
  elsif proc^.etype=et_type and then pentity_type(proc)^.stype=dt_procedure then
    -- nemá již přiřazenu volací konvenci ?
    if i_get_convention_proctype^(pentity_type(proc)^)<>icc_default then
      ce^.seterror({CCERR=}000554,ce_conventionset);
      ce^.setparam(sym_get_qid(proc));
      {%%POS}
      ce^.raiseerror;
      end if;

    -- určit volací konvenci
    i_id_to_convention(id,call);
    if call=icc_default then
      ce^.seterror({CCERR=}000556,ce_i_convention);
      ce^.setparam(entityident_to_string(id));
      {%%POS}
      ce^.raiseerror;
      end if;

    -- přiřadit konvenci
    i_set_convention_proctype^(pentity_type(proc)^,call);

  else
    -- jen proceduralni typy a podprogramy
    verify({VERIFY=}000910, true);
    end if;

  end setconvention;



----------------------------------------------------------------------------------------------------
override setlibrary =
-- Nastaví typ knihovny pro modul
----------------------------------------------------------------------------------------------------
var
  lib              : tlibrarytype;
  res              : t_logical;

begin
  -- chybny parametr?
  verify({VERIFY=}000658,modl=nil);   
  
  -- ma modul jiz definovanou informaci pro knihovnu?
  if modl^.lib_info<>nil then
    ce^.seterror({CCERR=}000391,ce_libtyped);
    ce^.loadpos;
    ce^.resumeerror;
    return;
    end if;

  lib:=tlt_system;
  res:=id_to_librarytype(id,lib);

  -- je platny identifikator id?
  if not res then
    ce^.seterror({CCERR=}000392,ce_libtypeunknown);
    ce^.setparam(entityident_to_string(id));
    ce^.loadpos;
    ce^.resumeerror;
    return;
    end if;

  new plibraryinfo(modl^.lib_info);

  -- vytvoren?
  verify({VERIFY=}000659,modl^.lib_info=nil);   

  plibraryinfo(modl^.lib_info)^.lib_type:=lib;
  end setlibrary;



----------------------------------------------------------------------------------------------------
override exportproc =
-- Export procedury do externí knihovny.
----------------------------------------------------------------------------------------------------
with 
  cc_base,
  cc_base.cc_sym;

begin
  -- chybny parametr?
  verify({VERIFY=}000660,proc=nil);

  -- ma procedura jiz definovanou informaci pro export?
  if proc^.export_info<>nil then
    ce^.seterror({CCERR=}000393,ce_exported);
    ce^.setparam(sym_get_qid(proc));
    ce^.loadpos;
    ce^.resumeerror;
    return;
    end if;

  new pexportinfo(proc^.export_info);
  
  pexportinfo(proc^.export_info)^.export_name:=expname;
  end exportproc;



----------------------------------------------------------------------------------------------------
override exportvar =
-- Export procedury do externí knihovny.
----------------------------------------------------------------------------------------------------
with 
  cc_base,
  cc_base.cc_sym;

begin
  -- chybny parametr?
  verify({VERIFY=}000903,variable=nil);

  -- ma procedura jiz definovanou informaci pro export?
  if variable^.export_info<>nil then
    ce^.seterror({CCERR=}000553,ce_exported);
    ce^.setparam(sym_get_qid(variable));
    ce^.loadpos;
    ce^.resumeerror;
    return;
    end if;

  -- %%TODO(HYNEK) - dodeat export taskovych promennych
  -- pouze taskove a staticke promenne
  if variable^.mclass<>mc_static {and variable^.mclass<>mc_task}then
    ce^.seterror({CCERR=}000555,ce_export_var_restrict);
    ce^.setparam(sym_get_qid(variable));
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  new pexportinfo(variable^.export_info);
  
  pexportinfo(variable^.export_info)^.export_name:=expname;
  end exportvar;



----------------------------------------------------------------------------------------------------
override genlibentry =
-- Vygeneruje entry proceduru pro knihovnu [modl], entry procedura se prida do [context]
----------------------------------------------------------------------------------------------------
begin
  -- %%TODO(HYNEK) - presunout sem generovani z generatoru
  end genlibentry;



----------------------------------------------------------------------------------------------------
override getimagebase =
-- Vrati bazovou adresu vysledneho image
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_options;

begin
  -- %%TODO(ANCESTOR) -- ziskar imagebase z implementace predka
  -- pokud adresa nastavena, jednoduse ji vrat...
  if o_get_option_param_unsigned_by_entity(opt_image_base,compi,result) then
    return;
    end if;

  -- ... jinak vrat defaultni hodnoty
  if compi.compitype=ct_program then
    result:=$400000;
  elsif compi.compitype=ct_library then
    result:=$10000000;
  else
    -- neznamy typ kompilacni jednotky
    verify({VERIFY=}000669,true);
    end if;
  end getimagebase;



----------------------------------------------------------------------------------------------------
override getstackreserve =
-- Vrati velikost alokovaneho mista na stacku kompilacni jednotky
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_options;

var
  size    : t_unsigned;

begin
  result:=0;
  if o_get_option_param_unsigned_by_entity(opt_stack_reserve,compi,size) then
    result:=size;
    end if;
  end getstackreserve;

end cp_osspecific;
