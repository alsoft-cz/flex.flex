----------------------------------------------------------------------------------------------------
module private ca_type =
-- Překladač Flexu.
-- Generování podprogramů pro inicializaci a finalizaci typů.
----------------------------------------------------------------------------------------------------
-- Ondra : 18.06.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_var,
  cc_base,
  cc_base.cc_sym,
  cc_base.cc_type,
  cc_attr,
  cd_decl,
  cd_decl.cd_create,
  cd_decl.cd_util,
  cb_block,
  cb_block.cb_make,
  cx_expr,
  cx_expr,cx_expr.cx_make,
  ca_util;

----------------------------------------------------------------------------------------------------
procedure a_make_subprogram (
    typ            : in out tentity_type;        -- analyzovaný symbol
    ptype          : in tentitytype;             -- typ symbolu
    id_proc        : in pentityident;            -- identifikátor procedury
    id_param       : in pentityident;            -- identifikátor parametru
    range_call     : in t_logical;               -- procedura volána na určený rozsah
    pproc          : out pentity_subprogram;     -- vytvořená procedura
    pproc_context  : out tcontext) =             -- kontext vytvořené procedury
-- Vytvoří proceduru s jedním in out parametrem zadaného typu a pripadne dvema paramtery udávajici
-- rozsah.
----------------------------------------------------------------------------------------------------
var
  pproctyp         : pentity_type;               -- typ procedury
  pproctyp_context : tcontext;                   -- kontext typu procedury
  pparam           : pentity_param;              -- parametr procedury
  pparam_context   : tcontext;                   -- kontext parametru procedury

    ------------------------------------------------------------------------------------------------
    procedure add_param (
        param_id   : in pentityident;            -- identifikátor parametru
        mode       : in parammode;               -- mód parametru
        pass       : in parampass;               -- způsob předání parametru
        typ        : in pentity_type) =          -- typ
    -- Prida parametr danych attributu.
    ------------------------------------------------------------------------------------------------
    begin
      -- parametr
      d_create_internal(pproctyp_context,pentity(pparam),pparam_context,et_param,param_id);

      -- doplnit základní údaje
      pparam^.mode:=mode;
      pparam^.pass:=pass;
      pparam^.typ.settype(typ);

      -- konec deklarace parametru
      d_end_internal(pparam^,true);
      end add_param;

begin
  -- vytvořit proceduru
  d_create_internal(sym_primary_context(typ),pentity(pproc),pproc_context,ptype,id_proc);

  -- typ procedury
  d_create_internal(pproc_context,pentity(pproctyp),pproctyp_context,et_type,nil);

  -- doplnit základní údaje
  pproctyp^.tkind:=tk_singular;
  pproctyp^.stype:=dt_procedure;
  pproctyp^.parcount:=1;

  -- asociovat s procedurou
  pproc^.typ.settype(pproctyp);

  -- predame jako parametr analyzovany symbol
  add_param(id_param,pm_inout,pp_ref,^typ);

  -- u stringu a pole se bude predavat rozsah inicializace
  if range_call then 
    -- predame jako parametr dolni mez provadeni
    add_param(^id_int_low,pm_in,pp_value,typ.srange.getctype);

    -- predame jako parametr horni mez provadeni
    add_param(^id_int_high,pm_in,pp_value,typ.srange.getctype);
    end if;

  -- konec deklarace typu procedury
  d_end_internal(pproctyp^,true);

  -- další část deklarace
  d_next_internal(pproc^);

  -- vygenerovat podle parametrů lokální proměnné
  p_genlocvar(pproc^);
  end a_make_subprogram;



----------------------------------------------------------------------------------------------------
procedure a_type_prepare (
    typ            : in out tentity_type;        -- analyzovaný symbol
    tst            : in tspectype;               -- typ speciální metody
    ancestor       : in t_logical;               -- T-volat odpovídající metodu předka
    binfo          : out blinfo;                 -- kontext generování příkazů
    xinfo          : out expinfo;                -- kontext generování výrazu
    pproc          : out pentity_special;        -- vygenerovaná procedura
    pproc_context  : out tcontext;               -- kontext vytvořené procedury
    pvar           : out pentity_var;            -- parametr procedury
    bl             : out pblblock;               -- blok příkazů
    initvars       : out t_logical) =            -- T-inicializovat jednotlivé prom.
-- Připraví speciální metodu
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hledátko
  range_call       : t_logical;                  -- procedura volána na určený rozsah
  crange           : texecuterange;              -- rozsah provádění

begin
  if typ.derive=td_private_extension then
    unimplemented({UNIMP=}000193);
    end if;

  -- budeme volat na celý nebo omezený rozsah typu?
  if (typ.stype in dts_index) 
    then range_call:=true
    else range_call:=false;
      end if;

  -- vytvořit podprogram
  a_make_subprogram(typ,et_special,tspectypeid[tst],^id_int_param,range_call,pentity_subprogram(pproc),pproc_context);

  -- určit typ objektu, ke kterému se metoda vztahuje
  pproc^.specobj:=tso_type;

  -- zařadit do tabulky speciálních metod
  typ.stable[tst].setentity(pproc);

  -- dohledat proměnnou odpovídající parametru
  srch.find_local_all(pproc_context,id_int_param);
  verify({VERIFY=}000561,(srch.psym=nil) or (srch.psym^.etype<>et_var));
  pvar:=pentity_var(srch.psym);

  -- inicializovat kontexty generování příkazů a výrazů
  a_prepare_info(binfo,xinfo);

  -- vytvořit prázdný blok
  bl:=b_make_block(pproc_context,binfo);

  -- asociovat s procedurou
  pproc^.bl.setblock(bl);


  -- zavolat odpovídající metodu předka
  if ancestor and typ.ancestor.isset and pentity_type(typ.ancestor.getcentity)^.stable[tst].isset then
    -- v jakém rozsahu inicializujeme předka?
    get_index_type_range(pproc_context,xinfo,pentity_type(typ.ancestor.getcentity),crange);

    -- zavoláme inicializační proceduru
    a_list_append(bl^.sub,
      a_type_make_call(pproc_context,binfo,xinfo,tst,pentity_type(typ.ancestor.getcentity)^,crange,
        x_make_component_var(pproc_context,xinfo,pvar)
        )
      );
    end if;

  -- není k dispozici počáteční hodnota pro celý typ ?
  if tst=tst_init and typ.init.isset

    -- ano => použít
    then
      -- přiřadit
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            x_make_component_var(pproc_context,xinfo,pvar),
            x_make_imm(pproc_context,xinfo,^typ,typ.init.getimm^,iek_imm)
            )
          )
        );

      -- jednotlivé proměnné už nebudeme inicializovat
      initvars:=false;

    -- ne => nechat to tak a použít hodnoty jednotlivých proměnných
    else 
      initvars:=true;
      end if;
  end a_type_prepare;



----------------------------------------------------------------------------------------------------
procedure a_type_class_entry_internal =
-- Inicializace instance třídy a volání ENTRY.
----------------------------------------------------------------------------------------------------
var
  hidden_fields    : c_class_hidden_field_helper;-- manipulátor se skrytými složkami

begin
  verify({VERIFY=}000563,ptyp^.etype<>et_class);

  -- inicializovat manipulátor se skrytými složkami
  hidden_fields.set_context(sym_primary_context(ptyp^));

  -- Instance.@TAG := <Typ:tag nebo fake tag interfacu>
  hidden_fields.a_make_set_tag(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- hodnota pole @TAG
      x_tag
      );

  -- Instance.@STATUS := <init_status>
  hidden_fields.a_make_set_status(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- počáteční hodnota pole @STATUS
      init_status
      );

  -- Instance.ENTRY
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_spec(curr,xinfo,tst_entry,nil,
        prefix^(curr,data,ptyp,xinfo),
        nil
        )
      )
    );

  -- Instance.@STATUS + [ <inicializováno> ]
  hidden_fields.a_make_add_status(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- počáteční hodnota pole @STATUS
      csf_initialized
      );
  end a_type_class_entry_internal;



----------------------------------------------------------------------------------------------------
procedure a_type_class_entry =
-- Inicializace instance třídy a volání ENTRY.
----------------------------------------------------------------------------------------------------
begin
  a_type_class_entry_internal(curr,prefix,data,ptyp,list,binfo,xinfo,
      -- výraz reprezentující tag typu
      x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag{ata_expr_tag},inttype_tag,
        x_make_component_type(curr,xinfo,ptyp)
        )
      );
  end a_type_class_entry;



----------------------------------------------------------------------------------------------------
procedure a_type_interface_entry =
-- Inicializace instance interfacu a volání ENTRY.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_rtl,
  cc_def.cc_unitype;

var
  pproc            : pentity_procedure;          -- interní procedura pro setup instance interfacu
  x_param          : pexpnode;                   -- řetěz parametrů
  srch             : tentitysearch;              -- hledátko na parametry interní procedury

begin
  -- budeme potřebovat interní proceduru pro setup instance interfacu
  rtl_get_entity(rtl_setup_interface_instance,pproc);

  -- 1. parametr - pointer na nadřazenou instance
  srch.find_et_first(pentity_type(pproc^.typ.getctype),rc_primary,et_param,[]);
  verify({VERIFY=}001001,srch.psym=nil);
  x_param:=
    x_make_param(curr,xinfo,
      x_make_ref(curr,xinfo,
        x_make_this(curr,xinfo,interface^.refclass.getcentity)
        ),
      pentity_param(srch.psym)
      );

  -- 1. parametr - index interfacu
  srch.find_et_next;
  verify({VERIFY=}001002,srch.psym=nil);
  x_param^.next:=
    x_make_param(curr,xinfo,
      x_make_imm_uniint(curr,xinfo,
        unsigned_to_uniint(interface^.interface_index)
        ),
      pentity_param(srch.psym)
      );

  -- víc parametrů procedura jistě nemá
  srch.find_et_next;
  verify({VERIFY=}001003,srch.psym<>nil);

  -- sestavit vlastní volání
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_rtl(curr,xinfo,rtl_setup_interface_instance,x_param)
      )
    );

  -- Původní, málo funkční řešení. Nenastavovalo korektně fake tag interfacu, jehož metody byly
  -- přetíženy až v potomkovi aktuální třídy.
  --
  -- a_type_class_entry_internal(curr,prefix,data,interface^.refclass.getcentity{ptyp},list,binfo,xinfo,
  --     -- výraz reprezentující fake tag interacu
  --     x_make_fake_tag(curr,xinfo,interface)
  --     -- počáteční hodnota pole @STATUS
  --     [csf_interface],
  --     );
  end a_type_interface_entry;
  


----------------------------------------------------------------------------------------------------
procedure a_type_class_exit =
-- Finalizace instance třídy - volání EXIT.
----------------------------------------------------------------------------------------------------
var
  hidden_fields    : c_class_hidden_field_helper;-- manipulátor se skrytými složkami

begin
  verify({VERIFY=}000569,ptyp^.etype<>et_class);

  -- inicializovat manipulátor se skrytými složkami
  hidden_fields.set_context(sym_primary_context(ptyp^));

  -- if Instance.@STATUS = STATUS_INITED then
  --   Instance.EXIT;
  --   end if;
  hidden_fields.a_make_test_status(curr,list,binfo,xinfo,
    -- precondition
    nil,
    -- instance
    prefix^(curr,data,ptyp,xinfo),
    -- testovaný příznak
    csf_initialized,
    -- sekvence příkazů
    b_make_list(
      b_make_cmd(curr,binfo,
        x_make_call_spec(curr,xinfo,tst_exit,nil,
          prefix^(curr,data,ptyp,xinfo),
          nil
          )
        ),
      nil
      )
    );
  end a_type_class_exit;



----------------------------------------------------------------------------------------------------
#template generate_simple_special_method (name,spec);
-- Vygeneruje proceduru pro generování volání jednoduché speciální metody, která nevyžaduje žádné
-- komplexní zpracování (např. ADJUST nebo COMMIT).
----------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  procedure name =
  -- Adjust instance třídy - volání ADJUST.
  --------------------------------------------------------------------------------------------------
  begin
    -- Instance.<spec>
    a_list_append(list,
      b_make_cmd(curr,binfo,
        x_make_call_spec(curr,xinfo,spec,nil,
          prefix^(curr,data,ptyp,xinfo),
          nil
          )
        )
      );
    end name

  #end generate_simple_special_method;



----------------------------------------------------------------------------------------------------
generate_simple_special_method(a_type_class_adjust,tst_adjust);
generate_simple_special_method(a_type_class_rollback,tst_rollback);
generate_simple_special_method(a_type_class_commit,tst_commit);
-- Volání jednoduchýc speciálních metod.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_make_action_on_prefix (
    pproc          : in pentity_special;         -- mateřská speciální metoda
    pproc_context  : in tcontext;                -- kontext mateřské speciální metody
    ptyp           : in pentity_type;            -- typ prefixu
    tst            : in tspectype;               -- typ speciální metody
    destbl         : in out bllist;              -- blok, do kterého příkaz zařadit
    prefix         : in pprefixproc;             -- konstruktor prefixu
    data           : in unchecked;               -- doplňující údaje
    binfo          : in blinfo;                  -- kontext generování příkazů
    xinfo          : in expinfo) =               -- kontext generování výrazu
-- Pro zadaný prefix a vygeneruje akci volání požadované speciální metody.
----------------------------------------------------------------------------------------------------
var
  crange           : texecuterange;              -- rozsah provádění

begin
  -- vygenerovat vlastní akci v závislosti na typu speciální metody
  case tst
    -- inicializace - přiřazení počáteční hodnoty
    when tst_init do
        -- nic nedělat, protože přiřazení počáteční hodnoty již proběhlo
        -- mimo tuto proceduru

    -- entry/exit/adjust - volání speciální metody
    when tst_entry, tst_exit, tst_adjust, tst_rollback, tst_commit do
        -- není složka dokonce sama instancí třídy ?
        if ptyp^.stype=dt_class then
          case tst
            --%%TODO(#FOR) Předělat na #for spec in tst_entry..tst_commit nebo tak něco.
            when tst_entry    do a_type_class_entry   (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_exit     do a_type_class_exit    (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_adjust   do a_type_class_adjust  (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_rollback do a_type_class_rollback(pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_commit   do a_type_class_commit  (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when others do verify({VERIFY=}000731,true);
            end case;

        -- pokud obsahuje třídu a příslušnou metodu, zavolat ji (pokud neobsahuje třídu, ale
        -- má příslušnou metodu, není nutné ji volat, protože stejně obsahuje jen přiřazení
        -- počáteční hodnoty, které jsme provedli před chvílí (mimo tuto proceduru).
        elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
          -- rozsah působení metody
          get_index_type_range(pproc_context,xinfo,ptyp,crange);

          -- Instance.Item:entry()
          a_list_append(destbl,
            a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,crange,
              prefix^(pproc_context,data,ptyp,xinfo)
              )
            );
          end if;

    when others do verify({VERIFY=}000732,true);
    end case;
  end a_make_action_on_prefix;



type
  -- doplňující parametry pro generátor prefixu složky recordu
  tprefixrecord    = record
      pvar         : pentity_var;            -- proměnná
      pitem        : pentity_var;            -- složka recordu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_record : tprefixproc =
-- Generování prefixu složky recordu.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_selector(curr,xinfo,pentity_var(tprefixrecord(_data).pitem),
            x_make_component_var(curr,xinfo,tprefixrecord(_data).pvar)
            );
  end a_make_prefix_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record (
    typ            : in out tentity_type;        -- analyzovaný symbol
    tst            : in tspectype) =             -- typ speciální metody
-- Vygeneruje pro zadaný typ požadovanou speciální metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovaná procedura
  pproc_context    : tcontext;                   -- kontext vygenerované procedury
  ptyp             : pentity_type;               -- typ složky
  binfo            : blinfo;                     -- kontext generování příkazů
  xinfo            : expinfo;                    -- kontext generování výrazu
  bl               : pblblock;                   -- blok příkazů
  initvars         : t_logical;                  -- T-inicializovat jednotlivé prom.
  x_imm            : pexpimm;                    -- počáteční hodnota proměnné
  data             : tprefixrecord;              -- data pro generování prefixu
  srch             : tentitysearch;              -- hledátko

begin
  verify({VERIFY=}000565,typ.stype<>dt_record);

  -- připravit speciální metodu
  a_type_prepare(typ,tst,true,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- prolézt všechny složky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou složku
    data.pitem:=srch.psym;

    -- pro zjednodušení zjistit typ složky
    ptyp:=pentity_var(data.pitem)^.typ.getctype;

    -- analyzovat typ složky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- přiřadit počáteční hodnotu
    if tst=tst_init and then initvars and then (data.pitem^.init.isset or ptyp^.init.isset) then
      -- připravit přímou hodnotu příkaz
      if data.pitem^.init.isset

        -- přednost má počáteční hodnota proměnné
        then 
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pitem^.init.getimm^,iek_imm)

        -- počáteční proměnné typu
        else
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_imm)
          end if;

      -- Instance.Item := <imm>
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            a_make_prefix_record(pproc_context,data,ptyp,xinfo),
            x_imm
            )
          )
        );
      end if;

    -- zavolat speciální metodu
    a_make_action_on_prefix(pproc,pproc_context,ptyp,tst,bl^.sub,^a_make_prefix_record,data,binfo,xinfo);

{  Ondra 23.1.2003 : Původní verze kombinující přiřazení počáteční hodnoty
   a volnání speciální metody. Rozděleno, zobecněno a odděleno do
   [a_make_action_on_prefix] použitelného i z a_type_array a dalších procedur.

    -- vygenerovat vlastní akci v závislosti na typu speciální metody
    case tst
      -- inicializace - přiřazení počáteční hodnoty
      when tst_init do
          -- přiřadit počáteční hodnotu
          if initvars and (data.pvar^.init.isset or ptyp^.init.isset) then
            -- připravit přímou hodnotu příkaz
            if data.pvar^.init.isset

              -- přednost má počáteční hodnota proměnné
              then 
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pvar^.init.getimm^,iek_imm)

              -- počáteční proměnné typu
              else
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_imm)
                end if;

            -- Instance.Item := <imm>
            a_list_append(bl^.sub,
              b_make_cmd(pproc_context,binfo,
                x_make_op_assign(pproc_context,xinfo,
                  a_make_prefix_record(pproc_context,data,ptyp,xinfo),
                  x_imm
                  )
                )
              );
            end if;

      -- entry/exit/adjust - volání speciální metody
      when tst_entry, tst_exit, tst_adjust do
          -- není složka dokonce sama instancí třídy ?
          if ptyp^.stype=dt_class then
            case tst
              when tst_entry  do a_type_class_entry (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_exit   do a_type_class_exit  (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_adjust do a_type_class_adjust(pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo)
              when others do verify({VERIFY=}000733,true);
              end case;

          -- pokud obsahuje třídu a příslušnou metodu, zavolat ji (pokud neobsahuje třídu, ale
          -- má příslušnou metodu, není nutné ji volat, protože stejně obsahuje jen přiřazení
          -- počáteční hodnoty, které jsme provedli před chvílí.
          elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
            -- Instance.Item:entry()
            a_list_append(bl^.sub,
              a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,
                a_make_prefix_record(pproc_context,data,ptyp,xinfo)
                )
              );
            end if;

      when others do verify({VERIFY=}000734,true);
      end case;
}
    -- další složka
    srch.find_et_next;
    end loop;

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovaný symbol
-- Vyhodnotí, zda je potřeba pro zadaný typ komplexní inicializace.
-- Při té příležitosti současně analyzuje typy všech složek recordu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hledátko
  pitem            : pentity_var;                -- složka recordu
  ptyp             : pentity_type;               -- typ složky
  complex          : t_logical;                  -- syntetický příznak komplexní inicializace
                                                 -- vypočtený z údajů o složkách recordu

begin
  -- prolézt všechny složky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou složku
    pitem:=srch.psym;

    -- pro zjednodušení zjistit typ složky
    ptyp:=pitem^.typ.getctype;

    -- analyzovat typ složky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- komplexní inicializace je vyžadována, jestliže alespoň jedna složka nebo její typ má 
    -- počáteční hodnotu nebo je komplexní inicializace vyžadována pro její typ
    complex or pitem^.init.isset or ptyp^.tinit=ti_complex or ptyp^.init.isset;

    -- další složka
    srch.find_et_next;
    end loop;

  -- komplexní inicializace recordu je vyžadována, je-li vyžadována alespoň pro jednu složku nebo
  -- má record počáteční hodnotu
  if complex or typ.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_record_resolve_complex;



type
  -- doplňující parametry pro generátor prefixu složky pole
  tprefixarray     = record
      pvar         : pentity_var;                -- proměnná
      for_var      : pentity_var;                -- řídící proměnná cyklu
      for_region   : pregion;                    -- region řídící proměnné cyklu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_array : tprefixproc =
-- Generování prefixu složky pole.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_index(curr,xinfo,
            x_make_component_var(curr,xinfo,tprefixarray(_data).pvar),
            x_make_component_var(curr,xinfo,tprefixarray(_data).for_var)
            );
  end a_make_prefix_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array (
    typ            : in out tentity_type;        -- analyzovaný symbol
    tst            : in tspectype) =             -- typ speciální metody
-- Vygeneruje pro zadaný typ požadovanou speciální metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovaná procedura
  pproc_context    : tcontext;                   -- kontext vygenerované procedury
  ptyp             : pentity_type;               -- typ báze pole
  binfo            : blinfo;                     -- kontext generování příkazů
  xinfo            : expinfo;                    -- kontext generování výrazu
  bl               : pblblock;                   -- blok příkazů
  blfor            : pblfor;                     -- for cyklus
  initvars         : t_logical;                  -- T-inicializovat jednotlivé prom.
  data             : tprefixarray;               -- data pro generování prefixu
  for_loop_context : tcontext;                   -- kontext FOR cyklu
  for_var_context  : tcontext;                   -- kontext řídící proměnné cyklu
  range_low        : pentity_var;                -- spodni mez rozsahu 
  range_high       : pentity_var;                -- horni mez rozsahu 

begin
  verify({VERIFY=}000566,typ.stype not in tdatatypeset:[dt_array,dt_uarray]);

  -- připravit speciální metodu
  a_type_prepare(typ,tst,false,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- zjistit si bázový typ pole
  ptyp:=typ.base.getctype;

{ Tohle za nás již udělalo [a_type_array_resolve_complex].
  -- analyzovat bázový typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;
}
  -- vznikl nový deklarativní region
  d_create_region(pproc_context,data.for_region,for_loop_context);

  -- založit řídící proměnnou cyklu
  d_create_internal(for_loop_context,pentity(data.for_var),for_var_context,et_var,^id_int_forvar);
  data.for_var^.typ.settype(typ.srange.getctype);
  data.for_var^.mclass:=mc_auto;
  data.for_var^.vmode:=vm_direct;
  data.for_var^.vaccess:=va_const;
  d_end_internal(data.for_var^,true);

  -- dohledat proměnnou odpovídající dolní a horní mezi rozsahu
  a_find_executing_range(pproc_context,range_low,range_high);
  
  -- vygenerujeme variantu s explicitně uvedeným rozsahem...
  if range_low<>nil then
    -- for @I in range_low..range_high loop
    blfor:=b_make_for(for_loop_context,binfo,data.for_var,data.for_region,bfo_normal,
      x_make_range(for_loop_context,xinfo,erk_static,typ.srange.getctype,
        x_make_component_var(for_loop_context,xinfo,range_low),
        x_make_component_var(for_loop_context,xinfo,range_high)
        )
      );

  -- ...nebo pres celý rozsah typu?
  else
    -- for @I in @PARAM:range loop
    blfor:=b_make_for(for_loop_context,binfo,data.for_var,data.for_region,bfo_normal,
      x_make_component_type(for_loop_context,xinfo,typ.srange.getctype)
      );
    end if;
  a_list_append(bl^.sub,blfor);

  -- zavolat speciální metodu
  a_make_action_on_prefix(pproc,for_loop_context,ptyp,tst,blfor^.sub,^a_make_prefix_array,data,binfo,xinfo);

  --unimplemented({UNIMP=}000199);

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovaný symbol
-- Vyhodnotí, zda je potřeba pro zadaný typ komplexní inicializace.
-- Při té příležitosti současně analyzuje bázový typ pole.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;               -- typ báze pole

begin
  -- zjistit si bázový typ pole
  ptyp:=typ.base.getctype;

  -- analyzovat bázový typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;

  -- komplexní inicializaci se provádí v případě, že má typ pole nebo jeho báze počáteční hodnotu
  if typ.init.isset or ptyp^.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_array_resolve_complex;



----------------------------------------------------------------------------------------------------
procedure a_type =
-- Analýza typu. Pokud je to potřeba, tak vygeneruje podprogramy pro
-- inicializaci, finalizaci a adjustment zadaného typu.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    #template generate_special_methods(generator);
    -- Pro aktuální typ vygeneruje potřebné speciální metody pomocí generátoru [generator].
    ------------------------------------------------------------------------------------------------
      -- INIT
      if typ.tinit=ti_complex then
        generator(typ,tst_init);
        end if;

      -- neobsahuje typ náhodou třídu ?
      if t_contains_class(typ) then 
        --%%TODO(#FOR) Nahradit meta-for-cyklem nebo se spolehnout na rozvíjení cyklů.
        for spec in succ tst_init..tspectype:last loop
          generator(typ,spec);
          end loop;
        end if;
      #end generate_special_methods;

with
  standard,console;

begin
  verify({VERIFY=}000576,typ.etype<>et_type);

  -- zajímají nás pouze entity z aktuální parition
  if typ.partition_id<>curr_partition then return end if;

  -- analyzovat jen dosud neanalyzované symboly
  if typ.analyzed<>as_none then return; end if;

  -- symbol je právě analyzován
  typ.analyzed:=as_analyzing;

  -- analyzovat předka
  if typ.ancestor.isset then
    -- analyzovat předka
    a_type(pentity_type(typ.ancestor.getcentity)^);

    -- převzít příznak komplexní inicializace (tímto způsobem se zajistí
    -- komplexní inicializace například pro jednoduché typy odvozené jako
    -- private extension od komplexních typů)
    if pentity_type(typ.ancestor.getcentity)^.tinit<>ti_normal then
      typ.tinit:=pentity_type(typ.ancestor.getcentity)^.tinit;
      end if;
    end if;

  -- vygenerovat speciální metody tohoto typu
  case typ.stype
    -- pole, neomezené pole
    when dt_array, dt_uarray do
        -- vyhodnotit, jestli je pro tento typ požadována komplexní inicializace
        a_type_array_resolve_complex(typ);

        -- vygenerovat speciální metody
        generate_special_methods(a_type_array);
      {
        -- INIT
        if typ.tinit=ti_complex then
          a_type_array(typ,tst_init);
          end if;

        -- neobsahuje typ náhodou třídu ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_array(typ,tst_entry);

          -- EXIT
          a_type_array(typ,tst_exit);

          -- ADJUST
          a_type_array(typ,tst_adjust);
          end if;
      }
    -- řetězec, neomezený řetězec
    when dt_string, dt_ustring do
        -- neobsahuje typ náhodou třídu ?
        if t_contains_class(typ) then 
          write_line(sym_get_qid(^typ));

          --unimplemented({UNIMP=}000200);
      {
          -- INIT
          a_type_string(typ,tst_init);

          -- ENTRY se negeneruje, protože řetězec tříd vzniká vždy prázdný a jiný případ nenastane
          vážně??? a co vnořené třídy?
          a_type_string(typ,tst_entry);

          -- EXIT
          a_type_string(typ,tst_exit);

          -- ADJUST
          a_type_string(typ,tst_adjust);
      }
          end if;

    -- record
    when dt_record do
        -- vyhodnotit, jestli je pro tento typ požadována komplexní inicializace
        a_type_record_resolve_complex(typ);

        -- vygenerovat speciální metody
        generate_special_methods(a_type_record);
      {
        -- INIT
        if typ.tinit=ti_complex then
          a_type_record(typ,tst_init);
          end if;

        -- neobsahuje typ náhodou třídu ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_record(typ,tst_entry);

          -- EXIT
          a_type_record(typ,tst_exit);

          -- ADJUST
          a_type_record(typ,tst_adjust);
          end if;
      }
    -- třída
    when dt_class     do -- nic nedělat, to se řeší přímo

    -- všechny ostatní typy
    when others do
    {
        -- INIT
        a_type_others(typ,tst_init);

        -- ENTRY
        a_type_others(typ,tst_entry);

        -- EXIT
        a_type_others(typ,tst_exit);

        -- ADJUST
        a_type_others(typ,tst_adjust);
    }

    end case;

  -- symbol byl analyzován
  typ.analyzed:=as_analyzed;
  end a_type;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_qualified =
-- Sestaví kvalifikované volání podprogramu pro inicializace, finalizace nebo
-- adjustment zadaného typu/třídy.
----------------------------------------------------------------------------------------------------
var
  x_param          : pexpitem;
  srch             : tentitysearch;
  typ_context      : tcontext;

begin
  verify({VERIFY=}000562,not typ.stable[tst].isset);

  -- pro zjednodušení si sestavit kontext typu
  typ_context:=sym_primary_context(typ);

  -- budou nějaké parametry ?
  if instance<>nil

    -- hodnotu máme k dispozici => dohledat parametr
    then
      -- dohledat parametr
      srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_param);
      verify({VERIFY=}000579,(srch.psym=nil) or (srch.psym^.etype<>et_param));

      -- sestavit výraz
      x_param:=x_make_param(typ_context,xinfo,instance,pentity_param(srch.psym));

      -- u stringu a pole jeste predame rozsah inicializace (pokud je očekáván)
      if typ.stype in dts_index then
        -- dohledat spodní mez
        srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_low);

		-- pokud existuje spodní mez musí bt hledaného typu a musí existovat i horní mez
		if srch.psym<>nil then
          verify({VERIFY=}000686,(srch.psym=nil) or (srch.psym^.etype<>et_param));

          -- sestavit výraz
          x_param^.next:=x_make_param(typ_context,xinfo,
            crange.low,
            pentity_param(srch.psym)
            );

          -- dohledat horní mez
          srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_high);
          verify({VERIFY=}000735,(srch.psym=nil) or (srch.psym^.etype<>et_param));

          -- sestavit výraz
          x_param^.next^.next:=x_make_param(typ_context,xinfo,
            crange.high,
            pentity_param(srch.psym)
            );
		  end if;
        end if;

    -- žádné parametry nebudou
    else
      x_param:=nil;
      end if;

  -- sestavit příkaz
  result:=b_make_cmd(typ_context,binfo,
    x_make_call_spec(typ_context,xinfo,tst,pentity_special(typ.stable[tst].getcentity),
      prefix,
      x_param
      )
    );
  end a_type_make_call_qualified;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call =
-- Sestaví volání podprogramu pro inicializace, finalizace nebo adjustment
-- zadaného typu.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000623,typ.stype=dt_class);

  -- zavolat
  result:=a_type_make_call_qualified(typ,binfo,xinfo,tst,nil,crange,instance);
  end a_type_make_call;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_ancestor =
-- Sestaví volání podprogramu pro inicializace, finalizace nebo adjustment
-- předka zadaného typu. Dohledá první speciální metodu v hierarchii předků.
-- Pokud žádnou nenalezne, žádné volání nevygeneruje.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity_type;               -- předek

begin
  verify({VERIFY=}000622,typ.stype<>dt_class);

  -- dohledat metodu předka
  ancestor:=pentity_type(typ.ancestor.getuentity);
  while (ancestor<>nil) and then not ancestor^.stable[tst].isset loop 
    ancestor:=pentity_type(ancestor^.ancestor.getuentity);
    end loop;

  -- nenalezlo-li se, tak se nic generovat nebude
  if ancestor=nil then
    result:=nil;
    return;
    end if;

  -- zavolat
  result:=a_type_make_call_qualified(ancestor^,binfo,xinfo,tst,x_make_this(sym_primary_context(typ),xinfo,^typ),crange,nil);
  end a_type_make_call_ancestor;



----------------------------------------------------------------------------------------------------
procedure get_index_type_range =
-- Vrátí rozsah indexovaného typu.
----------------------------------------------------------------------------------------------------
begin
  -- pokud se jedná o string nebo pole
  if typ^.stype=dt_array or typ^.stype=dt_string then
    -- spodní a dolní rozsah inicializace
    crange.low:=x_make_imm_uniint(context,xinfo,typ^.srange.getctype^.lval);
    crange.high:=x_make_imm_uniint(context,xinfo,typ^.srange.getctype^.hval);
    end if;
  end get_index_type_range;


end ca_type;
