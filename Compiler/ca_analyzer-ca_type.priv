----------------------------------------------------------------------------------------------------
module private ca_type =
-- P©eklada‡ Flexu.
-- Generov n¡ podprogram– pro inicializaci a finalizaci typ–.
----------------------------------------------------------------------------------------------------
-- Ondra : 18.06.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_var,
  cc_base,
  cc_base.cc_sym,
  cc_base.cc_type,
  cc_attr,
  cd_decl,
  cd_decl.cd_create,
  cd_decl.cd_util,
  cb_block,
  cb_block.cb_make,
  cx_expr,
  cx_expr,cx_expr.cx_make,
  ca_util;

----------------------------------------------------------------------------------------------------
procedure a_make_subprogram (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    ptype          : in tentitytype;             -- typ symbolu
    id_proc        : in pentityident;            -- identifik tor procedury
    id_param       : in pentityident;            -- identifik tor parametru
    range_call     : in t_logical;               -- procedura vol na na ur‡en˜ rozsah
    pproc          : out pentity_subprogram;     -- vytvo©en  procedura
    pproc_context  : out tcontext) =             -- kontext vytvo©en‚ procedury
-- Vytvo©¡ proceduru s jedn¡m in out parametrem zadan‚ho typu a pripadne dvema paramtery ud vajici
-- rozsah.
----------------------------------------------------------------------------------------------------
var
  pproctyp         : pentity_type;               -- typ procedury
  pproctyp_context : tcontext;                   -- kontext typu procedury
  pparam           : pentity_param;              -- parametr procedury
  pparam_context   : tcontext;                   -- kontext parametru procedury

    ------------------------------------------------------------------------------------------------
    procedure add_param (
        param_id   : in pentityident;            -- identifik tor parametru
        mode       : in parammode;               -- m¢d parametru
        pass       : in parampass;               -- zp–sob p©ed n¡ parametru
        typ        : in pentity_type) =          -- typ
    -- Prida parametr danych attributu.
    ------------------------------------------------------------------------------------------------
    begin
      -- parametr
      d_create_internal(pproctyp_context,pentity(pparam),pparam_context,et_param,param_id);

      -- doplnit z kladn¡ £daje
      pparam^.mode:=mode;
      pparam^.pass:=pass;
      pparam^.typ.settype(typ);

      -- konec deklarace parametru
      d_end_internal(pparam^,true);
      end add_param;

begin
  -- vytvo©it proceduru
  d_create_internal(sym_primary_context(typ),pentity(pproc),pproc_context,ptype,id_proc);

  -- typ procedury
  d_create_internal(pproc_context,pentity(pproctyp),pproctyp_context,et_type,nil);

  -- doplnit z kladn¡ £daje
  pproctyp^.tkind:=tk_singular;
  pproctyp^.stype:=dt_procedure;
  pproctyp^.parcount:=1;

  -- asociovat s procedurou
  pproc^.typ.settype(pproctyp);

  -- predame jako parametr analyzovany symbol
  add_param(id_param,pm_inout,pp_ref,^typ);

  -- u stringu a pole se bude predavat rozsah inicializace
  if range_call then 
    -- predame jako parametr dolni mez provadeni
    add_param(^id_int_low,pm_in,pp_value,typ.srange.getctype);

    -- predame jako parametr horni mez provadeni
    add_param(^id_int_high,pm_in,pp_value,typ.srange.getctype);
    end if;

  -- konec deklarace typu procedury
  d_end_internal(pproctyp^,true);

  -- dal¨¡ ‡ st deklarace
  d_next_internal(pproc^);

  -- vygenerovat podle parametr– lok ln¡ promˆnn‚
  p_genlocvar(pproc^);
  end a_make_subprogram;



----------------------------------------------------------------------------------------------------
procedure a_type_prepare (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype;               -- typ speci ln¡ metody
    ancestor       : in t_logical;               -- T-volat odpov¡daj¡c¡ metodu p©edka
    binfo          : out blinfo;                 -- kontext generov n¡ p©¡kaz–
    xinfo          : out expinfo;                -- kontext generov n¡ v˜razu
    pproc          : out pentity_special;        -- vygenerovan  procedura
    pproc_context  : out tcontext;               -- kontext vytvo©en‚ procedury
    pvar           : out pentity_var;            -- parametr procedury
    bl             : out pblblock;               -- blok p©¡kaz–
    initvars       : out t_logical) =            -- T-inicializovat jednotliv‚ prom.
-- P©iprav¡ speci ln¡ metodu
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko
  range_call       : t_logical;                  -- procedura vol na na ur‡en˜ rozsah
  crange           : texecuterange;              -- rozsah prov dˆn¡

begin
  if typ.derive=td_private_extension then
    unimplemented({UNIMP=}000193);
    end if;

  -- budeme volat na cel˜ nebo omezen˜ rozsah typu?
  if (typ.stype in dts_index) 
    then range_call:=true
    else range_call:=false;
      end if;

  -- vytvo©it podprogram
  a_make_subprogram(typ,et_special,tspectypeid[tst],^id_int_param,range_call,pentity_subprogram(pproc),pproc_context);

  -- ur‡it typ objektu, ke kter‚mu se metoda vztahuje
  pproc^.specobj:=tso_type;

  -- za©adit do tabulky speci ln¡ch metod
  typ.stable[tst].setentity(pproc);

  -- dohledat promˆnnou odpov¡daj¡c¡ parametru
  srch.find_local_all(pproc_context,id_int_param);
  verify({VERIFY=}000561,(srch.psym=nil) or (srch.psym^.etype<>et_var));
  pvar:=pentity_var(srch.psym);

  -- inicializovat kontexty generov n¡ p©¡kaz– a v˜raz–
  a_prepare_info(binfo,xinfo);

  -- vytvo©it pr zdn˜ blok
  bl:=b_make_block(pproc_context,binfo);

  -- asociovat s procedurou
  pproc^.bl.setblock(bl);


  -- zavolat odpov¡daj¡c¡ metodu p©edka
  if ancestor and typ.ancestor.isset and pentity_type(typ.ancestor.getcentity)^.stable[tst].isset then
    -- v jak‚m rozsahu inicializujeme p©edka?
    get_index_type_range(pproc_context,xinfo,pentity_type(typ.ancestor.getcentity),crange);

	-- zavol me inicializa‡n¡ proceduru
    a_list_append(bl^.sub,
      a_type_make_call(pproc_context,binfo,xinfo,tst,pentity_type(typ.ancestor.getcentity)^,crange,
        x_make_component_var(pproc_context,xinfo,pvar)
        )
      );
    end if;

  -- nen¡ k dispozici po‡ te‡n¡ hodnota pro cel˜ typ ?
  if tst=tst_init and typ.init.isset

    -- ano => pou‘¡t
    then
      -- p©i©adit
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            x_make_component_var(pproc_context,xinfo,pvar),
            x_make_imm(pproc_context,xinfo,^typ,typ.init.getimm^,iek_imm)
            )
          )
        );

      -- jednotliv‚ promˆnn‚ u‘ nebudeme inicializovat
      initvars:=false;

    -- ne => nechat to tak a pou‘¡t hodnoty jednotliv˜ch promˆnn˜ch
    else 
      initvars:=true;
      end if;
  end a_type_prepare;



----------------------------------------------------------------------------------------------------
procedure a_type_class_entry_internal (
    curr           : in tcontext;                -- kontext          
    prefix         : in pprefixproc;             -- gener tor prefixu
    data           : in unchecked;               -- dopl¤uj¡c¡ £daje pro gener tor
    ptyp           : in pentity_type;            -- typ promˆnn‚ (t©¡da)
    list           : in out bllist;              -- seznam p©¡kaz–
    binfo          : in blinfo;                  -- kontext generov n¡ p©¡kaz–
    xinfo          : in expinfo;                 -- kontext generov n¡ v˜razu
    init_status    : in t_class_status_field;    -- po‡ te‡n¡ hodnota pole @STATUS
    x_tag          : in pexpnode) =              -- v˜raz reprezentuj¡c¡ tag typu
-- Inicializace instance t©¡dy a vol n¡ ENTRY.
----------------------------------------------------------------------------------------------------
var
  hidden_fields    : c_class_hidden_field_helper;-- manipul tor se skryt˜mi slo‘kami

begin
  verify({VERIFY=}000563,ptyp^.etype<>et_class);

  -- inicializovat manipul tor se skryt˜mi slo‘kami
  hidden_fields.set_context(sym_primary_context(ptyp^));

  -- Instance.@TAG := <Typ:tag nebo fake tag interfacu>
  hidden_fields.a_make_set_tag(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- hodnota pole @TAG
      x_tag
      );

  -- Instance.@STATUS := <init_status>
  hidden_fields.a_make_set_status(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- po‡ te‡n¡ hodnota pole @STATUS
      init_status
      );

  -- Instance.ENTRY
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_spec(curr,xinfo,tst_entry,nil,
        prefix^(curr,data,ptyp,xinfo),
        nil
        )
      )
    );

  -- Instance.@STATUS + [ <inicializov no> ]
  hidden_fields.a_make_add_status(curr,list,binfo,xinfo,
      -- instance
      prefix^(curr,data,ptyp,xinfo),
      -- po‡ te‡n¡ hodnota pole @STATUS
      csf_initialized
      );
  end a_type_class_entry_internal;



----------------------------------------------------------------------------------------------------
procedure a_type_class_entry =
-- Inicializace instance t©¡dy a vol n¡ ENTRY.
----------------------------------------------------------------------------------------------------
begin
  a_type_class_entry_internal(curr,prefix,data,ptyp,list,binfo,xinfo,[],
      -- v˜raz reprezentuj¡c¡ tag typu
      x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag{ata_expr_tag},inttype_tag,
        x_make_component_type(curr,xinfo,ptyp)
        )
      );
  end a_type_class_entry;



----------------------------------------------------------------------------------------------------
procedure a_type_interface_entry =
-- Inicializace instance interfacu a vol n¡ ENTRY.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_rtl,
  cc_def.cc_unitype;

var
  pproc            : pentity_procedure;          -- intern¡ procedura pro setup instance interfacu
  x_param          : pexpnode;                   -- ©etˆz parametr–
  srch             : tentitysearch;              -- hled tko na parametry intern¡ procedury

begin
  -- budeme pot©ebovat intern¡ proceduru pro setup instance interfacu
  rtl_get_entity(rtl_setup_interface_instance,pproc);

  -- 1. parametr - pointer na nad©azenou instance
  srch.find_et_first(pentity_type(pproc^.typ.getctype),rc_primary,et_param,[]);
  verify({VERIFY=}001001,srch.psym=nil);
  x_param:=
    x_make_param(curr,xinfo,
      x_make_ref(curr,xinfo,
        x_make_this(curr,xinfo,interface^.refclass.getcentity)
        ),
      pentity_param(srch.psym)
      );

  -- 1. parametr - index interfacu
  srch.find_et_next;
  verify({VERIFY=}001002,srch.psym=nil);
  x_param^.next:=
    x_make_param(curr,xinfo,
      x_make_imm_uniint(curr,xinfo,
        unsigned_to_uniint(interface^.interface_index)
        ),
      pentity_param(srch.psym)
      );

  -- v¡c parametr– procedura jistˆ nem 
  srch.find_et_next;
  verify({VERIFY=}001003,srch.psym<>nil);

  -- sestavit vlastn¡ vol n¡
  a_list_append(list,
    b_make_cmd(curr,binfo,
      x_make_call_rtl(curr,xinfo,rtl_setup_interface_instance,x_param)
      )
    );

  -- P–vodn¡, m lo funk‡n¡ ©e¨en¡. Nenastavovalo korektnˆ fake tag interfacu, jeho‘ metody byly
  -- p©et¡‘eny a‘ v potomkovi aktu ln¡ t©¡dy.
  --
  -- a_type_class_entry_internal(curr,prefix,data,interface^.refclass.getcentity{ptyp},list,binfo,xinfo,[csf_interface],
  --     -- v˜raz reprezentuj¡c¡ fake tag interacu
  --     x_make_fake_tag(curr,xinfo,interface)
  --     );
  end a_type_interface_entry;
  


----------------------------------------------------------------------------------------------------
procedure a_type_class_exit =
-- Finalizace instance t©¡dy - vol n¡ EXIT.
----------------------------------------------------------------------------------------------------
var
  hidden_fields    : c_class_hidden_field_helper;-- manipul tor se skryt˜mi slo‘kami

begin
  verify({VERIFY=}000569,ptyp^.etype<>et_class);

  -- inicializovat manipul tor se skryt˜mi slo‘kami
  hidden_fields.set_context(sym_primary_context(ptyp^));

  -- if Instance.@STATUS = STATUS_INITED then
  --   Instance.EXIT;
  --   end if;
  hidden_fields.a_make_test_status(curr,list,binfo,xinfo,
    -- precondition
    nil,
    -- instance
    prefix^(curr,data,ptyp,xinfo),
    -- testovan˜ p©¡znak
    csf_initialized,
    -- sekvence p©¡kaz–
    b_make_list(
      b_make_cmd(curr,binfo,
        x_make_call_spec(curr,xinfo,tst_exit,nil,
          prefix^(curr,data,ptyp,xinfo),
          nil
          )
        ),
      nil
      )
    );
  end a_type_class_exit;



----------------------------------------------------------------------------------------------------
#template generate_simple_special_method (name,spec);
-- Vygeneruje proceduru pro generov n¡ vol n¡ jednoduch‚ speci ln¡ metody, kter  nevy‘aduje ‘ dn‚
-- komplexn¡ zpracov n¡ (nap©. ADJUST nebo COMMIT).
----------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  procedure name =
  -- Adjust instance t©¡dy - vol n¡ ADJUST.
  --------------------------------------------------------------------------------------------------
  begin
    -- Instance.<spec>
    a_list_append(list,
      b_make_cmd(curr,binfo,
        x_make_call_spec(curr,xinfo,spec,nil,
          prefix^(curr,data,ptyp,xinfo),
          nil
          )
        )
      );
    end name

  #end generate_simple_special_method;



----------------------------------------------------------------------------------------------------
generate_simple_special_method(a_type_class_adjust,tst_adjust);
generate_simple_special_method(a_type_class_rollback,tst_rollback);
generate_simple_special_method(a_type_class_commit,tst_commit);
-- Vol n¡ jednoduch˜c speci ln¡ch metod.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_make_action_on_prefix (
    pproc          : in pentity_special;         -- mate©sk  speci ln¡ metoda
    pproc_context  : in tcontext;                -- kontext mate©sk‚ speci ln¡ metody
    ptyp           : in pentity_type;            -- typ prefixu
    tst            : in tspectype;               -- typ speci ln¡ metody
    destbl         : in out bllist;              -- blok, do kter‚ho p©¡kaz za©adit
    prefix         : in pprefixproc;             -- konstruktor prefixu
    data           : in unchecked;               -- dopl¤uj¡c¡ £daje
    binfo          : in blinfo;                  -- kontext generov n¡ p©¡kaz–
    xinfo          : in expinfo) =               -- kontext generov n¡ v˜razu
-- Pro zadan˜ prefix a vygeneruje akci vol n¡ po‘adovan‚ speci ln¡ metody.
----------------------------------------------------------------------------------------------------
var
  crange           : texecuterange;              -- rozsah prov dˆn¡

begin
  -- vygenerovat vlastn¡ akci v z vislosti na typu speci ln¡ metody
  case tst
    -- inicializace - p©i©azen¡ po‡ te‡n¡ hodnoty
    when tst_init do
        -- nic nedˆlat, proto‘e p©i©azen¡ po‡ te‡n¡ hodnoty ji‘ probˆhlo
        -- mimo tuto proceduru

    -- entry/exit/adjust - vol n¡ speci ln¡ metody
    when tst_entry, tst_exit, tst_adjust, tst_rollback, tst_commit do
        -- nen¡ slo‘ka dokonce sama instanc¡ t©¡dy ?
        if ptyp^.stype=dt_class then
          case tst
            --%%TODO(#FOR) P©edˆlat na #for spec in tst_entry..tst_commit nebo tak nˆco.
            when tst_entry    do a_type_class_entry   (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_exit     do a_type_class_exit    (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_adjust   do a_type_class_adjust  (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_rollback do a_type_class_rollback(pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when tst_commit   do a_type_class_commit  (pproc_context,prefix,data,ptyp,destbl,binfo,xinfo);
            when others do verify({VERIFY=}000731,true);
            end case;

        -- pokud obsahuje t©¡du a p©¡slu¨nou metodu, zavolat ji (pokud neobsahuje t©¡du, ale
        -- m  p©¡slu¨nou metodu, nen¡ nutn‚ ji volat, proto‘e stejnˆ obsahuje jen p©i©azen¡
        -- po‡ te‡n¡ hodnoty, kter‚ jsme provedli p©ed chv¡l¡ (mimo tuto proceduru).
        elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
          -- rozsah p–soben¡ metody
          get_index_type_range(pproc_context,xinfo,ptyp,crange);

          -- Instance.Item:entry()
          a_list_append(destbl,
            a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,crange,
              prefix^(pproc_context,data,ptyp,xinfo)
              )
            );
          end if;

    when others do verify({VERIFY=}000732,true);
    end case;
  end a_make_action_on_prefix;



type
  -- dopl¤uj¡c¡ parametry pro gener tor prefixu slo‘ky recordu
  tprefixrecord    = record
      pvar         : pentity_var;            -- promˆnn 
      pitem        : pentity_var;            -- slo‘ka recordu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_record : tprefixproc =
-- Generov n¡ prefixu slo‘ky recordu.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_selector(curr,xinfo,pentity_var(tprefixrecord(_data).pitem),
            x_make_component_var(curr,xinfo,tprefixrecord(_data).pvar)
            );
  end a_make_prefix_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype) =             -- typ speci ln¡ metody
-- Vygeneruje pro zadan˜ typ po‘adovanou speci ln¡ metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovan  procedura
  pproc_context    : tcontext;                   -- kontext vygenerovan‚ procedury
  ptyp             : pentity_type;               -- typ slo‘ky
  binfo            : blinfo;                     -- kontext generov n¡ p©¡kaz–
  xinfo            : expinfo;                    -- kontext generov n¡ v˜razu
  bl               : pblblock;                   -- blok p©¡kaz–
  initvars         : t_logical;                  -- T-inicializovat jednotliv‚ prom.
  x_imm            : pexpimm;                    -- po‡ te‡n¡ hodnota promˆnn‚
  data             : tprefixrecord;              -- data pro generov n¡ prefixu
  srch             : tentitysearch;              -- hled tko

begin
  verify({VERIFY=}000565,typ.stype<>dt_record);

  -- p©ipravit speci ln¡ metodu
  a_type_prepare(typ,tst,true,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- prol‚zt v¨echny slo‘ky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou slo‘ku
    data.pitem:=srch.psym;

    -- pro zjednodu¨en¡ zjistit typ slo‘ky
    ptyp:=pentity_var(data.pitem)^.typ.getctype;

    -- analyzovat typ slo‘ky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- p©i©adit po‡ te‡n¡ hodnotu
    if tst=tst_init and then initvars and then (data.pitem^.init.isset or ptyp^.init.isset) then
      -- p©ipravit p©¡mou hodnotu p©¡kaz
      if data.pitem^.init.isset

        -- p©ednost m  po‡ te‡n¡ hodnota promˆnn‚
        then 
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pitem^.init.getimm^,iek_imm)

        -- po‡ te‡n¡ promˆnn‚ typu
        else
          x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_imm)
          end if;

      -- Instance.Item := <imm>
      a_list_append(bl^.sub,
        b_make_cmd(pproc_context,binfo,
          x_make_op_assign(pproc_context,xinfo,
            a_make_prefix_record(pproc_context,data,ptyp,xinfo),
            x_imm
            )
          )
        );
      end if;

    -- zavolat speci ln¡ metodu
    a_make_action_on_prefix(pproc,pproc_context,ptyp,tst,bl^.sub,^a_make_prefix_record,data,binfo,xinfo);

{  Ondra 23.1.2003 : P–vodn¡ verze kombinuj¡c¡ p©i©azen¡ po‡ te‡n¡ hodnoty
   a voln n¡ speci ln¡ metody. Rozdˆleno, zobecnˆno a oddˆleno do
   [a_make_action_on_prefix] pou‘iteln‚ho i z a_type_array a dal¨¡ch procedur.

    -- vygenerovat vlastn¡ akci v z vislosti na typu speci ln¡ metody
    case tst
      -- inicializace - p©i©azen¡ po‡ te‡n¡ hodnoty
      when tst_init do
          -- p©i©adit po‡ te‡n¡ hodnotu
          if initvars and (data.pvar^.init.isset or ptyp^.init.isset) then
            -- p©ipravit p©¡mou hodnotu p©¡kaz
            if data.pvar^.init.isset

              -- p©ednost m  po‡ te‡n¡ hodnota promˆnn‚
              then 
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,data.pvar^.init.getimm^,iek_imm)

              -- po‡ te‡n¡ promˆnn‚ typu
              else
                x_imm:=x_make_imm(pproc_context,xinfo,ptyp,ptyp^.init.getimm^,iek_imm)
                end if;

            -- Instance.Item := <imm>
            a_list_append(bl^.sub,
              b_make_cmd(pproc_context,binfo,
                x_make_op_assign(pproc_context,xinfo,
                  a_make_prefix_record(pproc_context,data,ptyp,xinfo),
                  x_imm
                  )
                )
              );
            end if;

      -- entry/exit/adjust - vol n¡ speci ln¡ metody
      when tst_entry, tst_exit, tst_adjust do
          -- nen¡ slo‘ka dokonce sama instanc¡ t©¡dy ?
          if ptyp^.stype=dt_class then
            case tst
              when tst_entry  do a_type_class_entry (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_exit   do a_type_class_exit  (pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo);
              when tst_adjust do a_type_class_adjust(pproc_context,^a_make_prefix_record,data,ptyp,bl^.sub,binfo,xinfo)
              when others do verify({VERIFY=}000733,true);
              end case;

          -- pokud obsahuje t©¡du a p©¡slu¨nou metodu, zavolat ji (pokud neobsahuje t©¡du, ale
          -- m  p©¡slu¨nou metodu, nen¡ nutn‚ ji volat, proto‘e stejnˆ obsahuje jen p©i©azen¡
          -- po‡ te‡n¡ hodnoty, kter‚ jsme provedli p©ed chv¡l¡.
          elsif t_contains_class(ptyp^) and ptyp^.stable[tst].isset then
            -- Instance.Item:entry()
            a_list_append(bl^.sub,
              a_type_make_call(pproc_context,binfo,xinfo,tst,ptyp^,
                a_make_prefix_record(pproc_context,data,ptyp,xinfo)
                )
              );
            end if;

      when others do verify({VERIFY=}000734,true);
      end case;
}
    -- dal¨¡ slo‘ka
    srch.find_et_next;
    end loop;

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_record;



----------------------------------------------------------------------------------------------------
procedure a_type_record_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovan˜ symbol
-- Vyhodnot¡, zda je pot©eba pro zadan˜ typ komplexn¡ inicializace.
-- P©i t‚ p©¡le‘itosti sou‡asnˆ analyzuje typy v¨ech slo‘ek recordu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko
  pitem            : pentity_var;                -- slo‘ka recordu
  ptyp             : pentity_type;               -- typ slo‘ky
  complex          : t_logical;                  -- syntetick˜ p©¡znak komplexn¡ inicializace
                                                 -- vypo‡ten˜ z £daj– o slo‘k ch recordu

begin
  -- prol‚zt v¨echny slo‘ky
  srch.find_et_first(^typ,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- poznamenat si nalezenou slo‘ku
    pitem:=srch.psym;

    -- pro zjednodu¨en¡ zjistit typ slo‘ky
    ptyp:=pitem^.typ.getctype;

    -- analyzovat typ slo‘ky
    if ptyp^.stype<>dt_class then
      a_type(ptyp^);
      end if;

    -- komplexn¡ inicializace je vy‘adov na, jestli‘e alespo¤ jedna slo‘ka nebo jej¡ typ m  
    -- po‡ te‡n¡ hodnotu nebo je komplexn¡ inicializace vy‘adov na pro jej¡ typ
    complex or pitem^.init.isset or ptyp^.tinit=ti_complex or ptyp^.init.isset;

    -- dal¨¡ slo‘ka
    srch.find_et_next;
    end loop;

  -- komplexn¡ inicializace recordu je vy‘adov na, je-li vy‘adov na alespo¤ pro jednu slo‘ku nebo
  -- m  record po‡ te‡n¡ hodnotu
  if complex or typ.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_record_resolve_complex;



type
  -- dopl¤uj¡c¡ parametry pro gener tor prefixu slo‘ky pole
  tprefixarray     = record
      pvar         : pentity_var;                -- promˆnn 
      for_var      : pentity_var;                -- ©¡d¡c¡ promˆnn  cyklu
      for_region   : pregion;                    -- region ©¡d¡c¡ promˆnn‚ cyklu
      end record;

----------------------------------------------------------------------------------------------------
procedure a_make_prefix_array : tprefixproc =
-- Generov n¡ prefixu slo‘ky pole.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_index(curr,xinfo,
            x_make_component_var(curr,xinfo,tprefixarray(_data).pvar),
            x_make_component_var(curr,xinfo,tprefixarray(_data).for_var)
            );
  end a_make_prefix_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array (
    typ            : in out tentity_type;        -- analyzovan˜ symbol
    tst            : in tspectype) =             -- typ speci ln¡ metody
-- Vygeneruje pro zadan˜ typ po‘adovanou speci ln¡ metodu.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_special;            -- vygenerovan  procedura
  pproc_context    : tcontext;                   -- kontext vygenerovan‚ procedury
  ptyp             : pentity_type;               -- typ b ze pole
  binfo            : blinfo;                     -- kontext generov n¡ p©¡kaz–
  xinfo            : expinfo;                    -- kontext generov n¡ v˜razu
  bl               : pblblock;                   -- blok p©¡kaz–
  blfor            : pblfor;                     -- for cyklus
  initvars         : t_logical;                  -- T-inicializovat jednotliv‚ prom.
  data             : tprefixarray;               -- data pro generov n¡ prefixu
  for_loop_context : tcontext;                   -- kontext FOR cyklu
  for_var_context  : tcontext;                   -- kontext ©¡d¡c¡ promˆnn‚ cyklu
  range_low        : pentity_var;                -- spodni mez rozsahu 
  range_high       : pentity_var;                -- horni mez rozsahu 

begin
  verify({VERIFY=}000566,typ.stype not in tdatatypeset:[dt_array,dt_uarray]);

  -- p©ipravit speci ln¡ metodu
  a_type_prepare(typ,tst,false,binfo,xinfo,pproc,pproc_context,data.pvar,bl,initvars);

  -- zjistit si b zov˜ typ pole
  ptyp:=typ.base.getctype;

{ Tohle za n s ji‘ udˆlalo [a_type_array_resolve_complex].
  -- analyzovat b zov˜ typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;
}
  -- vznikl nov˜ deklarativn¡ region
  d_create_region(pproc_context,data.for_region,for_loop_context);

  -- zalo‘it ©¡d¡c¡ promˆnnou cyklu
  d_create_internal(for_loop_context,pentity(data.for_var),for_var_context,et_var,^id_int_forvar);
  data.for_var^.typ.settype(typ.srange.getctype);
  data.for_var^.mclass:=mc_auto;
  data.for_var^.vmode:=vm_direct;
  data.for_var^.vaccess:=va_const;
  d_end_internal(data.for_var^,true);

  -- dohledat promˆnnou odpov¡daj¡c¡ doln¡ a horn¡ mezi rozsahu
  a_find_executing_range(pproc_context,range_low,range_high);
  
  -- vygenerujeme variantu s explicitnˆ uveden˜m rozsahem...
  if range_low<>nil then
    -- for @I in range_low..range_high loop
    blfor:=b_make_for(for_loop_context,binfo,data.for_var,data.for_region,bfo_normal,
      x_make_range(for_loop_context,xinfo,erk_static,typ.srange.getctype,
        x_make_component_var(for_loop_context,xinfo,range_low),
        x_make_component_var(for_loop_context,xinfo,range_high)
        )
      );

  -- ...nebo pres cel˜ rozsah typu?
  else
    -- for @I in @PARAM:range loop
    blfor:=b_make_for(for_loop_context,binfo,data.for_var,data.for_region,bfo_normal,
      x_make_component_type(for_loop_context,xinfo,typ.srange.getctype)
      );
    end if;
  a_list_append(bl^.sub,blfor);

  -- zavolat speci ln¡ metodu
  a_make_action_on_prefix(pproc,for_loop_context,ptyp,tst,blfor^.sub,^a_make_prefix_array,data,binfo,xinfo);

  --unimplemented({UNIMP=}000199);

  -- konec deklarace metody
  d_end_internal(pproc^,true);
  end a_type_array;



----------------------------------------------------------------------------------------------------
procedure a_type_array_resolve_complex (
    typ            : in out tentity_type) =      -- analyzovan˜ symbol
-- Vyhodnot¡, zda je pot©eba pro zadan˜ typ komplexn¡ inicializace.
-- P©i t‚ p©¡le‘itosti sou‡asnˆ analyzuje b zov˜ typ pole.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;               -- typ b ze pole

begin
  -- zjistit si b zov˜ typ pole
  ptyp:=typ.base.getctype;

  -- analyzovat b zov˜ typ pole
  if ptyp^.stype<>dt_class then
    a_type(ptyp^);
    end if;

  -- komplexn¡ inicializaci se prov d¡ v p©¡padˆ, ‘e m  typ pole nebo jeho b ze po‡ te‡n¡ hodnotu
  if typ.init.isset or ptyp^.init.isset then
    typ.tinit:=ti_complex;
    end if;
  end a_type_array_resolve_complex;



----------------------------------------------------------------------------------------------------
procedure a_type =
-- Anal˜za typu. Pokud je to pot©eba, tak vygeneruje podprogramy pro
-- inicializaci, finalizaci a adjustment zadan‚ho typu.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    #template generate_special_methods(generator);
    -- Pro aktu ln¡ typ vygeneruje pot©ebn‚ speci ln¡ metody pomoc¡ gener toru [generator].
    ------------------------------------------------------------------------------------------------
      -- INIT
      if typ.tinit=ti_complex then
        generator(typ,tst_init);
        end if;

      -- neobsahuje typ n hodou t©¡du ?
      if t_contains_class(typ) then 
        --%%TODO(#FOR) Nahradit meta-for-cyklem nebo se spolehnout na rozv¡jen¡ cykl–.
        for spec in succ tst_init..tspectype:last loop
          generator(typ,spec);
          end loop;
        end if;
      #end generate_special_methods;

with
  standard,console;

begin
  verify({VERIFY=}000576,typ.etype<>et_type);

  -- analyzovat jen dosud neanalyzovan‚ symboly
  if typ.analyzed<>as_none then return; end if;

  -- symbol je pr vˆ analyzov n
  typ.analyzed:=as_analyzing;

  -- analyzovat p©edka
  if typ.ancestor.isset then
    -- analyzovat p©edka
    a_type(pentity_type(typ.ancestor.getcentity)^);

    -- p©evz¡t p©¡znak komplexn¡ inicializace (t¡mto zp–sobem se zajist¡
    -- komplexn¡ inicializace nap©¡klad pro jednoduch‚ typy odvozen‚ jako
    -- private extension od komplexn¡ch typ–)
    if pentity_type(typ.ancestor.getcentity)^.tinit<>ti_normal then
      typ.tinit:=pentity_type(typ.ancestor.getcentity)^.tinit;
      end if;
    end if;

  -- vygenerovat speci ln¡ metody tohoto typu
  case typ.stype
    -- pole, neomezen‚ pole
    when dt_array, dt_uarray do
        -- vyhodnotit, jestli je pro tento typ po‘adov na komplexn¡ inicializace
        a_type_array_resolve_complex(typ);

        -- vygenerovat speci ln¡ metody
        generate_special_methods(a_type_array);
      {
        -- INIT
        if typ.tinit=ti_complex then
          a_type_array(typ,tst_init);
          end if;

        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_array(typ,tst_entry);

          -- EXIT
          a_type_array(typ,tst_exit);

          -- ADJUST
          a_type_array(typ,tst_adjust);
          end if;
      }
    -- ©etˆzec, neomezen˜ ©etˆzec
    when dt_string, dt_ustring do
        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          write_line(sym_get_qid(^typ));

          --unimplemented({UNIMP=}000200);
      {
          -- INIT
          a_type_string(typ,tst_init);

          -- ENTRY se negeneruje, proto‘e ©etˆzec t©¡d vznik  v‘dy pr zdn˜ a jin˜ p©¡pad nenastane
          v ‘nˆ??? a co vno©en‚ t©¡dy?
          a_type_string(typ,tst_entry);

          -- EXIT
          a_type_string(typ,tst_exit);

          -- ADJUST
          a_type_string(typ,tst_adjust);
      }
          end if;

    -- record
    when dt_record do
        -- vyhodnotit, jestli je pro tento typ po‘adov na komplexn¡ inicializace
        a_type_record_resolve_complex(typ);

        -- vygenerovat speci ln¡ metody
        generate_special_methods(a_type_record);
      {
        -- INIT
        if typ.tinit=ti_complex then
          a_type_record(typ,tst_init);
          end if;

        -- neobsahuje typ n hodou t©¡du ?
        if t_contains_class(typ) then 
          -- ENTRY
          a_type_record(typ,tst_entry);

          -- EXIT
          a_type_record(typ,tst_exit);

          -- ADJUST
          a_type_record(typ,tst_adjust);
          end if;
      }
    -- t©¡da
    when dt_class     do -- nic nedˆlat, to se ©e¨¡ p©¡mo

    -- v¨echny ostatn¡ typy
    when others do
    {
        -- INIT
        a_type_others(typ,tst_init);

        -- ENTRY
        a_type_others(typ,tst_entry);

        -- EXIT
        a_type_others(typ,tst_exit);

        -- ADJUST
        a_type_others(typ,tst_adjust);
    }

    end case;

  -- symbol byl analyzov n
  typ.analyzed:=as_analyzed;
  end a_type;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_qualified =
-- Sestav¡ kvalifikovan‚ vol n¡ podprogramu pro inicializace, finalizace nebo
-- adjustment zadan‚ho typu/t©¡dy.
----------------------------------------------------------------------------------------------------
var
  x_param          : pexpitem;
  srch             : tentitysearch;
  typ_context      : tcontext;

begin
  verify({VERIFY=}000562,not typ.stable[tst].isset);

  -- pro zjednodu¨en¡ si sestavit kontext typu
  typ_context:=sym_primary_context(typ);

  -- budou nˆjak‚ parametry ?
  if instance<>nil

    -- hodnotu m me k dispozici => dohledat parametr
    then
      -- dohledat parametr
      srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_param);
      verify({VERIFY=}000579,(srch.psym=nil) or (srch.psym^.etype<>et_param));

      -- sestavit v˜raz
      x_param:=x_make_param(typ_context,xinfo,instance,pentity_param(srch.psym));

      -- u stringu a pole jeste predame rozsah inicializace (pokud je o‡ek v n)
      if typ.stype in dts_index then
        -- dohledat spodn¡ mez
        srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_low);

		-- pokud existuje spodn¡ mez mus¡ bt hledan‚ho typu a mus¡ existovat i horn¡ mez
		if srch.psym<>nil then
          verify({VERIFY=}000686,(srch.psym=nil) or (srch.psym^.etype<>et_param));

          -- sestavit v˜raz
          x_param^.next:=x_make_param(typ_context,xinfo,
            crange.low,
            pentity_param(srch.psym)
            );

          -- dohledat horn¡ mez
          srch.find_local_all(sym_primary_context(pentity_special(typ.stable[tst].getcentity)^.typ.getctype^),id_int_high);
          verify({VERIFY=}000735,(srch.psym=nil) or (srch.psym^.etype<>et_param));

          -- sestavit v˜raz
          x_param^.next^.next:=x_make_param(typ_context,xinfo,
            crange.high,
            pentity_param(srch.psym)
            );
		  end if;
        end if;

    -- ‘ dn‚ parametry nebudou
    else
      x_param:=nil;
      end if;

  -- sestavit p©¡kaz
  result:=b_make_cmd(typ_context,binfo,
    x_make_call_spec(typ_context,xinfo,tst,pentity_special(typ.stable[tst].getcentity),
      prefix,
      x_param
      )
    );
  end a_type_make_call_qualified;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call =
-- Sestav¡ vol n¡ podprogramu pro inicializace, finalizace nebo adjustment
-- zadan‚ho typu.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000623,typ.stype=dt_class);

  -- zavolat
  result:=a_type_make_call_qualified(typ,binfo,xinfo,tst,nil,crange,instance);
  end a_type_make_call;



----------------------------------------------------------------------------------------------------
procedure a_type_make_call_ancestor =
-- Sestav¡ vol n¡ podprogramu pro inicializace, finalizace nebo adjustment
-- p©edka zadan‚ho typu. Dohled  prvn¡ speci ln¡ metodu v hierarchii p©edk–.
-- Pokud ‘ dnou nenalezne, ‘ dn‚ vol n¡ nevygeneruje.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity_type;               -- p©edek

begin
  verify({VERIFY=}000622,typ.stype<>dt_class);

  -- dohledat metodu p©edka
  ancestor:=pentity_type(typ.ancestor.getuentity);
  while (ancestor<>nil) and then not ancestor^.stable[tst].isset loop 
    ancestor:=pentity_type(ancestor^.ancestor.getuentity);
    end loop;

  -- nenalezlo-li se, tak se nic generovat nebude
  if ancestor=nil then
    result:=nil;
    return;
    end if;

  -- zavolat
  result:=a_type_make_call_qualified(ancestor^,binfo,xinfo,tst,x_make_this(sym_primary_context(typ),xinfo,^typ),crange,nil);
  end a_type_make_call_ancestor;



----------------------------------------------------------------------------------------------------
procedure get_index_type_range =
-- Vr t¡ rozsah indexovan‚ho typu.
----------------------------------------------------------------------------------------------------
begin
  -- pokud se jedn  o string nebo pole
  if typ^.stype=dt_array or typ^.stype=dt_string then
    -- spodn¡ a doln¡ rozsah inicializace
    crange.low:=x_make_imm_uniint(context,xinfo,typ^.srange.getctype^.lval);
    crange.high:=x_make_imm_uniint(context,xinfo,typ^.srange.getctype^.hval);
    end if;
  end get_index_type_range;


end ca_type;
