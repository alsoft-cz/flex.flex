----------------------------------------------------------------------------------------------------
module public cc_type =
-- P©eklada‡ Flexu.
-- Operace s typy.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.06.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def,cc_def.cc_entity,cc_def.cc_unitype;

----- %%TECH —rovnˆ typov‚ kompatibility -----------------------------------------------------------
-- Pro ur‡en¡ typov‚ kompatibility se pou‘¡vaj¡ n sleduj¡c¡ stupnˆ
-- 1. Nekompatibiln¡ - typy jsou nekompatibiln¡ a hodnoty nelze nijak
--        konvertovat
-- 2. Explicitnˆ konvertibiln¡ - konverzi hodnoty zdojov‚ho typu lze
--        explicitnˆ prov‚st jazykovou konstrukc¡ Kvalifikovan˜ v˜raz
-- 3. Konvertibiln¡ - hodnotu zdrojov‚ho typu lze implicitnˆ konvertovat na
--        hodnotu c¡lov‚ho typu za cenu zmˆny bin rn¡ reprezentace
-- 4. Dynamicky bin rnˆ shodn‚ - hodnotu zdrojov‚ho typu lze implicitnˆ
--        dynamicky konvertovat na hodnotu c¡lov‚ho typu (p©edat odkazem bez
--        zmˆny bin rn¡ reprezentace)
-- 5. Staticky bin rnˆ shodn‚ - hodnotu zdrojov‚ho typu lze implicitnˆ
--        staticky konvertovat na hodnotu c¡lov‚ho typu (p©edat hodnotou
--        bez zmˆny bin rn¡ reprezentace)
-- 6. Identick‚ - porovn van‚ typy jsou stejn‚
----------------------------------------------------------------------------------------------------

type
  -- £rovnˆ kompatibility
  tcomplevel       = enum
      tcl_incompatible;                          -- nekompatibiln¡ typy
      tcl_convertible;                           -- konvertibiln¡
      tcl_dynamic_identical;                     -- dynamicky bin rnˆ shodn‚
      tcl_static_identical;                      -- staticky bin rnˆ shodn‚
      tcl_identical;                             -- shodn‚
      end enum;
  tcomplevelset    = set of tcomplevel;

type
  ----- %%TECH T©¡dy operac¡ nad v˜razy typ– T1 a T2 -----------------------------------------------
  -- Ka‘d˜ oper tor (a dal¨¡ konstrukty ve v˜razu) pat©¡ do nˆjak‚ t©¡dy
  -- operace, pro kterou jsou definov na pravidla kompatibility mezi typy
  -- operand–. T©¡dy nejsou zavedeny pro un rn¡ oper tory.
  --   Existuj¡ t©i speci ln¡ t©¡dy, kter‚ neodpov¡daj¡ oper tor–m, ale kter‚
  -- se pou‘¡vaj¡ explicitnˆ pro ur‡en¡ kompatibility dvou v˜raz–:
  --   -- TOC_TRANSFORM: Kontrola kompatibility typy v˜razu (typ T2)
  --      a o‡ek van‚ho typu v˜razu (typ T1). Pou‘¡v  se v druh‚ f zi typov‚
  --      kontroly p©i ¨¡©en¡ typu shora.
  --   -- TOC_REF: Kontrola kompatibility typu v˜razu (typ T2) vzhledem k typu
  --      parametru (typ T1) s m¢dem [ IN ] OUT.
  --   -- TOC_SYMMETRIC: Skupina pravidel pro konverzi hodnot jednoduch˜ch
  --      univerz ln¡ch typ– na neuniverz ln¡ typy. Kontrola je definov na
  --      jako symetrick  vzhledem k typ–m operand–. P©¡klad: je-li jedna
  --      z b z¡ ©etˆzcov‚ho operandu oper toru & nebo := univerz ln¡, mus¡
  --      b˜t druh  kompatibiln¡ v t©¡dˆ TOC_SYMMETRIC.
  --------------------------------------------------------------------------------------------------

  -- t©¡da operace nad v˜razy typ– T1 a T2
  toperclass       = enum
      toc_none;                                  -- definitoricky nekompatibiln¡
      -- oper tory
      toc_aritm;                                 -- value(T1) Aritmetick˜ oper tor value(T2)
      toc_raritm;                                -- value(T1) Real aritm. oper. value(T2)
      toc_iaritm;                                -- value(T1) Integer aritm. oper. value(T2)
      toc_set;                                   -- value(T1) Set operator value(T2)
      toc_concat;                                -- value(T1) & value(T2)
      toc_logical;                               -- value(T1) AND/OR/XOR value(T2)
      toc_shift;                                 -- value(T1) SHL/SHR value(T2)
      toc_bit;                                   -- value(T1) BIT_AND/BIT_OR/BIT_XOR value(T2)
      toc_rel_compare;                           -- value(T1) Comparison operator value(T2)
      toc_rel_order;                             -- value(T1) Ordering operator value(T2)
      toc_rel_member;                            -- value(T1) [ not ] in value(T2)
      -- p©etypov n¡
      toc_typecast;                              -- T1(value(T2))
      toc_interface_cast;                        -- interface cast T1(var(T2))
      toc_symmetric;                             -- symetrick  konverze
      -- p©ed v n¡ parametr–
      toc_param_class;                           -- modifik tory CLASS nebo VIRTUAL
      toc_param_unchecked;                       -- modifik tor UNCHECKED
      toc_param_in;                              -- oby‡ejn˜ IN parametr
      toc_param_out;                             -- oby‡ejn˜ OUT parametr
      -- transformace a p©i©azen¡
      toc_assign;                                -- var(T1) := value(T2)
      toc_transform;                             -- transformace value(T2) --> value(T1)
      -- ostatn¡ operace
      toc_range;                                 -- value(T1) .. value(T2)
      end enum;
  toperclassset    = set of toperclass;

{%OFF}
var
  toperclasstxt    : const array toperclass of t_char32str := [
      for toc_none            use 'none',
      for toc_aritm           use 'aritm',
      for toc_raritm          use 'raritm',
      for toc_iaritm          use 'iaritm',
      for toc_set             use 'set',
      for toc_concat          use 'concat',
      for toc_logical         use 'logical',
      for toc_shift           use 'shift',
      for toc_bit             use 'bit',
      for toc_rel_compare     use 'rel_compare',
      for toc_rel_order       use 'rel_order',
      for toc_rel_member      use 'rel_member',
      for toc_typecast        use 'typecast',
      for toc_interface_cast  use 'interface_cast',
      for toc_symmetric       use 'symmetric',
      for toc_param_class     use 'param_class',
      for toc_param_unchecked use 'param_unchecked',
      for toc_param_in        use 'param_in',
      for toc_param_out       use 'param_out',
      for toc_assign          use 'assign',
      for toc_transform       use 'transform',
      for toc_range           use 'range'];
{%ON}

const
  -- re ln  aritmetika
  tocs_raritm      = toperclassset:[toc_aritm,toc_raritm];
  -- celo‡¡seln  aritmetika
  tocs_iaritm      = toperclassset:[toc_aritm,toc_iaritm];

type
  -- typ v˜sledku operace
  tresulttype      = enum
      trt_none;                                  -- nic
      trt_left;                                  -- typ lev‚ho operandu (T1)
      trt_right;                                 -- typ prav‚ho operandu (T2)
      trt_resolve;                               -- rozhodnout mezi T1 a T2
      trt_uniarray_el;                           -- univerz ln¡ pole of el:type
      trt_uniarray_er;                           -- univerz ln¡ pole of er:type
      trt_unireal;                               -- univerz ln¡ real
      trt_unilogical;                            -- univerz ln¡ logical
      end enum;

{%OFF}
var
  tresulttypetxt   : const array tresulttype of t_char32str := [
      for trt_none        use 'none',
      for trt_left        use 'left',
      for trt_right       use 'right',
      for trt_resolve     use 'resolve',
      for trt_uniarray_el use 'uniarray_el',
      for trt_uniarray_er use 'uniarray_er',
      for trt_unireal     use 'unireal',
      for trt_unilogical  use 'unilogical'];
{%ON}

{
  -- typ rozsahu
  tboundstype      = enum
      tbs_static;                                -- statick‚ meze
      tbs_dynamic;                               -- dynamick‚ meze
      end enum;
}


----------------------------------------------------------------------------------------------------
class public typeview = extend c_flex_class;
-- Pohled na typ
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static init (
        _context   : in tcontext{tentity};       -- kontext
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ pohled na zadan˜ typ.
    ------------------------------------------------------------------------------------------------
    static initunchecked (
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ Unchecked view na zadan˜ typ.
    ------------------------------------------------------------------------------------------------
    static initfull (
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ Full view na zadan˜ typ (pokud to lze, tj. jen v p©¡padˆ, ‘e
    -- by to standardnˆ bylo Partial view).
    ------------------------------------------------------------------------------------------------
    static initaggregate;
    -- Sestav¡ pohled na libovoln˜ agreg tn¡ typ.
    ------------------------------------------------------------------------------------------------
    static tview return ttypeview;
    -- Typ pohledu.
    ------------------------------------------------------------------------------------------------
    static stype return tdatatype;
    -- Datov˜ typ.
    ------------------------------------------------------------------------------------------------
    static isclass return t_logical;
    -- True, je-li typ t©¡da.
    ------------------------------------------------------------------------------------------------
    static compat return typecompat;
    -- Determinace kompatibility.
    ------------------------------------------------------------------------------------------------
    static evaluated return tentitydeclared;
    -- —rove¤ vyhodnocen¡ typu.
    ------------------------------------------------------------------------------------------------
    static tagged return t_logical;
    -- True, je-li typ tagged.
    ------------------------------------------------------------------------------------------------
    static getutype return pentity_type;
    -- Typ (v‡etnˆ NIL).
    ------------------------------------------------------------------------------------------------
    static getctype return pentity_type;
    -- Typ (NIL => internal_error).
    ------------------------------------------------------------------------------------------------
    static getancestor (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- P©edek typu (:ancestor).
    ------------------------------------------------------------------------------------------------
    static getbase (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- Typ b ze (:base).
    ------------------------------------------------------------------------------------------------
    static getrange (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- Typ rozsahu (:range).
    ------------------------------------------------------------------------------------------------
    static is_abstract return t_logical;
    -- True, je-li typ abstraktn¡.
    ------------------------------------------------------------------------------------------------
    static hassize return t_logical;
    -- True, lze-li zjistit velikost typu.
    ------------------------------------------------------------------------------------------------
    static getsize return tunidata_size;
    -- Velikost typu (:size).
    ------------------------------------------------------------------------------------------------
    static getbits return tunidata_bitsize;
    -- Velikost v bitech (:bits).
    ------------------------------------------------------------------------------------------------
    static getintaritm return tintaritm;
    -- Celo‡¡seln  aritmetika.
    ------------------------------------------------------------------------------------------------
    static getpclass return ptrclass;
    -- T©¡da pointeru.
    ------------------------------------------------------------------------------------------------
    static getpflags return ptrflagsset;
    -- Parametry pointeru.
    ------------------------------------------------------------------------------------------------
    static getpbase return ptrbase;
    -- Kompatibilita b ze pointeru.
    ------------------------------------------------------------------------------------------------
    static getpaccess return varaccess;
    -- Determinace p©¡stupu b ze pointeru.
    ------------------------------------------------------------------------------------------------
    static getpattrib return rtattribset{ptrattribset};
    -- Dynamick‚ atributy ulo‘en‚ v pointeru.
    ------------------------------------------------------------------------------------------------
    static getlval return tuniint;
    -- Doln¡ mez (:first).
    ------------------------------------------------------------------------------------------------
    static gethval return tuniint;
    -- Horn¡ mez (:last).
    ------------------------------------------------------------------------------------------------
    static getlength return tuniint;
    -- D‚lka rozsahu (:length, :last-:first+1).
    ------------------------------------------------------------------------------------------------
    static setunchecked;
    -- Zmˆn¡ pohled na Unchecked view.
    ------------------------------------------------------------------------------------------------

    end typeview;

----------------------------------------------------------------------------------------------------
procedure t_gettypeview {%%TODO(COMPATIBILITY) p©esunout do protected ‡ sti} (
    context        : in tcontext;                -- p©ekl dan  entita
    ptyp           : in pentity_type)            -- typ
                   return ttypeview;             -- typ pohledu na typ
-- Typ pohledu na typ.
----------------------------------------------------------------------------------------------------
procedure t_gettypefullview {%%TODO(COMPATIBILITY) p©esunout do protected ‡ sti} (
    ptyp           : in pentity_type)            -- typ
                   return ttypeview;             -- typ pohledu na typ
-- Typ pohledu na typ. Preferuje Full view, nikdy nevr t¡ Partial view.
----------------------------------------------------------------------------------------------------
procedure t_equal (
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-shodn‚
-- True, jsou-li typy shodn‚ nez visle na typu pohledu.
----------------------------------------------------------------------------------------------------
procedure t_equal_view (
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-shodn‚
-- True, jsou-li to shodn‚ pohledy na shodn‚ typy.
----------------------------------------------------------------------------------------------------
procedure t_typecheck (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview;                -- typy
    level          : out tcomplevel;             -- £rove¤ kompatibility
    restype        : out tresulttype);           -- typ v˜sledeku operace
-- Typov  kontrola.
----------------------------------------------------------------------------------------------------
procedure t_compatible (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-kompatibiln¡ typy
-- True, jsou-li typy kompatibiln¡ v–‡i po‘adovan‚ t©¡dˆ operace.
----------------------------------------------------------------------------------------------------
procedure t_get_compatibility_level (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return tcomplevel;            -- £rove¤ kompatibility
-- —rove¤ kompatibility typ– v–‡i po‘adovan‚ t©¡dˆ operace.
-- Slab  kontrola vynech  test determinace kompatibility.
----------------------------------------------------------------------------------------------------
procedure t_binary_identical (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-bin rnˆ identick‚
-- True, jsou-li typy bin rnˆ identick‚.
----------------------------------------------------------------------------------------------------
procedure t_descendant (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;              -- T1 je potomek T2
-- True, je-li T1 potomek T2.
----------------------------------------------------------------------------------------------------
procedure t_ancestor (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T1 je potomek T2
-- True, je-li T1 p©edek T2.
----------------------------------------------------------------------------------------------------
procedure t_derived (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T1 je p©edek nebo potomek T2
-- True, je-li T1 p©edek nebo potomek T2.
----------------------------------------------------------------------------------------------------
procedure t_get_pointer_rtattrib (
    pbase          : in ptrbase;                 -- typ b ze pointeru
    pclass         : in ptrclass;                -- t©¡da pointeru
    base           : in pentity_type;            -- b zov˜ typ
    pattrib        : in out rtattribset);        -- atributy
-- Ze zadan˜ch £daj– vypo‡¡t  mno‘inu voliteln˜ch atribut– pointeru.
-- Pozor: O‡ek v , ‘e mno‘ina PATTRIB je ji‘ inicializovan .
----------------------------------------------------------------------------------------------------
procedure t_derive_string (
    context        : in tcontext;                -- p©ekl dan  entita
    hval0          : in tuniint;                 -- po‘adovan  d‚lka
    base           : in typeview;                -- b zov˜ typ
    ptyp           : out pentity_type);          -- odvozen˜ typ
-- Odvod¡ typ constrained string o d‚lce HVAL a b zi BASE.
-- Pokud je HVAL vˆt¨¡ ne‘ maxim ln¡ dovolen , ohl s¡ varov n¡ CW_CONCAT_STRLENGTH a d‚lku o©¡zne na 
-- maxim ln¡ dovolenou.
----------------------------------------------------------------------------------------------------
procedure t_derive_string_range (
    typ            : in out tentity_type;        -- ©etˆzec
    isize          : in tunidata_size;           -- velikost intern¡ ‡ sti ©etˆzce
    hval           : in tuniint);                -- horn¡ mez ©etˆzce
-- Pro zadan˜ typ ©ˆtˆzce odvod¡ rozsah ©etˆzce.
----------------------------------------------------------------------------------------------------
procedure t_is_string_of_char (
    context        : in tcontext{tentity};       -- p©ekl dan  entita
    t              : in typeview)                -- typ
                   return t_logical;             -- T-je to string of char
-- True, je-li typ unistr/string/ustring of char/unichar.
----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_object (
    t              : in typeview)                -- typ
                   return t_logical;             -- T-typ je pointer na objekt
-- True, je-li typ pointer na objekt.
----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_unconstrained (
    context        : in tcontext{tentity};       -- p©ekl dan  entita
    t              : in typeview)                -- typ
                   return t_logical;             -- T-typ je pointer na objekt
-- True, je-li typ pointer na unconstrained array/string.
----------------------------------------------------------------------------------------------------
procedure t_is_sts (
    t              : in typeview;                -- typ
    sts            : in tdatatypeset)            -- ovˆ©ovan‚ datov‚ typy
                   return t_logical;             -- T-typ spad  do STS
-- True, je-li typ z mno‘iny STS.
----------------------------------------------------------------------------------------------------
procedure t_is_nonmod_ordinal (
    typ            : in typeview)                -- typ
                   return t_logical;             -- T-typ s pln˜m pohledem, ordin ln¡ a nemodul rn¡
-- Vrac¡ T, pokud je [typ] s pln˜m pohledem, ordin ln¡ a p©¡p. celo‡¡seln˜ bez modul rn¡ aritmetiky.
----------------------------------------------------------------------------------------------------
procedure t_is_range_inclusive (
    destt          : in typeview;                -- c¡lov˜ typ
    srct           : in typeview)                -- zdrojov˜ typ
                   return t_logical;             -- T-zdrojov˜ typ je rozsahem pod c¡lov˜m
-- Vrac¡ T, pokud je rozsah [srct] inkluzivnˆ podrozsahem [destt].
----------------------------------------------------------------------------------------------------
procedure t_is_stype (
    t              : in typeview;                -- typ
    stype          : in tdatatype)               -- ovˆ©ovan‚ datov‚ typy
                   return t_logical;             -- T-typ spad  do STS
-- True, je-li typ roven STYPE.
----------------------------------------------------------------------------------------------------
procedure t_is_composite (
    t              : in typeview)                -- typ
                   return t_logical;             -- T-je kompozitn¡
-- True, je-li typ kompozitn¡.
----------------------------------------------------------------------------------------------------
procedure t_contains_class (
    typ            : in out tentity_type)        -- zkouman˜ typ
                   return t_logical;
-- True, pokud zadan˜ typ obsahuje instanci t©¡dy jako subkomponentu.
-- (Nebo je s m t©¡da.) Ka¨le se na viditelnost struktury typu.               
----------------------------------------------------------------------------------------------------


type
  
  t_relative_range_disposition = enum
      rrd_emptyset;
      rrd_equalset;
      rrd_superset;
      rrd_subset;
      rrd_overlap_left;
      rrd_overlap_right;
      end enum;

    
----------------------------------------------------------------------------------------------------
procedure t_get_relative_range_disposition (
    t1             : in typeview;
    t2             : in typeview)
                     return t_relative_range_disposition;
-- vrati relativni rozlozeni mezi typu t1 vzhledem k typu t2
-- rrd_emptyset:      (t1:low<t2:low  and t1:high<t2:low)  or (t1:low>t2:high and t1:high>t2:high)
-- rrd_equalset:       t1:low=t2:low  and t1:high=t2:high
-- rrd_superset:      (t1:low<=t2:low and t1:high>t2:high) or (t1:low<t2:low and t1:high>=t2:high)
-- rrd_subset:        (t1:low>=t2:low and t1:high<t2:high) or (t1:low>t2:low and t1:high<=t2:high)
-- rrd_overlap_left:   t1:low<t2:low  and t1:high<=t2:high and t1:high>=t2:low
-- rrd_overlap_right:  t1:low>=t2:low and t1:low<=t2:high  and t1:high>t2:high
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
#separate private typeview;
-- Pohled na typ
----------------------------------------------------------------------------------------------------

var
  --%%TODO(???) Tohle se mi v–bec nel¡b¡. Mˆlo by to b˜t ©e¨iteln‚ p©es nˆjak‚
  -- Incomplete declarations promˆnn˜ch, abych nemusel m¡t private ‡ st t©¡dy
  -- v public ‡ sti modulu.
  nulltype         : const typeview;

type
  ptypeview        = ^typeview;



----------------------------------------------------------------------------------------------------
protected
----------------------------------------------------------------------------------------------------

type
  -- akce pro ur‡en¡ kompatibility podle porovn n¡ datov˜ch typ–
  t_type_check     = enum
      ---- jednoduch‚ kontroly ----
      ttc_incompatible;                          -- T1 nekompatibiln¡ T2
      ttc_convertible;                           -- T1 identick‚/konvertibiln¡ T2
                                                 -- Pozn mka: pouze pro zjednodu¨en¡, byl by 
                                                 -- nahraditeln˜ akcemi [ttc_simple_check], 
                                                 -- [ttc_iaritm_check], a [ttc_raritm_check], ale 
                                                 -- minim lnˆ posledn¡ dvˆ by se musely zab˜vat 
                                                 -- rozpozn n¡m univerz ln¡ch typ–
      ttc_iaritm_check;                          -- T1 p©edek/potomek/identick‚/stejn‚ aritmetiky/nekompatibiln¡ T2
      ttc_modaritm_check;                        -- T1 p©edek/potomek/identick‚/nekompatibiln¡ T2, pouze modul rn¡ aritmetika
      ttc_modaritm_left_check;                   -- T1 m  modul rn¡ aritmetiku, T2 se ignoruje
      ttc_raritm_check;                          -- T1 p©edek/potomek/identick‚/stejn‚ aritmetiky/nekompatibiln¡ T2
      ttc_simple_check;                          -- T1 p©edek/potomek/identick‚/konvertibiln¡ T2
      ttc_derived;                               -- T1 p©edek/potomek/identick‚/nekompatibiln¡ T2
      ttc_identical;                             -- T1 identick‚/nekompatibiln¡ T2
      ---- pole ----
      ttc_array;                                 -- T1 i T2 jsou pole
      ttc_uarray;                                -- T1 nebo T2 je unconstrained pole, zb˜vaj¡c¡ pole
      ttc_order_array;                           -- jako [ttc_array] pro £‡ely uspo© d n¡
      ttc_order_uarray;                          -- jako [ttc_uarray] pro £‡ely uspo© d n¡
      ---- ©etˆzce ----
      ttc_string;                                -- T1 i T2 jsou string nebo unconstrained string
      ttc_order_string;
      ---- univerz ln¡ pole ----
      ttc_uniarray;                              -- alespo¤ jeden z T1, T2 je univerz ln¡ pole, 
                                                 -- zb˜vaj¡c¡ je (unconstrained) pole nebo 
                                                 -- (unconstrained) string
      ttc_order_uniarray;                        -- jako [ttc_uniarray] pro £‡ely uspo© d n¡
      ---- speciality pro z©etˆzen¡ ----
      ttc_indexed_component;                     -- (u)string/(u)array  -- komponenta
      ttc_component_indexed;                     -- komponenta -- (u)string/(u)array
      ttc_component_component;                   -- komponenta -- komponenta
      ---- mno‘iny ----
      ttc_set;                                   -- mno‘ina -- mno‘ina
      ttc_in_set;                                -- diskr‚tn¡ IN mno‘ina
      ---- pointery ----
      ttc_pointer_assign;                        -- p©i©azen¡ pointeru
      ttc_pointer_rel;                           -- porovn n¡ pointeru
      ttc_pointer_out;                           -- p©ed n¡ pointeru jako OUT parametru
      ---- interface cast ----
      ttc_icast_class;                           -- t©¡da -- t©¡da
      ttc_icast_pointer;                         -- pointer na t©¡du -- pointer na t©¡du
      ---- NIL ----
      ttc_nil;                                   -- univerz lnˆ kompatibiln¡ NIL
      end enum;
  t_type_check_set = set of t_type_check;

{%OFF}
var
  t_type_check_txt  : const array t_type_check of t_char32str := [ 
      for ttc_incompatible        use 'compatible',
      for ttc_convertible         use 'convertible',
      for ttc_iaritm_check        use 'iaritm_check',
      for ttc_modaritm_check      use 'modaritm_check',
      for ttc_modaritm_left_check use 'modaritm_left_check',
      for ttc_raritm_check        use 'raritm_check',
      for ttc_simple_check        use 'simple_check',
      for ttc_derived             use 'derived',
      for ttc_identical           use 'identical',
      for ttc_array               use 'array',
      for ttc_uarray              use 'uarray',
      for ttc_order_array         use 'order_array',
      for ttc_order_uarray        use 'order_uarray',
      for ttc_string              use 'string',
      for ttc_order_string        use 'order_string',
      for ttc_uniarray            use 'uniarray',
      for ttc_order_uniarray      use 'order_uniarray',
      for ttc_indexed_component   use 'indexed_component',
      for ttc_component_indexed   use 'component_indexed',
      for ttc_component_component use 'component_component',
      for ttc_set                 use 'set',
      for ttc_in_set              use 'in_set',
      for ttc_pointer_assign      use 'pointer_assign',
      for ttc_pointer_rel         use 'pointer_rel',
      for ttc_pointer_out         use 'pointer_out',
      for ttc_icast_class         use 'icast_class',
      for ttc_icast_pointer       use 'icast_pointer',
      for ttc_nil                 use 'nil'];
{%ON}

const
{
  -- operace, u kter˜ch nem  smysl prov dˆt test determinace kompatibility nebo se prov d¡ jinak
  tocs_no_determination_check = toperclassset:[
      -- pro membership test se prov d¡ nad dvojic¡ <el:type,er:base>
      toc_rel_member,
      -- pro p©etypov n¡ a interface cast nem  smysl
      toc_typecast,
      toc_interface_cast];
}
  -- akce, u kter˜ch nem  smysl prov dˆt test determinace kompatibility nebo se prov d¡ jinak
  ttcs_no_determination_check = t_type_check_set:[
      -- pro z©etˆzen¡ ©etˆzce s komponentou se prov d¡ nad dvojic¡ <string:base,component:type>
      ttc_indexed_component,
      ttc_component_indexed,
      -- pro membership test se prov d¡ nad dvojic¡ <el:type,er:base> 
      ttc_in_set,
      -- pro p©etypov n¡ a interface cast nem  smysl
      ttc_icast_class,
      ttc_icast_pointer];

  -- %%TECH Pozn mka: Charakter test– TTC_SIMPLE_CHECK a TTC_STRICT_SIMPLE
  -- zaji¨Ÿuje automatickou kontrolu shodnosti aritmetik celo‡¡seln˜ch typ–.
  -- D–kaz: Aritmetiky nelze zmˆnit derivac¡ typu.

type
  -- tabulka pro kontrolu kompatibility
  t_type_check_tab = array toperclass,tdatatype,tdatatype of record
      c            : t_type_check;               -- kompatibilita/dal¨¡ kontrola
      r            : tresulttype;                -- typ v˜sledku
      a            : t_logical;                  -- T-povoleno zkr cen‚ p©i©azen¡
      end record;

var
  typecheck        : protected t_type_check_tab;

type
  -- akce pro ur‡en¡ kompatibility podle porovn n¡ pohled–
  t_view_check     = enum
      tvc_incompatible;                          -- nekompatibiln¡ pohledy
      tvc_partial;                               -- kontrola parci ln¡ch pohled–
      tvc_partial_descendant;                    -- kontrola parci ln¡ch pohled–, T1 p©edek T2
      tvc_unchecked;                             -- kontrola unchecked pohled–
      tvc_aggregate;                             -- kontrola kombinace Full view a Aggregate view
      tvc_interface;                             -- kontrola interface cast
      end enum;

{%OFF}
var
  t_view_check_txt : const array t_view_check of t_char32str := [
      for tvc_incompatible       use 'incompatible',
      for tvc_partial            use 'partial',
      for tvc_partial_descendant use 'partial_descendant',
      for tvc_unchecked          use 'unchecked',
      for tvc_aggregate          use 'aggregate',
      for tvc_interface          use 'interface'];
{%ON}

type
  -- tabulka pro kontrolu kompatibility
  t_view_check_tab = array toperclass,ttypeview,ttypeview of record
      c            : t_view_check;               -- kompatibilita/dal¨¡ kontrola
      r            : tresulttype;                -- typ v˜sledku
      end record;

var
  viewcheck        : protected t_view_check_tab;

----------------------------------------------------------------------------------------------------
procedure t_compatible_determinations (
    t1             : in typeview;                -- typ
    t2             : in typeview)                -- typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility.
-- Oba typy mus¡ b˜t pointery, z nich‘ alespo¤ jeden mus¡ b˜t unchecked.
----------------------------------------------------------------------------------------------------
procedure t_compatible_varaccesses (
    t1             : in typeview;                -- c¡lov˜ typ
    t2             : in typeview)                -- zdrojov˜ typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace p©¡stupu.
-- Oba typy mus¡ b˜t pointery. T1 mus¡ b˜t c¡lov˜ typ operace (p©i©azuje se do instance T1), T2 mus¡
-- b˜t zdrojov˜ typ (p©i©azuje se z instance T2).
----------------------------------------------------------------------------------------------------
procedure t_compatible_unchecked_pointers (
    t1             : in typeview;                -- typ
    t2             : in typeview)                -- typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility. 
-- Oba typy mus¡ b˜t pointery, z nich‘ alespo¤ jeden mus¡ b˜t unchecked.
----------------------------------------------------------------------------------------------------

end cc_type;
