----------------------------------------------------------------------------------------------------
module public cc_type =
-- P©eklada‡ Flexu.
-- Operace s typy.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.06.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def,cc_def.cc_entity,cc_def.cc_unitype;

----- %%TECH —rovnˆ typov‚ kompatibility -----------------------------------------------------------
-- Pro ur‡en¡ typov‚ kompatibility se pou‘¡vaj¡ n sleduj¡c¡ stupnˆ
-- 1. Nekompatibiln¡ - typy jsou nekompatibiln¡ a hodnoty nelze nijak
--        konvertovat
-- 2. Explicitnˆ konvertibiln¡ - konverzi hodnoty zdojov‚ho typu lze
--        explicitnˆ prov‚st jazykovou konstrukc¡ Kvalifikovan˜ v˜raz
-- 3. Konvertibiln¡ - hodnotu zdrojov‚ho typu lze implicitnˆ konvertovat na
--        hodnotu c¡lov‚ho typu za cenu zmˆny bin rn¡ reprezentace
-- 4. Dynamicky bin rnˆ shodn‚ - hodnotu zdrojov‚ho typu lze implicitnˆ
--        dynamicky konvertovat na hodnotu c¡lov‚ho typu (p©edat odkazem bez
--        zmˆny bin rn¡ reprezentace)
-- 5. Staticky bin rnˆ shodn‚ - hodnotu zdrojov‚ho typu lze implicitnˆ
--        staticky konvertovat na hodnotu c¡lov‚ho typu (p©edat hodnotou
--        bez zmˆny bin rn¡ reprezentace)
-- 6. Identick‚ - porovn van‚ typy jsou stejn‚
----------------------------------------------------------------------------------------------------

type
  -- £rovnˆ kompatibility
  tcomplevel       = enum
      tcl_incompatible;                          -- nekompatibiln¡ typy
      tcl_convertible;                           -- konvertibiln¡
      tcl_dynamic_identical;                     -- dynamicky bin rnˆ shodn‚
      tcl_static_identical;                      -- staticky bin rnˆ shodn‚
      tcl_identical;                             -- shodn‚
      end enum;
  tcomplevelset    = set of tcomplevel;

type
  ----- %%TECH T©¡dy operac¡ nad v˜razy typ– T1 a T2 -----------------------------------------------
  -- Ka‘d˜ oper tor (a dal¨¡ konstrukty ve v˜razu) pat©¡ do nˆjak‚ t©¡dy
  -- operace, pro kterou jsou definov na pravidla kompatibility mezi typy
  -- operand–. T©¡dy nejsou zavedeny pro un rn¡ oper tory.
  --   Existuj¡ t©i speci ln¡ t©¡dy, kter‚ neodpov¡daj¡ oper tor–m, ale kter‚
  -- se pou‘¡vaj¡ explicitnˆ pro ur‡en¡ kompatibility dvou v˜raz–:
  --   -- TOC_TRANSFORM: Kontrola kompatibility typy v˜razu (typ T2)
  --      a o‡ek van‚ho typu v˜razu (typ T1). Pou‘¡v  se v druh‚ f zi typov‚
  --      kontroly p©i ¨¡©en¡ typu shora.
  --   -- TOC_REF: Kontrola kompatibility typu v˜razu (typ T2) vzhledem k typu
  --      parametru (typ T1) s m¢dem [ IN ] OUT.
  --   -- TOC_SYMMETRIC: Skupina pravidel pro konverzi hodnot jednoduch˜ch
  --      univerz ln¡ch typ– na neuniverz ln¡ typy. Kontrola je definov na
  --      jako symetrick  vzhledem k typ–m operand–. P©¡klad: je-li jedna
  --      z b z¡ ©etˆzcov‚ho operandu oper toru & nebo := univerz ln¡, mus¡
  --      b˜t druh  kompatibiln¡ v t©¡dˆ TOC_SYMMETRIC.
  --------------------------------------------------------------------------------------------------

  -- t©¡da operace nad v˜razy typ– T1 a T2
  toperclass       = enum
      toc_none;                                  -- definitoricky nekompatibiln¡
      -- oper tory
      toc_aritm;                                 -- value(T1) Aritmetick˜ oper tor value(T2)
      toc_raritm;                                -- value(T1) Real aritm. oper. value(T2)
      toc_iaritm;                                -- value(T1) Integer aritm. oper. value(T2)
      toc_set;                                   -- value(T1) Set operator value(T2)
      toc_concat;                                -- value(T1) & value(T2)
      toc_logical;                               -- value(T1) AND/OR/XOR value(T2)
      toc_shift;                                 -- value(T1) SHL/SHR value(T2)
      toc_bit;                                   -- value(T1) BIT_AND/BIT_OR/BIT_XOR value(T2)
      toc_rel_compare;                           -- value(T1) Comparison operator value(T2)
      toc_rel_order;                             -- value(T1) Ordering operator value(T2)
      toc_rel_member;                            -- value(T1) [ not ] in value(T2)
      -- p©etypov n¡
      toc_typecast;                              -- T1(value(T2))
      toc_interface_cast;                        -- interface cast T1(var(T2))
      toc_symmetric;                             -- symetrick  konverze
      -- p©ed v n¡ parametr–
      toc_param_class;                           -- modifik tory CLASS nebo VIRTUAL
      toc_param_unchecked;                       -- modifik tor UNCHECKED
      toc_param_in;                              -- oby‡ejn˜ IN parametr
      toc_param_out;                             -- oby‡ejn˜ OUT parametr
      -- transformace a p©i©azen¡
      toc_assign;                                -- var(T1) := value(T2)
      toc_transform;                             -- transformace value(T2) --> value(T1)
      -- ostatn¡ operace
      toc_range;                                 -- value(T1) .. value(T2)
      end enum;
  toperclassset    = set of toperclass;

const
  -- re ln  aritmetika
  tocs_raritm      = toperclassset:[toc_aritm,toc_raritm];
  -- celo‡¡seln  aritmetika
  tocs_iaritm      = toperclassset:[toc_aritm,toc_iaritm];

type
  -- typ v˜sledku operace
  tresulttype      = enum
      trt_none;                                  -- nic
      trt_left;                                  -- typ lev‚ho operandu (T1)
      trt_right;                                 -- typ prav‚ho operandu (T2)
      trt_resolve;                               -- rozhodnout mezi T1 a T2
      trt_uniarray_el;                           -- univerz ln¡ pole of el:type
      trt_uniarray_er;                           -- univerz ln¡ pole of er:type
      trt_unireal;                               -- univerz ln¡ real
      trt_unilogical;                            -- univerz ln¡ logical
      end enum;
{
  -- typ rozsahu
  tboundstype      = enum
      tbs_static;                                -- statick‚ meze
      tbs_dynamic;                               -- dynamick‚ meze
      end enum;
}


----------------------------------------------------------------------------------------------------
class public typeview = extend c_flex_class;
-- Pohled na typ
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static init (
        _context   : in tcontext{tentity};       -- kontext
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ pohled na zadan˜ typ.
    ------------------------------------------------------------------------------------------------
    static initunchecked (
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ Unchecked view na zadan˜ typ.
    ------------------------------------------------------------------------------------------------
    static initfull (
        _ptyp      : in pentity_type);           -- skute‡n˜ typ
    -- Sestav¡ Full view na zadan˜ typ (pokud to lze, tj. jen v p©¡padˆ, ‘e
    -- by to standardnˆ bylo Partial view).
    ------------------------------------------------------------------------------------------------
    static initaggregate;
    -- Sestav¡ pohled na libovoln˜ agreg tn¡ typ.
    ------------------------------------------------------------------------------------------------
    static tview return ttypeview;
    -- Typ pohledu.
    ------------------------------------------------------------------------------------------------
    static stype return tdatatype;
    -- Datov˜ typ.
    ------------------------------------------------------------------------------------------------
    static isclass return t_logical;
    -- True, je-li typ t©¡da.
    ------------------------------------------------------------------------------------------------
    static compat return typecompat;
    -- Determinace kompatibility.
    ------------------------------------------------------------------------------------------------
    static evaluated return tentitydeclared;
    -- —rove¤ vyhodnocen¡ typu.
    ------------------------------------------------------------------------------------------------
    static tagged return t_logical;
    -- True, je-li typ tagged.
    ------------------------------------------------------------------------------------------------
    static getutype return pentity_type;
    -- Typ (v‡etnˆ NIL).
    ------------------------------------------------------------------------------------------------
    static getctype return pentity_type;
    -- Typ (NIL => internal_error).
    ------------------------------------------------------------------------------------------------
    static getancestor (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- P©edek typu (:ancestor).
    ------------------------------------------------------------------------------------------------
    static getbase (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- Typ b ze (:base).
    ------------------------------------------------------------------------------------------------
    static getrange (
        _context   : in tcontext{tentity})       -- kontext
                   return typeview;              -- pohled na p©edka
    -- Typ rozsahu (:range).
    ------------------------------------------------------------------------------------------------
    static is_abstract return t_logical;
    -- True, je-li typ abstraktn¡.
    ------------------------------------------------------------------------------------------------
    static hassize return t_logical;
    -- True, lze-li zjistit velikost typu.
    ------------------------------------------------------------------------------------------------
    static getsize return tunidata_size;
    -- Velikost typu (:size).
    ------------------------------------------------------------------------------------------------
    static getbits return tunidata_bitsize;
    -- Velikost v bitech (:bits).
    ------------------------------------------------------------------------------------------------
    static getintaritm return tintaritm;
    -- Celo‡¡seln  aritmetika.
    ------------------------------------------------------------------------------------------------
    static getpclass return ptrclass;
    -- T©¡da pointeru.
    ------------------------------------------------------------------------------------------------
    static getpflags return ptrflagsset;
    -- Parametry pointeru.
    ------------------------------------------------------------------------------------------------
    static getpbase return ptrbase;
    -- Kompatibilita b ze pointeru.
    ------------------------------------------------------------------------------------------------
    static getpaccess return varaccess;
    -- Determinace p©¡stupu b ze pointeru.
    ------------------------------------------------------------------------------------------------
    static getpattrib return rtattribset{ptrattribset};
    -- Dynamick‚ atributy ulo‘en‚ v pointeru.
    ------------------------------------------------------------------------------------------------
    static getlval return tuniint;
    -- Doln¡ mez (:first).
    ------------------------------------------------------------------------------------------------
    static gethval return tuniint;
    -- Horn¡ mez (:last).
    ------------------------------------------------------------------------------------------------
    static getlength return tuniint;
    -- D‚lka rozsahu (:length, :last-:first+1).
    ------------------------------------------------------------------------------------------------
    static setunchecked;
    -- Zmˆn¡ pohled na Unchecked view.
    ------------------------------------------------------------------------------------------------

    end typeview;

----------------------------------------------------------------------------------------------------
procedure t_gettypeview {%%TODO(COMPATIBILITY) p©esunout do protected ‡ sti} (
    context        : in tcontext;                -- p©ekl dan  entita
    ptyp           : in pentity_type)            -- typ
                   return ttypeview;             -- typ pohledu na typ
-- Typ pohledu na typ.
----------------------------------------------------------------------------------------------------
procedure t_gettypefullview {%%TODO(COMPATIBILITY) p©esunout do protected ‡ sti} (
    ptyp           : in pentity_type)            -- typ
                   return ttypeview;             -- typ pohledu na typ
-- Typ pohledu na typ. Preferuje Full view, nikdy nevr t¡ Partial view.
----------------------------------------------------------------------------------------------------
procedure t_equal (
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-shodn‚
-- True, jsou-li typy shodn‚ nez visle na typu pohledu.
----------------------------------------------------------------------------------------------------
procedure t_equal_view (
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-shodn‚
-- True, jsou-li to shodn‚ pohledy na shodn‚ typy.
----------------------------------------------------------------------------------------------------
procedure t_typecheck (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview;                -- typy
    level          : out tcomplevel;             -- £rove¤ kompatibility
    restype        : out tresulttype);           -- typ v˜sledeku operace
-- Typov  kontrola.
----------------------------------------------------------------------------------------------------
procedure t_compatible (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-kompatibiln¡ typy
-- True, jsou-li typy kompatibiln¡ v–‡i po‘adovan‚ t©¡dˆ operace.
----------------------------------------------------------------------------------------------------
procedure t_get_compatibility_level (
    context        : in tcontext;                -- p©ekl dan  entita
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-p©i©azovac¡ oper tor
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return tcomplevel;            -- £rove¤ kompatibility
-- —rove¤ kompatibility typ– v–‡i po‘adovan‚ t©¡dˆ operace.
-- Slab  kontrola vynech  test determinace kompatibility.
----------------------------------------------------------------------------------------------------
procedure t_binary_identical (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T-bin rnˆ identick‚
-- True, jsou-li typy bin rnˆ identick‚.
----------------------------------------------------------------------------------------------------
procedure t_descendant (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;              -- T1 je potomek T2
-- True, je-li T1 potomek T2.
----------------------------------------------------------------------------------------------------
procedure t_ancestor (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T1 je potomek T2
-- True, je-li T1 p©edek T2.
----------------------------------------------------------------------------------------------------
procedure t_derived (
    context        : in tcontext;                -- p©ekl dan  entita
    t1             : in typeview;                -- typy
    t2             : in typeview)                -- typy
                   return t_logical;             -- T1 je p©edek nebo potomek T2
-- True, je-li T1 p©edek nebo potomek T2.
----------------------------------------------------------------------------------------------------
procedure t_checktype (
    context        : in tcontext;                -- p©ekl dan  entita
    ptyp           : in pentity_type);           -- typ
-- Dodate‡n  kontrola typu - zejm‚na z vislost¡ na jin˜ch typech.
-- Nap©¡klad pro typ procedura kontroluje £plnost deklarace typ– parametr–.
----------------------------------------------------------------------------------------------------
procedure t_get_pointer_rtattrib (
    pbase          : in ptrbase;                 -- typ b ze pointeru
    pclass         : in ptrclass;                -- t©¡da pointeru
    base           : in pentity_type;            -- b zov˜ typ
    pattrib        : in out rtattribset);        -- atributy
-- Ze zadan˜ch £daj– vypo‡¡t  mno‘inu voliteln˜ch atribut– pointeru.
-- Pozor: O‡ek v , ‘e mno‘ina PATTRIB je ji‘ inicializovan .
----------------------------------------------------------------------------------------------------
procedure t_derive_string (
    context        : in tcontext;                -- p©ekl dan  entita
    hval0          : in tuniint;                 -- po‘adovan  d‚lka
    base           : in typeview;                -- b zov˜ typ
    ptyp           : out pentity_type);          -- odvozen˜ typ
-- Odvod¡ typ constrained string o d‚lce HVAL a b zi BASE.
-- Pokud je HVAL vˆt¨¡ ne‘ maxim ln¡ dovolen , ohl s¡ varov n¡ CW_CONCAT_STRLENGTH a d‚lku o©¡zne na 
-- maxim ln¡ dovolenou.
----------------------------------------------------------------------------------------------------
procedure t_derive_string_range (
    typ            : in out tentity_type;        -- ©etˆzec
    isize          : in tunidata_size;           -- velikost intern¡ ‡ sti ©etˆzce
    hval           : in tuniint);                -- horn¡ mez ©etˆzce
-- Pro zadan˜ typ ©ˆtˆzce odvod¡ rozsah ©etˆzce.
----------------------------------------------------------------------------------------------------
procedure t_is_string_of_char (
    context        : in tcontext{tentity};       -- p©ekl dan  entita
    t              : in typeview)                -- typ
                   return t_logical;             -- T-je to string of char
-- True, je-li typ unistr/string/ustring of char/unichar.
----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_object (
    t              : in typeview)                -- typ
                   return t_logical;             -- T-typ je pointer na objekt
-- True, je-li typ pointer na objekt.
----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_unconstrained (
    context        : in tcontext{tentity};       -- p©ekl dan  entita
    t              : in typeview)                -- typ
                   return t_logical;             -- T-typ je pointer na objekt
-- True, je-li typ pointer na unconstrained array/string.
----------------------------------------------------------------------------------------------------
procedure t_is_sts (
    t              : in typeview;                -- typ
    sts            : in tdatatypeset)            -- ovˆ©ovan‚ datov‚ typy
                   return t_logical;             -- T-typ spad  do STS
-- True, je-li typ z mno‘iny STS.
----------------------------------------------------------------------------------------------------
procedure t_is_stype (
    t              : in typeview;                -- typ
    stype          : in tdatatype)               -- ovˆ©ovan‚ datov‚ typy
                   return t_logical;             -- T-typ spad  do STS
-- True, je-li typ roven STYPE.
----------------------------------------------------------------------------------------------------
procedure t_is_composite (
    t              : in typeview)                -- typ
                   return t_logical;             -- T-je kompozitn¡
-- True, je-li typ kompozitn¡.
----------------------------------------------------------------------------------------------------
procedure t_contains_class (
    typ            : in out tentity_type)        -- zkouman˜ typ
                   return t_logical;
-- True, pokud zadan˜ typ obsahuje instanci t©¡dy jako subkomponentu.
-- (Nebo je s m t©¡da.) Ka¨le se na viditelnost struktury typu.               
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
#separate private typeview;
-- Pohled na typ
----------------------------------------------------------------------------------------------------

var
  --%%TODO(???) Tohle se mi v–bec nel¡b¡. Mˆlo by to b˜t ©e¨iteln‚ p©es nˆjak‚
  -- Incomplete declarations promˆnn˜ch, abych nemusel m¡t private ‡ st t©¡dy
  -- v public ‡ sti modulu.
  nulltype         : const typeview;

type
  ptypeview        = ^typeview;



----------------------------------------------------------------------------------------------------
protected
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure t_compatible_determinations (
    t1             : in typeview;                -- typ
    t2             : in typeview)                -- typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility.
-- Oba typy mus¡ b˜t pointery, z nich‘ alespo¤ jeden mus¡ b˜t unchecked.
----------------------------------------------------------------------------------------------------
procedure t_compatible_varaccesses (
    t1             : in typeview;                -- c¡lov˜ typ
    t2             : in typeview)                -- zdrojov˜ typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace p©¡stupu.
-- Oba typy mus¡ b˜t pointery. T1 mus¡ b˜t c¡lov˜ typ operace (p©i©azuje se do instance T1), T2 mus¡
-- b˜t zdrojov˜ typ (p©i©azuje se z instance T2).
----------------------------------------------------------------------------------------------------
procedure t_compatible_unchecked_pointers (
    t1             : in typeview;                -- typ
    t2             : in typeview)                -- typ
                   return t_logical;             -- T-kompatibiln¡ determinace
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility. 
-- Oba typy mus¡ b˜t pointery, z nich‘ alespo¤ jeden mus¡ b˜t unchecked.
----------------------------------------------------------------------------------------------------

end cc_type;