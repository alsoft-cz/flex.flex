----------------------------------------------------------------------------------------------------
module public cx_def =
-- Překladač Flexu.
-- Definice stromového tvaru výrazu a základní operace.
----------------------------------------------------------------------------------------------------
-- Ondra : 19.06.2001 : Vytvořil
----------------------------------------------------------------------------------------------------
--
-- %%X Poznámky:
--
--   -- Co by se stalo, kdybych univerzální typy fyzicky nevytvářel (T.TYP=NIL),
--      ale jen do uzlu poznamenal T.STYPE=ST_UNIxxx ?
--        Zřejmě by to přivodilo problémy při přebírání výsledku výrazu jako
--      hodnota konstanty.
--        Také bych mohl univerzální typy vytvořit jednou pro vždy při spuštění
--      překladu. Pak by například platilo "1:TYPE=1:TYPE", což v této
--      implementaci není pravda - co je správně ?
--
--   -- Vyřešit postavení operátoru ::. Kde je jeho místo v BNF ? Má být vůbec
--      součástí jazyka ?
--
--   -- Typ REFIMM    : nemel by se spis vzdy uvazovat REFEXPR a hodnotu konstanty
--      si z vyrazu vzdycky znova vzit ? Kdyz budu promennou inicializovat
--      adresou jine promenne, tak to stejne neni konstanta. Pro makra (:value)
--      by se tam holt musela udelat nejaka odbocka.
--
--   -- V typech REFxxx by se mělo rozlišovat mezi vyhodnocením výrazu
--      a vyhodnocením souvisejícího symbolu.
--
--   -- Jak se pozná, že byla proměnná inicializována metapříkazem ? Potom
--      je totiž var^.init.x.x=nil.
--
--   -- Zpřesnit chybová hlášení pro nekompatibilní operandy.
--
--   -- Neměl by se v první fázi typové kontroly aritmetických výrazů volit
--      typ :root_base z toho, který se bere teď ?
--
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_lexsym,cc_def.cc_tree,cc_attr;

use
  cc_sym,
  cc_base.cc_rtl;

----- %%TECH ---------------------------------------------------------------------------------------
-- Výraz je převeden do obecného stromového tvaru. Strom je tvořen
-- jednosměrně zřetězenými seznamy (složka NEXT), které jsou na sebe
-- navěšeny do úrovní (složka SUB). Reprezentuje-li tedy uzel stromu
-- binární operátor, pak jeho operandy jsou SUB a SUB^.NEXT.
--   Jednotlivé uzly se vytváří procedurou NEWNODE. Uzly zařazené na vrchol
-- stromu vytváří NEWTREE.                                                    
--                                                                            
-- Poznámka: Překladač Flexu je zřejmě unikátní v tom, že má neceločíselný    
-- počet průchodů (tzv. Hausdorfův překladač) - průchodů stromem je 5.5.      
--   Mezifáze CX_RESOLVE se provádí buď při formální analýze nebo v typové    
-- kontrole a to jen někdy a jen pro některé typy uzlů, ale zato je           
-- rekurzivní - lze ji tedy považovat za p-samostatný průchod. :-)            
--                                                                            
-- Analýza výrazu je rozdělena do těchto hlavních průchodů:                   
--   1. Syntaktická analýza (CX_PARSE)
--      - obecný výraz převede do stromu, kontroluje BNF výrazu, ale          
--        neprovádí typové ani žádné jiné kontroly                            
--   2. Formální analýza (CX_FORM)
--      - analýza výrazu zdola nahoru                                         
--   -. Mezifáze: Vyhodnocení nejednoznačných typů (CX_RESOLVE)               
--   3. Typová kontrola (CX_TYPE)                                             
--      - analýza výrazu shora dolů                                           
--   4. Optimalizace (CX_OPT)                                                 
--      - vyhodnocení statických podvýrazů                                    
--   5. Finalizace (CX_FINAL)                                                 
--      - závěrečná kontrola optimalizovaného výrazu, dosazení typů konstant, 
--        kontrola mezí                                                       
--                                                                            
-- Strom se postupně zpracovává všemi fázemi analýzy. Některé typy podvýrazů  
-- se analyzují dopředu: např. pro prefix atributu se provádí typová kontrola 
-- i optimalizace během formální analýzy. Obecně lze takto "mimo pořadí"      
-- analyzovat jakýkoli podvýraz, který nijak nezávisí na nadřazeném uzlu.     
--   Každý průchod ignoruje uzly (včetně všech podstromů), které již byly     
-- analyzovány jím nebo dalším průchodem.                                     
----------------------------------------------------------------------------------------------------

type
  -- druh očekávaného výrazu
  expkind          = enum
      ek_any;                                    -- libovolný
    --ek_type;                                   -- uvedeného typu
      ek_typename;                               -- jméno typu
      ek_typename_or_const_integer;              -- jméno typu nebo konstantní celočíselný výraz
      ek_rangetype;                              -- jméno diskrétního typu nebo const. rozsah
      ek_range;                                  -- rozsah nebo jméno diskrétního typu
      ek_assign;                                 -- přiřazení/volání
      ek_cond;                                   -- podmínka
      ek_sym;                                    -- symbol - libovolný
      ek_sym_proc;                               -- symbol - procedura
      ek_sym_proc_proctype;                      -- symbol - procedura nebo proceduralni typ
      ek_sym_static_subprogram;                  -- symbol - statický podprogram (procedure nebo static)
      ek_sym_var_proc;                           -- symbol - proměnná nebo procedura
      ek_sym_virtual;                            -- symbol - virtuální metoda
      ek_sym_export;                             -- symbol vhodný pro export nebo trasování k exportu
      ek_sym_import;                             -- symbol vhodný pro import nebo trasování k importu
      ek_var_pointer;                            -- proměnná typu pointer
      ek_var_ordinal;                            -- proměnná diskrétního typu
      ek_expr_ordinal;                           -- výraz diskrétního typu
      ek_expr_integer;                           -- celočíselný výraz bez znaménka
      ek_expr_tag;                               -- výraz typu TAG
      ek_const;                                  -- konstantní - libovolný
      ek_const_ord;                              -- konstantní - ordinální
      ek_const_int;                              -- konstantní - celočíselný
      ek_const_logical;                          -- konstantní - logický
      ek_const_real;                             -- konstantní - reálný
      ek_const_str;                              -- konstantní - string of char
      ek_context_extend;                         -- kontext - EXTEND
      ek_context_expose;                         -- kontext - EXPOSE
      ek_context_with;                           -- kontext - WITH
      ek_context_use;                            -- kontext - USE
      ek_context_message;                        -- kontext - jméno zprávy
      ek_context_send;                           -- kontext - SEND nebo RAISE
      ek_context_accept;                         -- kontext - CATCH
      ek_context_case;                           -- kontext - konst. výběr uvedeného typu v CASE
      end enum;
  expkindset       = set of expkind;

const
  -- druh výrazu : jméno procedury
  eks_subprogram   = expkindset:[ek_sym,ek_sym_proc,ek_sym_proc_proctype,ek_sym_static_subprogram,ek_sym_var_proc,ek_sym_virtual,ek_sym_export,ek_sym_import];
  -- druh výrazu : operace se zprávou
  eks_message      = expkindset:[ek_context_send,ek_context_accept];
  -- druh výrazu : vazba na jiný modul/třídu
  eks_link         = expkindset:[ek_context_extend,ek_context_expose,ek_context_with,ek_context_use];

type
  -- fáze překladu výrazu 
  expphase         = enum
      ep_syntax;                                 -- syntaktická analýza
      ep_form;                                   -- formální kontrola
      ep_type;                                   -- typová kontrola
      ep_opt;                                    -- optimalizace
      ep_final;                                  -- finalizace
      end enum;
var
  -- fáze překladu výrazu 
{%OFF}
 expphase_export_id : const array expphase of t_char32str := [
      for ep_syntax use 'syntax',
      for ep_form   use 'form',
      for ep_type   use 'type',
      for ep_opt    use 'opt',
      for ep_final  use 'final'];
{%ON}

type
  -- použití podvýrazu
  expusage         = enum
      eu_none;                                   -- nic; neurčeno
      -- speciální typy výrazů
      eu_formal;                                 -- formální výraz; hodnota je nezajímavá
      -- očekáván adresní výraz
      eu_addr;                                   -- zjistit adresu
      eu_write;                                  -- přiřadit jinou hodnotu
      eu_change;                                 -- přečíst hodnotu; změnit; přiřadit zpět
      -- očekávána hodnota
      eu_read;                                   -- přečíst hodnotu a transformovat
      eu_use;                                    -- přečíst hodnotu a přiřadit jinam
      end enum;
  expusageset      = set of expusage;

----------------------------------------------------------------------------------------------------
class public expinfo = extend c_flex_class;
-- informace o průběhu analýzy
----------------------------------------------------------------------------------------------------

    var
      phase        : expphase;                   -- fáze překladu
      kind         : expkind;                    -- druh očekávaného výrazu
      typ          : pentity_type;               -- požadovaný typ výrazu

    ------------------------------------------------------------------------------------------------
    static init (
        _typ       : in pentity_type);           -- požadovaný typ výrazu
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    end expinfo;



----- %%TECH ---------------------------------------------------------------------------------------
-- Postup při přidávání nových uzlů:
--   1. do NODETYPE přidat identifikátor (dále odkazovaný jako xxx)
--   2. vytvořit objekt EXPxxx jako (nepřímý) potomek EXPNODE
--       a pointer PEXPxxx
--   3. v objektu implementovat alespoň metodu DUMP
--   4. do procedur CX_FORM.A_FORM, CX_TYPE.A_TYPE, CX_OPT.A_OPT
--      a CX_FINAL.A_FINAL doplnit obsluhu nového typu uzlu
----------------------------------------------------------------------------------------------------

type
  -- typy uzlů
  nodetype         = enum
      -- %%TECH NT_NONE se používá pro reprezentaci nezparsovatelnýchh výrazů
      nt_none;                                   -- neznámý uzel
      -- uzly použité poprvé při syntaktické analýze
      nt_operator;                               -- operátor
      nt_unary;                                  -- unární operátor
      nt_component;                              -- komponenta
      nt_imm;                                    -- přímá hodnota (konstanta)
      nt_range;                                  -- rozsah
      nt_list;                                   -- seznam výrazů (parametrů procedury)
      nt_item;                                   -- položka seznamu výrazů
      nt_index;                                  -- selektor pole
      nt_ref;                                    -- reference
      nt_deref;                                  -- dereference
      nt_attrib;                                 -- atribut
      nt_aggregate;                              -- agregát
      nt_this;                                   -- THIS
      nt_interface_cast;                         -- přetypování na interface
      -- uzly použité pouze v syntaktické analýze a formální kontrole
      nt_current;                                -- CURRENT
      -- uzly použité poprvé při formální kontrole
      nt_call;                                   -- volání procedury
      nt_typecast;                               -- přetypování
      nt_send;                                   -- odeslání zprávy
      nt_accept;                                 -- přijetí zprávy
      -- uzly použité poprvé při kompilátorem řízeném generování výrazů (typicky v globální analýze)
      nt_callspec;                               -- volání speciální metody
      nt_fake_tag;                               -- fake tag interfacu třídy
      nt_call_rtl;                               -- přímé volání funkce RTL
--    nt_tag_field;                              -- položka tagu
      nt_task_var_slot;                          -- task promenna
      end enum;
  nodetypeset      = set of nodetype;

var
  -- typy uzlů
{%OFF}
  nodetype_export_id : const array nodetype of t_char32str := [
      for nt_none           use 'none',             
      for nt_operator       use 'operator',         
      for nt_unary          use 'unary',            
      for nt_component      use 'component',        
      for nt_imm            use 'imm',              
      for nt_range          use 'range',            
      for nt_list           use 'list',             
      for nt_item           use 'item',             
      for nt_index          use 'index',            
      for nt_ref            use 'ref',              
      for nt_deref          use 'deref',            
      for nt_attrib         use 'attrib',           
      for nt_aggregate      use 'aggregate',        
      for nt_this           use 'this',             
      for nt_interface_cast use 'interface_cast',   
      for nt_current        use 'current',          
      for nt_call           use 'call',             
      for nt_typecast       use 'typecast',         
      for nt_send           use 'send',             
      for nt_accept         use 'accept',           
      for nt_callspec       use 'callspec',         
      for nt_fake_tag       use 'fake_tag',         
      for nt_call_rtl       use 'call_rtl',
      for nt_task_var_slot  use 'task_var_slot'];
{%ON}

const
  -- operátory
  nts_operator     = nodetypeset:[nt_operator,nt_unary];
  -- uzly s nejednoznačným typem
  nts_ambiguous    = nodetypeset:[nt_operator,nt_unary,nt_range];

type
  -- třídy uzlů
  nodeclass        = enum
      nc_undef;                                  -- dosud neznámá třída uzlu
      nc_none;                                   -- nic
      nc_module;                                 -- modul
      nc_value;                                  -- hodnota/mezivýsledek
      nc_composite;                              -- složená hodnota (typicky rozsah)
      nc_var;                                    -- adresa proměnné
    --nc_metavar;                                -- metaproměnná
      nc_proc;                                   -- adresa procedury
      nc_message;                                -- zpráva
      nc_type;                                   -- typ
      nc_tag;                                    -- tag typu
      end enum;
  nodeclassset     = set of nodeclass;

var
  -- třídy uzlů
{%OFF}
  nodeclass_export_id : const array nodeclass of t_char32str := [
      for nc_undef     use 'undef',
      for nc_none      use 'none',
      for nc_module    use 'module',
      for nc_value     use 'value',
      for nc_composite use 'composite',
      for nc_var       use 'var',
      for nc_proc      use 'proc',
      for nc_message   use 'message',
      for nc_type      use 'type',
      for nc_tag       use 'tag']; 
{%ON}

const
  -- proměnná 
  ncs_var              = nodeclassset:[nc_var];
  -- hodnota
  ncs_value            = ncs_var + nodeclassset:[nc_value];
  -- podprogramy - pohled na volatelný podprogram
  ncs_actual_subprogram= nodeclassset:[nc_proc];
  -- podprogramy - pohled na ne nutně volatelný podprogram
  ncs_formal_subprogram= nodeclassset:[nc_proc,nc_none];
  -- zprávy
  ncs_message          = nodeclassset:[nc_message];
  -- entity s adresou
  ncs_ref              = ncs_var + ncs_actual_subprogram + ncs_message;
  -- výběr
  ncs_range            = nodeclassset:[nc_type,nc_composite];
  ncs_choice           = ncs_value + ncs_range;
  -- prefix selektoru komponenty
  ncs_prefix_component = ncs_value + ncs_formal_subprogram + nodeclassset:[nc_none,nc_module,nc_type];
  -- prefix indexu
  ncs_prefix_index     = ncs_value + nodeclassset:[nc_type];
  -- prefix dereference
  ncs_prefix_deref     = ncs_value + nodeclassset:[nc_type];
  -- prefix agregátu
  ncs_prefix_aggregate = nodeclassset:[nc_type];
  -- prefix přetypování a interface cast
  ncs_prefix_typecast  = nodeclassset:[nc_type];
  -- prefix odeslání zprávy
  ncs_prefix_send      = ncs_value + nodeclassset:[nc_message];
  -- prefix přijetí zprávy
  ncs_prefix_accept    = ncs_value + nodeclassset:[nc_message,nc_type];
  -- kód zprávy
  ncs_message_code     = ncs_value + nodeclassset:[nc_message];

type
  -- příznaky uzlu
  nodeflags        = enum
      nf_name;                                   -- uzel je jméno
      nf_top;                                    -- uzel je na úplném vrcholu stromu
      nf_parenthesized;                          -- uzel je uzávorkován
      nf_reference;                              -- uzel se bude referencovat
      nf_dereference;                            -- uzel se bude dereferencovat
      nf_const;                                  -- uzel je konstantní z pohledu sémantiky jazyka
                                                 -- (viz komentář "%%TECH Detekce výrazů 
                                                 -- konstantních v důsledku optimalizace" v [cx_opt])
      end enum;
  nodeflagset      = set of nodeflags;

var
  -- příznaky uzlu
{%OFF}
  nodeflags_export_id : const array nodeflags of t_char32str := [
      for nf_name          use 'name',
      for nf_top           use 'top',
      for nf_parenthesized use 'parenthesized',
      for nf_reference     use 'reference',
      for nf_dereference   use 'dereference',
      for nf_const         use 'const'];
{%ON}

type
  ----- %%TECH Způsob zřetězení uzlu vzhledem k typu -----------------------------------------------
  -- Pro typovou kontrolu operátoru & se musí určovat tzv. způsob zřetězení.
  -- Určuje, zda je podvýraz podřetězec nebo jedna komponenta řetězce.
  --   Tento příznak se určuje pouze pro operátor & v druhé fázi typové
  -- kontroly. Využívá se ještě při finalizaci a při generování kódu.
  --   Výpočet příznaku provádí X_GETCONCATKIND a je uložen v každém uzlu
  -- ve složce CONCATKIND. Výpočet je podobný průběhu typové kontroly &.
  --------------------------------------------------------------------------------------------------

  -- způsob zřetězení uzlu vzhledem k typu
  nodeconcatkind     = enum
      nck_unknown;                               -- neví se
      nck_substring;                             -- podřetězec
      nck_subarray;                              -- podpole
      nck_component;                             -- komponenta
      end enum;                                  
  nodeconcatkindset  = set of nodeconcatkind;

var
  nodeconcatkindtxt : const array nodeconcatkind of t_char32str := [
      for nck_unknown   use 'unknown',
      for nck_substring use 'substring',
      for nck_subarray  use 'subarray',
      for nck_component use 'component'];

type
  -- index typu 
  typeindex        = t_unsigned;

  -- seznam typů
  typeviewlist     = string of record
      t            : aliased typeview;           -- typ
      el           : typeindex;                  -- indexy typů, ze kterých byl odvozen
      er           : typeindex;                  -- indexy typů, ze kterých byl odvozen
      psym         : pentity;                    -- související symbol (přetížený operátor)
      end record;
  ptypeviewlist    = ^typeviewlist;

const
  tlistinit        = 4;
  tlistdelta       = 4;


---- Run-time kontroly -----------------------------------------------------------------------------

type
  -- trida run-time kontroly
  t_runtime_check_class = enum
      rchcl_gen;                                 -- provadi se behem generovani vyrazu
      rchcl_load;                                -- provadi se po nacteni vyrazu pro prirazeni
      end enum;
  
  -- typ run-time kontrol
  t_runtime_check  = enum
      rch_ordinal_overflow;                      -- ordinalni preteceni/podteceni
      rch_ordinal_range;                         -- ordinalni kontrola mezi
      rch_index_string;                          -- indexovani retezce
      rch_index_array;
   -- rch_tag_contrained;
   -- rch_tag_unconstrained;
      end enum;
  t_runtime_check_set = set of t_runtime_check;


---- Dopředné deklarace ----------------------------------------------------------------------------

class expnode;          type pexpnode          = ^class expnode;
class expnoper;         type pexpnoper         = ^class expnoper;
class expambiguous;     type pexpambiguous     = ^class expambiguous;
class expoper;          type pexpoper          = ^class expoper;
class expunary;         type pexpunary         = ^class expunary;
class expcomponent;     type pexpcomponent     = ^class expcomponent;
class expimm;           type pexpimm           = ^class expimm;
class exprange;         type pexprange         = ^class exprange;
class explist;          type pexplist          = ^class explist;
class expitem;          type pexpitem          = ^class expitem;
class expindex;         type pexpindex         = ^class expindex;
class expref;           type pexpref           = ^class expref;
class expderef;         type pexpderef         = ^class expderef;
class expattrib;        type pexpattrib        = ^class expattrib;
class expaggregate;     type pexpaggregate     = ^class expaggregate;
class expinterfacecast; type pexpinterfacecast = ^class expinterfacecast;
class expcallspec;      type pexpcallspec      = ^class expcallspec;
class expthis;          type pexpthis          = ^class expthis;
class expcurrent;       type pexpcurrent       = ^class expcurrent;
class expfaketag;       type pexpfaketag       = ^class expfaketag;
class expcallrtl;       type pexpcallrtl       = ^class expcallrtl;
class exptaskvarslot;   type pexptaskvarslot   = ^class exptaskvarslot;
{
class exptagfield;      type pexptagfield      = ^class exptagfield;
}
class abstract expunary0;  type pexpunary0  = ^class expunary0;
class abstract expbinary0; type pexpbinary0 = ^class expbinary0;



----------------------------------------------------------------------------------------------------
class public expnode = extend c_flex_construct;
-- Uzel
----------------------------------------------------------------------------------------------------

    var
      ntype        : nodetype;                   -- typ uzlu
      nclass       : nodeclass;                  -- třída uzlu
      nflags       : nodeflagset;                -- další příznaky
      org          : expphase;                   -- fáze vzniku tohoto uzlu
      zprac        : expphase;                   -- fáze zpracování tohoto uzlu
      sub          : pexpnode;                   -- podřízený uzel
      next         : pexpnode;                   -- následující uzel
      t            : aliased typeview;           -- typ uzlu
      pos          : lexposblock;                -- začátek a konec uzlu ve zdrojovém textu
      rta_avail    : rtattribset;                -- dynamické atributy poskytované tímto uzlem
      rta_modes    : t_rtattrib_modes;           -- způsob zjištění dynamických atributů 
                                                 -- poskytovaných tímto uzlem
      rta_used     : rtattribset;                -- dynamické atributy použité v nadřazeném uzlu
      concatkind   : nodeconcatkind;             -- způsob zřetězení uzlu

    ------------------------------------------------------------------------------------------------
    static newtype (
      --curr       : in out tentity;             -- překládaný prvek
        curr       : in tcontext;                -- překládaný prvek
        stype      : in tdatatype;               -- datový typ
        size       : in tunidata_size);          -- velikost
    -- Vytvoří dočasný typ a doplní do něj implicitní hodnoty.
    ------------------------------------------------------------------------------------------------
    static settype (
        curr       : in tcontext;                -- překládaný prvek
        ptyp       : in pentity_type);           -- typ
    -- Přiřadí výrazu typ.
    ------------------------------------------------------------------------------------------------
    static settypeunchecked (
        curr       : in tcontext;                -- překládaný prvek
        ptyp       : in pentity_type);           -- typ
    -- Přiřadí výrazu Unchecked view typu.
    ------------------------------------------------------------------------------------------------
    static setunchecked (
        curr       : in tcontext;                -- překládaný prvek
        ptyp       : in typeview);               -- typ
    -- Přiřadí typ výrazu UNCHECKED.
    ------------------------------------------------------------------------------------------------
    virtual gettype (
        index      : in typeindex;               -- kolikátý typ chceme
        typ        : out ptypeview);             -- typ
    -- INDEX-tý typ uzlu
    ------------------------------------------------------------------------------------------------
    virtual gettypecount return typeindex;
    -- Počet typů uzlu.
    ------------------------------------------------------------------------------------------------
    virtual getsymbol return pentity;
    -- Symbol související s uzlem (je-li nějaký).
    ------------------------------------------------------------------------------------------------
    virtual dump return t_char32str;
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    static loadpos (
        npos       : in nodeposset;              -- nastavovaná pozice
        level      : in lexlevel);               -- který lexikální symbol
    -- Nastaví pozici uzlu podle pozice posledního symbolu.
    ------------------------------------------------------------------------------------------------
    static setpos (
        _pos       : in lexposblock);            -- pozice uzlu
    -- Nastaví pozici uzlu podle dodané pozice.
    ------------------------------------------------------------------------------------------------
    static setpospart (
        npos       : in nodeposset;              -- nastavovaná pozice
        _pos       : in lexpos);                 -- pozice lexikálního symbolu
    -- Nastaví pozici uzlu podle dodané pozice symbolu.
    ------------------------------------------------------------------------------------------------
    static getpos (
        _pos       : out lexposblock);           -- pozice výrazu
    -- Zjistí pozici výrazu.
    ------------------------------------------------------------------------------------------------
    -- static errpos;
    -- Dosadí pozici výrazu do posledního chybového hlášení.
    ------------------------------------------------------------------------------------------------
    static set_run_check (
        rcheck_class : in t_runtime_check_class;
        rcheck       : in t_runtime_check);
    -- nastavi behovou kontrolu [check] na vyrazu pro tridu behovych kontrol [rcheck_class]
    -- zpusobi interni chybu pokud takova kontrola jiz nastavena
    ------------------------------------------------------------------------------------------------
    static get_run_checks (
        rcheck_class : in t_runtime_check_class)
                       return t_runtime_check_set;
    -- vrati mnozinu behovych kontrol vyrazu pro tridu behovych kontrol [rcheck_class]
    ------------------------------------------------------------------------------------------------
    static get_rangecheck_type (
        rcheck_class : in t_runtime_check_class)
                       return typeview;  -- typ proti kteremu je treba provest kontrolu mezi
    -- vrati typ kontroly mezi pro tridu behovych kontrol [rcheck_class]
    ------------------------------------------------------------------------------------------------
    static set_rangecheck_type (
        rcheck_class : in t_runtime_check_class;
        typ          : in typeview);             -- typ proti kteremu je treba provest kontrolu mezi
    -- nastavi typ kontroly mezi pro tridu behovych kontrol [rcheck_class]
    ------------------------------------------------------------------------------------------------
    end expnode;



----------------------------------------------------------------------------------------------------
class public abstract expunary0 = extend expnode;
-- Uzel s jedním podvýrazem.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode);              -- podvýraz
    -- Oddělí podvýraz od uzlu.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode);               -- podvýraz
    -- Sloučí podvýraz s uzlem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode);              -- podvýraz
    -- Vrátí podvýraz uzlu.
    ------------------------------------------------------------------------------------------------

    end expunary0;



----------------------------------------------------------------------------------------------------
class public abstract expbinary0 = extend expnode;
-- Uzel se dvěma podvýrazy.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;           -- podvýrazy
        er         : out pexpnode);          -- podvýrazy
    -- Oddělí podvýrazy od uzlu.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;           -- podvýrazy
        er         : in pexpnode);          -- podvýrazy
    -- Sloučí podvýrazy s uzlem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;           -- podvýrazy
        er         : out pexpnode);          -- podvýrazy
    -- Vrátí podvýrazy uzlu.
    ------------------------------------------------------------------------------------------------

    end expbinary0;



----------------------------------------------------------------------------------------------------
class public expambiguous = extend expnode;
-- Uzel s nejednoznačně určeným typem
----------------------------------------------------------------------------------------------------

    ----- %%TECH Reprezentace uzlů s nejednoznačným typem ------------------------------------------
    -- Uzly, které mohou mít nejednoznačný typ, jsou odvozeny od EXPAMBIGUOS.
    -- Každý typ uzlu má přidělen index (od nuly) odvozený od pořadí přiřazení
    -- k uzlu.
    --   Z výkonnostních důvodů se používá nestandardní způsob uložení seznamu
    -- typů. Nultý typ je uložen ve složce EXPNODE.T a indexy typů podvýrazů,
    -- ze kterých byl odvozen jsou v EXPAMBIGUOUS.EL0 a ER0, symbol v PSYM0.
    -- První až (TLEN-1)-tý typ je uložen v poli TLIST.
    --   Vzhledem k tomu, že většina výrazů ma typ určen jednoznačně, převažují
    -- rychlostní výhody tohoto řešení nad jeho nesystémovostí.
    ------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static addtype (
        typ        : in typeview;                -- přidávaný typ
        el         : in typeindex;               -- indexy zdrojových typů
        er         : in typeindex;               -- indexy zdrojových typů
        psym       : in pentity);                -- související symbol
    -- Do tabulku typů přidá zadaný typ (i kdyby byl redundantní).
    ------------------------------------------------------------------------------------------------
    procedure checktype (
        psym       : in pentity)                 -- související symbol
                   return t_logical;             -- T-nalezen takový typ
    -- True, má-li výraz přiřazen typ, se kterým souvisí zadaný symbol.
    ------------------------------------------------------------------------------------------------
    static gettypeinfo (
        index      : in typeindex;               -- kolikátý typ chceme
        typ        : out ptypeview;              -- typ
        eli        : out typeindex;              -- indexy zdrojových typů
        eri        : out typeindex;              -- indexy zdrojových typů
        psym       : out pentity);               -- související symbol
    -- INDEX-tý typ uzlu včetně doplňkových informací.
    ------------------------------------------------------------------------------------------------
    static gettypesym (
        index      : in typeindex;               -- kolikátý typ chceme
        psym       : out pentity);               -- související symbol
    -- Symbol související s INDEX-tým typem uzlu.
    ------------------------------------------------------------------------------------------------
    static gettypeorigin (
        index      : in typeindex;               -- kolikátý typ chceme
        eli        : out typeindex;              -- indexy zdrojových typů
        eri        : out typeindex);             -- indexy zdrojových typů
    -- Zdrojové typy související s INDEX-tým typem uzlu.
    ------------------------------------------------------------------------------------------------
    static resolve (
        index      : in typeindex);              -- kolikátý typ chceme
    -- Zvolí INDEX-tý typ jako definitivní.
    ------------------------------------------------------------------------------------------------
    static isresolved return t_logical;
    -- True, má-li uzel přiřazen definitivní typ.
    ------------------------------------------------------------------------------------------------

  protected

    var
      tlist        : ptypeviewlist;              -- seznam typů
      set0         : t_logical;                  -- již byl použit nultý typ
      el0          : typeindex;                  -- z čeho byl odvozen nultý typ (EXPNODE.T)
      er0          : typeindex;                  -- z čeho byl odvozen nultý typ (EXPNODE.T)
      psym0        : pentity;                    -- související symbol
      resolved     : t_logical;                  -- T-vyhodnoceny nejednoznačné typy

    end expambiguous;



  ----- %%TECH Přirozený typ operandů --------------------------------------------------------------
  -- Pro každý operátor se vypočítává tzv. přirozený typ operandů. Při
  -- generování se všechny operandy před provedením operace konvertují na
  -- tento typ.
  -- Příklady:
  --   -- pro aritmetické operatárory + - je přirozený typ operandů shodný s
  --      typem uzlu (výsledku)
  --   -- pro relační operátory < > je přirozený typ operandů stejný jako
  --      kdyby se provádělo například sčítání
  --------------------------------------------------------------------------------------------------

type
  -- arita operátoru
  expoperarity     = enum
      eoa_1;                                     -- unární operátor
      eoa_2;                                     -- binární operátor
      eoa_n;                                     -- n-ární operátor
      end enum;

var
  -- arita operátoru
{%OFF}
  expoperarity_export_id : const array expoperarity of t_char32str := [
    for eoa_1 use '1',
    for eoa_2 use '2',
    for eoa_n use 'n'];
{%ON}

----------------------------------------------------------------------------------------------------
class public expnoper = extend expambiguous;
-- Obecný operátor
----------------------------------------------------------------------------------------------------

    var
      assign       : t_logical;                  -- T-přiřazení
      arity        : expoperarity;               -- arita operátoru

    end expnoper;



  ----- %%TECH -----------------------------------------------------------
  -- Postup při přidávání nových binárních operátorů:
  --   1. do EXPOPERTYPE přidat identifikátor
  --   2. informace o operátoru zařadit do EXPOPERINFO
  --   3. jeho textovou reprezentaci zařadit do EXPOPERTXT
  --   4. rozpoznání operátoru podle lexikálního elementu zařadit
  --      do LEXTOBINARYOPER
  --   5. nový operátor zohlenit v překladu zkráceného přiřazení
  --      (CX_EXPR.A_PRIKAZ) - zakázat nebo doplnit překlad pravé strany
  --   6. doplnit související pravidla do řídících tabulek v CX_TYPE
  --------------------------------------------------------------------------------------------------

type
  -- typy operátorů
  expopertype      = enum
      op_none;
      -- přiřazení
      op_assign;
      -- aritmetické operátory
      op_add; op_sub;
      op_mul; op_div; op_idiv; op_imod;
      op_shl; op_shr;
      -- relační operátory
      -- %%TECH Pozor ! Na pořadí deklarace relačních operátorů je závislý
      -- generátor kódu (resp. jeho interní tabulky)
      op_eq; op_ne; op_lt; op_le; op_gt; op_ge;
      op_in; op_notin;
      -- množinové operátory
      op_union; op_diff; op_isect;
      -- řetězcové operátory
      op_concat;
      -- logické operátory
      op_and; op_or; op_xor; op_and_then; op_or_else;
      -- bitové operátory
      op_bitand; op_bitor; op_bitxor;
      -- různé další operátory
      op_op1 {; op_op2; op_op3; op_op4};
      end enum;
  expopertypeset = set of expopertype;

var
  -- textová reprezentace binárních operátorů pro dump
  expopertxt       : const array expopertype of t_char32str := [
      for op_none     use '',
      -- přiřazení
      for op_assign   use ':=',
      -- aritmetické operátory
      for op_add      use '+',
      for op_sub      use '-',
      for op_mul      use '*',
      for op_div      use '/',
      for op_idiv     use 'DIV',
      for op_imod     use 'MOD',
      for op_shl      use 'SHL',
      for op_shr      use 'SHR',
      -- relační operátory
      for op_eq       use '=',
      for op_ne       use '<>',
      for op_lt       use '<',
      for op_le       use '<=',
      for op_gt       use '>',
      for op_ge       use '>=',
      for op_in       use 'IN',
      for op_notin    use 'NOT IN',
      -- množinové operátory
      for op_union    use 'UNION',
      for op_diff     use 'DIFF',
      for op_isect    use 'INTERSECT',
      -- řetězcové operátory
      for op_concat   use '&',
      -- logické operátory
      for op_and      use 'AND',
      for op_or       use 'OR',
      for op_xor      use 'XOR',
      for op_and_then use 'AND THEN',
      for op_or_else  use 'OR ELSE',
      -- bitové operátory
      for op_bitand   use 'BIT AND',
      for op_bitor    use 'BIT OR',
      for op_bitxor   use 'BIT XOR',
      -- různé další operátory
      for op_op1      use '::' {, op_op2, op_op3, op_op4}];

var
  -- textová reprezentace binárních operátorů pro XML dump
{%OFF}
  expopertype_export_id : const array expopertype of t_char32str := [
      for op_none     use 'none',
      for op_assign   use 'assign',
      for op_add      use 'add',
      for op_sub      use 'sub',
      for op_mul      use 'mul',
      for op_div      use 'div',
      for op_idiv     use 'idiv',
      for op_imod     use 'imod',
      for op_shl      use 'shl',
      for op_shr      use 'shr',
      for op_eq       use 'eq',
      for op_ne       use 'ne',
      for op_lt       use 'lt',
      for op_le       use 'le',
      for op_gt       use 'gt',
      for op_ge       use 'ge',
      for op_in       use 'in',
      for op_notin    use 'notin',
      for op_union    use 'union',
      for op_diff     use 'diff',
      for op_isect    use 'isect',
      for op_concat   use 'concat',
      for op_and      use 'and',
      for op_or       use 'or',
      for op_xor      use 'xor',
      for op_and_then use 'and_then',
      for op_or_else  use 'or_else',
      for op_bitand   use 'bitand',
      for op_bitor    use 'bitor',
      for op_bitxor   use 'bitxor',
      for op_op1      use 'op1'];
{%ON}

  ----- %%TECH Priorita operátorů ------------------------------------------------------------------
  -- Tabulky priorit operátorů mají pouze pomocný význam a vyjadřují
  -- postavení operátoru v hierarchii BNF. Číslování priority je stejné
  -- pro unární i binární operátory.
  --   Používají se např. při sestavování zkráceného přiřazení
  -- (viz CX_PARSE.A_PRIKAZ).
  --------------------------------------------------------------------------------------------------

type
  -- šíření typu výsledku do podvýrazů v top-down fázích analýzy
  typecontrol      = enum
      tc_none;                                   -- typ dodaný shora dále nešířit
      tc_left;                                   -- pouze do levého operandu
      tc_right;                                  -- pouze do pravého operandu
      tc_both;                                   -- do obou operandů
      tc_concat;                                 -- do obou operandů, podle pravidel pro zřetězení
      end enum;

  -- asociativita operátoru
  expoperasoc      = enum
      eoa_none;                                  -- neasociativní: a op b op c op d = ((a op b) op c) op d
      eoa_full;                                  -- asociativní:   a op b op c = (a op b) op c = a op (b op c)
      eoa_pfull;                                 -- p-asociativní: a op b op c op d = a op (b jiný_op c) op d
      end enum;
  expoperasocset   = set of expoperasoc;

  -- komutativita operátorů
  expopercom       = enum
      eoc_none;                                  -- nekomutativní: a op b = a op b
      eoc_full;                                  -- komutativní:   a op b = b op a
      eoc_pfull;                                 -- p-komutativní: a op b op c = a op c op b
      end enum;
  expopercomset    = set of expopercom;

type
  -- informace o binárním operátoru
  toperinfo        = record
      pri          : t_unsigned;                 -- priorita
      com          : expopercom;                 -- komutativita
      asoc         : expoperasoc;                -- asociativita
      tc           : typecontrol;                -- šíření typu do podvýrazů
      oc           : toperclass;                 -- třída operace
      oop          : tooperator;                 -- odpovídající přetížitelný operátor
      cmp          : tcmpoper;                   -- odpovídající porovnávací operace
      tdiff        : t_logical;                  -- mezi typem výsledku a typy operandů je
                                                 -- podstatný rozdíl (viz CX_UTIL.X_RESOLVE)
      end record;

var
  -- vlastnosti binárních operátorů
  expoperinfo      : const array expopertype of toperinfo := [
      for op_none      use [for pri use 0, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_none       , for oop use oop_none  , for cmp use cmp_none, for tdiff use false],
      -- přiřazení
      for op_assign    use [for pri use 1, for com use eoc_none , for asoc use eoa_none , for tc use tc_right, for  oc use toc_assign     , for oop use oop_assign, for cmp use cmp_none, for tdiff use false],
      -- aritmetické operátory
      for op_add       use [for pri use 4, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_aritm      , for oop use oop_add   , for cmp use cmp_none, for tdiff use false],
      for op_sub       use [for pri use 4, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_both, for   oc use toc_aritm      , for oop use oop_sub   , for cmp use cmp_none, for tdiff use false],
      for op_mul       use [for pri use 6, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_aritm      , for oop use oop_mul   , for cmp use cmp_none, for tdiff use false],
      for op_div       use [for pri use 6, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_both, for   oc use toc_raritm     , for oop use oop_div   , for cmp use cmp_none, for tdiff use false],
      for op_idiv      use [for pri use 6, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_both, for   oc use toc_iaritm     , for oop use oop_idiv  , for cmp use cmp_none, for tdiff use false],
      for op_imod      use [for pri use 6, for com use eoc_none , for asoc use eoa_none , for tc use tc_both, for   oc use toc_iaritm     , for oop use oop_imod  , for cmp use cmp_none, for tdiff use false],
      -- shifty
      for op_shl       use [for pri use 6, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_left, for   oc use toc_shift      , for oop use oop_shl   , for cmp use cmp_none, for tdiff use false],
      for op_shr       use [for pri use 6, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_left, for   oc use toc_shift      , for oop use oop_shr   , for cmp use cmp_none, for tdiff use false],
      -- relační operátory
      for op_eq        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_compare, for oop use oop_eq    , for cmp use cmp_eq  , for tdiff use true ],
      for op_ne        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_compare, for oop use oop_ne    , for cmp use cmp_ne  , for tdiff use true ],
      for op_lt        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_order  , for oop use oop_lt    , for cmp use cmp_lt  , for tdiff use true ],
      for op_le        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_order  , for oop use oop_le    , for cmp use cmp_le  , for tdiff use true ],
      for op_gt        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_order  , for oop use oop_gt    , for cmp use cmp_gt  , for tdiff use true ],
      for op_ge        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_order  , for oop use oop_ge    , for cmp use cmp_ge  , for tdiff use true ],
      for op_in        use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_member , for oop use oop_none  , for cmp use cmp_none, for tdiff use true ],
      for op_notin     use [for pri use 3, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_rel_member , for oop use oop_none  , for cmp use cmp_none, for tdiff use true ],
      -- množinové operátory
      for op_union     use [for pri use 4, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_set        , for oop use oop_add   , for cmp use cmp_none, for tdiff use false],
      for op_diff      use [for pri use 4, for com use eoc_pfull, for asoc use eoa_pfull, for tc use tc_both, for   oc use toc_set        , for oop use oop_sub   , for cmp use cmp_none, for tdiff use false],
      for op_isect     use [for pri use 6, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_set        , for oop use oop_mul   , for cmp use cmp_none, for tdiff use false],
      -- řetězcové operátory
      for op_concat    use [for pri use 4, for com use eoc_none , for asoc use eoa_full , for tc use tc_concat, for oc use toc_concat     , for oop use oop_concat, for cmp use cmp_none, for tdiff use false],
      -- logické operátory
      for op_and       use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_logical    , for oop use oop_and   , for cmp use cmp_none, for tdiff use false],
      for op_or        use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_logical    , for oop use oop_or    , for cmp use cmp_none, for tdiff use false],
      for op_xor       use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_logical    , for oop use oop_xor   , for cmp use cmp_none, for tdiff use false],
      for op_and_then  use [for pri use 2, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_logical    , for oop use oop_none  , for cmp use cmp_none, for tdiff use false],
      for op_or_else   use [for pri use 2, for com use eoc_none , for asoc use eoa_none , for tc use tc_none, for   oc use toc_logical    , for oop use oop_none  , for cmp use cmp_none, for tdiff use false],
                       -- %%X/%%LANG Pro operátory AND THEN a OR ELSE je
                       -- typová kontrola trochu jiná než pro AND a OR !
                       -- Zohlednit v příručce.
      -- bitové operátory
      for op_bitand    use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_bit        , for oop use oop_and   , for cmp use cmp_none, for tdiff use false],
      for op_bitor     use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_bit        , for oop use oop_or    , for cmp use cmp_none, for tdiff use false],
      for op_bitxor    use [for pri use 2, for com use eoc_full , for asoc use eoa_full , for tc use tc_both, for   oc use toc_bit        , for oop use oop_xor   , for cmp use cmp_none, for tdiff use false],
      -- různé další operátory
      for op_op1       use [for pri use 7, for com use eoc_none , for asoc use eoa_none , for tc use tc_left, for   oc use toc_none       , for oop use oop_op1   , for cmp use cmp_none, for tdiff use false]];

----------------------------------------------------------------------------------------------------
class public expoper = extend expnoper;
-- Operátor
----------------------------------------------------------------------------------------------------

    var
      oper         : expopertype;                -- typ operátoru

    ------------------------------------------------------------------------------------------------
    static setoper (
        _oper      : in expopertype;        -- operátor
        _assign    : in t_logical);         -- T-přiřazení
    -- Dosadí do uzlu operátor.
    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;           -- podvýrazy
        er         : out pexpnode);          -- podvýrazy
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;           -- podvýrazy
        er         : in pexpnode);          -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;           -- podvýrazy
        er         : out pexpnode);          -- podvýrazy
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    end expoper;



  ----- %%TECH -------------------------------------------------------------------------------------
  -- Postup při přidávání nových unárních operátorů:
  --     viz obdobný postup pro binární operátory
  --------------------------------------------------------------------------------------------------
type
  -- typy operátorů
  expunarytype  = enum
      un_none;
      -- unární aritmetické operátory
      un_plus; un_minus;
      -- unární operátory s nejvyšší prioritou
      un_not; un_abs; un_succ; un_pred;
      -- bitové unární operátory
      un_bitnot;
      -- množinové unární operátory
      un_setnot;
      end enum;
  expunarytypeset  = set of expunarytype;

var
  -- textová reprezentace unárních operátorů pro dump
  expunarytxt      : const array expunarytype of t_char32str := [
      for un_none   use '',
      -- unární aritmetické operátory
      for un_plus   use 'UNARY +',
      for un_minus  use 'UNARY -',
      -- unární operátory s nejvyšší prioritou
      for un_not    use 'NOT',
      for un_abs    use 'ABS',
      for un_succ   use 'SUCC',
      for un_pred   use 'PRED',
      -- bitové unární operátory
      for un_bitnot use 'BIT NOT',
      -- množinové unární operátory
      for un_setnot use 'SET NOT'];

var
  -- textová reprezentace unárních operátorů pro XML dump
{%OFF}
  expunarytype_export_id : const array expunarytype of t_char32str := [
      for un_none   use 'none',
      for un_plus   use 'plus',
      for un_minus  use 'minus',
      for un_not    use 'not',
      for un_abs    use 'abs',
      for un_succ   use 'succ',
      for un_pred   use 'pred',
      for un_bitnot use 'bitnot',
      for un_setnot use 'setnot'];
{%ON}

type      
  -- informace o unárním operátoru
  tunaryinfo       = record
      pri          : t_unsigned;                 -- priorita
      oop          : tooperator;                 -- odpovídající přetížitelný operátor
      end record;

var
  -- priorita unárních operátorů
  expunaryinfo     : const array expunarytype of tunaryinfo := [
      for un_none      use [for pri use 0, for oop use oop_none     ],
      -- unární aritmetické operátory
      for un_plus      use [for pri use 5, for oop use oop_add      ],
      for un_minus     use [for pri use 5, for oop use oop_sub      ],
      -- unární operátory s nejvyšší prioritou
      for un_not       use [for pri use 8, for oop use oop_not      ],
      for un_abs       use [for pri use 8, for oop use oop_abs      ],
      for un_succ      use [for pri use 8, for oop use oop_succ     ],
      for un_pred      use [for pri use 8, for oop use oop_pred     ],
      for un_bitnot    use [for pri use 8, for oop use oop_not      ],
      for un_setnot    use [for pri use 8, for oop use oop_not      ]];

----------------------------------------------------------------------------------------------------
class public expunary = extend expnoper;
-- Unární operátor
----------------------------------------------------------------------------------------------------

    var
      oper         : expunarytype;               -- typ operátoru

    ------------------------------------------------------------------------------------------------
    static setoper (
        _oper      : in expunarytype;            -- operátor
        _assign    : in t_logical);              -- T-přiřazení
    -- Dosadí do uzlu operátor.
    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode);              -- podvýraz
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------
    end expunary;



----------------------------------------------------------------------------------------------------
class public expcomponent = extend expunary0;
-- Komponenta
----------------------------------------------------------------------------------------------------

    var
      id           : pentityident;               -- identifikátor komponenty
      s            : cc_sym.tentitysearch;       -- informace o nalezeném symbolu

    ------------------------------------------------------------------------------------------------
    static setid (
        _id        : in tentityident);           -- identifikátor
    -- Dosadí do komponenty její identifikátor.
    ------------------------------------------------------------------------------------------------
    end expcomponent;



----------------------------------------------------------------------------------------------------
class public expimm = extend expnode;
-- Přímá hodnota (konstanta)
----------------------------------------------------------------------------------------------------

    var
      imm          : aliased timm_value;         -- hodnota
      immkind      : timmentrykind;              -- druh přímé hodnoty
      linked       : linkstatus;                 -- přímé hodnoty se někdy též linkují...

    end expimm;



type    
  -- druh rozsahu
  exprangekind     = enum
      erk_dynamic;                               -- dynamický rozsah
      erk_static;                                -- statický rozsah
      erk_single;                                -- rozsah typu 1..1 (jen const. meze)
      erk_null;                                  -- prázdný rozsah (Null range)
      end enum;
  exprangekindset  = set of exprangekind;

var
  -- druh rozsahu
{%OFF}
  exprangekind_export_id : const array exprangekind of t_char32str := [
      for erk_dynamic use 'dynamic',
      for erk_static  use 'static',
      for erk_single  use 'single',
      for erk_null    use 'null'];
{%ON}

const
  -- konstantní rozsahy
  erks_const       = exprangekindset:[erk_static,erk_single];

----------------------------------------------------------------------------------------------------
class public exprange = extend expambiguous;
-- Rozsah
----------------------------------------------------------------------------------------------------

    var
      rkind        : exprangekind;               -- druh rozsahu

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;                -- podvýrazy
        er         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    end exprange;



----------------------------------------------------------------------------------------------------
class public explist = extend expnode;
-- Seznam výrazů
----------------------------------------------------------------------------------------------------

    var
      qualified    : t_logical := true;          -- T-kvalifikovaný seznam, F-nekvalifikovaný

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;               -- prefix
        arglist    : out pexpitem);              -- seznam argumentů
    -- Oddělí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;                -- prefix
        arglist    : in pexpitem);               -- seznam argumentů
    -- Sloučí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;               -- prefix
        arglist    : out pexpitem);              -- seznam argumentů
    -- Vrátí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    static getarglist (
        arglist    : out pexpitem);              -- seznam argumentů
    -- Vrátí argumenty.
    ------------------------------------------------------------------------------------------------
    end explist;



type
  -- typ položky seznamu výrazů
  expitemtype      = enum
      ei_empty;                                  -- poziční, implicitní
      ei_expr;                                   -- poziční, výraz
      ei_ident;                                  -- klíčová, daná identifikátorem
      ei_choice;                                 -- klíčová, daná výběrem
      ei_others;                                 -- klíčová, OTHERS
      end enum;
  expitemtypeset   = set of expitemtype;

var
  -- typ položky seznamu výrazů
{%OFF}
  expitemtype_export_id : const array expitemtype of t_char32str := [
      for ei_empty  use 'empty',
      for ei_expr   use 'expr',
      for ei_ident  use 'ident',
      for ei_choice use 'choice',
      for ei_others use 'others'];
{%ON}

----------------------------------------------------------------------------------------------------
class public expitem = extend expnode;
-- Položka seznamu výrazů
----------------------------------------------------------------------------------------------------

    var
      itype        : expitemtype;                -- typ položky
      id           : pentityident;               -- vazba položky
      sym          : pentity;                    -- související symbol (pro zjednodušení)

    ------------------------------------------------------------------------------------------------
    static setid (
        _id        : in tentityident);           -- identifikátor
    -- Dosadí do položky její identifikátor.
    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;                -- podvýrazy
        er         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------

    end expitem;


----------------------------------------------------------------------------------------------------
class public exptaskvarslot = extend expunary0;
-- Selektor slotu táskové proměnné.
----------------------------------------------------------------------------------------------------

    end exptaskvarslot;



type
  -- typ indexu (selektoru) pole
  expindextype     = enum
      eix_component;                             -- index určuje komponentu
      eix_slice;                                 -- index je řez
      end enum;

var
  -- typ indexu (selektoru) pole
{%OFF}
  expindextype_export_id : const array expindextype of t_char32str := [
      for eix_component use 'component',
      for eix_slice     use 'slice'];
{%ON}

----------------------------------------------------------------------------------------------------
class public expindex = extend expnode;
-- Selektor pole.
----------------------------------------------------------------------------------------------------

    var
      itype        : expindextype;               -- typ indexu

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode;                -- podvýrazy
        er         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode;               -- podvýrazy
        er         : out pexpnode);              -- podvýrazy
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------

    end expindex;



----------------------------------------------------------------------------------------------------
class public expref = extend expnode;
-- reference
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode);              -- podvýraz
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------

    end expref;



----------------------------------------------------------------------------------------------------
class public expderef = extend expnode;
-- dereference
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split (
        el         : out pexpnode);              -- podvýrazy
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    static join (
        el         : in pexpnode);               -- podvýrazy
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    static get (
        el         : out pexpnode);              -- podvýraz
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------

    end expderef;



----------------------------------------------------------------------------------------------------
class public expattrib = extend explist;
-- atribut
----------------------------------------------------------------------------------------------------

    var
      aclass       : tattrclass;                 -- třída atributu
      atf          : tattrformal;                -- jazykem definovaný formální atribut
      ata          : tattractual;                -- jazykem definovaný skutečný atribut
      id           : pentityident;               -- identifikátor atributu
      asym         : pentity_attribute;          -- související atribut (pro zjednodušení)
      xsym         : pentity;                    -- související symbol - výsledek atributu

    ------------------------------------------------------------------------------------------------
    static setid (
        _id        : in tentityident);           -- identifikátor
    -- Dosadí identifikátor atributu.
    ------------------------------------------------------------------------------------------------
    end expattrib;



----------------------------------------------------------------------------------------------------
class public expaggregate = extend explist;
-- Agregát.
----------------------------------------------------------------------------------------------------

    var
      imm          : timm_value;                 -- statická šablona agregátu

    end expaggregate;



----------------------------------------------------------------------------------------------------
class public expinterfacecast = extend expbinary0;
-- Přetypování na interface.
----------------------------------------------------------------------------------------------------

    end expinterfacecast;



----------------------------------------------------------------------------------------------------
class public expcallspec = extend explist;
-- Volání speciální metody.
----------------------------------------------------------------------------------------------------

    var
      spectype     : tspectype;                  -- kterou speciální metodu volat
      spec         : pentity_special;            -- volaná spec. metoda, je-li staticky určena

    end expcallspec;



----------------------------------------------------------------------------------------------------
class public expcallrtl = extend explist;
-- Volání funkce RTL knihovny.
----------------------------------------------------------------------------------------------------

    var
      rtl_proc     : cc_base.cc_rtl.t_rtl_entity;-- procedura run-time knihovny, která se má volat

    end expcallrtl;



----------------------------------------------------------------------------------------------------
class public expthis = extend expnode;
-- THIS
----------------------------------------------------------------------------------------------------

    end expthis;



type
  -- CURRENT
  tcurrentity      = enum
      tce_entry;                                 -- speciální metoda ENTRY
      tce_exit;                                  -- speciální metoda EXIT
      tce_adjust;                                -- speciální metoda ADJUST
      tce_procedure;                             -- procedura
      tce_static;                                -- statická metoda
      tce_virtual;                               -- virtuální metoda
      tce_override;                              -- přetížení virtuální metody
      tce_task;                                  -- task
      tce_macro;                                 -- makro
      tce_class;                                 -- třída
      tce_module;                                -- modul
      tce_program;                               -- program
      end enum;

var
  -- CURRENT
{%OFF}
  tcurrentity_export_id : const array tcurrentity of t_char32str := [
      for tce_entry     use 'entry',
      for tce_exit      use 'exit',
      for tce_adjust    use 'adjust',
      for tce_procedure use 'procedure',
      for tce_static    use 'static',
      for tce_virtual   use 'virtual',
      for tce_override  use 'override',
      for tce_task      use 'task',
      for tce_macro     use 'macro',
      for tce_class     use 'class',
      for tce_module    use 'module',
      for tce_program   use 'program'];
{%ON}

type
  -- informace o entitě
  tcurrentityinfo  = record
      lex          : lexsym;                     -- odpovídající klíčové slovo
      etype        : tentitytype;                -- typ entity
      end record;

var
  currentityinfo   : const array tcurrentity of tcurrentityinfo := [
      for tce_entry      use [for lex use lex_entry     , for etype use et_special    ],
      for tce_exit       use [for lex use lex_exit      , for etype use et_special    ],
      for tce_adjust     use [for lex use lex_adjust    , for etype use et_special    ],
      for tce_procedure  use [for lex use lex_procedure , for etype use et_procedure  ],
      for tce_static     use [for lex use lex_static    , for etype use et_static     ],
      for tce_virtual    use [for lex use lex_virtual   , for etype use et_virtual    ],
      for tce_override   use [for lex use lex_override  , for etype use et_override   ],
      for tce_task       use [for lex use lex_task      , for etype use et_task       ],
      for tce_macro      use [for lex use lex_macro     , for etype use et_macro      ],
      for tce_class      use [for lex use lex_class     , for etype use et_class      ],
      for tce_module     use [for lex use lex_module    , for etype use et_module     ],
      for tce_program    use [for lex use lex_program   , for etype use et_program    ]];

----------------------------------------------------------------------------------------------------
class public expcurrent = extend expnode;
-- CURRENT
----------------------------------------------------------------------------------------------------

    var
      spectype     : tspectype;                  -- kterou speciální metodu volat
      entity       : tcurrentity;                -- vybraná entita

    end expcurrent;



----------------------------------------------------------------------------------------------------
class public expfaketag = extend expnode;
-- Fake tag interfacu třídy.
----------------------------------------------------------------------------------------------------

    var
      interface    : p_class_interface;          -- interface třídy

    end expfaketag;



{
type
  -- položky tagu
  t_tag_field      = enum
      end;

----------------------------------------------------------------------------------------------------
class public exptagfield = extend expnode;
-- Položka tagu.
----------------------------------------------------------------------------------------------------

    end exptagfield;
}

----------------------------------------------------------------------------------------------------
procedure newnode (
    node           : out pexpnode;               -- uzel stromu
    info           : in expinfo;                 -- informace o průběhu analýzy
    ntype          : in nodetype);               -- typ uzlu
-- Vytvoření nového uzlu stromu.
----------------------------------------------------------------------------------------------------
procedure newnodex (
    node           : out pexpnode;               -- uzel stromu
    info           : in expinfo;                 -- informace o průběhu analýzy
    ntype          : in nodetype);               -- typ uzlu
-- Jako NEWNODE, ale úroveň zpracování uzlu (EXPNODE.ZPRAC) nastaví na
-- minimum.
----------------------------------------------------------------------------------------------------
procedure newtree (
    node           : in out pexpnode;            -- uzel stromu
    info           : in expinfo;                 -- informace o průběhu analýzy
    ntype          : in nodetype);               -- typ uzlu
-- Vytvoření nového podstromu.
----------------------------------------------------------------------------------------------------
procedure derivenode (
    node           : out pexpnode;               -- uzel stromu                       
    srcnode        : in pexpnode;                -- referenční uzel                   
    info           : in expinfo;                 -- informace o průběhu analýzy       
    ntype          : in nodetype;                -- typ uzlu                          
    is_const       : in t_logical := false);     -- T-konstanta/F-konstanta v důsledku optimalizace,
                                                 -- resp. nekonstantní
-- Podle dodaného uzlu odvodí nový uzel.                                      
-- Převezme typ, druh zřetězení, pozici a příznaky. Dynamické atributy se nepřebírají.                                                               }
----------------------------------------------------------------------------------------------------
procedure lextobinaryoper (
    lex            : in lexsym)                  -- lexikální symbol
                   return expopertype;           -- odpovídající operátor
-- Převede lexikální symbol na binární operátor
----------------------------------------------------------------------------------------------------
procedure lextounaryoper (
    lex            : in lexsym)                  -- lexikální symbol
                   return expunarytype;          -- odpovídající operátor
-- Převede lexikální symbol na unární operátor.
----------------------------------------------------------------------------------------------------
procedure dumptree (
    expr_          : in pexpnode);               -- strom
-- Dump stromu na obrazovku.
----------------------------------------------------------------------------------------------------
procedure dumptree_xml (
    expr           : in pexpnode);               -- strom
-- Dump stromu na obrazovku ve tvaru XML.
----------------------------------------------------------------------------------------------------
procedure node_catch_resume_error (
    catch_mode     : t_catch_mode;               -- způsob, jakým zachytávat výjimku t_catch_mode
    node_type      : nodetype)                   -- typ uzlu
    return t_logical;
-- Vrátí, zda zachytávat výjimky typu resume_error v uzlu.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
#separate public c_expr_iterator;
-- Iterátor
----------------------------------------------------------------------------------------------------

end cx_def;
