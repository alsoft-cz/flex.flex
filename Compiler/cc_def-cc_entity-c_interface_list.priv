----------------------------------------------------------------------------------------------------
class private c_interface_list =
-- Seznam interfac– t©¡dy.
----------------------------------------------------------------------------------------------------
    
----------------------------------------------------------------------------------------------------
static add_interface =
-- P©id  do seznamu interfac– zadanou t©¡du [pexpr]/[pclass].
----------------------------------------------------------------------------------------------------
var 
  interface        : p_class_interface;
               
begin
  -- inicializovat nov˜ interface
  new interface;
  interface^.init(pexpr,pclass);

  -- vlo‘it do seznamu
  insert(interface);

rollback
  discard interface;
  end add_interface;



----------------------------------------------------------------------------------------------------
static add_interface_and_instance (
    pexpr          : in p_flex_class;            -- v˜raz obsahuj¡c¡ jm‚no t©¡dy
    pclass         : in pentity_type;            -- t©¡da reprezentuj¡c¡ interface.
    pvar           : in pentity_var) =
-- P©id  do seznamu interfac– zadanou t©¡du [pexpr]/[pclass] a jej¡ instanci.
----------------------------------------------------------------------------------------------------
var 
  interface        : p_class_interface;
               
begin
  -- inicializovat nov˜ interface
  new interface;
  interface^.init(pexpr,pclass);
  interface^.instance.setentity(pvar);

  -- vlo‘it do seznamu
  insert(interface);

rollback
  discard interface;
  end add_interface_and_instance;



----------------------------------------------------------------------------------------------------
static find_interface =
-- Najde interface p©¡slu¨ej¡c¡ dan‚ t©¡dˆ.
----------------------------------------------------------------------------------------------------
var
  it                : c_list_iterator;

begin
  it.init(p_list(^this)^);
  while it.get(result) and then result^.refclass.getcentity<>pclass loop end loop;
  end find_interface;



----------------------------------------------------------------------------------------------------
static get_native_interface =
-- Vr t¡ nativn¡ interface t©¡dy.
----------------------------------------------------------------------------------------------------
begin
  -- nativn¡ interface je ten prvn¡
  result:=get_first;
  verify(688,result=nil);
  end get_native_interface;



----------------------------------------------------------------------------------------------------
static get_exposed_interfaces =
-- P©iprav¡ iter tor pro zpracov n¡ v¨ech exposovan˜ch interfac–.
----------------------------------------------------------------------------------------------------
var
  _result          : t_logical;
  _interface       : p_class_interface;

begin
  -- p©ipravit iter tor
  it.init(p_list(^this)^);

  -- p©esko‡it nativn¡ interface
  _result:=it.get(_interface);
  verify(687,not _result);
  end get_exposed_interfaces;



----------------------------------------------------------------------------------------------------
static get_all_interfaces =
-- P©iprav¡ iter tor pro zpracov n¡ v¨ech (nativn¡ho i exposovan˜ch) interfac–.
----------------------------------------------------------------------------------------------------
begin
  verify(689,is_empty);

  -- p©ipravit iter tor
  it.init(p_list(^this)^);
  end get_all_interfaces;



----------------------------------------------------------------------------------------------------
static exposed_interfaces =
-- Po‡et exposovan˜ch interfac–.
----------------------------------------------------------------------------------------------------
begin
  result:=count-1;
  end exposed_interfaces;



----------------------------------------------------------------------------------------------------
static is_native_interface =
-- Zjist¡, je-li zadan  t©¡da nativn¡ interface t‚to t©¡dy. Za nativn¡ interface se pova‘uje
-- i p©edek t‚to t©¡dy.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;

begin
  result:=sym_is_ancestor(pclass,get_native_interface^.refclass.getcentity);
  end is_native_interface;



----------------------------------------------------------------------------------------------------
static is_exposed_interface =
-- Zjist¡, je-li zadan  t©¡da exposovan˜ interface t‚to t©¡dy.
----------------------------------------------------------------------------------------------------
var
  it               : c_list_iterator;
  interface        : p_class_interface;

begin
  -- p©ipravit iter tor
  get_exposed_interfaces(it);

  -- zjistit, zda zadan  t©¡da odpov¡d  nˆkter‚mu z interfac–
  while it.get(interface) loop
    if interface^.refclass.getcentity=pclass then
      result:=true;
      return;
      end if;
    end loop;
  end is_exposed_interface;



----------------------------------------------------------------------------------------------------
static is_interface =
-- Zjist¡, je-li zadan  t©¡da (nativn¡ nebo exposovan˜) interface t‚to t©¡dy.
----------------------------------------------------------------------------------------------------
begin
  result:=is_native_interface(pclass) or is_exposed_interface(pclass);
  end is_interface;



----------------------------------------------------------------------------------------------------
static merge_interface_list =
-- Zamerguje dodan˜ seznam interfac– do aktu ln¡ho. Ignoruje nativn¡ interface (prvn¡ v po©ad¡).
----------------------------------------------------------------------------------------------------
var
  it               : c_list_iterator;
  interface        : p_class_interface;

begin
  -- p©ipravit iter tor
  plist^.get_exposed_interfaces(it);

  -- zamergovat dohromady
  while it.get(interface) loop
    if not is_exposed_interface(interface^.refclass.getcentity) then
      add_interface_and_instance(
          interface^.refclass.getuexpr,
          interface^.refclass.getcentity,
          interface^.instance.getcentity);
      end if;
    end loop;
  end merge_interface_list;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat seznam
  init(c_class_interface:tag,true,false);
  end entry;

end c_interface_list;