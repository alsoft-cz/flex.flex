---------------------------------------------------------------------------------------------------
module private cd_eval =
-- P©eklada‡ Flexu.
-- Vyhodnocen¡ deklarac¡.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.09.2000 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_entity.cc_ref,
  cx_expr,cx_expr.cx_def,cx_expr.cx_compile,
  cd_create,
  cc_options;

use
  cx_expr.cx_def,
  cb_block,
  cb_block.cb_compile,
  cb_block.cb_def;


#if #declared dump; #and then; dump then;
var
  -- pr–bˆh p©ekladu deklarace
  tentitydeclaredtxt : array tentitydeclared of t_char32str := [
      for etd_none        use 'none',
      for etd_incomplete  use 'incomplete',
      for etd_public      use 'public',
      for etd_full        use 'full'];

  -- vyhodnocen¡ symbolu
  tentityevaltxt   : array tentityeval of t_char32str := [
      for ete_none        use 'none',
   -- for ete_generic     use 'generic',
      for ete_evaluated   use 'evaluated',
      for ete_unevaluated use 'unevaluated'];
#end if;

type
  tevalspecproc    = procedure (
      curr         : in out tentity_type;        -- vyhodnocovan  entita
      curr_context : in tcontext;                -- prim rn¡ kontext entity
      final        : in t_logical);              -- T-v˜sledek mus¡ b˜t vyhodnocen
  pevalspecproc    = ^tevalspecproc;

var
  e_spec_tab       : array tdatatype of pevalspecproc;



----------------------------------------------------------------------------------------------------
procedure arraysize (
    item           : tunidata_size;              -- velikost prvku pole
    lval           : tuniint;                    -- doln¡ mez
    hval           : tuniint)                    -- horn¡ mez
                   return tunidata_size =        -- velikost pole
-- Vypo‡¡t  velikost pole. Nebere v £vahu zarovn n¡ prvk– pole.
----------------------------------------------------------------------------------------------------
begin
  result:=uniint_to_unidata_size(unidata_size_to_uniint(item)*(hval-lval+ui_1));
  end arraysize;



----------------------------------------------------------------------------------------------------
procedure type_setsize (
    curr           : in out tentity_type;        -- vyhodnocovan˜ typ
    size           : in tunidata_size) =         -- vypo‡ten  velikost
-- Dosad¡ do typu velikost.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;

begin
  if curr.attr_size.isset

    -- ur‡ena explicitnˆ atributem
    then
      -- p©evz¡t z v˜razu velikost
      x_const_int(pexpnode(curr.attr_size.getcexpr),ui);

      -- mus¡ b˜t nez porn 
      if ui<ui_0 then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_size);
        curr.attr_size.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.size:=size;
        return;
        end if;

      -- dosadit
      curr.size:=uniint_to_unidata_size(ui);

      -- nen¡ to m‚nˆ, ne‘ implicitn¡ velikost ?
      if curr.size<size then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_size);
        curr.attr_size.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.size:=size;
        return;
        end if;

    -- ur‡ena implicitnˆ
    else
      curr.size:=size;
      end if;
  end type_setsize;



----------------------------------------------------------------------------------------------------
procedure type_setalign (
    curr           : in out tentity_type;        -- vyhodnocovan˜ typ
    align          : in tunidata_size) =         -- zarovn n¡
-- Dosad¡ do typu zarovn n¡.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;

begin
  if curr.attr_align.isset

    -- ur‡eno explicitnˆ atributem
    then
      -- p©evz¡t z v˜razu zarovn n¡
      x_const_int(pexpnode(curr.attr_align.getcexpr),ui);

      -- mus¡ b˜t >=1
      if ui<ui_1 then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_align);
        curr.attr_align.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.align:=align;
        return;
        end if;

      -- dosadit
      curr.align:=uniint_to_unidata_size(ui);

    -- ur‡eno implicitnˆ
    else
      curr.align:=align;
      end if;
  end type_setalign;



----------------------------------------------------------------------------------------------------
procedure e_part =
-- Zapo‡¡t  vyhodnocen¡ ‡ sti do celku a vr t¡ True, nen¡-li celek vyhodnocen.
----------------------------------------------------------------------------------------------------
begin
  if (celek=ete_none)or (celek>cast) then celek:=cast; end if;
  result:=celek<ete_evaluated;
  end e_part;



----------------------------------------------------------------------------------------------------
procedure e_is_evaluated =
-- True, odpov¡d -li zadan‚ vyhodnocen¡ stavu "vyhodnoceno".
----------------------------------------------------------------------------------------------------
begin
  result:=e>=ete_evaluated;
  end e_is_evaluated;



----------------------------------------------------------------------------------------------------
procedure e_refexpr (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out refexpr;             -- v˜raz
    kind           : in expkind;                 -- o‡ek van˜ druh v˜razu
    typ            : in pentity_type;            -- po‘adovan˜ typ
    usage          : in expusage;                -- pou‘it¡ v˜razu
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na v˜raz.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  x                : pexpnode;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if expr.geteval>ete_none then return; end if;

  if expr.getuexpr=nil
    -- v˜raz nen¡ uveden (nevad¡, t©eba je to z mˆr)
    then expr.seteval(ete_evaluated)
    -- jinak ho vyhodnotit
    else
      x:=pexpnode(expr.getcexpr);
      x_evaluate(curr,x,kind,typ,usage,final,e);
      expr.setexpr(x);
      expr.seteval(e);
      end if;
  end e_refexpr;



----------------------------------------------------------------------------------------------------
procedure e_refblock (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out refblock;            -- v˜raz
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na v˜raz.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  b                : cb_block.cb_def.pblnode;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if bl.geteval>ete_none then return; end if;

  if bl.getublock=nil
    -- blok p©¡kaz– nen¡ uveden (nevad¡, t©eba je to z mˆr)
    then bl.seteval(ete_evaluated)
    -- jinak ho vyhodnotit
    else
      b:=cb_block.cb_def.pblnode(bl.getcblock);
      cb_block.cb_compile.b_evaluate(curr,b,final,e);
      bl.setblock(b);
      bl.seteval(e);
      end if;
  end e_refblock;



----------------------------------------------------------------------------------------------------
procedure e_reftype_check (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    ptyp           : in pentity_type;            -- kontrolovan˜ typ
    tview          : in ttypeviewset;            -- povolen‚ typy pohled– na typ
    dts            : in tdatatypeset;            -- povolen‚ datov‚ typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view t©¡dy
    allow_abstract : in t_logical) =             -- T-povolit abstraktn¡ typy
-- Kontrola, zda typ odpov¡d  zadan˜m po‘adavk–m.
----------------------------------------------------------------------------------------------------
var
  t                : typeview;                   -- pohled na typ

begin
  -- sestavit si pohled na typ
  t.init(curr,ptyp);

  -- jsou povoleny abstraktn¡ typy ?
  if not allow_abstract and ptyp^.is_abstract then
    ce^.seterror({CCERR=}000000,ce_i_type);
    ce^.resumeerror;
    end if;

  if allow_class {(tview_partial in tview) and (st_class in dts)} and t.isclass

    -- Ondra 29.6.2001 : p©i povolen‚m Partial view povol¡me pro t©¡du i Incomplete view
    then
      -- nic nedˆlat

    else
      -- kontrola p©¡pustnosti pohledu
      if t.tview not in tview then
        ce^.seterror({CCERR=}000249,ce_i_type);
        ce^.resumeerror;
        end if;

      --Full view => kontrola p©¡pustnosti datov‚ho typu
      if t.tview=tview_full and t.stype not in dts then
        ce^.seterror({CCERR=}000250,ce_i_type);
        ce^.resumeerror;
        end if;

      -- Incomplete view => typ mus¡ b˜t regul rn¡
      if t.tview=tview_incomplete then t.getutype^.tkind:=tk_regular; end if;
      end if;
  end e_reftype_check;



----------------------------------------------------------------------------------------------------
procedure e_reftype (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    typ            : in out cc_ref.reftype;      -- typ
    ekind          : in expkind;                 -- druh o‡ek van‚ho v˜razu
    tview          : in ttypeviewset;            -- povolen‚ typy pohled– na typ
    dts            : in tdatatypeset;            -- povolen‚ datov‚ typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view t©¡dy
    allow_abstract : in t_logical;               -- T-povolit abstraktn¡ typy
 -- declared       : in tentitydeclared;         -- po‘adovan  £rove¤ deklarace
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na typ.
-- Pohled na typ mus¡ b˜t z [tview] a datov˜ typ ve Full view mus¡ b˜t z [dts].
-- Pokud je to Incomplete view, po‘aduje se, aby byl typ regul rn¡.
-- Je-li [allow_class]=True, pak je povoleno i Incomplete view na t©¡du.
-- Je-li [allow_abstract]=True, pak jsou povoleny i abstraktn¡ typy.
-- Je-li [ekind]=[ek_rangetype], pak z p©¡padn‚ho rozsahu univerz ln¡ho typu vygeneruje typ
-- o velikosti alespo¤ strojov‚ho slova, v opa‡n‚m p©¡padˆ o minim ln¡ mo‘n‚ velikosti.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;
  t                : typeview;

begin
  -- typ je¨tˆ nem me, ale zato m me v˜raz --> vyhodnotit
  if typ.getutype=nil and then typ.getuexpr<>nil then

    -- vyhodnotit v˜raz
    e_refexpr(curr,typ.getrefexpr^,ekind{ek_typename},nil,eu_formal,final);
    if e_part(typ.e,typ.getrefexpr^.geteval) then return; end if;

    -- p©evz¡t typ
    x_get_type(curr,pexpnode(typ.getcexpr),ptyp,ekind=ek_rangetype);
    typ.settype(ptyp,for clear_expr use false);
    end if;

  -- zkontrolovat typ
  if typ.getutype<>nil

    -- je k dispozici
    then
      -- zkontrolovat zda typ odpov¡d  zadan˜m po‘adavk–m
      begin
        e_reftype_check(curr,typ.getutype,tview,dts,allow_class,allow_abstract);
      catch
        when compiler_error, resume_error do
            typ.errpos;
            raise;
        end;

    -- typ nem me, ale t©eba je to z mˆr
    else
      -- nic nedˆlat
      end if;

  -- vyhodnoceno
  typ.seteval(ete_evaluated);
  end e_reftype;



----------------------------------------------------------------------------------------------------
procedure e_refimm (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    imm            : in out refimm;              -- hodnota
    kind           : in expkind;                 -- o‡ek van˜ druh v˜razu
    typ            : in pentity_type;            -- po‘adovan˜ typ
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na hodnotu.
----------------------------------------------------------------------------------------------------
begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if imm.geteval>ete_none then return; end if;

  -- vyhodnotit v˜raz
  e_refexpr(curr,imm.getrefexpr^,kind,typ,eu_use,final);
  if e_part(imm.e,imm.getrefexpr^.geteval) then return; end if;

  -- p©evz¡t hodnotu
  x_const_imm(pexpnode(imm.getcexpr),imm.getundefimm^);
  end e_refimm;



----------------------------------------------------------------------------------------------------
procedure e_refsymbol (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    sym            : in out refentity;           -- symbol
    level          : in tentitydeclared;         -- po‘adovan˜ urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na symbol.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if sym.e>ete_none then return; end if;

  -- vyhodnotit v˜raz
  if sym.getuentity=nil and then sym.getuexpr<>nil then
    -- vyhodnotit v˜raz
    e_refexpr(curr,sym.getrefexpr^,ek_sym,nil,eu_formal,final);
    if e_part(sym.e,sym.getrefexpr^.geteval) then return; end if;

    -- p©evz¡t symbol
    x_get_symbol(pexpnode(sym.getcexpr),entity);
    sym.setentity(entity);
    end if;

  if sym.getuentity<>nil

    -- symbol je k dispozici
    then
      -- vyhodnotit symbol
      {e_symbol(sym._s,sym.pos,level,final);}
      if e_part(sym.e,sym.getuentity^.eval) then return; end if;

    -- symbol nem me, ale t©eba je to z mˆr
    else sym.e:=ete_evaluated;
    end if;
  end e_refsymbol;



----------------------------------------------------------------------------------------------------
procedure e_refsymbol_from_typename (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    sym            : in out refentity;           -- symbol
    level          : in tentitydeclared;         -- po‘adovan˜ urove¤ vyhodnocen¡
    tview          : in ttypeviewset;            -- povolen‚ typy pohled– na typ
    dts            : in tdatatypeset;            -- povolen‚ datov‚ typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view t©¡dy
    allow_abstract : in t_logical;               -- T-povolit abstraktn¡ typy
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ referenci na symbol zadan˜ jako jm‚no typu.
-- Je-li [allow_class]=True, pak je povoleno i Incomplete view na t©¡du.
-- Je-li [allow_abstract]=True, pak jsou povoleny i abstraktn¡ typy.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if sym.geteval>ete_none then return end if;

  -- vyhodnotit v˜raz
  e_refexpr(curr,sym.getrefexpr^,ek_typename,nil,eu_formal,final);
  if e_part(sym.e,sym.getrefexpr^.geteval) then return end if;

  -- p©evz¡t symbol
  x_get_type(curr,pexpnode(sym.getcexpr),ptyp,false);
  sym.setentity(ptyp);
  if e_part(sym.e,ptyp^.eval) then return end if;

  -- kontrolova zda typ odpov¡d  zadan˜m po‘adavk–m
  begin
    e_reftype_check(curr,ptyp,tview,dts,allow_class,allow_abstract);
  catch
    when resume_error, compiler_error do
        sym.errpos;
        raise;
    end;
  end e_refsymbol_from_typename;



----------------------------------------------------------------------------------------------------
procedure e_spec_ordinal : tevalspecproc =
-- Vyhodnot¡ definici ordin ln¡ho typu SIGNED, UNSIGNED, LOGICAL, CHARACTER.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;                    -- v˜sledek (po‡et bit–)
  size             : tunidata_size;              -- vypo‡ten  velikost

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnotit v˜raz
  e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Ot zka: nem  zde b˜t EU_USE ??? }final);
  if e_part(curr.seval,curr.expr.geteval) then return; end if;

  -- na‡¡st hodnotu
  x_const_int(pexpnode(curr.expr.getcexpr),ui);

  -- zkontrolovat a doplnit meze
  cpu^.getordparams1(curr.stype,uniint_to_unidata_bitsize(ui),size{curr.size},curr.lval,curr.hval);

  -- doplnit velikost
  type_setsize(curr,size);

  -- dosadit velikost v bitech
  curr.bits:=uniint_to_unidata_bitsize(ui);
  end e_spec_ordinal;



----------------------------------------------------------------------------------------------------
procedure e_spec_enum : tevalspecproc =
-- Vyhodnot¡ definici v˜‡tov‚ho typu.
----------------------------------------------------------------------------------------------------
var
  hval             : tuniint;                    -- horn¡ mez
  srch             : tentitysearch;              -- hled tko
  size             : tunidata_size;              -- vypo‡ten  velikost
  e                : tentityeval;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- slo‘ky
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;

  -- ur‡it nejvy¨¨¡ ordin ln¡ hodnotu
  -- %%X Optimalizace: Kdy‘ nen¡ uvedena specifikace reprezentace ‘ dn‚ho
  -- v˜‡tov‚ho prvku, tak sta‡¡ vz¡t posledn¡ prvek z tabulky symbol–
  hval:=ui_0;
  srch.find_et_first(^curr,rc_primary,et_enum,[]);
  while srch.psym<>nil loop
    if pentity_enum(srch.psym)^.ordinal>hval then hval:=pentity_enum(srch.psym)^.ordinal; end if;
    srch.find_et_next;
    end loop;

  -- meze typu
  curr.lval:=ui_0;
  curr.hval:=hval;

  -- odvodit velikost typu
  cpu^.getordparams2(dt_enum,curr.bits,size{curr.size},ui_0,hval,false);

  -- doplnit velikost
  type_setsize(curr,size);
  end e_spec_enum;



----------------------------------------------------------------------------------------------------
procedure e_spec_float : tevalspecproc =
-- Vyhodnot¡ definici floating-point typu.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;                    -- v˜sledek
  size             : tunidata_size;              -- vypo‡ten  velikost

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnotit v˜raz
  e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Ot zka: nem  zde b˜t EU_USE ??? }final);
  if e_part(curr.seval,curr.expr.geteval) then return; end if;

  -- na‡¡st hodnotu
  x_const_int(pexpnode(curr.expr.getcexpr),ui);

{ Ondra 3.4.2003 : Zru¨eno, float se novˆ definuje po‡tem bit–.
  case curr.dtype
    -- delta definice
    when fdt_delta      do
        -- vyhodnotit v˜raz
        e_refexpr(curr_context,curr.expr,ek_const_real,nil,eu_read,{%%X Ot zka: nem  zde b˜t EU_USE ??? }final);
        if e_part(curr.seval,curr.expr.geteval) then return; end if;

        -- na‡¡st hodnotu
        x_const_real(pexpnode(curr.expr.getcexpr),curr.fp.fdelta);

      {%%TODO(REAL)
        -- mus¡ b˜t > 0
        if curr.fp.fdelta<=ur_0 then
          ce^.seterror({CCERR=}000251,ce_numrange);
          ce^.setinfo(hint_float_delta);
          curr.expr.errpos;
          ce^.resumeerror;
          end if;
      }

    -- digits definice
    when fdt_digits     do
        -- vyhodnotit v˜raz
        e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Ot zka: nem  zde b˜t EU_USE ??? }final);
        if e_part(curr.seval,curr.expr.geteval) then return; end if;

        -- na‡¡st hodnotu
        x_const_int(pexpnode(curr.expr.getcexpr),curr.fp.fdigits);

        -- mus¡ b˜t >= 1
        if curr.fp.fdigits<ui_1 then
          ce^.seterror({CCERR=}000252,ce_numrange);
          ce^.setinfo(hint_float_digits);
          curr.expr.errpos;
          ce^.resumeerror;
          end if;

    when others do verify(235,true);
    end case;
}
  -- parametry typu
  cpu^.getrealparams(uniint_to_unidata_bitsize(ui){curr.dtype},size{curr.size},curr.fp);

  -- doplnit velikost
  type_setsize(curr,size);

  -- dosadit velikost v bitech
  curr.bits:=uniint_to_unidata_bitsize(ui);
  end e_spec_float;



----------------------------------------------------------------------------------------------------
procedure e_spec_fixed : tevalspecproc =
-- Vyhodnot¡ definici fixed-point typu.
----------------------------------------------------------------------------------------------------
begin
  unimplemented(204);
  end e_spec_fixed;



----------------------------------------------------------------------------------------------------
procedure e_spec_procedure : tevalspecproc =
-- Vyhodnot¡ definici typu procedura/task/zpr va.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- parametry
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;
{
  -- vyhodnotit typ n vratov‚ hodnoty
  e_reftype(curr,curr.rtype,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_regular,{etd_full,}final);
  if e_part(curr.seval,curr.rtype.geteval) then return; end if;
}
  end e_spec_procedure;



----------------------------------------------------------------------------------------------------
procedure e_spec_array : tevalspecproc =
-- Vyhodnot¡ definici typu (neomezen‚) pole.
----------------------------------------------------------------------------------------------------
var
  rtype            : pentity_type;               -- typ rozsahu
  rtype_context    : tcontext;                   -- kontext typu rozsahu
  size             : tunidata_size;              -- vypo‡ten  velikost
  e                : tentityeval;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- b zov˜ typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_constrained,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
{
  -- b zov˜ typ nesm¡ b˜t neomezen˜
  if curr.base.getctype^.stype in dts_unconstrained then
    ce^.seterror({CCERR=}000253,ce_i_basetype);
    ce^.setinfo(hint_array_base);
    curr.base.errpos;
    ce^.resumeerror;
    end if;
}
  if curr.stype=dt_array

    -- norm ln¡ pole
    then
      -- rozsah
      e_reftype(curr_context,curr.srange,ek_rangetype,ttypeviewset:[tview_full],dts_ordinal,false,false,{etd_full,}final);
      if e_part(curr.seval,curr.srange.geteval) then return; end if;

      -- %%X A co zarovn n¡ prvku pole ?!

      -- vypo‡¡tat d‚lku pole
      size{curr.size}:=arraysize(curr.base.getctype^.size,curr.srange.getctype^.lval,curr.srange.getctype^.hval);

    -- neomezen‚ pole
    else
      -- odvodit typ rozsahu
      d_create_implicit_type(curr_context,rtype,rtype_context,dt_unsigned,nil);

      -- doplnit £daje
      cpu^.getdefaultord(dt_unsigned,rtype^.bits,rtype^.size,rtype^.lval,rtype^.hval);

      -- konec deklarace
      d_end_implicit_type(rtype^,nil,false);

      -- dosadit jako typ rozsahu neomezen‚ho pole
      curr.srange.settype(rtype);

      -- velikost
      size:=uds_0;

      -- vyhodnoceno
      curr.seval:=ete_evaluated;
      end if;
  -- %%X doplnit dal¨¡ kontroly !!

  -- doplnit velikost
  type_setsize(curr,size);
  end e_spec_array;



----------------------------------------------------------------------------------------------------
procedure e_spec_string : tevalspecproc =
-- Vyhodnot¡ definici typu (neomezen˜) ©etˆzec.
----------------------------------------------------------------------------------------------------
var
  delka            : tuniint;                    -- po‡et prvk– ©etˆzce
  isize            : tunidata_size;              -- d‚lka intern¡ ‡ sti ©etˆzce
  base             : pentity_type;               -- b ze ©etˆzce
  rtype            : pentity_type;               -- typ rozsahu
  size             : tunidata_size;              -- vypo‡ten  velikost
  e                : tentityeval;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- b zov˜ typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_constrained,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getctype;
{
  -- b zov˜ typ nesm¡ b˜t neomezen˜
  if base^.stype in dts_unconstrained then
    ce^.seterror({CCERR=}000254,ce_i_basetype);
    ce^.setinfo(hint_string_base);
    curr.base.errpos;
    ce^.resumeerror;
    end if;
}
  if curr.stype=dt_string

    -- norm ln¡ ©etˆzec
    then
      -- d‚lka
      e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,final);
      if e_part(curr.seval,curr.expr.geteval) then return; end if;

      -- d‚lka ©etˆzce ve znac¡ch
      x_const_int(pexpnode(curr.expr.getcexpr),delka);

      -- d‚lka mus¡ b˜t <= CPU^.MAXSTRHVAL a >= 1
      if delka<ui_1 or delka>cpu^.maxstrhval then
        ce^.seterror({CCERR=}000255,ce_numrange);
        --%%TODO(LIB) ce^.setinfo(formats(hint_string_range,linttostr(cpu^.maxstrhval,tuniint:size)));
        curr.expr.errpos;
        ce^.resumeerror;
        end if;

    -- neomezen‚ pole
    else
      delka:=ui_0;
      end if;

  -- parametry ©etˆzce
  cpu^.getstrparams(curr.stype,size{curr.size},isize,base^.size,delka);

  -- doplnit velikost
  type_setsize(curr,size);

  -- odvodit typ rozsahu
  if curr.stype=dt_string
    then t_derive_string_range(curr,isize,delka);
    else t_derive_string_range(curr,isize,cpu^.maxstrhval);
    end if;

  -- vyhodnoceno
  curr.seval:=ete_evaluated;

  {%%X doplnit dal¨¡ kontroly !! a jak˜ ?? }
  end e_spec_string;



----------------------------------------------------------------------------------------------------
procedure e_spec_record : tevalspecproc =
-- Vyhodnot¡ definici typu record.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  varofs           : tunidata_addr;              -- aktu ln¡ offset slo‘ky
  maxofs           : tunidata_addr;              -- nejvy¨¨¡ dosa‘en˜ offset slo‘ky
  srch             : tentitysearch;              -- hled tko
  ui               : tuniint;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- slo‘ky
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;

  -- ur‡it adresy slo‘ek
  varofs:=curr.extofs;
  maxofs:=varofs;
  srch.find_et_first(^curr,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    verify(240,pentity_var(srch.psym)^.mclass<>mc_record);

    -- nen¡ pozice explicitnˆ specifikov na atributem ?
    if pentity_var(srch.psym)^.attr_position.isset

      -- ano => pou‘¡t
      then
        -- p©evz¡t hodnotu
        x_const_int(pentity_var(srch.psym)^.attr_position.getcexpr,ui);

        -- nastavit pozici
        cpu^.forcelayoutrecitem(pentity_var(srch.psym),uniint_to_unidata_addr(ui),curr.align,varofs,maxofs);

      -- ne => vypo‡¡tat automaticky
      else
        cpu^.layoutrecitem(pentity_var(srch.psym),curr.align,varofs,maxofs)
        end if;

    -- dal¨¡ slo‘ka
    srch.find_et_next;
    end loop;

  -- velikost recordu
  type_setsize(curr,unidata_addr_to_size(maxofs));

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_record;



----------------------------------------------------------------------------------------------------
procedure e_spec_set : tevalspecproc =
-- Vyhodnot¡ definici mno‘iny.
----------------------------------------------------------------------------------------------------
var
  base             : pentity_type;               -- b zov˜ typ mno‘iny
  items            : tuniint;                    -- po‡et prvk– mno‘iny
  size             : tunidata_size;              -- vypo‡ten  velikost mno‘iny

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- b zov˜ typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_full],dts_ordinal,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getctype;

  -- po‡et prvk– mno‘iny
  items:=base^.hval-base^.lval+ui_1;

  -- zjistit velikost mno‘iny
  cpu^.getsetparams(items,size);

  -- velikost recordu
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_set;



----------------------------------------------------------------------------------------------------
procedure e_spec_pointer : tevalspecproc =
-- Vyhodnot¡ definici typu pointer.
----------------------------------------------------------------------------------------------------
var
  base             : pentity_type;               -- b zov˜ typ
  size             : tunidata_size;              -- vypo‡ten  velikost
  ul               : tunilogical;
  e                : tentityeval;

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- b zov˜ typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_incomplete,tview_partial,tview_full],dts_all-dts_internal,true,true,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getutype;

  -- nen¡ po‘adov n strojov˜ pointer ?
  if curr.attr_mptr.isset then
    x_const_logical(curr.attr_mptr.getcexpr,ul);
    if ul=ul_true then curr.pflags+ptrflagsset:[pf_machine]; end if;
    end if;

  -- ur‡it t©¡du pointeru
  if base<>nil and then base^.tkind<>tk_unknown

    -- podle typu b ze
    then
      -- t©¡da pointeru
      case base^.stype
        when { tk_singular: } dt_procedure do curr.pclass:=pc_subprogram;
        when { tk_singular: } dt_task      do curr.pclass:=pc_task;
        when { tk_singular: } dt_message   do curr.pclass:=pc_message;
        when { tk_regular:  } others       do curr.pclass:=pc_data;
        end case;

      -- pro pointery na nedatov‚ objekty plat¡ jist  omezen¡
      if curr.pclass<>pc_data then
        -- pointer na proceduru nesm¡ b˜t PROTECTED/CONST
        if curr.paccess<>va_norm {pf_const in curr.pflags} then
          ce^.seterror({CCERR=}000256,ce_i_const);
          ce^.setinfo(hint_ptrproc_no_const);
          ce^.setpos(curr.pos[etp_def]);
          {%%RESUME ce^.raiseerror;}
          curr.paccess:=va_norm{curr.pflags-[pf_const]};
          end if;

        -- pointer na proceduru nesm¡ b˜t UNCHECKED
        if curr.pbase=pb_unchecked then
          ce^.seterror({CCERR=}000257,ce_i_const);
          ce^.setinfo(hint_ptrproc_no_unchecked);
          ce^.setpos(curr.pos[etp_def]);
          {%%RESUME ce^.raiseerror;}
          curr.pbase:=pb_strict;
          end if;
        end if;

    -- b ze nen¡ uvedena nebo nen¡ zn ma jej¡ t©¡da
    else
      verify(108,(base=nil) and (curr.pbase<>pb_unchecked));

      -- t©¡da pointeru
      curr.pclass:=pc_data;
      end if;

  -- strojov˜ pointer nesm¡ b˜t jen tak ledajak˜
  if pf_machine in curr.pflags then
    if not ((curr.pclass in ptrclassset:[pc_data,pc_subprogram])
    and (curr.pbase in ptrbaseset:[pb_strict,pb_unchecked])) then
      ce^.seterror({CCERR=}000258,ce_i_machineptr);
      ce^.setpos(curr.pos[etp_def]);
      {%%RESUME ce^.raiseerror;}
      curr.pflags-ptrflagsset:[pf_machine];
      end if;
    end if;

  -- pokud je uvedeno CLASS, mus¡ b˜t b zov˜ typ TAGGED
  if curr.pbase=pb_class and tf_tagged not in base^.tflags then
    ce^.seterror({CCERR=}000259,ce_i_basetype);
    ce^.setinfo(hint_ptr_tagged_base);
    {%%RESUME ce^.raiseerror;}
    curr.pbase:=pb_strict;
    end if;

  -- sestavit mno‘inu voliteln˜ch atribut–
  if pf_machine not in curr.pflags then
    t_get_pointer_rtattrib(curr.pbase,curr.pclass,base,curr.pattrib);
    end if;

  -- velikost pointeru
  cpu^.getptrsize({curr.pclass,curr.pbase,pf_machine in curr.pflags,}curr.pattrib,size{curr.size});

  -- doplnit velikost
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_pointer;



----------------------------------------------------------------------------------------------------
procedure e_spec_tag : tevalspecproc =
-- Vyhodnot¡ definici typu tag.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  size             : tunidata_size;              -- vypo‡ten  velikost

begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- velikost tagu (stejn  jako dynamick˜ atribut :tag)
  cpu^.getrtattribsize(rta_tag,size{curr.size});

  -- doplnit velikost
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_tag;



----------------------------------------------------------------------------------------------------
procedure e_spec_unitype : tevalspecproc =
-- Vyhodnot¡ definici univerz ln¡ho typu.
----------------------------------------------------------------------------------------------------
begin
  -- vyhodnocen¡ ji‘ jednou probˆhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_unitype;



{
----------------------------------------------------------------------------------------------------
procedure e_link (
var curr           : in deflink;                 -- vyhodnocovan˜ odkaz
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ odkaz.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- symbol
        e_refsymbol(curr,curr.sym,etd_full,true);
        if e_part(curr.eval,curr.sym.geteval) then return; end if;


    when others do verify(156,true);
    end case;
  end e_link;
}


----------------------------------------------------------------------------------------------------
procedure e_var (
    curr           : in out tentity_var;         -- vyhodnocovan  promˆnn 
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci promˆnn‚.
----------------------------------------------------------------------------------------------------
var
  sts              : tdatatypeset;
  ui               : tuniint;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- mno‘ina povolen˜ch typ– z vis¡ na m¢du p©¡stupu k promˆnn‚
        case curr.vmode
          when vm_direct do sts:=dts_constrained{+dts_class};
          when vm_ref    do sts:=dts_regular{+dts_class};
          when vm_index  do sts:=dts_constrained;
          when others    do verify(319,true);
          end case;

      {
        -- povolen‚ pohledy na typ
        tview:=ttypeviewset:[tview_partial,tview_full];

        -- Ondra 29.6.2001 : pokud je promˆnn  instance t©¡dy, tak je povolen
        -- i ne£pln˜ pohled na ty, aby bylo mo‘n‚ pou‘¡t typ t©¡dy v deklaraci
        -- parametru metody t‚ sam‚ t©¡dy
        -- %%X Nen¡ tohle n hodou z plata ??
        if (curr.typ.getctype^.stype=dt_class) and (curr.vmode=vm_ref) then
          tview+ttypeviewset:[tview_incomplete];
          end if;
      }

        -- typ promˆnn‚
        e_reftype(curr_context,curr.typ,ek_typename,ttypeviewset:[tview_partial,tview_full],sts,
            {for allow_class    use} curr.context.entity^.compiling=etd_public or curr.vimplements in vis_incomplete_class,
            {for allow_abstract use} curr.vimplements in vis_abstract{true,false},
            true);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- explicitnˆ ur‡en  pozice slo‘ky
        if curr.attr_position.isset then
          e_refexpr(curr_context,curr.attr_position,ek_const_int,nil,eu_use,true);
          if e_part(curr.eval,curr.attr_position.e) then return; end if;

          -- p©evz¡t z v˜razu pozici slo‘ky
          x_const_int(curr.attr_position.getcexpr,ui);

          -- mus¡ b˜t nez porn 
          if uniint_sign(ui) then
            ce^.seterror({ERRNUM=}000000,ce_i_attr_position);
            curr.attr_position.errpos;
            {%%RESUME ce^.raiseerror;}
            end if;
          end if;

        -- po‡ te‡n¡ hodnota
        if curr.init.getuexpr<>nil then
          e_refimm(curr_context,curr.init,ek_const,curr.typ.getctype,true);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if;

    when others do verify(157,true);
    end case;
  end e_var;



------------------------------------------------------------------------------------------------------
--procedure e_alias (
--    curr           : in out tentity_alias;       -- vyhodnocovan˜ alias
--    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
--    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
---- Vyhodnot¡ deklaraci aliasu.
------------------------------------------------------------------------------------------------------
--var
--  psym             : pentity;
--
--begin
--  u_nimplemented(62);
--{
--  case level
--    -- --> incomplete
--    when etd_incomplete  do curr.eval:=ete_evaluated;
--
--    -- --> full
--    when etd_full do
--        -- typ
--        e_reftype(curr,curr.typ,ek_typename,etd_full,true);
--        if e_part(curr.eval,curr.typ.geteval) then return; end if;
--
--        -- metoda pro z pis (IN)
--        e_refsymbol(curr,curr.write,sd_specified,{ek_sym_var_proc,nil,}final);
--        if e_part(curr.eval,curr.write.geteval) then return; end if;
--
--        -- kontrola symbolu
--        psym:=curr.write.getcentity;
--        case psym^.etype
--          -- promˆnn 
--          when et_var do
--              -- nesm¡ b˜t konstantn¡
--
--              -- typy mus¡ b˜t kompatibiln¡
--              {%%TECH Kontroluje se pro p©i©azen¡ ALIAS.IN:=value(ALIAS:type) }
--              if not t_compatible(toc_assign,t_defview(pentity_var(psym)^.typ.getctype),t_defview(curr.typ.getctype),false) then
--                ce^.seterror({CCERR=}000260,ce_aliastype);
--                ce^.setpos(curr.write.pos);
--                {%%RESUME ce^.raiseerror;}
--                ce^.resumeerror;
--                end if;
--
--
--          -- procedura
--          when et_proc  do
--              {%%X mus¡ m¡t jeden parametr kompatibiln¡ho typu }
--              u_nimplemented(33);
--
--
--          -- jin˜ symbol je chyba
--          when others do
--              ce^.seterror({CCERR=}000261,ce_x_ex_sym_var_proc);
--              ce^.setpos(curr.write.pos);
--              {%%RESUME ce^.raiseerror;}
--              ce^.resumeerror;
--              --verify(102,false);
--          end case;
--
--        -- metoda pro ‡ten¡ (OUT)
--        e_refsymbol(curr,curr.read,sd_specified,{ek_sym_var_proc,nil,}final);
--        if e_part(curr.eval,curr.read.geteval) then return; end if;
--
--        -- kontrola symbolu
--        psym:=curr.write.getcentity;
--        case psym^.etype
--          -- promˆnn 
--          when et_var do
--              -- typy mus¡ b˜t kompatibiln¡
--              {%%TECH Kontroluje se pro p©i©azen¡ var(ALIAS:type):=ALIAS.OUT }
--              if not t_compatible(toc_assign,t_defview(curr.typ.getctype),t_defview(pentity_var(psym)^.typ.getctype),false) then
--                ce^.seterror({CCERR=}000262,ce_aliastype);
--                ce^.setpos(curr.read.pos);
--                {%%RESUME ce^.raiseerror;}
--                ce^.resumeerror;
--                end if;
--
--
--          -- procedura
--          when et_proc  do
--              {%%X nesm¡ m¡t ‘ dn‚ parametry, mus¡ vracet hodnotu kompatibiln¡ho typu }
--              -- a co takhle REF parametr ? (resp. OUT)
--              u_nimplemented(33);
--
--
--          -- jin˜ symbol je chyba
--          when others do
--              ce^.seterror({CCERR=}000263,ce_x_ex_sym_var_proc);
--              ce^.setpos(curr.read.pos);
--              {%%RESUME ce^.raiseerror;}
--              ce^.resumeerror;
--              --verify(102,false);
--          end case;
--
--
--    when others do verify(158,true);
--    end case;
--}
--  end e_alias;



----------------------------------------------------------------------------------------------------
procedure e_type_derived (
    curr           : in out tentity_type;        -- vyhodnocovan˜ typ
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ odvozen˜ typ.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity_type;               -- p©edek
  t                : typeview;                   -- pohled na p©edka
  lval             : tuniint;                    -- nov‚ meze pole
  hval             : tuniint;                    -- nov‚ meze pole
  oldrange         : pentity_type;               -- p–vodn¡ typ rozsahu
  newrange         : pentity_type;               -- nov˜ typ rozsahu
  newrange_context : tcontext;                   -- prim rn¡ kontext nov‚ho rozsahu
  pos              : lexposblock;                -- pozice rozsahu
  size             : tunidata_size;              -- nov  velikost typu
  isize            : tunidata_size;              -- velikost intern¡ ‡ sti ©etˆzce
  delka            : tuniint;                    -- d‚lka ©etˆzce
  e                : tentityeval;

begin
  -- vyhodnotit p©edka
  e_refsymbol_from_typename(curr_context,curr.ancestor,etd_full,ttypeviewset:[tview_partial,tview_full],dts_singular+dts_regular-dts_class,false,true,final);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

  -- p©edek
  ancestor:=pentity_type(curr.ancestor.getcentity);

  -- zkonstruovat pohled na typ p©edka
  t.init(curr_context,ancestor);

  -- nesm¡ to b˜t Incomplete view ani Unchecked view
  if t.tview in ttypeviewset:[tview_incomplete,tview_unchecked] then
    ce^.seterror({CCERR=}000264,ce_i_derive);
    ce^.setinfo(hint_derive_full);
    curr.ancestor.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- zkontrolovat druh typu, pokud je pro odvozovan˜ typ p©edvybr n
  if (curr.tkind<>tk_unknown) and (curr.tkind<>ancestor^.tkind) then
    ce^.seterror({CCERR=}000429,ce_i_derive);
    if ancestor^.tkind=tk_regular
      then ce^.setinfo(hint_derive_regular);
      else ce^.setinfo(hint_derive_singular);
      end if;
    curr.ancestor.errpos;
    ce^.resumeerror;
    end if;

  -- zkop¡rovat determinaci kompatibility, jestli se nezmˆnila
  if (curr.compat=tc_norm) and (t.tview=tview_full) then curr.compat:=t.compat; end if;

  -- zkop¡rovat z kladn¡ £daje, kter‚ se nemohly ur‡itˆ zmˆnit
  curr.size    :=ancestor^.size;
  curr.extofs  :=ancestor^.extofs{size}; -- EXTOFS se zmˆn¡ jen pro TD_EXTENSION
  curr.tflags  :=ancestor^.tflags;
  curr.align   :=ancestor^.align;

  case curr.derive
    -- trivi ln¡ derivace
    when td_unconstrained     do
        -- zkop¡rovat ostatn¡ £daje o typu
        curr.seval   :=ancestor^.seval;
        curr.tkind   :=ancestor^.tkind;
        curr.stype   :=ancestor^.stype;
        curr.lval    :=ancestor^.lval;
        curr.hval    :=ancestor^.hval;
        curr.bits    :=ancestor^.bits;
        curr.intaritm:=ancestor^.intaritm;
      { Ondra 3.4.2003 : Zru¨eno, float se novˆ definuje po‡tem bit–.
        curr.dtype   :=ancestor^.dtype;
      }
        curr.fp      :=ancestor^.fp;
        curr.srange  :=ancestor^.srange;
      --curr.lsize   :=ancestor^.lsize;
        curr.pflags  :=ancestor^.pflags;
        curr.pclass  :=ancestor^.pclass;
        curr.pbase   :=ancestor^.pbase;
        curr.pattrib :=ancestor^.pattrib;
        curr.rflags  :=ancestor^.rflags;
        curr.result  :=ancestor^.result;
        curr.insize  :=ancestor^.insize;
        curr.parcount:=ancestor^.parcount;
        curr.base    :=ancestor^.base;
        curr.srange  :=ancestor^.srange;
        curr.saliased:=ancestor^.saliased;

        -- default view
        curr.defview :=t.tview;

    -- type constraint
    when td_constrained       do
        -- p©edek mus¡ b˜t Full view
        if t.tview<>tview_full then
          ce^.seterror({CCERR=}000265,ce_i_derive);
          ce^.setinfo(hint_derive_constraint);
          curr.ancestor.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;

        -- zkop¡rovat nˆkter‚ £daje
        curr.seval   :=ancestor^.seval;
        curr.tkind   :=ancestor^.tkind;
        curr.stype   :=ancestor^.stype;

        case t.stype
          -- ordin ln¡ typy
          when dt_signed, dt_unsigned, dt_char, dt_enum, dt_logical do
              -- p©evz¡t z kladn¡ £daje
              curr.bits    :=ancestor^.bits;
              curr.intaritm:=ancestor^.intaritm;

              -- vyhodnotit rozsah
              e_refexpr(curr_context,curr.expr,ek_rangetype,ancestor,eu_read,final);
              if e_part(curr.eval,curr.expr.geteval) then return; end if;

              -- meze
              x_const_range(curr.expr.getcexpr,curr.lval,curr.hval);

          -- pole/neomezen‚ pole
          -- Ondra 25.2.2002 : Zak z no odvozov n¡ od constrained pol¡
          when {dt_array,} dt_uarray  do
              -- pole je jistˆ omezen‚
              curr.stype   :=dt_array;

              -- p©evz¡t z kladn¡ £daje
              curr.base    :=ancestor^.base;

              -- %%TECH Tˆ‘k  finta: pro odvozen¡ nov‚ho typu rozsahu se
              -- pou‘ije mechanismus pro p©eklad deklarac¡. Ale mysl¡m, ‘e je
              -- to naprosto v souladu s koncepc¡ Flexu - omezen¡ rozsahu
              -- pole je vlastnˆ implicitn¡ deklarace typu rozsahu (stejnˆ
              -- jako v norm ln¡ deklaraci pole) s implicitn¡m p©edkem.

              -- pozice v˜razu
              pexpnode(curr.expr.getcexpr)^.getpos(pos);

              -- odvodit nov˜ typ rozsahu
              d_create_implicit_type(curr_context,newrange,newrange_context,dt_undef,pos);

              -- ozna‡it typ za odvozen˜
              newrange^.derive:=td_constrained;

              -- p©i©adit p©edka a nov˜ rozsah
              newrange^.ancestor.setentity(t.getrange(curr_context).getctype);
              newrange^.expr.setexpr(curr.expr.getcexpr);

              -- konec deklarace (a zde se rekurzivnˆ zavol  E_TYPE_DERIVED)
              d_end_implicit_type(newrange^,pos,true);

              -- dosadit nov˜ rozsah do pole
              curr.srange.settype(newrange);{%%TODO(DECLPOS) Nastavit souvisej¡c¡ v˜raz nebo aspo¤ pozici, ne ? }

              -- vypo‡¡tat d‚lku pole
              size:=arraysize(curr.base.getctype^.size,curr.srange.getctype^.lval,curr.srange.getctype^.hval);

              -- dosadit velikost typu
              type_setsize(curr,size);

          -- ©etˆzec/neomezen˜ ©etˆzec
          -- Ondra 25.2.2002 : Zak z no odvozov n¡ od constrained string–
          when {dt_string,} dt_ustring do
              -- ©etˆzec je jistˆ omezen˜
              curr.stype   :=dt_string;

              -- p©evz¡t z kladn¡ £daje
              curr.base    :=ancestor^.base;

              -- d‚lka
              e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,final);
              if e_part(curr.seval,curr.expr.geteval) then return; end if;

              -- d‚lka ©etˆzce ve znac¡ch
              x_const_int(pexpnode(curr.expr.getcexpr),delka);

              -- d‚lka mus¡ spadat do mez¡ p–vodn¡ho ©etˆzce
              if delka<ancestor^.srange.getctype^.lval or delka>ancestor^.srange.getctype^.hval then
                ce^.seterror({CCERR=}000266,ce_numrange);
                curr.expr.errpos;
                ce^.resumeerror;
                end if;

              -- parametry ©etˆzce
              cpu^.getstrparams(curr.stype,size,isize,curr.base.getctype^.size,delka);

              -- odvodit typ rozsahu
              -- %%X Zde se pro odvozen¡ typu rozsahu ©etˆzce pou‘¡v  jin˜ mechanismus,
              -- ne‘ pro odvozen¡ rozsahu pole. To je minim lnˆ divn‚.
              t_derive_string_range(curr,isize,delka);

              -- p©i©adit p©edka typu rozsahu
              curr.srange.getctype^.ancestor.setentity(t.getrange(curr_context).getctype);

              -- dosadit velikost typu
              type_setsize(curr,size);
              --u_nimplemented(86);

          -- pro ostatn¡ typy nem  omezen¡ rozsahu smysl
          when others do
              ce^.seterror({CCERR=}000267,ce_i_derive);
              ce^.setinfo(hint_derive_constraint);
              curr.ancestor.errpos;
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
          end case;

        -- default view
        curr.defview:=tview_full;

    -- type extension/private extension,
    when td_extension, td_private_extension do
        -- v˜sledn˜ typ bude jistˆ regul rn¡
        curr.tkind:=tk_regular;

        -- vypo‡¡tat offset extension ‡ sti
        curr.extofs:=unidata_size_to_addr(ancestor^.size);

        case t.tview
          -- Partial view => typ lze roz¨¡©it libovolnˆ
          when tview_partial do
              -- vyhodnotit specifikaci
              verify(451,e_spec_tab[curr.stype]=nil);
              e_spec_tab[curr.stype]^(curr,curr_context,final);
              if e_part(curr.eval,curr.seval) then return; end if;

          -- Full view => lze roz¨¡©it jen record recordem
          when tview_full do
              if (ancestor^.stype=dt_record) and (curr.stype=dt_record)

                -- record -- record
                then
                  -- vyhodnotit specifikaci
                  e_spec_record(curr,curr_context,final);
                  if e_part(curr.eval,curr.seval) then return; end if;

                -- jin‚ extension nejsou dovoleny
                else
                  ce^.seterror({CCERR=}000268,ce_i_extension);
                  curr.ancestor.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

          -- jin‚ typy pohled– na typ nelze roz¨¡©it
          when others do
              ce^.seterror({CCERR=}000269,ce_i_extension);
              curr.ancestor.errpos;
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
          end case;

        --u_nimplemented(86)

    when others do verify(241,true);
    end case;
  end e_type_derived;



----------------------------------------------------------------------------------------------------
procedure e_type (
    curr           : in out tentity_type;        -- vyhodnocovan˜ typ
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci typu.
----------------------------------------------------------------------------------------------------
use
  cc_base.cc_sym.cc_advanced;

var
  i                : t_unsigned;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
      { Ondra 12.11.2003 : Zru¨eno, novˆ jsou tagged v¨echny netemporary typy. Dospˆl jsem k z vˆru,
        ‘e v ka‘d‚m deklarativn¡m regionu existuje nejv˜¨e jeden nepojmenovan˜ typ, tak‘e je v‘dy
        plnˆ kvalifikovateln˜ a tud¡‘ neexistuje probl‚m p©i dynamick‚m linkov n¡

        -- pojmenovan˜ typ je automaticky tagged
        if curr.id<>nil then curr.tflags+typeflagsset:[tf_tagged]; end if;
      }

        -- netemporary typ je automaticky tagged
        if tf_temp not in curr.tflags then curr.tflags+typeflagsset:[tf_tagged]; end if;

        curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
--      verify(17,(curr.stype=st_undef) and final);
{
        -- vyhodnotit statick‚ p©edky
        for i in 1..curr.pcount loop
          e_reftype(curr.context.entity^,curr.plist^[i],ek_typename,etd_full,final);
          if e_part(curr.{s^.}eval,curr.plist^[i].geteval) then return; end if;
          end loop;
}
        -- ur‡it/zkontrolovat t©¡du typu
        if curr.derive=td_root then
          case curr.tkind
            -- dosud nezji¨tˆna
            when tk_unknown do
                -- ur‡it z definice typu
                if curr.stype in dts_regular+dts_unitype
                  then curr.tkind:=tk_regular;
                  else curr.tkind:=tk_singular;
                  end if;

            -- regul rn¡
            when tk_regular do
                -- pokud to nen¡ private extension (ta je zat¡m ST_UNDEF)
                if {(curr.derive<>td_private_extension)
                -- mus¡ tomu odpov¡dat i definice typu
                and} not (curr.stype in dts_regular) then
                  ce^.seterror({CCERR=}000270,ce_i_typedef);
                  if curr.derive=td_root
                    then ce^.setinfo(hint_type_regular);
                    else {%%X};
                    end if;
                  ce^.setpos(curr.pos[etp_def]);
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

            -- singul rn¡
            when tk_singular do
                -- odpov¡d  tomu i definice typu ?
                if not (curr.stype in dts_singular) then
                  ce^.seterror({CCERR=}000271,ce_i_typedef);
                  ce^.setinfo(hint_type_singular);
                  ce^.setpos(curr.pos[etp_def]);
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

            end case;
          end if;

        -- %%TECH Zde se vyhodnocuj¡ v¨echy atributy, i kdy‘ nemaj¡ pro
        -- dan˜ typ smysl. P©¡pustnost mˆl zajistit p©eklad atribut–.

        -- vyhodnotit atributy
        e_refexpr(curr_context,curr.attr_align,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_align.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_size,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_size.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_mptr,ek_const_logical,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_mptr.geteval) then return; end if;

        -- zarovn n¡
        type_setalign(curr,cpu^.defaultalign);

        -- vyhodnotit specifikaci typu
        if curr.derive=td_root

          -- vyhodnotit ko©enov˜ typ
          then
            -- vyhodnotit specifikaci
            verify(35,e_spec_tab[curr.stype]=nil);
            e_spec_tab[curr.stype]^(curr,curr_context,final);
            if e_part(curr.eval,curr.seval) then return; end if;

          -- vyhodnotit odvozen˜ typ
          else
            e_type_derived(curr,curr_context,level,final);
            end if;

        -- po‡ te‡n¡ hodnota
        if curr.init.getuexpr<>nil then
          -- %%X Tak tohle je tedy ligov  z plata: Aby fungovala typov  kontrola, mus¡ b˜t
          -- dokon‡ena deklarace typu
          cc_base.cc_sym.cc_advanced.sym_set_evaluated(^curr);

          -- vyhodnotit po‡ te‡n¡ hodnotu
          e_refimm(curr_context,curr.init,ek_const,^curr,true);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if;

    when others do verify(159,true);
    end case;
  end e_type;



----------------------------------------------------------------------------------------------------
procedure e_const (
    curr           : in out tentity_const;       -- vyhodnocovan  konstanta
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci konstanty.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        if cf_typed in curr.cflags

          -- konstanta s explicitnˆ uveden˜m typem
          then
            -- vyhodnotit typ
            e_reftype(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_incomplete,tview_full],dts_constrained-dts_class,false,false,final);
            if e_part(curr.eval,curr.typ.geteval) then return; end if;

          -- konstanta s implicitnˆ uveden˜m typem
          else
            curr.eval:=ete_evaluated
            end if;

    -- --> full
    when etd_full do
        if cf_typed in curr.cflags

          -- konstanta s explicitnˆ uveden˜m typem
          then
            -- vyhodnotit typ
            e_reftype(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],dts_constrained-dts_class,false,false,{etd_full,}final);
            if e_part(curr.eval,curr.typ.geteval) then return; end if;

            -- vyhodnotit hodnotu
            e_refimm(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.init,ek_const,curr.typ.getctype,final);
            if e_part(curr.eval,curr.init.geteval) then return; end if;

          -- konstanta s implicitnˆ uveden˜m typem
          else
            -- vyhodnotit hodnotu
            e_refimm(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.init,ek_const,nil,final);
            if e_part(curr.eval,curr.init.geteval) then return; end if;

            -- p©evz¡t typ
            -- %%X nem–‘u tady p©ij¡t o v˜raz ?
            {%%TODO(DECLPOS) Nastavit souvisej¡c¡ v˜raz nebo aspo¤ pozici, ne ? }
            curr.typ.settype(pexpnode(curr.init.getcexpr)^.t.getutype);
            end if;

    when others do verify(160,true);
    end case;
  end e_const;



----------------------------------------------------------------------------------------------------
procedure e_enum (
    curr           : in out tentity_enum;        -- vyhodnocovan  konstanta
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci prvku v˜‡tov‚ho typu.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- m me k dispozici explicitnˆ p©edepsanou ordin ln¡ hodnotu ?
        if curr.attr_ord.isset

          -- ano => pou‘¡t
          then
            -- vyhodnotit atribut
            e_refexpr(curr_context,curr.attr_ord,ek_const_int,nil,eu_use,true);
            if e_part(curr.eval,curr.attr_ord.geteval) then return; end if;

            -- p©evz¡t z v˜razu hodnotu
            x_const_int(curr.attr_ord.getcexpr,curr.ordinal);

          -- ne => default podle po©ad¡ prvku
          else
            curr.ordinal:=unsigned_to_uniint(curr.order);
            end if;

        -- ozna‡it za vyhodnocen‚
        curr.eval:=ete_evaluated;

    when others do verify(161,true);
    end case;
  end e_enum;



----------------------------------------------------------------------------------------------------
procedure e_code_body (
    curr           : in out class tentity_code;  -- vyhodnocovan  procedura
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnocen¡ tˆla podprogramu pro £rove¤ SD_FULL.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- lok ln¡ symboly
  e_all(curr,etd_full,final,e);
  if e_part(curr.eval,e) then return; end if;

  -- p©¡kazy
  e_refblock(curr_context,curr.bl,final);
  if e_part(curr.eval,curr.bl.e) then return; end if;
  end e_code_body;



----------------------------------------------------------------------------------------------------
procedure e_check_subprogram_type (
    ptyp           : in pentity_type) =          -- typ podprogramu
-- Dodate‡n  kontrola typu podprogramu - kontroluje £plnost deklarace typ– parametr–.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko

begin
  verify(230,ptyp^.stype<>dt_procedure);

  -- projet v¨echny parametry
  srch.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
  while srch.psym<>nil loop
    -- teƒ u‘ jsou povoleny jen Partial view a Full view na typ parametru
    e_reftype(sym_primary_context(srch.psym^),pentity_param(srch.psym)^.typ,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_regular,true,true,true);

    -- dal¨¡ parametr
    srch.find_et_next;
    end loop;
  end e_check_subprogram_type;



----------------------------------------------------------------------------------------------------
procedure e_before_subprogram_body =
-- Dokon‡en¡ vyhodnocen¡ specifikace podprogram p©ed p©ekladem definice.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype 
    -- procedura, statick  a virtu ln¡ metoda
    when et_procedure, et_static, et_virtual do
        -- kontrola typu procedury
        e_check_subprogram_type(pentity_subprogram(entity)^.typ.getctype);

    -- override virtu ln¡ metody
    when et_override do
        {%%X};

    -- speci ln¡ metoda
    when et_special do
        -- kontrola typu procedury
        if etc_generated in entity^.compile then
          e_check_subprogram_type(pentity_special(entity)^.typ.getctype);
          end if;

    -- nic jin‚ho nen¡ podprogram
    when others do verify(728,true);
    end case;
  end e_before_subprogram_body;



----------------------------------------------------------------------------------------------------
procedure e_special (
    curr           : in out tentity_special;     -- vyhodnocovan  speci ln¡ metoda
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci speci ln¡ metody.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_none do
        verify(577,etc_generated in curr.compile);
        curr.eval:=ete_evaluated;

    -- --> incomplete -- pouze pro intern¡ speci ln¡ metody
    when etd_incomplete  do
        verify(578,etc_generated not in curr.compile);

        -- vyhodnotit typ speci ln¡ metody
        e_reftype(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_procedure],false,false,false);
        if e_part(curr.eval,curr.typ.e) then return; end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tˆlo
        e_code_body(curr,curr_context,final);

    when others do verify(162,true);
    end case;
  end e_special;



----------------------------------------------------------------------------------------------------
procedure e_subprogram (
    curr           : in out class tentity_subprogram; -- vyhodnocovan  procedura
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci procedury, statick‚ a virtu ln¡ metody.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  pclass           : pentity_type;           -- souvisej¡c¡ t©¡da

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        -- typ procedury
        e_reftype(curr_context{%%TODO(Ondra): Pro‡ tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_procedure],false,false,false);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- nen¡ to n hodou virtu ln¡ metoda ?
        if curr.etype=et_virtual then
          -- v ‡em je deklarovan  ?
          if curr.context.entity^.etype=et_class

            -- v t©¡dˆ => nemus¡ m¡t ©¡d¡c¡ parametry
            then
              -- pro zjednodu¨en¡: pointer na t©¡du
              pclass:=pentity_type(curr.context.entity);

              -- m  virtu ln¡ metoda ©¡d¡c¡ parametry
              if rf_virtual in curr.typ.getctype^.rflags

                -- ano m  => komplexn¡ vol n¡
                then
                  pentity_virtual(^curr)^.vcall:=tvct_complex;

                  unimplemented(159);

                -- nem  => jednoduch‚ vol n¡
                else
                  declare var
                    interface : p_class_interface;

                  begin
                    -- zp–sob vol n¡
                    pentity_virtual(^curr)^.vcall:=tvct_simple_index;

                    -- naj¡t nativn¡ interface
                    interface:=pclass^.interfaces^.get_native_interface;

                    -- p©idˆlit index a za©adit do virtu ln¡ tabulky
                    interface^.add_virtual_method(^curr);
                    end declare;
                  end if;

            -- v modulu, programu nebo kompila‡n¡ jednotce => mus¡ m¡t ©¡d¡c¡ parametry
            else
              -- typ mus¡ m¡t ©¡d¡c¡ parametry
              if rf_virtual not in curr.typ.getctype^.rflags then
                {%%X}
                end if;

              -- zp–sob vol n¡: komplexn¡
              pentity_virtual(^curr)^.vcall:=tvct_complex;

              unimplemented(160);
              end if;

          -- p©idˆlit slot ve virtu ln¡ tabulce
          {%%X}
          end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tˆlo
        e_code_body(curr,curr_context,final);

    when others do verify(163,true);
    end case;
  end e_subprogram;



----------------------------------------------------------------------------------------------------
procedure e_override (
    curr           : in out tentity_override;    -- vyhodnocovan  procedura
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci p©et¡‘en¡ virtu ln¡ metody.
----------------------------------------------------------------------------------------------------
var
  pvirt            : pentity_virtual;        -- souvisej¡c¡ virtu ln¡ metoda

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        -- p©etˆ‘ovan  virtu ln¡ metoda
        e_refsymbol(curr_context,curr.virt,etd_incomplete,true);
        if e_part(curr.eval,curr.virt.geteval) then return; end if;

        -- pro zjednodu¨en¡: pointer na virtu ln¡ metodu
        pvirt:=pentity_virtual(curr.virt.getcentity);

        -- v ‡em byla p–vodn¡ virtu ln¡ metoda deklarov na ?
        if pvirt^.context.entity^.etype=et_class

          -- v t©¡dˆ
          then
            -- override mus¡ b˜t t‚‘ v t©¡dˆ
            if curr.context.entity^.etype<>et_class then
              {%%X}
              end if;

            -- m  virtu ln¡ metoda nˆjak‚ ©¡d¡c¡ parametry ?
            if rf_virtual in pvirt^.typ.getctype^.rflags then
              unimplemented(162);
              end if;

            declare var
              pclass_virt : pentity_type;        -- t©¡da ve kter‚ je virtu ln¡ metoda
              pclass_this : pentity_type;        -- t©¡da ve kter‚ je override = tato t©¡da

            begin
              -- pro zjednodu¨en¡: pointer na t©¡du
              x_get_context(curr.virt.getcexpr,pclass_virt);
            --pclass_virt:=pentity_type(pvirt^.context.entity);
              pclass_this:=pentity_type(curr.context.entity);

              -- vyhledat interface
              if sym_is_ancestor(pclass_virt,pclass_this)

                -- overridujeme metodu p©edka => nativn¡ interface
                then curr.interface:=pclass_this^.interfaces^.find_interface(pclass_this);

                -- overridujeme jinou metodu => nˆjak˜ exposovan˜ interface
                else curr.interface:=pclass_this^.interfaces^.find_interface(pclass_virt);
                end if;

              -- nena¨el-li se interface, nem  tu override co dˆlat
              if curr.interface=nil then
                ce^.seterror({CCERR=}000000,ce_i_override);
                pexpnode(curr.virt.getcexpr)^.errpos;
                ce^.raiseerror;
                end if;
              verify(697,curr.interface^.is_exposed<>not sym_is_ancestor(pclass_virt,pclass_this));

              -- nebyla u‘ metoda jednou p©et¡‘ena ?
              if curr.interface^.is_virtual_method_overriden(pvirt) then
                ce^.seterror({CCERR=}000430,ce_multioverride);
                ce^.setparam(sym_get_qid(pvirt));
                ce^.setpos(curr.pos[etp_header]);
                ce^.raiseerror;
                end if;

              -- p©et¡‘it virtu ln¡ metodu
              curr.interface^.override_virtual_method(pvirt,^curr);
              end declare;

          -- v modulu, programu ‡i kompila‡n¡ jednotce
          else
            -- override mus¡ b˜t t‚‘ v modulu, programu ‡i kompila‡n¡ jednotce
            if curr.context.entity^.etype not in ets_container-tentitytypeset:[et_class] then
              {%%X}
              end if;

            unimplemented(161);
            end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tˆlo
        e_code_body(curr,curr_context,final);

    when others do verify(164,true);
    end case;
  end e_override;



----------------------------------------------------------------------------------------------------
procedure e_overload (
    curr           : in out tentity_overload;    -- vyhodnocovan‚ p©et¡‘en¡
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci p©et¡‘en¡.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level

    -- --> full
    when etd_full do
        -- na p©et¡‘en‚ procedury nejsou kladena skoro ‘ dn  omezen¡
        for i in curr.table^:range loop
          -- vyhodnotit odkaz
          e_refsymbol(curr_context,curr.table^[i].psym,etd_incomplete,true);
          if e_part(curr.eval,curr.table^[i].psym.geteval) then return; end if;
          end loop;
        curr.eval:=ete_evaluated;

    when others do verify(274,true);
    end case;
  end e_overload;



----------------------------------------------------------------------------------------------------
procedure e_operator (
    curr           : in out tentity_operator;    -- vyhodnocovan˜ oper tor
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci p©et¡‘en¡.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_procedure;          -- p©et¡‘en  procedura
  ptyp             : pentity_type;               -- typ procedury
  pparam           : pentity_param;              -- parametr
  srch             : tentitysearch;              -- hled tko
  e                : tentityeval;

begin
  case level

    -- --> full
    when etd_full do
        -- zkontrolovat p©¡pustnost p©et¡‘en˜ch procedur
        for i in curr.table^:range loop
          -- vyhodnotit odkaz
          e_refsymbol(curr_context,curr.table^[i].psym,etd_incomplete,true);
          if e_part(curr.eval,curr.table^[i].psym.geteval) then return; end if;

          -- p©et¡‘en  procedura a jej¡ typ
          pproc:=pentity_procedure(curr.table^[i].psym.getcentity);
          ptyp:=pproc^.typ.getctype;

          {%%X p©etˆ‘ovat metody zat¡m neum¡m }
          if pproc^.instance<>tip_none then unimplemented(97); end if;

          -- kolik m  parametr– ?
          case ptyp^.parcount
            -- jeden parametr
            when 1 do
                -- p©etˆ‘ovan˜ oper tor mus¡ b˜t un rn¡
                if not (toa_unary in ooperinfo[curr.oop].arity) then
                  ce^.seterror({CCERR=}000272,ce_operator_params);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- poznamenat, ‘e je oper tor un rn¡
                curr.table^[i].arity:=toa_unary;

            -- dva parametry
            when 2 do
                -- p©etˆ‘ovan˜ oper tor mus¡ b˜t bin rn¡
                if not (toa_binary in ooperinfo[curr.oop].arity) then
                  ce^.seterror({CCERR=}000273,ce_operator_params);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- nal‚zt druh˜ parametr
                srch.find_et_first(ptyp,rc_primary,et_param,[]);
                srch.find_et_next;
                pparam:=pentity_param(srch.psym);
                verify(279,pparam=nil);

                -- nemˆl by b˜t UNCHECKED
                if pparam^.pass=pp_unchecked then
                  ce^.seterror({CCERR=}000274,ce_operator_pass2);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- druh˜ parametr mus¡ b˜t IN
                if pparam^.mode<>pm_in then
                  ce^.seterror({CCERR=}000275,ce_operator_mode2);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- poznamenat, ‘e je oper tor un rn¡
                curr.table^[i].arity:=toa_binary;

            -- v¡ce parametr– je jistˆ chyba, takov‚ oper tory nem me
            when others do
                ce^.seterror({CCERR=}000276,ce_operator_params);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
            end case;

          -- nal‚zt prvn¡ parametr
          srch.find_et_first(ptyp,rc_primary,et_param,[]);
          pparam:=pentity_param(srch.psym);
          verify(280,pparam=nil);

          -- nemˆl by b˜t UNCHECKED
          if pparam^.pass=pp_unchecked then
            ce^.seterror({CCERR=}000277,ce_operator_pass1);
            curr.table^[i].psym.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- m  n vratovou hodnotu ?
          if ptyp^.result=nil

            -- ne
            then
              -- pak mus¡ b˜t prvn¡ parametr IN OUT, pro p©i©azen¡ lze i pouze OUT
              if (curr.oop=oop_assign and then pparam^.mode not in parammodeset:[pm_out,pm_inout])
              or (curr.oop<>oop_assign and then pparam^.mode<>pm_inout) then
                ce^.seterror({CCERR=}000278,ce_operator_mode1);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- poznamenat, ‘e je to zkr cen‚ p©i©azen¡
              curr.table^[i].assign:=true;

            -- ano
            else
              -- oper tor nesm¡ b˜t prost‚ p©i©azen¡
              if curr.oop=oop_assign then
                ce^.seterror({CCERR=}000279,ce_operator_noret);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- pak mus¡ b˜t prvn¡ parametr IN
              if pparam^.mode<>pm_in then
                ce^.seterror({CCERR=}000280,ce_operator_mode1);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- poznamenat, ‘e je to zkr cen‚ p©i©azen¡
              curr.table^[i].assign:=false;
              end if;
          end loop;

        -- vyhodnoceno
        curr.eval:=ete_evaluated;

    when others do verify(275,true);
    end case;
  end e_operator;



----------------------------------------------------------------------------------------------------
procedure e_extend_module (
    curr           : in out tentity_module;      -- vyhodnocovan˜ modul
    curr_context   : in tcontext) =              -- prim rn¡ kontext modulu
-- Vyhodnot¡ p©edka modulu.
----------------------------------------------------------------------------------------------------
begin
  -- m  smysl nˆco za‡¡nat ?
  if not curr.ancestor.isset then return end if;

  -- vyhodnotit p©edka
  e_refsymbol(curr_context,curr.ancestor,etd_incomplete,true);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;
  end e_extend_module;



----------------------------------------------------------------------------------------------------
procedure e_module (
    curr           : in out tentity_module;      -- vyhodnocovan˜ modul
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci modulu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> public
    when etd_public do
        -- lok ln¡ symboly
        e_all(curr,etd_incomplete,final,e);
        if e_part(curr.eval,e) then return; end if;

    -- --> full
    when etd_full do
        -- lok ln¡ symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

    when others do verify(164,true);
    end case;
  end e_module;



----------------------------------------------------------------------------------------------------
procedure e_extend_class (
    curr           : in out tentity_type;         -- vyhodnocovan  t©¡da
    curr_context   : in tcontext) =              -- prim rn¡ kontext entity
-- Vyhodnot¡ p©edka t©¡dy.
----------------------------------------------------------------------------------------------------
begin
  -- m  smysl nˆco za‡¡nat ?
  if not curr.ancestor.isset then return end if;

  -- vyhodnotit p©edka
  e_refsymbol_from_typename(curr_context,curr.ancestor,etd_incomplete,ttypeviewset:[tview_full,tview_incomplete],dts_class,true,true,for final use true);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

  -- p©evz¡t informace o v¨ech interfacech z p©edka
  curr.interfaces^.merge_interface_list(pentity_type(curr.ancestor.getcentity)^.interfaces);
  end e_extend_class;



----------------------------------------------------------------------------------------------------
procedure e_expose_class (
    curr           : in out tentity_type;         -- vyhodnocovan  t©¡da
    curr_context   : in tcontext) =              -- prim rn¡ kontext entity
-- Vyhodnot¡ interfacy t©¡dy.
----------------------------------------------------------------------------------------------------
with
  standard.classes.lists;

begin
  -- vyhodnotit interfacy (1. je nativn¡, nen¡ pot©eba vyhodnocovat)
  if curr.interfaces^.count>1 then
    declare var
      it       : c_list_iterator;            -- iter tor
      interface: p_class_interface;          -- interface t©¡dy

    begin
      -- p©ipravit iter tor
      curr.interfaces^.get_exposed_interfaces(it);

      -- zpracovat v¨echny interfacy
      while it.get(interface) loop
        -- vyhodnotit
        e_refsymbol_from_typename(curr_context,interface^.refclass,etd_incomplete,ttypeviewset:[tview_full,tview_incomplete],dts_class,true,true,for final use true);
        if e_part(curr.eval,interface^.refclass.geteval) then return; end if;

        -- pokud se tak ji‘ nestalo, tak zalo‘it skrytou promˆnnou odpov¡daj¡c¡ interfacu
        if not interface^.instance.isset then
          declare var
            instance         : pentity_var;-- novˆ zalo‘en  instance interfacu
            instance_context : tcontext;   -- kontext instance interfacu

          begin
            verify(685,curr.ancestor.isset and then pentity_type(curr.ancestor.getcentity)^.interfaces^.is_exposed_interface(interface^.refclass.getcentity));

            -- zalo‘it instanci interfacu
            d_create_internal(curr_context,pentity(instance),instance_context,et_var,nil);
            instance^.compile-tentitycompileset:[etc_generated];
            instance^.typ.settype(pentity_type(interface^.refclass.getcentity));
            instance^.mclass     :=mc_class;
            instance^.vmode      :=vm_direct;
            instance^.vaccess    :=va_norm;
            instance^.vimplements:=vi_interface;
            d_end_internal(instance^,true);

            -- doplnit do popisu interfacu
            interface^.instance.setentity(instance);
            end declare;
          end if;
        end loop;
      end declare;
    end if;
  end e_expose_class;

  

----------------------------------------------------------------------------------------------------
procedure e_class (
    curr           : in out tentity_type;         -- vyhodnocovan  t©¡da
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci t©¡dy.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  varofs           : tunidata_addr;              -- aktu ln¡ offset v t©¡dˆ
  maxofs           : tunidata_addr;              -- nejvy¨¨¡ dosa‘en˜ offset slo‘ky

    ------------------------------------------------------------------------------------------------
    procedure assignvaraddr (
        context    : in tcontext) =              -- aktu ln¡ kontext
    -- P©idˆlen¡ adres promˆnn˜m.
    ------------------------------------------------------------------------------------------------
    var
      p            : pentity;                    -- zpracov van  entita
      region       : pregion;                    -- zpracov van˜ kontext

    begin
      -- zpracovat v¨echny symboly v tabulce symbol–
      p:=context.region^.entities.first;
      while p<>nil loop
        -- promˆnn 
        if p^.etype=et_var then
          -- zaj¡mav‚ jsou jen promˆnn‚ t©¡dy
          if pentity_var(p)^.mclass=mc_class then
            cpu^.layoutrecitem(pentity_var(p),curr.align,varofs,maxofs);
            end if;

        -- metoda, mohla by obsahovat nˆjak‚ skryt‚ promˆnn‚ t©¡dy
        elsif p^.etype in ets_subprogram then
          assignvaraddr(sym_primary_context(p^));
          end if;

        -- dal¨¡ symbol
        p:=p^.next;
        end loop;

      -- zpracovat vno©en‚ regiony
      region:=context.region^.regions.first;
      while region<>nil loop
        -- zpracovat
        assignvaraddr(sym_build_context(context.entity,region));

        -- dal¨¡ region
        region:=region^.next;
        end loop;
      end assignvaraddr;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        curr.eval:=ete_evaluated;

        -- t©¡da je automaticky tagged
        curr.tflags+typeflagsset:[tf_tagged];

        -- t©¡da je regul rn¡ typ
        curr.tkind:=tk_regular;

        -- zalo‘it tabulku interfac–
        new curr.interfaces;

        -- t©¡da je sama sobˆ nativn¡m interfacem
        curr.interfaces^.add_interface(nil,^curr);

        -- vyhodnotit atributy
        e_refexpr(curr_context,curr.attr_align,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_align.geteval) then return; end if;

        -- zarovn n¡
        type_setalign(curr,cpu^.defaultalign);

    -- --> public
    when etd_public do
        verify(600,tf_tagged not in curr.tflags);

        -- lok ln¡ symboly
        e_all(curr,etd_incomplete,final,e);
        if e_part(curr.eval,e) then return; end if;

    -- --> full
    when etd_full do
        verify(600,tf_tagged not in curr.tflags);

        -- lok ln¡ symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

        -- vy©e¨it p©edka
        if curr.ancestor.isset

          -- m  p©edka => rezervovat pro nˆj m¡sto na za‡ tku t©¡dy
          then
            varofs:=unidata_size_to_addr(pentity_type(curr.ancestor.getcentity)^.size)

          -- nem  p©edka => rezervovat m¡sto pro tag
          else
            varofs:=unidata_size_to_addr(cpu^.classisize)
            end if;

        -- ur‡it zat¡m maxim ln¡ dosa‘en˜ offset
        maxofs:=varofs;

        -- p©idˆlit adresy promˆnn˜ch
        assignvaraddr(curr_context);

        -- ur‡it velikost t©¡dy
        type_setsize(curr,unidata_addr_to_size(maxofs));

    when others do verify(165,true);
    end case;
  end e_class;



----------------------------------------------------------------------------------------------------
procedure e_compile (
    curr           : in out tentity_compile;     -- vyhodnocovan  kompila‡n¡ jednotka
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci kompila‡n¡ jednotky.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- lok ln¡ symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

    when others do verify(166,true);
    end case;
  end e_compile;



----------------------------------------------------------------------------------------------------
procedure e_program (
    curr           : in out tentity_program;     -- vyhodnocovan˜ program
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci programu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- vyhodnotit tˆlo
        e_code_body(curr,curr_context,final);

    when others do verify(167,true);
    end case;
  end e_program;



----------------------------------------------------------------------------------------------------
procedure e_param (
    curr           : in out tentity_param;       -- vyhodnocovan˜ parametr
    curr_context   : in tcontext;                -- prim rn¡ kontext entity
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci parametru.
----------------------------------------------------------------------------------------------------
var
  typ              : typeview;                   -- pohled na typ parametru

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- typ parametru
        e_reftype(curr.context{curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_incomplete,tview_partial,tview_full],dts_regular,true,true,final);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- sestavit pohled na typ parametru
        if curr.typ.getutype=nil
          then typ.initunchecked(curr.typ.getutype);
          else typ.init(curr_context,curr.typ.getutype);
          end if;

        ----- %%TECH Dopo‡et volac¡ konvence -----------------------------
        -- Volac¡ konvence parametru z–stane neur‡ena (PP_DEFAULT) pouze
        -- v tˆchto p©¡padech:
        --     1) IN parametr bez explicitnˆ ur‡en‚ volac¡ konvence,
        --     2) n vratov  hodnota.
        -- V obou p©¡padech se na tomto m¡stˆ p©ekvapivˆ nastav¡ spr vn 
        -- volac¡ konvence -- zejm‚na u n vratov‚ hodnoty stoj¡ za pozornost,
        -- ‘e se zcela spr vnˆ dopln¡ volac¡ konvence PP_VALUE pro jednoduch‚
        -- typy, i kdy‘ se vlastnˆ jedn  o OUT parametr.
        ------------------------------------------------------------------

        -- dopo‡¡tat volac¡ konvenci
        if curr.pass=pp_default then
          if t_is_composite(typ)
            -- kompozitn¡ typy se p©ed vaj¡ referenc¡
            then curr.pass:=pp_ref
            -- jednoduch‚ typy se p©ed vaj¡ hodnotou
            else curr.pass:=pp_value;
            end if;
          end if;

        -- %%LANG S parametrem se p©ed vaj¡ n sleduj¡c¡ dynamick‚ atributy:
        --   -- pro parametr typu t©¡da ‘ dn‚,
        if t_is_stype(typ,dt_class) then
          -- nic

      #if #environment compiler_version;='4.0.3.x' then;
        --   -- pro class a virtual parametry atribut :tag
        elsif curr.pass in pps_tagged then
          curr.rta_avail+rtattribset:[rta_tag];
      #else;
        --   -- pro class a virtual parametry atribut :tag, je-li typ
        --      takov‚ho parametru unconstrained, pak taky :last,
        elsif curr.pass in pps_tagged then
          curr.rta_avail+rtattribset:[rta_tag];
          if t_is_sts(typ,dts_unconstrained) then
            curr.rta_avail+rtattribset:[rta_last];
            end if;
      #end if;

        --   -- pro beztypov˜ unchecked parametr atributy :tag a :size,
        --   -- pro unchecked parametr s constrained typem atribut :tag,
        --   -- pro unchecked parametr s unconstrained typem atributy :tag
        --      :size (nikoliv :last!),
        elsif curr.pass=pp_unchecked then
          curr.rta_avail+rtattribset:[rta_tag]; {%%X pro‡ tag?}
          if typ.tview=tview_unchecked or t_is_sts(typ,dts_unconstrained) then
            curr.rta_avail+rtattribset:[rta_size];
            end if;

      #if #environment compiler_version;='4.0.3.x' then;
        --   -- pro libovoln˜ jin˜ parametr s unconstrained typem atribut
        --      :tag
        elsif t_is_sts(typ,dts_unconstrained) then
          curr.rta_avail+rtattribset:[rta_tag];
          end if;
      #else;
        --   -- pro libovoln˜ jin˜ parametr s unconstrained typem atribut
        --      :last (nikoliv :size).
        elsif t_is_sts(typ,dts_unconstrained) then
          curr.rta_avail+rtattribset:[rta_last];
          end if;
      #end if;

        -- %%X %%TODO(TAG) z plata: nen¡ udˆlan‚ dynamick‚ zji¨Ÿov n¡ RTA_USED
        curr.rta_used:=curr.rta_avail;

        -- vyhodnotit implicitn¡ hodnotu
        if curr.init.isset then
          -- vyhodnotit hodnotu
          e_refimm(curr_context,curr.init,ek_const,curr.typ.getutype,final);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if

    when others do verify(168,true);
    end case;
  end e_param;



----------------------------------------------------------------------------------------------------
procedure e_message (
    curr           : in out tentity_message;     -- vyhodnocovan  zpr va
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci zpr vy.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- p©edek
        e_refsymbol(curr.context{.entity^},curr.ancestor,etd_full,final);
        if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

        -- typ zpr vy
        e_reftype(curr.context{.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_message],false,false,final);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- nen¡ pot©eba p©evz¡t typ od p©edka
        if not curr.typ.isset then
          verify(555,not curr.ancestor.isset);
          {%%TODO(DECLPOS) Nastavit souvisej¡c¡ v˜raz nebo aspo¤ pozici, ne ? }
          curr.typ.settype(pentity_message(curr.ancestor.getcentity)^.typ.getctype);
          end if;

    when others do verify(233,true);
    end case;

  -- celkem nen¡ co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_message;



----------------------------------------------------------------------------------------------------
procedure e_label (
    curr           : in out tentity_label;       -- vyhodnocovan‚ n vˆ¨t¡
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci n vˆ¨t¡.
----------------------------------------------------------------------------------------------------
begin
  -- celkem nen¡ co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_label;



----------------------------------------------------------------------------------------------------
procedure e_template (
    curr           : in out tentity_template;    -- vyhodnocovan  ¨ablona
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci n vˆ¨t¡.
----------------------------------------------------------------------------------------------------
begin
  -- celkem nen¡ co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_template;



----------------------------------------------------------------------------------------------------
procedure e_tparam (
    curr           : in out tentity_tparam;      -- vyhodnocovan˜ parametr ¨ablony
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci n vˆ¨t¡.
----------------------------------------------------------------------------------------------------
begin
  -- celkem nen¡ co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_tparam;



----------------------------------------------------------------------------------------------------
procedure e_attribute (
    curr           : in out tentity_attribute;   -- vyhodnocovan˜ atribut
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci atributu.
----------------------------------------------------------------------------------------------------
begin
  -- celkem nen¡ co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_attribute;



----------------------------------------------------------------------------------------------------
procedure e_undef (
    curr           : in out tentity;             -- vyhodnocovan‚ n vˆ¨t¡
    level          : in tentitydeclared;         -- po‘adovan  urove¤ vyhodnocen¡
    final          : in t_logical) =             -- T-v˜sledek mus¡ b˜t vyhodnocen
-- Vyhodnot¡ deklaraci nedefinovan‚ho prvku.
----------------------------------------------------------------------------------------------------
begin
  -- takov˜ prvek si jistˆ vymyslel p©eklada‡,
  -- tak‘e ho lze pova‘ovat za vyhodnocen˜
  curr.eval:=ete_evaluated;
  end e_undef;



----------------------------------------------------------------------------------------------------
procedure check_unused_with (
    context        : in tcontext)=
-- Nahlasi nepouzite moduly, uvedene ve WITH tabulce entity
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;
  _e               : pentity;
  wtab             : twithtable;

begin
  if context=nil then return; end if;

  -- projit WITH tabulku
  wtab:=context.entity^.regions[rc_primary]^.withtable;
  if wtab<>nil then
    for i in wtab^:range loop

      -- nahlasit nepouzite moduly
      if wtab^[i].stat_usage=0 and not wtab^[i].automatic then
        ce^.sethint(context,000000,ch_unused_module);
        ce^.setparam(entityident_to_string(wtab^[i].entity.getcentity^.id^));
        ce^.setpos(wtab^[i].lexpos);
        end if;
      end loop;
    end if;
  end check_unused_with;



----------------------------------------------------------------------------------------------------
procedure check_unused_entities (
    curr           : in tcontext) =              -- p©ekl dan˜ kontext
-- Ohl s¡ varov n¡ pro ka‘dou nepou‘itou entitu uvnit© [curr].
----------------------------------------------------------------------------------------------------
begin
  -- m  cenu se t¡m zab˜vat ?
  if ch_unused_entity not in curr.entity^.compv.hints then return end if;

  -- v¨echny entity v tomto regionu
  declare var
    p              : pentity;

  begin
    p:=curr.region^.entities.first;
    while p<>nil loop
      declare var 
        ommit        : t_logical;                  -- T-nehl sit pro tuto entitu

      begin
        if p^.stat_usage=0 and p^.id<>nil and etc_generated not in p^.compile then

          -- parametr virtualni metody ci overridu?
          if p^.etype=et_var and then pentity_var(p)^.vimplements=vi_parameter {and then pentity_var(p)^.imp_param<>nil} then
            ommit or curr.entity^.etype in tentitytypeset:[et_virtual,et_override];
            end if;

          -- ne-private slozka tridy ci modulu?
          ommit or (p^.visible<>etv_private and then curr.entity^.etype in ets_modular);

          -- nehlasit kompilatorem generovane entity
          ommit or etc_generated in p^.compile;

          -- nastav HINT
          if not ommit then
            ce^.sethint(curr,000000,ch_unused_entity);
            ce^.setparam(entityident_to_string(p^.id^));
            ce^.setpos(p^.pos[etp_header]);
            end if;
          end if;

        -- dal¨¡ symbol
        p:=p^.next;
        end declare;
      end loop;
    end declare;

  -- v¨echny podregiony
  declare var
    region         : pregion;

  begin
    region:=curr.region^.regions.first;
    while region<>nil loop
      -- zpracovat
      check_unused_entities(sym_build_context(curr.entity,region));

      -- dal¨¡ region
      region:=region^.next;
      end loop;
    end declare;
  end check_unused_entities;



----------------------------------------------------------------------------------------------------
procedure e_symbol =
-- Vyhodnocen¡ jednoho symbolu.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_debug;

var
  sym_context      : tcontext;                   -- context vyhodnocovan‚ho symbolu
#if #declared dump; #and then; dump then;
  elevel           : static t_unsigned := 0;
#end if;

begin
  -- symbol je pr vˆ vyhodnocov n (cirkul rn¡ reference)
  if etc_evaluating in psym^.compile then return; end if;

  -- symbol je nevyhodnotiteln˜
  if psym^.eval=ete_unevaluated then return; end if;

  -- symbol je v po‘adovan‚ £rovni ji‘ vyhodnocen
  if (psym^.evaluated>level) or ((psym^.evaluated=level) and (psym^.eval=ete_evaluated)) then return; end if;

  begin
    -- symbol je vyhodnocov n
    psym^.compile+tentitycompileset:[etc_evaluating];

  #if #declared dump; #and then; dump then;
    if o_is_option_by_entity(opt_dump,psym^) then
      debug_dump({%%TODO(AGGREGATE) fillstr(' ',elevel)+}'e_symbol(' & sym_get_qid(psym) & '; ' & tentitydeclaredtxt[psym^.declared] & '): ' & tentitydeclaredtxt[psym^.evaluated] & ' (' & tentityevaltxt[psym^.eval] & ') --> ' & tentitydeclaredtxt[level]);
      end if;
    elevel+2;
  #end if;

    -- vypo‡¡tat kontext symbolu
    sym_context:=sym_primary_context(psym^);

    -- vyhodnotit podle typu symbolu
    case psym^.etype
      when et_undef     do e_undef(psym^,level,final);{psym^.eval:=ete_evaluated;}
      when et_compile   do e_compile(pentity_compile(psym)^,sym_context,level,final);
      when et_program   do e_program(pentity_program(psym)^,sym_context,level,final);
      when et_module    do e_module(pentity_module(psym)^,level,final);
      when et_special   do e_special(pentity_special(psym)^,sym_context,level,final);
      when et_procedure do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_static    do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_virtual   do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_override  do e_override(pentity_override(psym)^,sym_context,level,final);
      when et_overload  do e_overload(pentity_overload(psym)^,sym_context,level,final);
      when et_operator  do e_operator(pentity_operator(psym)^,sym_context,level,final);
      when et_var       do e_var(pentity_var(psym)^,sym_context,level,final);
--    when et_alias     do e_alias(pentity_alias(psym)^,level,final);
      when et_type      do e_type(pentity_type(psym)^,sym_context,level,final);
      when et_class     do e_class(pentity_type(psym)^,sym_context,level,final);
      when et_const     do e_const(pentity_const(psym)^,sym_context,level,final);
      when et_enum      do e_enum(pentity_enum(psym)^,sym_context,level,final);
      when et_param     do e_param(pentity_param(psym)^,sym_context,level,final);
      when et_message   do e_message(pentity_message(psym)^,level,final);
      when et_label     do e_label(pentity_label(psym)^,level,final);
      when et_template  do e_template(pentity_template(psym)^,level,final);
      when et_tparam    do e_tparam(pentity_tparam(psym)^,level,final);
      when et_attribute do e_attribute(pentity_attribute(psym)^,level,final);
      when others do verify(15,true);
      end case;

    -- povedlo se deklaraci vyhodnotit ?
  #if #declared dump; #and then; dump then;
    elevel-2;
  #end if;
    if psym^.eval=ete_evaluated
      then psym^.evaluated:=level
      else
      #if #declared dump; #and then; dump then;
        if o_is_option_by_entity(opt_dump,psym^) then debug_dump({%%TODO(AGGREGATE)fillstr(' ',elevel)+}'Failed.'); end if;
      #end if;
        end if;

    -- plnˆ vyhodnocen‚ entity analyzovat pro pot©eby hl ¨en¡ r–zn˜ch hint–
    if psym^.evaluated=etd_full and then psym^.etype in ets_enclosing then
      -- nahlasit nepouzite WITH/USE moduly
      check_unused_with(sym_context);
      
      -- nahlasit varov n¡ pro nepou‘it‚ entity
      check_unused_entities(sym_context);
      end if;

  catch
    when resume_error do
        -- symbol se nepoda©ilo vyhodnotit a nem  cenu to zkou¨et d l
        psym^.eval:=ete_unevaluated;

        -- chyba
        ce^.seterror({CCERR=}000281,ce_unevaluated);
        ce^.setparam(sym_get_qid(psym));
        ce^.setpos(pos);
        raise;

  leave
    -- konec vyhodnocov n¡ symbolu
    psym^.compile-tentitycompileset:[etc_evaluating];
    end;

  -- jak to dopadlo ?
  -- je po‘adov no £pln‚ vyhodnocen¡ entity
  if {final 
  -- a entita nen¡ vyhodnocena
  and} psym^.eval not in tentityevalset:[ete_evaluated] then
{
  -- je po‘adov no uplne vyhodnoceni symbolu
  if final
  -- generick˜ symbol: nen¡ vyhodnocen
  and (   (etc_generic     in psym^.compile and psym^.eval not in tentityevalset:[ete_evaluated,ete_generic])
  -- statick˜ symbol:  nen¡ vyhodnocen
       or (etc_generic not in psym^.compile and psym^.eval not in tentityevalset:[ete_evaluated]))
  -- => chyba
  then
}
    -- symbol se nepoda©ilo vyhodnotit a nem  cenu to zkou¨et d l
    psym^.eval:=ete_unevaluated;

    -- chyba
    ce^.seterror({CCERR=}000282,ce_unevaluated);
    ce^.setparam(sym_get_qid(psym));
    ce^.setpos(pos);
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end e_symbol;



----------------------------------------------------------------------------------------------------
procedure e_check (
    psym           : in pentity;                 -- p©ekl dan˜ prvek
    pos            : in lexposblock;             -- referen‡n¡ pozice
    level          : in tentitydeclared;         -- po‘adovan  £rove¤ deklarace
    final          : in t_logical;               -- T-v˜sledek mus¡ b˜t vyhodnocen
    e              : out tentityeval) =          -- zji¨tˆn‚ vyhodnocen¡
-- Kontrola vyhodnocen¡ symbolu.
----------------------------------------------------------------------------------------------------
begin
  -- po‘adov  £rove¤ deklarace
  if psym^.declared<level then
    {if final
      -- symbol nen¡ deklarov n a mˆl by --> chyba
      then}
        ce^.seterror({CCERR=}000248,ce_incomplete);
        ce^.setparam(sym_get_qid(psym));
        ce^.setpos(pos);
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

      {-- zat¡m se nic nedˆje
      else
        if psym^.eval=ete_evaluated
          then e:=ete_none;
          else e:=psym^.eval;
          end if;
        return;
        end if;}
    end if;

  -- je¨tˆ se pokusit vyhodnotit nevyhodnocen˜ symbol
  e_symbol(psym,pos,level,final);
  if psym^.eval=ete_evaluated and psym^.evaluated<level
    -- symbol je sice vyhodnocen, ale v ni‘¨¡ ne‘ po‘adovan‚ £rovni
    then e:=ete_none
    -- ostatn¡ p©¡pady p©evz¡t
    else e:=psym^.eval;
    end if;
  end e_check;



----------------------------------------------------------------------------------------------------
procedure e_all_context (
    context        : in tcontext;                -- vyhodnocovan˜ kontext
    level          : in tentitydeclared;         -- po‘adovan˜ urove¤ vyhodnocen¡
    final          : in t_logical;               -- T-v˜sledek mus¡ b˜t vyhodnocen
    e              : in out tentityeval) =       -- kumulativn¡ vyhodnocen¡
-- Vyhodnocen¡ v¨ech prvk– obsa‘en˜ch v zadan‚m kontextu a v¨ech subkontextech.
----------------------------------------------------------------------------------------------------
var
  p                : pentity;                    -- vyhodnocovan  entita
  ee               : tentityeval;                -- vyhodnocen¡ entity
  ignore           : t_logical;                  -- ignorovan  n vratov  hodnota
  region           : pregion;                    -- zpracov van˜ region

begin
  -- vyhodnotit v¨echny symboly
  p:=context.region^.entities.first;
  while p<>nil loop
    -- %%X pozor na cirkul rn¡ reference modul–

    -- vyhodnotit symbol
    if etc_generated not in p^.compile and p^.eval<>ete_unevaluated then

      -- vyhodnotit
      e_check(p,p^.pos[etp_header],level,final{true},ee);

      -- zapo‡¡tat do celkov‚ho v˜sledku
      ignore:=e_part(e,ee);
      -- n vratov  hodnota se ignoruje, entity vyhodnot¡me v‘dy v¨echny
      end if;

    -- dal¨¡ symbol
    p:=p^.next;
    end loop;

  -- zpracovat subkontexty
  region:=context.region^.regions.first;
  while region<>nil loop
    -- zpracovat
    e_all_context(sym_build_context(context.entity,region),level,final,e);

    -- dal¨¡ region
    region:=region^.next;
    end loop;
  end e_all_context;



----------------------------------------------------------------------------------------------------
procedure e_all =
-- Vyhodnocen¡ v¨ech prvk– obsa‘en˜ch v pr vˆ p©ekl dan‚m prvku.
----------------------------------------------------------------------------------------------------
begin
  -- p©edpoklad: vyhodnot¡ se £plnˆ v¨echno
  e:=ete_evaluated;

  -- zpracovat v¨echny regiony
  for rcategory in tregioncategory loop
    -- zpracovat region
    if curr.regions[rcategory]<>nil then
      e_all_context(sym_build_context(^curr,curr.regions[rcategory]),level,final,e);
      end if;
    end loop;
  end e_all;



----------------------------------------------------------------------------------------------------
procedure e_after_extend =
-- Vyhodnocen¡ specifikace p©edka v klauzuli EXTEND.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype
    when et_module do e_extend_module(pentity_module(entity)^,sym_primary_context(entity^));
    when et_class  do e_extend_class(pentity_type(entity)^,sym_primary_context(entity^));
    when others    do verify(726,true);
    end case;
  end e_after_extend;



----------------------------------------------------------------------------------------------------
procedure e_after_expose =
-- Vyhodnocen¡ specifikace interfac– v klauzuli EXPOSE.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype
    when et_class do e_expose_class(pentity_type(entity)^,sym_primary_context(entity^));
    when others   do verify(727,true);
    end case;
  end e_after_expose;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  e_spec_tab[dt_uniint    ]:=^e_spec_unitype;
  e_spec_tab[dt_unireal   ]:=^e_spec_unitype;
  e_spec_tab[dt_unilogical]:=^e_spec_unitype;
  e_spec_tab[dt_unichar   ]:=^e_spec_unitype;
  e_spec_tab[dt_uniarray  ]:=^e_spec_unitype;
  e_spec_tab[dt_uninil    ]:=^e_spec_unitype;
  e_spec_tab[dt_signed    ]:=^e_spec_ordinal;
  e_spec_tab[dt_unsigned  ]:=^e_spec_ordinal;
  e_spec_tab[dt_float     ]:=^e_spec_float;
  e_spec_tab[dt_fixed     ]:=^e_spec_fixed;
  e_spec_tab[dt_char      ]:=^e_spec_ordinal;
  e_spec_tab[dt_logical   ]:=^e_spec_ordinal;
  e_spec_tab[dt_enum      ]:=^e_spec_enum;
  e_spec_tab[dt_string    ]:=^e_spec_string;
  e_spec_tab[dt_ustring   ]:=^e_spec_string;
  e_spec_tab[dt_array     ]:=^e_spec_array;
  e_spec_tab[dt_uarray    ]:=^e_spec_array;
  e_spec_tab[dt_record    ]:=^e_spec_record;
  e_spec_tab[dt_set       ]:=^e_spec_set;
  e_spec_tab[dt_pointer   ]:=^e_spec_pointer;
  e_spec_tab[dt_tag       ]:=^e_spec_tag;
  e_spec_tab[dt_message   ]:=^e_spec_procedure;
  e_spec_tab[dt_procedure ]:=^e_spec_procedure;
  e_spec_tab[dt_task      ]:=^e_spec_procedure;
  end entry;



end cd_eval;