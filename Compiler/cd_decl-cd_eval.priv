---------------------------------------------------------------------------------------------------
module private cd_eval =
-- Překladač Flexu.
-- Vyhodnocení deklarací.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.09.2000 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_entity.cc_ref,
  cx_expr,cx_expr.cx_def,cx_expr.cx_compile,
  cd_create,
  cc_options;

use
  cx_expr.cx_def,
  cb_block,
  cb_block.cb_compile,
  cb_block.cb_def;


#if #declared dump; #and then; dump then;
var
  -- průběh překladu deklarace
  tentitydeclaredtxt : array tentitydeclared of t_char32str := [
      for etd_none        use 'none',
      for etd_incomplete  use 'incomplete',
      for etd_public      use 'public',
      for etd_full        use 'full'];

  -- vyhodnocení symbolu
  tentityevaltxt   : array tentityeval of t_char32str := [
      for ete_none        use 'none',
   -- for ete_generic     use 'generic',
      for ete_evaluated   use 'evaluated',
      for ete_unevaluated use 'unevaluated'];
#end if;

type
  tevalspecproc    = procedure (
      curr         : in out tentity_type;        -- vyhodnocovaná entita
      curr_context : in tcontext;                -- primární kontext entity
      final        : in t_logical);              -- T-výsledek musí být vyhodnocen
  pevalspecproc    = ^tevalspecproc;

var
  e_spec_tab       : array tdatatype of pevalspecproc;



----------------------------------------------------------------------------------------------------
procedure arraysize (
    item           : tunidata_size;              -- velikost prvku pole
    lval           : tuniint;                    -- dolní mez
    hval           : tuniint)                    -- horní mez
                   return tunidata_size =        -- velikost pole
-- Vypočítá velikost pole. Nebere v úvahu zarovnání prvků pole.
----------------------------------------------------------------------------------------------------
begin
  result:=uniint_to_unidata_size(unidata_size_to_uniint(item)*(hval-lval+ui_1));
  end arraysize;



----------------------------------------------------------------------------------------------------
procedure type_setsize (
    curr           : in out tentity_type;        -- vyhodnocovaný typ
    size           : in tunidata_size) =         -- vypočtená velikost
-- Dosadí do typu velikost.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;

begin
  if curr.attr_size.isset

    -- určena explicitně atributem
    then
      -- převzít z výrazu velikost
      x_const_int(pexpnode(curr.attr_size.getcexpr),ui);

      -- musí být nezáporná
      if ui<ui_0 then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_size);
        curr.attr_size.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.size:=size;
        return;
        end if;

      -- dosadit
      curr.size:=uniint_to_unidata_size(ui);

      -- není to méně, než implicitní velikost ?
      if curr.size<size then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_size);
        curr.attr_size.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.size:=size;
        return;
        end if;

    -- určena implicitně
    else
      curr.size:=size;
      end if;
  end type_setsize;



----------------------------------------------------------------------------------------------------
procedure type_setalign (
    curr           : in out tentity_type;        -- vyhodnocovaný typ
    align          : in tunidata_size) =         -- zarovnání
-- Dosadí do typu zarovnání.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;
  ul               : tunilogical;

begin
  -- globální zarovnání složek
  if curr.attr_align.isset

    -- určeno explicitně atributem
    then
      -- převzít z výrazu zarovnání
      x_const_int(pexpnode(curr.attr_align.getcexpr),ui);

      -- musí být >=1
      if ui<ui_1 then
        ce^.seterror({ERRNUM=}000000,ce_i_attr_align);
        curr.attr_align.errpos;
        {%%RESUME ce^.raiseerror;}
        curr.align:=align;
        return;
        end if;

      -- dosadit
      curr.align:=uniint_to_unidata_size(ui);

    -- určeno implicitně
    else
      curr.align:=align;
      end if;

  -- nativní zarovnání složek menších než [curr.align]
  if curr.attr_native_align.isset

    -- určeno explicitně atributem
    then
      -- převzít z výrazu nativní zarovnání
      x_const_logical(pexpnode(curr.attr_native_align.getcexpr),ul);

      -- dosadit
      curr.native_align:=unilogical_to_logical(ul);

    -- určeno implicitně
    else
      curr.native_align:=false;
      end if;
  end type_setalign;



----------------------------------------------------------------------------------------------------
procedure e_part =
-- Započítá vyhodnocení části do celku a vrátí True, není-li celek vyhodnocen.
----------------------------------------------------------------------------------------------------
begin
  if (celek=ete_none)or (celek>cast) then celek:=cast; end if;
  result:=celek<ete_evaluated;
  end e_part;



----------------------------------------------------------------------------------------------------
procedure e_is_evaluated =
-- True, odpovídá-li zadané vyhodnocení stavu "vyhodnoceno".
----------------------------------------------------------------------------------------------------
begin
  result:=e>=ete_evaluated;
  end e_is_evaluated;



----------------------------------------------------------------------------------------------------
procedure e_refexpr (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out refexpr;             -- výraz
    kind           : in expkind;                 -- očekávaný druh výrazu
    typ            : in pentity_type;            -- požadovaný typ
    usage          : in expusage;                -- použití výrazu
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na výraz.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  x                : pexpnode;

begin
  -- vyhodnocení již jednou proběhlo
  if expr.geteval>ete_none then return; end if;

  if expr.getuexpr=nil
    -- výraz není uveden (nevadí, třeba je to záměr)
    then expr.seteval(ete_evaluated)
    -- jinak ho vyhodnotit
    else
      x:=pexpnode(expr.getcexpr);
      x_evaluate(curr,x,kind,typ,usage,final,e);
      expr.setexpr(x);
      expr.seteval(e);
      end if;
  end e_refexpr;



----------------------------------------------------------------------------------------------------
procedure e_refblock (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out refblock;            -- výraz
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na výraz.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  b                : cb_block.cb_def.pblnode;

begin
  -- vyhodnocení již jednou proběhlo
  if bl.geteval>ete_none then return; end if;

  if bl.getublock=nil
    -- blok příkazů není uveden (nevadí, třeba je to záměr)
    then bl.seteval(ete_evaluated)
    -- jinak ho vyhodnotit
    else
      b:=cb_block.cb_def.pblnode(bl.getcblock);
      cb_block.cb_compile.b_evaluate(curr,b,final,e);
      bl.setblock(b);
      bl.seteval(e);
      end if;
  end e_refblock;



----------------------------------------------------------------------------------------------------
procedure e_reftype_check (
    curr           : in tcontext;                -- překládaný prvek
    ptyp           : in pentity_type;            -- kontrolovaný typ
    tview          : in ttypeviewset;            -- povolené typy pohledů na typ
    dts            : in tdatatypeset;            -- povolené datové typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view třídy
    allow_abstract : in t_logical) =             -- T-povolit abstraktní typy
-- Kontrola, zda typ odpovídá zadaným požadavkům.
----------------------------------------------------------------------------------------------------
var
  t                : typeview;                   -- pohled na typ

begin
  -- sestavit si pohled na typ
  t.init(curr,ptyp);

  -- jsou povoleny abstraktní typy ?
  if not allow_abstract and ptyp^.is_abstract then
    ce^.seterror({CCERR=}000204,ce_i_type);
    ce^.resumeerror;
    end if;

  if allow_class {(tview_partial in tview) and (st_class in dts)} and t.isclass

    -- Ondra 29.6.2001 : při povoleném Partial view povolíme pro třídu i Incomplete view
    then
      -- nic nedělat

    else
      -- kontrola přípustnosti pohledu
      if t.tview not in tview then
        ce^.seterror({CCERR=}000205,ce_i_type);
        ce^.resumeerror;
        end if;

      --Full view => kontrola přípustnosti datového typu
      if t.tview=tview_full and t.stype not in dts then
        ce^.seterror({CCERR=}000206,ce_i_type);
        ce^.resumeerror;
        end if;

      -- Incomplete view => typ musí být regulární
      if t.tview=tview_incomplete then t.getutype^.tkind:=tk_regular; end if;
      end if;
  end e_reftype_check;



----------------------------------------------------------------------------------------------------
procedure e_reftype (
    curr           : in tcontext;                -- překládaný prvek
    typ            : in out cc_ref.reftype;      -- typ
    ekind          : in expkind;                 -- druh očekávaného výrazu
    tview          : in ttypeviewset;            -- povolené typy pohledů na typ
    dts            : in tdatatypeset;            -- povolené datové typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view třídy
    allow_abstract : in t_logical;               -- T-povolit abstraktní typy
 -- declared       : in tentitydeclared;         -- požadovaná úroveň deklarace
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na typ.
-- Pohled na typ musí být z [tview] a datový typ ve Full view musí být z [dts].
-- Pokud je to Incomplete view, požaduje se, aby byl typ regulární.
-- Je-li [allow_class]=True, pak je povoleno i Incomplete view na třídu.
-- Je-li [allow_abstract]=True, pak jsou povoleny i abstraktní typy.
-- Je-li [ekind]=[ek_rangetype], pak z případného rozsahu univerzálního typu vygeneruje typ
-- o velikosti alespoň strojového slova, v opačném případě o minimální možné velikosti.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;
  t                : typeview;

begin
  -- typ ještě nemáme, ale zato máme výraz --> vyhodnotit
  if typ.getutype=nil and then typ.getuexpr<>nil then

    -- vyhodnotit výraz
    e_refexpr(curr,typ.getrefexpr^,ekind{ek_typename},nil,eu_formal,final);
    if e_part(typ.e,typ.getrefexpr^.geteval) then return; end if;

    -- převzít typ
    x_get_type(curr,pexpnode(typ.getcexpr),ptyp,ekind=ek_rangetype);
    typ.settype(ptyp,for clear_expr use false);
    end if;

  -- zkontrolovat typ
  if typ.getutype<>nil

    -- je k dispozici
    then
      -- zkontrolovat zda typ odpovídá zadaným požadavkům
      begin
        e_reftype_check(curr,typ.getutype,tview,dts,allow_class,allow_abstract);
      catch
        when compiler_error, resume_error do
            typ.errpos;
            raise;
        end;

    -- typ nemáme, ale třeba je to záměr
    else
      -- nic nedělat
      end if;

  -- vyhodnoceno
  typ.seteval(ete_evaluated);
  end e_reftype;



----------------------------------------------------------------------------------------------------
procedure e_refimm (
    curr           : in tcontext;                -- překládaný prvek
    imm            : in out refimm;              -- hodnota
    kind           : in expkind;                 -- očekávaný druh výrazu
    typ            : in pentity_type;            -- požadovaný typ
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na hodnotu.
----------------------------------------------------------------------------------------------------
begin
  -- vyhodnocení již jednou proběhlo
  if imm.geteval>ete_none then return; end if;

  -- vyhodnotit výraz
  e_refexpr(curr,imm.getrefexpr^,kind,typ,eu_use,final);
  if e_part(imm.e,imm.getrefexpr^.geteval) then return; end if;

  -- převzít hodnotu
  x_const_imm(pexpnode(imm.getcexpr),imm.getundefimm^);
  end e_refimm;



----------------------------------------------------------------------------------------------------
procedure e_refsymbol (
    curr           : in tcontext;                -- překládaný prvek
    sym            : in out refentity;           -- symbol
    level          : in tentitydeclared;         -- požadovaný uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na symbol.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;

begin
  -- vyhodnocení již jednou proběhlo
  if sym.e>ete_none then return; end if;

  -- vyhodnotit výraz
  if sym.getuentity=nil and then sym.getuexpr<>nil then
    -- vyhodnotit výraz
    e_refexpr(curr,sym.getrefexpr^,ek_sym,nil,eu_formal,final);
    if e_part(sym.e,sym.getrefexpr^.geteval) then return; end if;

    -- převzít symbol
    x_get_symbol(pexpnode(sym.getcexpr),entity);
    sym.setentity(entity);
    end if;

  if sym.getuentity<>nil

    -- symbol je k dispozici
    then
      -- vyhodnotit symbol
      {e_symbol(sym._s,sym.pos,level,final);}
      if e_part(sym.e,sym.getcentity^.eval) then return; end if;

      -- zkontrolovat úroveň vyhodnocení
      if sym.getcentity^.declared<level then
        ce^.seterror({CCERR=}000582,ce_i_symbol);
        sym.errpos;
        end if;

    -- symbol nemáme, ale třeba je to záměr
    else sym.e:=ete_evaluated;
    end if;
  end e_refsymbol;



----------------------------------------------------------------------------------------------------
procedure e_refsymbol_from_typename (
    curr           : in tcontext;                -- překládaný prvek
    sym            : in out refentity;           -- symbol
    level          : in tentitydeclared;         -- požadovaný uroveň vyhodnocení
    tview          : in ttypeviewset;            -- povolené typy pohledů na typ
    dts            : in tdatatypeset;            -- povolené datové typy
    allow_class    : in t_logical;               -- T-povolit Incomplete view třídy
    allow_abstract : in t_logical;               -- T-povolit abstraktní typy
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí referenci na symbol zadaný jako jméno typu.
-- Je-li [allow_class]=True, pak je povoleno i Incomplete view na třídu.
-- Je-li [allow_abstract]=True, pak jsou povoleny i abstraktní typy.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;

begin
  -- vyhodnocení již jednou proběhlo
  if sym.geteval>ete_none then return end if;

  -- vyhodnotit výraz
  e_refexpr(curr,sym.getrefexpr^,ek_typename,nil,eu_formal,final);
  if e_part(sym.e,sym.getrefexpr^.geteval) then return end if;

  -- převzít symbol
  x_get_type(curr,pexpnode(sym.getcexpr),ptyp,false);
  sym.setentity(ptyp);
  if e_part(sym.e,ptyp^.eval) then return end if;

  -- zkontrolovat úroveň vyhodnocení
  if sym.getcentity^.declared<level then
    ce^.seterror({CCERR=}000583,ce_i_symbol);
    sym.errpos;
    end if;

  -- kontrolova zda typ odpovídá zadaným požadavkům
  begin
    e_reftype_check(curr,ptyp,tview,dts,allow_class,allow_abstract);
  catch
    when resume_error, compiler_error do
        sym.errpos;
        raise;
    end;
  end e_refsymbol_from_typename;



----------------------------------------------------------------------------------------------------
procedure e_spec_ordinal : tevalspecproc =
-- Vyhodnotí definici ordinálního typu SIGNED, UNSIGNED, LOGICAL, CHARACTER.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;                    -- výsledek (počet bitů)
  size             : tunidata_size;              -- vypočtená velikost

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnotit výraz
  e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Otázka: nemá zde být EU_USE ??? }final);
  if e_part(curr.seval,curr.expr.geteval) then return; end if;

  -- načíst hodnotu
  x_const_int(pexpnode(curr.expr.getcexpr),ui);

  -- zkontrolovat a doplnit meze
  cpu^.getordparams1(curr.stype,uniint_to_unidata_bitsize(ui),size{curr.size},curr.lval,curr.hval);

  -- doplnit velikost
  type_setsize(curr,size);

  -- dosadit velikost v bitech
  curr.bits:=uniint_to_unidata_bitsize(ui);
  end e_spec_ordinal;



----------------------------------------------------------------------------------------------------
procedure e_spec_enum : tevalspecproc =
-- Vyhodnotí definici výčtového typu.
----------------------------------------------------------------------------------------------------
var
  hval             : tuniint;                    -- horní mez
  srch             : tentitysearch;              -- hledátko
  size             : tunidata_size;              -- vypočtená velikost
  e                : tentityeval;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- složky
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;

  -- určit nejvyšší ordinální hodnotu
  -- %%X Optimalizace: Když není uvedena specifikace reprezentace žádného
  -- výčtového prvku, tak stačí vzít poslední prvek z tabulky symbolů
  hval:=ui_0;
  srch.find_et_first(^curr,rc_primary,et_enum,[]);
  while srch.psym<>nil loop
    if pentity_enum(srch.psym)^.ordinal>hval then hval:=pentity_enum(srch.psym)^.ordinal; end if;
    srch.find_et_next;
    end loop;

  -- meze typu
  curr.lval:=ui_0;
  curr.hval:=hval;

  -- odvodit velikost typu
  cpu^.getordparams2(dt_enum,curr.bits,size{curr.size},ui_0,hval,false);

  -- doplnit velikost
  type_setsize(curr,size);
  end e_spec_enum;



----------------------------------------------------------------------------------------------------
procedure e_spec_float : tevalspecproc =
-- Vyhodnotí definici floating-point typu.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;                    -- výsledek
  size             : tunidata_size;              -- vypočtená velikost

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnotit výraz
  e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Otázka: nemá zde být EU_USE ??? }final);
  if e_part(curr.seval,curr.expr.geteval) then return; end if;

  -- načíst hodnotu
  x_const_int(pexpnode(curr.expr.getcexpr),ui);

{ Ondra 3.4.2003 : Zrušeno, float se nově definuje počtem bitů.
  case curr.dtype
    -- delta definice
    when fdt_delta      do
        -- vyhodnotit výraz
        e_refexpr(curr_context,curr.expr,ek_const_real,nil,eu_read,{%%X Otázka: nemá zde být EU_USE ??? }final);
        if e_part(curr.seval,curr.expr.geteval) then return; end if;

        -- načíst hodnotu
        x_const_real(pexpnode(curr.expr.getcexpr),curr.fp.fdelta);

      {%%TODO(REAL)
        -- musí být > 0
        if curr.fp.fdelta<=ur_0 then
          ce^.seterror({CCERR=}000207,ce_numrange);
          ce^.setinfo(hint_float_delta);
          curr.expr.errpos;
          ce^.resumeerror;
          end if;
      }

    -- digits definice
    when fdt_digits     do
        -- vyhodnotit výraz
        e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,{%%X Otázka: nemá zde být EU_USE ??? }final);
        if e_part(curr.seval,curr.expr.geteval) then return; end if;

        -- načíst hodnotu
        x_const_int(pexpnode(curr.expr.getcexpr),curr.fp.fdigits);

        -- musí být >= 1
        if curr.fp.fdigits<ui_1 then
          ce^.seterror({CCERR=}000208,ce_numrange);
          ce^.setinfo(hint_float_digits);
          curr.expr.errpos;
          ce^.resumeerror;
          end if;

    when others do verify({VERIFY=}000235,true);
    end case;
}
  -- parametry typu
  cpu^.getrealparams(uniint_to_unidata_bitsize(ui){curr.dtype},size{curr.size},curr.fp);

  -- doplnit velikost
  type_setsize(curr,size);

  -- dosadit velikost v bitech
  curr.bits:=uniint_to_unidata_bitsize(ui);
  end e_spec_float;



----------------------------------------------------------------------------------------------------
procedure e_spec_fixed : tevalspecproc =
-- Vyhodnotí definici fixed-point typu.
----------------------------------------------------------------------------------------------------
begin
  unimplemented({UNIMP=}000210);
  end e_spec_fixed;



----------------------------------------------------------------------------------------------------
procedure e_spec_procedure : tevalspecproc =
-- Vyhodnotí definici typu procedura/task/zpráva.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- parametry
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;
{
  -- vyhodnotit typ návratové hodnoty
  e_reftype(curr,curr.rtype,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_regular,{etd_full,}final);
  if e_part(curr.seval,curr.rtype.geteval) then return; end if;
}
  end e_spec_procedure;



----------------------------------------------------------------------------------------------------
procedure e_spec_array : tevalspecproc =
-- Vyhodnotí definici typu (neomezené) pole.
----------------------------------------------------------------------------------------------------
var
  rtype            : pentity_type;               -- typ rozsahu
  rtype_context    : tcontext;                   -- kontext typu rozsahu
  size             : tunidata_size;              -- vypočtená velikost
  e                : tentityeval;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- bázový typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_constrained,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
{
  -- bázový typ nesmí být neomezený
  if curr.base.getctype^.stype in dts_unconstrained then
    ce^.seterror({CCERR=}000209,ce_i_basetype);
    ce^.setinfo(hint_array_base);
    curr.base.errpos;
    ce^.resumeerror;
    end if;
}
  if curr.stype=dt_array

    -- normální pole
    then
      -- rozsah
      e_reftype(curr_context,curr.srange,ek_rangetype,ttypeviewset:[tview_full],dts_ordinal,false,false,{etd_full,}final);
      if e_part(curr.seval,curr.srange.geteval) then return; end if;

      -- %%X A co zarovnání prvku pole ?!

      -- vypočítat délku pole
      size{curr.size}:=arraysize(curr.base.getctype^.size,curr.srange.getctype^.lval,curr.srange.getctype^.hval);

    -- neomezené pole
    else
      -- odvodit typ rozsahu
      d_create_implicit_type(curr_context,rtype,rtype_context,dt_unsigned,nil);

      -- doplnit údaje
      cpu^.getdefaultord(dt_unsigned,rtype^.bits,rtype^.size,rtype^.lval,rtype^.hval);

      -- konec deklarace
      d_end_implicit_type(rtype^,nil,false);

      -- dosadit jako typ rozsahu neomezeného pole
      curr.srange.settype(rtype);

      -- velikost
      size:=uds_0;

      -- vyhodnoceno
      curr.seval:=ete_evaluated;
      end if;
  -- %%X doplnit další kontroly !!

  -- doplnit velikost
  type_setsize(curr,size);
  end e_spec_array;



----------------------------------------------------------------------------------------------------
procedure e_spec_string : tevalspecproc =
-- Vyhodnotí definici typu (neomezený) řetězec.
----------------------------------------------------------------------------------------------------
var
  delka            : tuniint;                    -- počet prvků řetězce
  isize            : tunidata_size;              -- délka interní části řetězce
  base             : pentity_type;               -- báze řetězce
  rtype            : pentity_type;               -- typ rozsahu
  size             : tunidata_size;              -- vypočtená velikost
  e                : tentityeval;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- bázový typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_constrained,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getctype;
{
  -- bázový typ nesmí být neomezený
  if base^.stype in dts_unconstrained then
    ce^.seterror({CCERR=}000210,ce_i_basetype);
    ce^.setinfo(hint_string_base);
    curr.base.errpos;
    ce^.resumeerror;
    end if;
}
  if curr.stype=dt_string

    -- normální řetězec
    then
      -- délka
      e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,final);
      if e_part(curr.seval,curr.expr.geteval) then return; end if;

      -- délka řetězce ve znacích
      x_const_int(pexpnode(curr.expr.getcexpr),delka);

      -- délka musí být <= CPU^.MAXSTRHVAL a >= 1
      if delka<ui_1 or delka>cpu^.maxstrhval then
        ce^.seterror({CCERR=}000211,ce_numrange);
        --%%TODO(LIB) ce^.setinfo(formats(hint_string_range,linttostr(cpu^.maxstrhval,tuniint:size)));
        curr.expr.errpos;
        ce^.resumeerror;
        end if;

    -- neomezené pole
    else
      delka:=ui_0;
      end if;

  -- parametry řetězce
  cpu^.getstrparams(curr.stype,size{curr.size},isize,base^.size,delka);

  -- doplnit velikost
  type_setsize(curr,size);

  -- odvodit typ rozsahu
  if curr.stype=dt_string
    then t_derive_string_range(curr,isize,delka);
    else t_derive_string_range(curr,isize,cpu^.maxstrhval);
    end if;

  -- vyhodnoceno
  curr.seval:=ete_evaluated;

  {%%X doplnit další kontroly !! a jaký ?? }
  end e_spec_string;



----------------------------------------------------------------------------------------------------
procedure e_spec_record : tevalspecproc =
-- Vyhodnotí definici typu record.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  varofs           : tunidata_addr;              -- aktuální offset složky
  maxofs           : tunidata_addr;              -- nejvyšší dosažený offset složky
  srch             : tentitysearch;              -- hledátko
  ui               : tuniint;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- složky
  e_all(curr,etd_full,final,e);
  if e_part(curr.seval,e) then return; end if;

  -- určit adresy složek
  varofs:=curr.extofs;
  maxofs:=varofs;
  srch.find_et_first(^curr,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    verify({VERIFY=}000240,pentity_var(srch.psym)^.mclass<>mc_record);

    -- není pozice explicitně specifikována atributem ?
    if pentity_var(srch.psym)^.attr_position.isset

      -- ano => použít
      then
        -- převzít hodnotu
        x_const_int(pentity_var(srch.psym)^.attr_position.getcexpr,ui);

        -- nastavit pozici
        cpu^.forcelayoutrecitem(pentity_var(srch.psym),uniint_to_unidata_addr(ui),curr.align,curr.native_align,varofs,maxofs);

      -- ne => vypočítat automaticky
      else
        cpu^.layoutrecitem(pentity_var(srch.psym),curr.align,curr.native_align,varofs,maxofs)
        end if;

    -- další složka
    srch.find_et_next;
    end loop;

  -- velikost recordu
  type_setsize(curr,unidata_addr_to_size(maxofs));

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_record;



----------------------------------------------------------------------------------------------------
procedure e_spec_set : tevalspecproc =
-- Vyhodnotí definici množiny.
----------------------------------------------------------------------------------------------------
var
  base             : pentity_type;               -- bázový typ množiny
  items            : tuniint;                    -- počet prvků množiny
  size             : tunidata_size;              -- vypočtená velikost množiny

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- bázový typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_full],dts_ordinal,false,false,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getctype;

  -- počet prvků množiny
  items:=base^.hval-base^.lval+ui_1;

  -- zjistit velikost množiny
  cpu^.getsetparams(items,size);

  -- velikost recordu
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_set;



----------------------------------------------------------------------------------------------------
procedure e_spec_pointer : tevalspecproc =
-- Vyhodnotí definici typu pointer.
----------------------------------------------------------------------------------------------------
var
  base             : pentity_type;               -- bázový typ
  size             : tunidata_size;              -- vypočtená velikost
  ul               : tunilogical;
  e                : tentityeval;

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- bázový typ
  e_reftype(curr_context,curr.base,ek_typename,ttypeviewset:[tview_incomplete,tview_partial,tview_full],dts_all-dts_internal,true,true,{etd_full,}final);
  if e_part(curr.seval,curr.base.geteval) then return; end if;
  base:=curr.base.getutype;

  -- není požadován strojový pointer ?
  if curr.attr_mptr.isset then
    x_const_logical(curr.attr_mptr.getcexpr,ul);
    if ul=ul_true then curr.pflags+ptrflagsset:[pf_machine]; end if;
    end if;

  -- určit třídu pointeru
  if base<>nil and then base^.tkind<>tk_unknown

    -- podle typu báze
    then
      -- třída pointeru
      case base^.stype
        when { tk_singular: } dt_procedure do curr.pclass:=pc_subprogram;
        when { tk_singular: } dt_task      do curr.pclass:=pc_task;
        when { tk_singular: } dt_message   do curr.pclass:=pc_message;
        when { tk_regular:  } others       do curr.pclass:=pc_data;
        end case;

      -- pro pointery na nedatové objekty platí jistá omezení
      if curr.pclass<>pc_data then
        -- pointer na proceduru nesmí být PROTECTED/CONST
        if curr.paccess<>va_norm {pf_const in curr.pflags} then
          ce^.seterror({CCERR=}000212,ce_i_const);
          ce^.setinfo(hint_ptrproc_no_const);
          ce^.setpos(curr.pos[etp_def]);
          {%%RESUME ce^.raiseerror;}
          curr.paccess:=va_norm{curr.pflags-[pf_const]};
          end if;

        -- pointer na proceduru nesmí být UNCHECKED
        if curr.pbase=pb_unchecked then
          ce^.seterror({CCERR=}000213,ce_i_const);
          ce^.setinfo(hint_ptrproc_no_unchecked);
          ce^.setpos(curr.pos[etp_def]);
          {%%RESUME ce^.raiseerror;}
          curr.pbase:=pb_strict;
          end if;
        end if;

    -- báze není uvedena nebo není známa její třída
    else
      verify({VERIFY=}000108,(base=nil) and (curr.pbase<>pb_unchecked));

      -- třída pointeru
      curr.pclass:=pc_data;
      end if;

  -- strojový pointer nesmí být jen tak ledajaký
  if pf_machine in curr.pflags then
    if not ((curr.pclass in ptrclassset:[pc_data,pc_subprogram])
    and (curr.pbase in ptrbaseset:[pb_strict,pb_unchecked])) then
      ce^.seterror({CCERR=}000214,ce_i_machineptr);
      ce^.setpos(curr.pos[etp_def]);
      {%%RESUME ce^.raiseerror;}
      curr.pflags-ptrflagsset:[pf_machine];
      end if;
    end if;

  -- pokud je uvedeno CLASS, musí být bázový typ TAGGED
  if curr.pbase=pb_class and tf_tagged not in base^.tflags then
    ce^.seterror({CCERR=}000215,ce_i_basetype);
    ce^.setinfo(hint_ptr_tagged_base);
    {%%RESUME ce^.raiseerror;}
    curr.pbase:=pb_strict;
    end if;

  -- sestavit množinu volitelných atributů
  if pf_machine not in curr.pflags then
    t_get_pointer_rtattrib(curr.pbase,curr.pclass,base,curr.pattrib);
    end if;

  -- velikost pointeru
  cpu^.getptrsize({curr.pclass,curr.pbase,pf_machine in curr.pflags,}curr.pattrib,size{curr.size});

  -- doplnit velikost
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_pointer;



----------------------------------------------------------------------------------------------------
procedure e_spec_tag : tevalspecproc =
-- Vyhodnotí definici typu tag.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  size             : tunidata_size;              -- vypočtená velikost

begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- velikost tagu (stejná jako dynamický atribut :tag)
  cpu^.getrtattribsize(rta_tag,size{curr.size});

  -- doplnit velikost
  type_setsize(curr,size);

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_tag;



----------------------------------------------------------------------------------------------------
procedure e_spec_unitype : tevalspecproc =
-- Vyhodnotí definici univerzálního typu.
----------------------------------------------------------------------------------------------------
begin
  -- vyhodnocení již jednou proběhlo
  if curr.seval>ete_none then return; end if;

  -- vyhodnoceno
  curr.seval:=ete_evaluated;
  end e_spec_unitype;



{
----------------------------------------------------------------------------------------------------
procedure e_link (
var curr           : in deflink;                 -- vyhodnocovaný odkaz
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí odkaz.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- symbol
        e_refsymbol(curr,curr.sym,etd_full,true);
        if e_part(curr.eval,curr.sym.geteval) then return; end if;


    when others do verify({VERIFY=}000156,true);
    end case;
  end e_link;
}


----------------------------------------------------------------------------------------------------
procedure e_var (
    curr           : in out tentity_var;         -- vyhodnocovaná proměnná
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci proměnné.
----------------------------------------------------------------------------------------------------
var
  sts              : tdatatypeset;
  ui               : tuniint;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- množina povolených typů závisí na módu přístupu k proměnné
        case curr.vmode
          when vm_direct do sts:=dts_constrained{+dts_class};
          when vm_ref    do sts:=dts_regular{+dts_class};
          when vm_index  do sts:=dts_constrained;
          when others    do verify({VERIFY=}000319,true);
          end case;

      {
        -- povolené pohledy na typ
        tview:=ttypeviewset:[tview_partial,tview_full];

        -- Ondra 29.6.2001 : pokud je proměnná instance třídy, tak je povolen
        -- i neúplný pohled na ty, aby bylo možné použít typ třídy v deklaraci
        -- parametru metody té samé třídy
        -- %%X Není tohle náhodou záplata ??
        if (curr.typ.getctype^.stype=dt_class) and (curr.vmode=vm_ref) then
          tview+ttypeviewset:[tview_incomplete];
          end if;
      }

        -- typ proměnné
        e_reftype(curr_context,curr.typ,ek_typename,ttypeviewset:[tview_partial,tview_full],sts,
            {for allow_class    use} curr.context.entity^.compiling=etd_public or curr.vimplements in vis_incomplete_class,
            {for allow_abstract use} curr.vimplements in vis_abstract{true,false},
            true);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- explicitně určená pozice složky
        if curr.attr_position.isset then
          e_refexpr(curr_context,curr.attr_position,ek_const_int,nil,eu_use,true);
          if e_part(curr.eval,curr.attr_position.e) then return; end if;

          -- převzít z výrazu pozici složky
          x_const_int(curr.attr_position.getcexpr,ui);

          -- musí být nezáporná
          if uniint_sign(ui) then
            ce^.seterror({ERRNUM=}000000,ce_i_attr_position);
            curr.attr_position.errpos;
            {%%RESUME ce^.raiseerror;}
            end if;
          end if;

        -- počáteční hodnota
        if curr.init.getuexpr<>nil then
          e_refimm(curr_context,curr.init,ek_const,curr.typ.getctype,true);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if;

    when others do verify({VERIFY=}000157,true);
    end case;
  end e_var;



------------------------------------------------------------------------------------------------------
--procedure e_alias (
--    curr           : in out tentity_alias;       -- vyhodnocovaný alias
--    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
--    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
---- Vyhodnotí deklaraci aliasu.
------------------------------------------------------------------------------------------------------
--var
--  psym             : pentity;
--
--begin
--  u_nimplemented(62);
--{
--  case level
--    -- --> incomplete
--    when etd_incomplete  do curr.eval:=ete_evaluated;
--
--    -- --> full
--    when etd_full do
--        -- typ
--        e_reftype(curr,curr.typ,ek_typename,etd_full,true);
--        if e_part(curr.eval,curr.typ.geteval) then return; end if;
--
--        -- metoda pro zápis (IN)
--        e_refsymbol(curr,curr.write,sd_specified,{ek_sym_var_proc,nil,}final);
--        if e_part(curr.eval,curr.write.geteval) then return; end if;
--
--        -- kontrola symbolu
--        psym:=curr.write.getcentity;
--        case psym^.etype
--          -- proměnná
--          when et_var do
--              -- nesmí být konstantní
--
--              -- typy musí být kompatibilní
--              {%%TECH Kontroluje se pro přiřazení ALIAS.IN:=value(ALIAS:type) }
--              if not t_compatible(toc_assign,t_defview(pentity_var(psym)^.typ.getctype),t_defview(curr.typ.getctype),false) then
--                ce^.seterror({CCERR=}000216,ce_aliastype);
--                ce^.setpos(curr.write.pos);
--                {%%RESUME ce^.raiseerror;}
--                ce^.resumeerror;
--                end if;
--
--
--          -- procedura
--          when et_proc  do
--              {%%X musí mít jeden parametr kompatibilního typu }
--              u_nimplemented(33);
--
--
--          -- jiný symbol je chyba
--          when others do
--              ce^.seterror({CCERR=}000217,ce_x_ex_sym_var_proc);
--              ce^.setpos(curr.write.pos);
--              {%%RESUME ce^.raiseerror;}
--              ce^.resumeerror;
--              --verify({VERIFY=}000777,false);
--          end case;
--
--        -- metoda pro čtení (OUT)
--        e_refsymbol(curr,curr.read,sd_specified,{ek_sym_var_proc,nil,}final);
--        if e_part(curr.eval,curr.read.geteval) then return; end if;
--
--        -- kontrola symbolu
--        psym:=curr.write.getcentity;
--        case psym^.etype
--          -- proměnná
--          when et_var do
--              -- typy musí být kompatibilní
--              {%%TECH Kontroluje se pro přiřazení var(ALIAS:type):=ALIAS.OUT }
--              if not t_compatible(toc_assign,t_defview(curr.typ.getctype),t_defview(pentity_var(psym)^.typ.getctype),false) then
--                ce^.seterror({CCERR=}000218,ce_aliastype);
--                ce^.setpos(curr.read.pos);
--                {%%RESUME ce^.raiseerror;}
--                ce^.resumeerror;
--                end if;
--
--
--          -- procedura
--          when et_proc  do
--              {%%X nesmí mít žádné parametry, musí vracet hodnotu kompatibilního typu }
--              -- a co takhle REF parametr ? (resp. OUT)
--              u_nimplemented(33);
--
--
--          -- jiný symbol je chyba
--          when others do
--              ce^.seterror({CCERR=}000219,ce_x_ex_sym_var_proc);
--              ce^.setpos(curr.read.pos);
--              {%%RESUME ce^.raiseerror;}
--              ce^.resumeerror;
--              --verify({VERIFY=}000778,false);
--          end case;
--
--
--    when others do verify({VERIFY=}000158,true);
--    end case;
--}
--  end e_alias;



----------------------------------------------------------------------------------------------------
procedure e_type_derived (
    curr           : in out tentity_type;        -- vyhodnocovaný typ
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí odvozený typ.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity_type;               -- předek
  t                : typeview;                   -- pohled na předka
  lval             : tuniint;                    -- nové meze pole
  hval             : tuniint;                    -- nové meze pole
  oldrange         : pentity_type;               -- původní typ rozsahu
  newrange         : pentity_type;               -- nový typ rozsahu
  newrange_context : tcontext;                   -- primární kontext nového rozsahu
  pos              : lexposblock;                -- pozice rozsahu
  size             : tunidata_size;              -- nová velikost typu
  isize            : tunidata_size;              -- velikost interní části řetězce
  delka            : tuniint;                    -- délka řetězce
  e                : tentityeval;

begin
  -- vyhodnotit předka
  e_refsymbol_from_typename(curr_context,curr.ancestor,etd_full,ttypeviewset:[tview_partial,tview_full],dts_singular+dts_regular-dts_class,false,true,final);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

  -- předek
  ancestor:=pentity_type(curr.ancestor.getcentity);

  -- zkonstruovat pohled na typ předka
  t.init(curr_context,ancestor);

  -- nesmí to být Incomplete view ani Unchecked view
  if t.tview in ttypeviewset:[tview_incomplete,tview_unchecked] then
    ce^.seterror({CCERR=}000220,ce_i_derive);
    ce^.setinfo(hint_derive_full);
    curr.ancestor.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- zkontrolovat druh typu, pokud je pro odvozovaný typ předvybrán
  if (curr.tkind<>tk_unknown) and (curr.tkind<>ancestor^.tkind) then
    ce^.seterror({CCERR=}000221,ce_i_derive);
    if ancestor^.tkind=tk_regular
      then ce^.setinfo(hint_derive_regular);
      else ce^.setinfo(hint_derive_singular);
      end if;
    curr.ancestor.errpos;
    ce^.resumeerror;
    end if;

  -- zkopírovat determinaci kompatibility, jestli se nezměnila
  if (curr.compat=tc_norm) and (t.tview=tview_full) then curr.compat:=t.compat; end if;

  -- zkopírovat základní údaje, které se nemohly určitě změnit
  curr.size    :=ancestor^.size;
  curr.extofs  :=ancestor^.extofs{size}; -- EXTOFS se změní jen pro TD_EXTENSION
  curr.tflags  :=ancestor^.tflags;
  curr.align   :=ancestor^.align;

  case curr.derive
    -- triviální derivace
    when td_unconstrained     do
        -- zkopírovat ostatní údaje o typu
        curr.seval   :=ancestor^.seval;
        curr.tkind   :=ancestor^.tkind;
        curr.stype   :=ancestor^.stype;
        curr.lval    :=ancestor^.lval;
        curr.hval    :=ancestor^.hval;
        curr.bits    :=ancestor^.bits;
        curr.intaritm:=ancestor^.intaritm;
      { Ondra 3.4.2003 : Zrušeno, float se nově definuje počtem bitů.
        curr.dtype   :=ancestor^.dtype;
      }
        curr.fp      :=ancestor^.fp;
        curr.srange  :=ancestor^.srange;
      --curr.lsize   :=ancestor^.lsize;
        curr.pflags  :=ancestor^.pflags;
        curr.pclass  :=ancestor^.pclass;
        curr.pbase   :=ancestor^.pbase;
        curr.pattrib :=ancestor^.pattrib;
        curr.rflags  :=ancestor^.rflags;
        curr.result  :=ancestor^.result;
      --curr.insize  :=ancestor^.insize;
        curr.parcount:=ancestor^.parcount;
        curr.base    :=ancestor^.base;
        curr.srange  :=ancestor^.srange;
        curr.saliased:=ancestor^.saliased;

        -- default view
      --curr.defview :=t.tview;

    -- type constraint
    when td_constrained       do
        -- předek musí být Full view
        if t.tview<>tview_full then
          ce^.seterror({CCERR=}000222,ce_i_derive);
          ce^.setinfo(hint_derive_constraint);
          curr.ancestor.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;

        -- zkopírovat některé údaje
        curr.seval   :=ancestor^.seval;
        curr.tkind   :=ancestor^.tkind;
        curr.stype   :=ancestor^.stype;

        case t.stype
          -- ordinální typy
          when dt_signed, dt_unsigned, dt_char, dt_enum, dt_logical do
              -- převzít základní údaje
              curr.bits    :=ancestor^.bits;
              curr.intaritm:=ancestor^.intaritm;

              -- vyhodnotit rozsah
              e_refexpr(curr_context,curr.expr,ek_rangetype,ancestor,eu_read,final);
              if e_part(curr.eval,curr.expr.geteval) then return; end if;

              -- meze
              x_const_range(curr.expr.getcexpr,curr.lval,curr.hval);

          -- pole/neomezené pole
          -- Ondra 25.2.2002 : Zakázáno odvozování od constrained polí
          when {dt_array,} dt_uarray  do
              -- pole je jistě omezené
              curr.stype   :=dt_array;

              -- převzít základní údaje
              curr.base    :=ancestor^.base;

              -- %%TECH Těžká finta: pro odvození nového typu rozsahu se
              -- použije mechanismus pro překlad deklarací. Ale myslím, že je
              -- to naprosto v souladu s koncepcí Flexu - omezení rozsahu
              -- pole je vlastně implicitní deklarace typu rozsahu (stejně
              -- jako v normální deklaraci pole) s implicitním předkem.

              -- pozice výrazu
              pexpnode(curr.expr.getcexpr)^.getpos(pos);

              -- odvodit nový typ rozsahu
              d_create_implicit_type(curr_context,newrange,newrange_context,dt_undef,pos);

              -- označit typ za odvozený
              newrange^.derive:=td_constrained;

              -- přiřadit předka a nový rozsah
              newrange^.ancestor.setentity(t.getrange(curr_context).getctype);
              newrange^.expr.setexpr(curr.expr.getcexpr);

              -- konec deklarace (a zde se rekurzivně zavolá E_TYPE_DERIVED)
              d_end_implicit_type(newrange^,pos,true);

              -- dosadit nový rozsah do pole
              curr.srange.settype(newrange);{%%TODO(DECLPOS) Nastavit související výraz nebo aspoň pozici, ne ? }

              -- vypočítat délku pole
              size:=arraysize(curr.base.getctype^.size,curr.srange.getctype^.lval,curr.srange.getctype^.hval);

              -- dosadit velikost typu
              type_setsize(curr,size);

          -- řetězec/neomezený řetězec
          -- Ondra 25.2.2002 : Zakázáno odvozování od constrained stringů
          when {dt_string,} dt_ustring do
              -- řetězec je jistě omezený
              curr.stype   :=dt_string;

              -- převzít základní údaje
              curr.base    :=ancestor^.base;

              -- délka
              e_refexpr(curr_context,curr.expr,ek_const_int,nil,eu_read,final);
              if e_part(curr.seval,curr.expr.geteval) then return; end if;

              -- délka řetězce ve znacích
              x_const_int(pexpnode(curr.expr.getcexpr),delka);

              -- délka musí spadat do mezí původního řetězce
              if delka<ancestor^.srange.getctype^.lval or delka>ancestor^.srange.getctype^.hval then
                ce^.seterror({CCERR=}000223,ce_numrange);
                curr.expr.errpos;
                ce^.resumeerror;
                end if;

              -- parametry řetězce
              cpu^.getstrparams(curr.stype,size,isize,curr.base.getctype^.size,delka);

              -- odvodit typ rozsahu
              -- %%X Zde se pro odvození typu rozsahu řetězce používá jiný mechanismus,
              -- než pro odvození rozsahu pole. To je minimálně divné.
              t_derive_string_range(curr,isize,delka);

              -- přiřadit předka typu rozsahu
              curr.srange.getctype^.ancestor.setentity(t.getrange(curr_context).getctype);

              -- dosadit velikost typu
              type_setsize(curr,size);
              --u_nimplemented(86);

          -- pro ostatní typy nemá omezení rozsahu smysl
          when others do
              ce^.seterror({CCERR=}000224,ce_i_derive);
              ce^.setinfo(hint_derive_constraint);
              curr.ancestor.errpos;
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
          end case;

        -- default view
      --curr.defview:=tview_full;

    -- type extension/private extension,
    when td_extension, td_private_extension do
        -- výsledný typ bude jistě regulární
        curr.tkind:=tk_regular;

        -- vypočítat offset extension části
        curr.extofs:=unidata_size_to_addr(ancestor^.size);

        case t.tview
          -- Partial view => typ lze rozšířit libovolně
          when tview_partial do
              -- vyhodnotit specifikaci
              verify({VERIFY=}000451,e_spec_tab[curr.stype]=nil);
              e_spec_tab[curr.stype]^(curr,curr_context,final);
              if e_part(curr.eval,curr.seval) then return; end if;

          -- Full view => lze rozšířit jen record recordem
          when tview_full do
              if (ancestor^.stype=dt_record) and (curr.stype=dt_record)

                -- record -- record
                then
                  -- vyhodnotit specifikaci
                  e_spec_record(curr,curr_context,final);
                  if e_part(curr.eval,curr.seval) then return; end if;

                -- jiné extension nejsou dovoleny
                else
                  ce^.seterror({CCERR=}000225,ce_i_extension);
                  curr.ancestor.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

          -- jiné typy pohledů na typ nelze rozšířit
          when others do
              ce^.seterror({CCERR=}000226,ce_i_extension);
              curr.ancestor.errpos;
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
          end case;

        --u_nimplemented(86)

    when others do verify({VERIFY=}000241,true);
    end case;
  end e_type_derived;



----------------------------------------------------------------------------------------------------
procedure e_type (
    curr           : in out tentity_type;        -- vyhodnocovaný typ
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci typu.
----------------------------------------------------------------------------------------------------
use
  cc_base.cc_sym.cc_advanced;

var
  i                : t_unsigned;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
      { Ondra 12.11.2003 : Zrušeno, nově jsou tagged všechny netemporary typy. Dospěl jsem k závěru,
        že v každém deklarativním regionu existuje nejvýše jeden nepojmenovaný typ, takže je vždy
        plně kvalifikovatelný a tudíž neexistuje problém při dynamickém linkování

        -- pojmenovaný typ je automaticky tagged
        if curr.id<>nil then curr.tflags+typeflagsset:[tf_tagged]; end if;
      }

        -- netemporary typ je automaticky tagged
        if tf_temp not in curr.tflags then curr.tflags+typeflagsset:[tf_tagged]; end if;

        curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
--      verify({VERIFY=}000017,(curr.stype=st_undef) and final);
{
        -- vyhodnotit statické předky
        for i in 1..curr.pcount loop
          e_reftype(curr.context.entity^,curr.plist^[i],ek_typename,etd_full,final);
          if e_part(curr.{s^.}eval,curr.plist^[i].geteval) then return; end if;
          end loop;
}
        -- určit/zkontrolovat třídu typu
        if curr.derive=td_root then
          case curr.tkind
            -- dosud nezjištěna
            when tk_unknown do
                -- určit z definice typu
                if curr.stype in dts_regular+dts_unitype
                  then curr.tkind:=tk_regular;
                  else curr.tkind:=tk_singular;
                  end if;

            -- regulární
            when tk_regular do
                -- pokud to není private extension (ta je zatím ST_UNDEF)
                if {(curr.derive<>td_private_extension)
                -- musí tomu odpovídat i definice typu
                and} not (curr.stype in dts_regular) then
                  ce^.seterror({CCERR=}000227,ce_i_typedef);
                  if curr.derive=td_root
                    then ce^.setinfo(hint_type_regular);
                    else {%%X};
                    end if;
                  ce^.setpos(curr.pos[etp_def]);
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

            -- singulární
            when tk_singular do
                -- odpovídá tomu i definice typu ?
                if not (curr.stype in dts_singular) then
                  ce^.seterror({CCERR=}000228,ce_i_typedef);
                  ce^.setinfo(hint_type_singular);
                  ce^.setpos(curr.pos[etp_def]);
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

            end case;
          end if;

        -- %%TECH Zde se vyhodnocují všechy atributy, i když nemají pro
        -- daný typ smysl. Přípustnost měl zajistit překlad atributů.

        -- vyhodnotit atributy
        e_refexpr(curr_context,curr.attr_align,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_align.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_native_align,ek_const_logical,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_native_align.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_size,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_size.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_mptr,ek_const_logical,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_mptr.geteval) then return; end if;

        -- zarovnání
        type_setalign(curr,cpu^.defaultalign);

        -- vyhodnotit specifikaci typu
        if curr.derive=td_root

          -- vyhodnotit kořenový typ
          then
            -- vyhodnotit specifikaci
            verify({VERIFY=}000035,e_spec_tab[curr.stype]=nil);
            e_spec_tab[curr.stype]^(curr,curr_context,final);
            if e_part(curr.eval,curr.seval) then return; end if;

          -- vyhodnotit odvozený typ
          else
            e_type_derived(curr,curr_context,level,final);
            end if;

        -- počáteční hodnota
        if curr.init.getuexpr<>nil then
          -- %%X Tak tohle je tedy ligová záplata: Aby fungovala typová kontrola, musí být
          -- dokončena deklarace typu
          cc_base.cc_sym.cc_advanced.sym_set_evaluated(^curr);

          -- vyhodnotit počáteční hodnotu
          e_refimm(curr_context,curr.init,ek_const,^curr,true);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if;

    when others do verify({VERIFY=}000159,true);
    end case;
  end e_type;



----------------------------------------------------------------------------------------------------
procedure e_const (
    curr           : in out tentity_const;       -- vyhodnocovaná konstanta
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci konstanty.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        if cf_typed in curr.cflags

          -- konstanta s explicitně uvedeným typem
          then
            -- vyhodnotit typ
            e_reftype(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_incomplete,tview_full],dts_constrained-dts_class,false,false,final);
            if e_part(curr.eval,curr.typ.geteval) then return; end if;

          -- konstanta s implicitně uvedeným typem
          else
            curr.eval:=ete_evaluated
            end if;

    -- --> full
    when etd_full do
        if cf_typed in curr.cflags

          -- konstanta s explicitně uvedeným typem
          then
            -- vyhodnotit typ
            e_reftype(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],dts_constrained-dts_class,false,false,{etd_full,}final);
            if e_part(curr.eval,curr.typ.geteval) then return; end if;

            -- vyhodnotit hodnotu
            e_refimm(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.init,ek_const,curr.typ.getctype,final);
            if e_part(curr.eval,curr.init.geteval) then return; end if;

          -- konstanta s implicitně uvedeným typem
          else
            -- vyhodnotit hodnotu
            e_refimm(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.init,ek_const,nil,final);
            if e_part(curr.eval,curr.init.geteval) then return; end if;

            -- převzít typ
            -- %%X nemůžu tady přijít o výraz ?
            {%%TODO(DECLPOS) Nastavit související výraz nebo aspoň pozici, ne ? }
            curr.typ.settype(pexpnode(curr.init.getcexpr)^.t.getutype);
            end if;

    when others do verify({VERIFY=}000160,true);
    end case;
  end e_const;



----------------------------------------------------------------------------------------------------
procedure e_enum (
    curr           : in out tentity_enum;        -- vyhodnocovaná konstanta
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci prvku výčtového typu.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- máme k dispozici explicitně předepsanou ordinální hodnotu ?
        if curr.attr_ord.isset

          -- ano => použít
          then
            -- vyhodnotit atribut
            e_refexpr(curr_context,curr.attr_ord,ek_const_int,nil,eu_use,true);
            if e_part(curr.eval,curr.attr_ord.geteval) then return; end if;

            -- převzít z výrazu hodnotu
            x_const_int(curr.attr_ord.getcexpr,curr.ordinal);

          -- ne => default podle pořadí prvku
          else
            curr.ordinal:=unsigned_to_uniint(curr.order);
            end if;

        -- označit za vyhodnocené
        curr.eval:=ete_evaluated;

    when others do verify({VERIFY=}000161,true);
    end case;
  end e_enum;



----------------------------------------------------------------------------------------------------
procedure e_code_body (
    curr           : in out class tentity_code;  -- vyhodnocovaná procedura
    curr_context   : in tcontext;                -- primární kontext entity
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnocení těla podprogramu pro úroveň SD_FULL.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- lokální symboly
  e_all(curr,etd_full,final,e);
  if e_part(curr.eval,e) then return; end if;

  -- příkazy
  e_refblock(curr_context,curr.bl,final);
  if e_part(curr.eval,curr.bl.e) then return; end if;
  end e_code_body;



----------------------------------------------------------------------------------------------------
procedure e_check_subprogram_type (
    ptyp           : in pentity_type) =          -- typ podprogramu
-- Dodatečná kontrola typu podprogramu - kontroluje úplnost deklarace typů parametrů.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hledátko

begin
  verify({VERIFY=}000230,ptyp^.stype<>dt_procedure);

  -- projet všechny parametry
  srch.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
  while srch.psym<>nil loop
    -- teď už jsou povoleny jen Partial view a Full view na typ parametru
    e_reftype(sym_primary_context(srch.psym^),pentity_param(srch.psym)^.typ,ek_typename,ttypeviewset:[tview_partial,tview_full],dts_regular,true,true,true);

    -- další parametr
    srch.find_et_next;
    end loop;
  end e_check_subprogram_type;



----------------------------------------------------------------------------------------------------
procedure e_before_subprogram_body =
-- Dokončení vyhodnocení specifikace podprogram před překladem definice.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype 
    -- procedura, statická a virtuální metoda
    when et_procedure, et_static, et_virtual do
        -- kontrola typu procedury
        e_check_subprogram_type(pentity_subprogram(entity)^.typ.getctype);

    -- override virtuální metody
    when et_override do
        {%%X};

    -- speciální metoda
    when et_special do
        -- kontrola typu procedury
        if etc_generated in entity^.compile then
          e_check_subprogram_type(pentity_special(entity)^.typ.getctype);
          end if;

    -- nic jiného není podprogram
    when others do verify({VERIFY=}000728,true);
    end case;
  end e_before_subprogram_body;



----------------------------------------------------------------------------------------------------
procedure e_special (
    curr           : in out tentity_special;     -- vyhodnocovaná speciální metoda
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci speciální metody.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_none do
        verify({VERIFY=}000577,etc_generated in curr.compile);
        curr.eval:=ete_evaluated;

    -- --> incomplete -- pouze pro interní speciální metody
    when etd_incomplete  do
        verify({VERIFY=}000578,etc_generated not in curr.compile);

        -- vyhodnotit typ speciální metody
        e_reftype(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_procedure],false,false,false);
        if e_part(curr.eval,curr.typ.e) then return; end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tělo
        e_code_body(curr,curr_context,final);

    when others do verify({VERIFY=}000162,true);
    end case;
  end e_special;



----------------------------------------------------------------------------------------------------
procedure e_subprogram (
    curr           : in out class tentity_subprogram; -- vyhodnocovaná procedura
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci procedury, statické a virtuální metody.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  pclass           : pentity_type;           -- související třída

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        -- typ procedury
        e_reftype(curr_context{%%TODO(Ondra): Proč tu byl parent?: curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_procedure],false,false,false);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- není to náhodou virtuální metoda ?
        if curr.etype=et_virtual then
          -- v čem je deklarovaná ?
          if curr.context.entity^.etype=et_class

            -- v třídě => nemusí mít řídící parametry
            then
              -- pro zjednodušení: pointer na třídu
              pclass:=pentity_type(curr.context.entity);

              -- má virtuální metoda řídící parametry
              if rf_virtual in curr.typ.getctype^.rflags

                -- ano má => komplexní volání
                then
                  pentity_virtual(^curr)^.vcall:=tvct_complex;

                  unimplemented({UNIMP=}000159);

                -- nemá => jednoduché volání
                else
                  declare var
                    interface : p_class_interface;

                  begin
                    -- způsob volání
                    pentity_virtual(^curr)^.vcall:=tvct_simple_index;

                    -- najít nativní interface
                    interface:=pclass^.interfaces^.get_native_interface;

                    -- přidělit index a zařadit do virtuální tabulky
                    interface^.add_virtual_method(^curr);
                    end declare;
                  end if;

            -- v modulu, programu nebo kompilační jednotce => musí mít řídící parametry
            else
              -- typ musí mít řídící parametry
              if rf_virtual not in curr.typ.getctype^.rflags then
                {%%X}
                end if;

              -- způsob volání: komplexní
              pentity_virtual(^curr)^.vcall:=tvct_complex;

              unimplemented({UNIMP=}000160);
              end if;

          -- přidělit slot ve virtuální tabulce
          {%%X}
          end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tělo
        e_code_body(curr,curr_context,final);

    when others do verify({VERIFY=}000163,true);
    end case;
  end e_subprogram;



----------------------------------------------------------------------------------------------------
procedure e_override (
    curr           : in out tentity_override;    -- vyhodnocovaná procedura
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci přetížení virtuální metody.
----------------------------------------------------------------------------------------------------
var
  pvirt            : pentity_virtual;        -- související virtuální metoda

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        -- přetěžovaná virtuální metoda
        e_refsymbol(curr_context,curr.virt,etd_incomplete,true);
        if e_part(curr.eval,curr.virt.geteval) then return; end if;

        -- pro zjednodušení: pointer na virtuální metodu
        pvirt:=pentity_virtual(curr.virt.getcentity);

        -- v čem byla původní virtuální metoda deklarována ?
        if pvirt^.context.entity^.etype=et_class

          -- v třídě
          then
            -- override musí být též v třídě
            if curr.context.entity^.etype<>et_class then
              {%%X}
              end if;

            -- má virtuální metoda nějaké řídící parametry ?
            if rf_virtual in pvirt^.typ.getctype^.rflags then
              unimplemented({UNIMP=}000162);
              end if;

            declare var
              pclass_virt : pentity_type;        -- třída ve které je virtuální metoda
              pclass_this : pentity_type;        -- třída ve které je override = tato třída

            begin
              -- pro zjednodušení: pointer na třídu
              x_get_context(curr.virt.getcexpr,pclass_virt);
            --pclass_virt:=pentity_type(pvirt^.context.entity);
              pclass_this:=pentity_type(curr.context.entity);

              -- vyhledat interface
              if sym_is_ancestor(pclass_virt,pclass_this)

                -- overridujeme metodu předka => nativní interface
                then curr.interface:=pclass_this^.interfaces^.find_interface(pclass_this);

                -- overridujeme jinou metodu => nějaký exposovaný interface
                else curr.interface:=pclass_this^.interfaces^.find_interface(pclass_virt);
                end if;

              -- nenašel-li se interface, nemá tu override co dělat
              if curr.interface=nil then
                ce^.seterror({CCERR=}000229,ce_i_override);
                pexpnode(curr.virt.getcexpr)^.errpos;
                ce^.raiseerror;
                end if;
              verify({VERIFY=}000697,curr.interface^.is_exposed<>not sym_is_ancestor(pclass_virt,pclass_this));

              -- nebyla už metoda jednou přetížena ?
              if curr.interface^.is_virtual_method_overriden(pvirt) then
                ce^.seterror({CCERR=}000230,ce_multioverride);
                ce^.setparam(sym_get_qid(pvirt));
                ce^.setpos(curr.pos[etp_header]);
                ce^.raiseerror;
                end if;

              -- přetížit virtuální metodu
              curr.interface^.override_virtual_method(pvirt,^curr);
              end declare;

          -- v modulu, programu či kompilační jednotce
          else
            -- override musí být též v modulu, programu či kompilační jednotce
            if curr.context.entity^.etype not in ets_container-tentitytypeset:[et_class] then
              {%%X}
              end if;

            unimplemented({UNIMP=}000161);
            end if;

    -- --> full
    when etd_full do
        -- vyhodnotit tělo
        e_code_body(curr,curr_context,final);

    when others do verify({VERIFY=}000779,true);
    end case;
  end e_override;



----------------------------------------------------------------------------------------------------
procedure e_overload (
    curr           : in out tentity_overload;    -- vyhodnocované přetížení
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci přetížení.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level

    -- --> full
    when etd_full do
        -- na přetížené procedury nejsou kladena skoro žádná omezení
        for i in curr.table^:range loop
          -- vyhodnotit odkaz
          e_refsymbol(curr_context,curr.table^[i].psym,etd_incomplete,true);
          if e_part(curr.eval,curr.table^[i].psym.geteval) then return; end if;
          end loop;
        curr.eval:=ete_evaluated;

    when others do verify({VERIFY=}000274,true);
    end case;
  end e_overload;



----------------------------------------------------------------------------------------------------
procedure e_operator (
    curr           : in out tentity_operator;    -- vyhodnocovaný operátor
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci přetížení.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_procedure;          -- přetížená procedura
  ptyp             : pentity_type;               -- typ procedury
  pparam           : pentity_param;              -- parametr
  srch             : tentitysearch;              -- hledátko
  e                : tentityeval;

begin
  case level

    -- --> full
    when etd_full do
        -- zkontrolovat přípustnost přetížených procedur
        for i in curr.table^:range loop
          -- vyhodnotit odkaz
          e_refsymbol(curr_context,curr.table^[i].psym,etd_incomplete,true);
          if e_part(curr.eval,curr.table^[i].psym.geteval) then return; end if;

          -- přetížená procedura a její typ
          pproc:=pentity_procedure(curr.table^[i].psym.getcentity);
          ptyp:=pproc^.typ.getctype;

          -- nemí možné přetížit operátor metodou, která vyžaduje uvedení instance, aby byla volatelná
          if pproc^.instance not in tip_as_operator then
            ce^.seterror({CCERR=}000581,ce_operator_no_instance);
            curr.table^[i].psym.errpos;
            ce^.resumeerror;
            end if;
          -- {%%X přetěžovat metody zatím neumím }
          --if pproc^.instance<>tip_none then unimplemented({UNIMP=}000097); end if;

          -- kolik má parametrů ?
          case ptyp^.parcount
            -- jeden parametr
            when 1 do
                -- přetěžovaný operátor musí být unární
                if not (toa_unary in ooperinfo[curr.oop].arity) then
                  ce^.seterror({CCERR=}000231,ce_operator_params);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- poznamenat, že je operátor unární
                curr.table^[i].arity:=toa_unary;

            -- dva parametry
            when 2 do
                -- přetěžovaný operátor musí být binární
                if not (toa_binary in ooperinfo[curr.oop].arity) then
                  ce^.seterror({CCERR=}000232,ce_operator_params);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- nalézt druhý parametr
                srch.find_et_first(ptyp,rc_primary,et_param,[]);
                srch.find_et_next;
                pparam:=pentity_param(srch.psym);
                verify({VERIFY=}000279,pparam=nil);

                -- neměl by být UNCHECKED
                if pparam^.pass=pp_unchecked then
                  ce^.seterror({CCERR=}000233,ce_operator_pass2);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- druhý parametr musí být IN
                if pparam^.mode<>pm_in then
                  ce^.seterror({CCERR=}000234,ce_operator_mode2);
                  curr.table^[i].psym.errpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- poznamenat, že je operátor unární
                curr.table^[i].arity:=toa_binary;

            -- více parametrů je jistě chyba, takové operátory nemáme
            when others do
                ce^.seterror({CCERR=}000235,ce_operator_params);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
            end case;

          -- nalézt první parametr
          srch.find_et_first(ptyp,rc_primary,et_param,[]);
          pparam:=pentity_param(srch.psym);
          verify({VERIFY=}000280,pparam=nil);

          -- neměl by být UNCHECKED
          if pparam^.pass=pp_unchecked then
            ce^.seterror({CCERR=}000236,ce_operator_pass1);
            curr.table^[i].psym.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- má návratovou hodnotu ?
          if ptyp^.result=nil

            -- ne
            then
              -- pak musí být první parametr IN OUT, pro přiřazení lze i pouze OUT
              if (curr.oop=oop_assign and then pparam^.mode not in parammodeset:[pm_out,pm_inout])
              or (curr.oop<>oop_assign and then pparam^.mode<>pm_inout) then
                ce^.seterror({CCERR=}000237,ce_operator_mode1);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- poznamenat, že je to zkrácené přiřazení
              curr.table^[i].assign:=true;

            -- ano
            else
              -- operátor nesmí být prosté přiřazení
              if curr.oop=oop_assign then
                ce^.seterror({CCERR=}000238,ce_operator_noret);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- pak musí být první parametr IN
              if pparam^.mode<>pm_in then
                ce^.seterror({CCERR=}000239,ce_operator_mode1);
                curr.table^[i].psym.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

              -- poznamenat, že je to zkrácené přiřazení
              curr.table^[i].assign:=false;
              end if;
          end loop;

        -- vyhodnoceno
        curr.eval:=ete_evaluated;

    when others do verify({VERIFY=}000275,true);
    end case;
  end e_operator;



----------------------------------------------------------------------------------------------------
procedure e_extend_module (
    curr           : in out tentity_module;      -- vyhodnocovaný modul
    curr_context   : in tcontext) =              -- primární kontext modulu
-- Vyhodnotí předka modulu.
----------------------------------------------------------------------------------------------------
begin
  -- má smysl něco začínat ?
  if not curr.ancestor.isset then return end if;

  -- vyhodnotit předka
  e_refsymbol(curr_context,curr.ancestor,etd_public,true);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;
  end e_extend_module;



----------------------------------------------------------------------------------------------------
procedure e_module (
    curr           : in out tentity_module;      -- vyhodnocovaný modul
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci modulu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> public
    when etd_public do
        -- lokální symboly
        e_all(curr,etd_incomplete,final,e);
        if e_part(curr.eval,e) then return; end if;

    -- --> full
    when etd_full do
        -- lokální symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

    when others do verify({VERIFY=}000780,true);
    end case;
  end e_module;



----------------------------------------------------------------------------------------------------
procedure e_extend_class (
    curr           : in out tentity_type;         -- vyhodnocovaná třída
    curr_context   : in tcontext) =              -- primární kontext entity
-- Vyhodnotí předka třídy.
----------------------------------------------------------------------------------------------------
begin
  -- má smysl něco začínat ?
  if not curr.ancestor.isset then return end if;

  -- vyhodnotit předka
  e_refsymbol_from_typename(curr_context,curr.ancestor,etd_public,ttypeviewset:[tview_full,tview_incomplete],dts_class,true,true,for final use true);
  if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

  -- převzít informace o všech interfacech z předka
  curr.interfaces^.merge_interface_list(pentity_type(curr.ancestor.getcentity)^.interfaces);
  end e_extend_class;



----------------------------------------------------------------------------------------------------
procedure e_expose_class (
    curr           : in out tentity_type;        -- vyhodnocovaná třída
    curr_context   : in tcontext) =              -- primární kontext entity
-- Vyhodnotí interfacy třídy.
----------------------------------------------------------------------------------------------------
with
  standard.classes.lists;

begin
  -- vyhodnotit interfacy (1. je nativní, není potřeba vyhodnocovat)
  if curr.interfaces^.count>1 then
    declare var
      it       : c_list_iterator;            -- iterátor
      interface: p_class_interface;          -- interface třídy

    begin
      -- připravit iterátor
      curr.interfaces^.get_exposed_interfaces(it);

      -- zpracovat všechny interfacy
      while it.get(interface) loop
        -- vyhodnotit
        e_refsymbol_from_typename(curr_context,interface^.refclass,etd_public,ttypeviewset:[tview_full,tview_incomplete],dts_class,true,true,for final use true);
        if e_part(curr.eval,interface^.refclass.geteval) then return; end if;

        -- pokud se tak již nestalo, tak založit skrytou proměnnou odpovídající interfacu
        if not interface^.instance.isset then
          declare var
            instance         : pentity_var;-- nově založená instance interfacu
            instance_context : tcontext;   -- kontext instance interfacu

          begin
            verify({VERIFY=}000781,curr.ancestor.isset and then pentity_type(curr.ancestor.getcentity)^.interfaces^.is_exposed_interface(interface^.refclass.getcentity));

            -- založit instanci interfacu
            d_create_internal(curr_context,pentity(instance),instance_context,et_var,nil);
            instance^.compile-tentitycompileset:[etc_generated];
            instance^.typ.settype(pentity_type(interface^.refclass.getcentity));
            instance^.mclass     :=mc_class;
            instance^.vmode      :=vm_direct;
            instance^.vaccess    :=va_norm;
            instance^.vimplements:=vi_interface;
            d_end_internal(instance^,true);

            -- doplnit do popisu interfacu
            interface^.instance.setentity(instance);
            end declare;
          end if;
        end loop;
      end declare;
    end if;
  end e_expose_class;

  

----------------------------------------------------------------------------------------------------
procedure e_class (
    curr           : in out tentity_type;         -- vyhodnocovaná třída
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci třídy.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;
  varofs           : tunidata_addr;              -- aktuální offset v třídě
  maxofs           : tunidata_addr;              -- nejvyšší dosažený offset složky

    ------------------------------------------------------------------------------------------------
    procedure check_abstract_methods =
    -- Zkontroluje, zda byly implementovány všechny virtuální abstraktní metody. Pokud ne, hlásí
    -- chybu.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes.lists;

    var
      it           : c_list_iterator;            -- iterátor přes všechny interfacy
      iface        : p_class_interface;          -- právě zpracovávaný interface
      impl         : pentity_code;               -- právě zpracovávaná metoda

    begin
      -- prolézt všechny interfacy
      curr.interfaces^.get_all_interfaces(it);
      while it.get(iface) loop
        -- pro každou virtuální metodu zkontrolovat, jestli není abstraktní
        for vindex in 1..iface^.get_vtable_size loop
          -- zjistit implementaci [vindex]-té virtuální metody
          impl:=iface^.get_virtual_method(vindex);

          -- není náhodou abstraktní ?
          if impl^.is_abstract then
            ce^.seterror({VERIFY=}001129,ce_abstract_not_overriden);
            ce^.setparam(sym_get_qid(impl));
            ce^.setpos(curr.pos[etp_header]);
            end if;
          end loop;
        end loop;
      end check_abstract_methods;



    ------------------------------------------------------------------------------------------------
    procedure assignvaraddr (
        context    : in tcontext) =              -- aktuální kontext
    -- Přidělení adres proměnným.
    ------------------------------------------------------------------------------------------------
    var
      p            : pentity;                    -- zpracovávaná entita
      region       : pregion;                    -- zpracovávaný kontext

    begin
      -- zpracovat všechny symboly v tabulce symbolů
      p:=context.region^.entities.first;
      while p<>nil loop
        -- proměnná
        if p^.etype=et_var then
          -- zajímavé jsou jen proměnné třídy
          if pentity_var(p)^.mclass=mc_class then
            cpu^.layoutrecitem(pentity_var(p),curr.align,curr.native_align,varofs,maxofs);
            end if;

        -- metoda, mohla by obsahovat nějaké skryté proměnné třídy
        elsif p^.etype in ets_subprogram then
          assignvaraddr(sym_primary_context(p^));
          end if;

        -- další symbol
        p:=p^.next;
        end loop;

      -- zpracovat vnořené regiony
      region:=context.region^.regions.first;
      while region<>nil loop
        -- zpracovat
        assignvaraddr(sym_build_context(context.entity,region));

        -- další region
        region:=region^.next;
        end loop;
      end assignvaraddr;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do
        curr.eval:=ete_evaluated;

        -- třída je automaticky tagged
        curr.tflags+typeflagsset:[tf_tagged];

        -- třída je regulární typ
        curr.tkind:=tk_regular;

        -- založit tabulku interfaců
        new curr.interfaces;

        -- třída je sama sobě nativním interfacem
        curr.interfaces^.add_interface(nil,^curr);

        -- vyhodnotit atributy
        e_refexpr(curr_context,curr.attr_align,ek_const_int,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_align.geteval) then return; end if;
        e_refexpr(curr_context,curr.attr_native_align,ek_const_logical,nil,eu_use,true);
        if e_part(curr.eval,curr.attr_native_align.geteval) then return; end if;

        -- zarovnání
        type_setalign(curr,cpu^.defaultalign);

    -- --> public
    when etd_public do
        verify({VERIFY=}000782,tf_tagged not in curr.tflags);

        -- lokální symboly
        e_all(curr,etd_incomplete,final,e);
        if e_part(curr.eval,e) then return; end if;

    -- --> full
    when etd_full do
        verify({VERIFY=}000783,tf_tagged not in curr.tflags);

        -- lokální symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

        -- zkontrolovat, zda byly implementovány všechny abstraktní virtuální metody
        if not curr.is_abstract then
          check_abstract_methods;
          end if;

        -- vyřešit předka
        if curr.ancestor.isset

          -- má předka => rezervovat pro něj místo na začátku třídy
          then
            varofs:=unidata_size_to_addr(pentity_type(curr.ancestor.getcentity)^.size)

          -- nemá předka => rezervovat místo pro tag
          else
            varofs:=unidata_size_to_addr(cpu^.classisize)
            end if;

        -- určit zatím maximální dosažený offset
        maxofs:=varofs;

        -- přidělit adresy proměnných
        assignvaraddr(curr_context);

        -- určit velikost třídy
        type_setsize(curr,unidata_addr_to_size(maxofs));

    when others do verify({VERIFY=}000165,true);
    end case;
  end e_class;



----------------------------------------------------------------------------------------------------
procedure e_compile (
    curr           : in out tentity_compile;     -- vyhodnocovaná kompilační jednotka
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci kompilační jednotky.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- lokální symboly
        e_all(curr,etd_full,final,e);
        if e_part(curr.eval,e) then return; end if;

    when others do verify({VERIFY=}000166,true);
    end case;
  end e_compile;



----------------------------------------------------------------------------------------------------
procedure e_program (
    curr           : in out tentity_program;     -- vyhodnocovaný program
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci programu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- vyhodnotit tělo
        e_code_body(curr,curr_context,final);

    when others do verify({VERIFY=}000167,true);
    end case;
  end e_program;



----------------------------------------------------------------------------------------------------
procedure e_param (
    curr           : in out tentity_param;       -- vyhodnocovaný parametr
    curr_context   : in tcontext;                -- primární kontext entity
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci parametru.
----------------------------------------------------------------------------------------------------
var
  typ              : typeview;                   -- pohled na typ parametru

begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- typ parametru
        e_reftype(curr.context{curr.context.entity^},curr.typ,ek_typename,ttypeviewset:[tview_incomplete,tview_partial,tview_full],dts_regular,true,true,final);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- sestavit pohled na typ parametru
        if curr.typ.getutype=nil
          then typ.initunchecked(curr.typ.getutype);
          else typ.init(curr_context,curr.typ.getutype);
          end if;

        ----- %%TECH Dopočet volací konvence -----------------------------
        -- Volací konvence parametru zůstane neurčena (PP_DEFAULT) pouze
        -- v těchto případech:
        --     1) IN parametr bez explicitně určené volací konvence,
        --     2) návratová hodnota.
        -- V obou případech se na tomto místě překvapivě nastaví správná
        -- volací konvence -- zejména u návratové hodnoty stojí za pozornost,
        -- že se zcela správně doplní volací konvence PP_VALUE pro jednoduché
        -- typy, i když se vlastně jedná o OUT parametr.
        ------------------------------------------------------------------

        -- dopočítat volací konvenci
        if curr.pass=pp_default then
          if t_is_composite(typ)
            -- kompozitní typy se předávají referencí
            then curr.pass:=pp_ref
            -- jednoduché typy se předávají hodnotou
            else curr.pass:=pp_value;
            end if;
          end if;

        -- %%LANG S parametrem se předávají následující dynamické atributy:
        --   -- pro parametr typu třída žádné,
        if t_is_stype(typ,dt_class) then
          -- nic

--      #if #environment compiler_version;>='4.0.3.14' then;
        --   -- pro class a virtual parametry atribut :tag
        elsif curr.pass in pps_tagged then
          curr.rta_avail+rtattribset:[rta_tag];
--      #else;
--        --   -- pro class a virtual parametry atribut :tag, je-li typ
--        --      takového parametru unconstrained, pak taky :last,
--        elsif curr.pass in pps_tagged then
--          curr.rta_avail+rtattribset:[rta_tag];
--          if t_is_sts(typ,dts_unconstrained) then
--            curr.rta_avail+rtattribset:[rta_last];
--            end if;
--      #end if;

        --   -- pro beztypový unchecked parametr atributy :tag a :size,
        --   -- pro unchecked parametr s constrained typem atribut :tag,
        --   -- pro unchecked parametr s unconstrained typem atributy :tag
        --      :size (nikoliv :last!),
        elsif curr.pass=pp_unchecked then
          curr.rta_avail+rtattribset:[rta_tag]; {%%X proč tag?}
          if typ.tview=tview_unchecked or t_is_sts(typ,dts_unconstrained) then
            curr.rta_avail+rtattribset:[rta_size];
            end if;

--      #if #environment compiler_version;='4.0.3.14' then;
        --   -- pro libovolný jiný parametr s unconstrained typem atribut
        --      :tag
        elsif t_is_sts(typ,dts_unconstrained) then
          curr.rta_avail+rtattribset:[rta_tag];
          end if;
--      #else;
--        --   -- pro libovolný jiný parametr s unconstrained typem atribut
--        --      :last (nikoliv :size).
--        elsif t_is_sts(typ,dts_unconstrained) then
--          curr.rta_avail+rtattribset:[rta_last];
--          end if;
--      #end if;

        -- %%X %%TODO(TAG) záplata: není udělané dynamické zjišťování RTA_USED
        curr.rta_used:=curr.rta_avail;

        -- vyhodnotit implicitní hodnotu
        if curr.init.isset then
          -- vyhodnotit hodnotu
          e_refimm(curr_context,curr.init,ek_const,curr.typ.getutype,final);
          if e_part(curr.eval,curr.init.geteval) then return; end if;
          end if

    when others do verify({VERIFY=}000168,true);
    end case;
  end e_param;



----------------------------------------------------------------------------------------------------
procedure e_message (
    curr           : in out tentity_message;     -- vyhodnocovaná zpráva
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci zprávy.
----------------------------------------------------------------------------------------------------
begin
  case level
    -- --> incomplete
    when etd_incomplete  do curr.eval:=ete_evaluated;

    -- --> full
    when etd_full do
        -- předek
        e_refsymbol(curr.context{.entity^},curr.ancestor,etd_full,final);
        if e_part(curr.eval,curr.ancestor.geteval) then return; end if;

        -- typ zprávy
        e_reftype(curr.context{.entity^},curr.typ,ek_typename,ttypeviewset:[tview_full],tdatatypeset:[dt_message],false,false,final);
        if e_part(curr.eval,curr.typ.geteval) then return; end if;

        -- není potřeba převzít typ od předka
        if not curr.typ.isset then
          verify({VERIFY=}000555,not curr.ancestor.isset);
          {%%TODO(DECLPOS) Nastavit související výraz nebo aspoň pozici, ne ? }
          curr.typ.settype(pentity_message(curr.ancestor.getcentity)^.typ.getctype);
          end if;

    when others do verify({VERIFY=}000233,true);
    end case;

  -- celkem není co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_message;



----------------------------------------------------------------------------------------------------
procedure e_label (
    curr           : in out tentity_label;       -- vyhodnocované návěští
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci návěští.
----------------------------------------------------------------------------------------------------
begin
  -- celkem není co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_label;



----------------------------------------------------------------------------------------------------
procedure e_template (
    curr           : in out tentity_template;    -- vyhodnocovaná šablona
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci návěští.
----------------------------------------------------------------------------------------------------
begin
  -- celkem není co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_template;



----------------------------------------------------------------------------------------------------
procedure e_tparam (
    curr           : in out tentity_tparam;      -- vyhodnocovaný parametr šablony
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci návěští.
----------------------------------------------------------------------------------------------------
begin
  -- celkem není co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_tparam;



----------------------------------------------------------------------------------------------------
procedure e_attribute (
    curr           : in out tentity_attribute;   -- vyhodnocovaný atribut
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci atributu.
----------------------------------------------------------------------------------------------------
begin
  -- celkem není co vyhodnocovat
  curr.eval:=ete_evaluated;
  end e_attribute;



----------------------------------------------------------------------------------------------------
procedure e_undef (
    curr           : in out tentity;             -- vyhodnocované návěští
    level          : in tentitydeclared;         -- požadovaná uroveň vyhodnocení
    final          : in t_logical) =             -- T-výsledek musí být vyhodnocen
-- Vyhodnotí deklaraci nedefinovaného prvku.
----------------------------------------------------------------------------------------------------
begin
  -- takový prvek si jistě vymyslel překladač,
  -- takže ho lze považovat za vyhodnocený
  curr.eval:=ete_evaluated;
  end e_undef;



----------------------------------------------------------------------------------------------------
procedure check_unused_with (
    context        : in tcontext)=
-- Nahlasi nepouzite moduly, uvedene ve WITH tabulce entity
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;
  _e               : pentity;
  wtab             : twithtable;

begin
  if context=nil then return; end if;

  -- projit WITH tabulku
  wtab:=context.entity^.regions[rc_primary]^.withtable;
  if wtab<>nil then
    for i in wtab^:range loop

      -- nahlasit nepouzite moduly
      if wtab^[i].stat_usage=0 and not wtab^[i].automatic then
        ce^.sethint(context,000000,ch_unused_module);
        ce^.setparam(entityident_to_string(wtab^[i].entity.getcentity^.id^));
        ce^.setpos(wtab^[i].lexpos);
        end if;
      end loop;
    end if;
  end check_unused_with;



----------------------------------------------------------------------------------------------------
procedure check_unused_entities (
    curr           : in tcontext) =              -- překládaný kontext
-- Ohlásí varování pro každou nepoužitou entitu uvnitř [curr].
----------------------------------------------------------------------------------------------------
begin
  -- má cenu se tím zabývat ?
  if ch_unused_entity not in curr.entity^.compv.hints then return end if;

  -- všechny entity v tomto regionu
  declare var
    p              : pentity;

  begin
    p:=curr.region^.entities.first;
    while p<>nil loop
      declare var 
        ommit        : t_logical;                  -- T-nehlásit pro tuto entitu

      begin
        if p^.stat_usage=0 and p^.id<>nil and etc_generated not in p^.compile then

          -- parametr virtualni metody ci overridu?
          if p^.etype=et_var and then pentity_var(p)^.vimplements=vi_parameter {and then pentity_var(p)^.imp_param<>nil} then
            ommit or curr.entity^.etype in tentitytypeset:[et_virtual,et_override];
            end if;

          -- ne-private slozka tridy ci modulu?
          ommit or (p^.visible<>etv_private and then curr.entity^.etype in ets_modular);

          -- nehlasit kompilatorem generovane entity
          ommit or etc_generated in p^.compile;

          -- nastav HINT
          if not ommit then
            ce^.sethint(curr,000000,ch_unused_entity);
            ce^.setparam(entityident_to_string(p^.id^));
            ce^.setpos(p^.pos[etp_header]);
            end if;
          end if;

        -- další symbol
        p:=p^.next;
        end declare;
      end loop;
    end declare;

  -- všechny podregiony
  declare var
    region         : pregion;

  begin
    region:=curr.region^.regions.first;
    while region<>nil loop
      -- zpracovat
      check_unused_entities(sym_build_context(curr.entity,region));

      -- další region
      region:=region^.next;
      end loop;
    end declare;
  end check_unused_entities;



----------------------------------------------------------------------------------------------------
procedure e_symbol =
-- Vyhodnocení jednoho symbolu.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_debug;

var
  sym_context      : tcontext;                   -- context vyhodnocovaného symbolu
--#if #declared dump; #and then; dump then;
--  elevel           : static t_unsigned := 0;
--#end if;
  errors           : t_unsigned32;               -- počet chyb pořed započetím zpracování symbolu

begin
  -- symbol je právě vyhodnocován (cirkulární reference)
  if etc_evaluating in psym^.compile then return; end if;

  -- symbol je nevyhodnotitelný
  if psym^.eval=ete_unevaluated then return; end if;

  -- symbol je v požadované úrovni již vyhodnocen
  if (psym^.evaluated>level) or ((psym^.evaluated=level) and (psym^.eval=ete_evaluated)) then return; end if;

  -- zjistit počet chyb
  errors:=ce^.error_count;

  begin
    -- symbol je vyhodnocován
    psym^.compile+tentitycompileset:[etc_evaluating];

--  #if #declared dump; #and then; dump then;
--    if o_is_option_by_entity(opt_dump,psym^) then
--      debug_dump({%%TODO(AGGREGATE) fillstr(' ',elevel)+}'e_symbol(' & sym_get_qid(psym) & '; ' & tentitydeclaredtxt[psym^.declared] & '): ' & tentitydeclaredtxt[psym^.evaluated] & ' (' & tentityevaltxt[psym^.eval] & ') --> ' & tentitydeclaredtxt[level]);
--      end if;
--    elevel+2;
--  #end if;

    -- vypočítat kontext symbolu
    sym_context:=sym_primary_context(psym^);

    -- vyhodnotit podle typu symbolu
    case psym^.etype
      when et_undef     do e_undef(psym^,level,final);{psym^.eval:=ete_evaluated;}
      when et_compile   do e_compile(pentity_compile(psym)^,sym_context,level,final);
      when et_program   do e_program(pentity_program(psym)^,sym_context,level,final);
      when et_module    do e_module(pentity_module(psym)^,level,final);
      when et_special   do e_special(pentity_special(psym)^,sym_context,level,final);
      when et_procedure do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_static    do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_virtual   do e_subprogram(pentity_subprogram(psym)^,sym_context,level,final);
      when et_override  do e_override(pentity_override(psym)^,sym_context,level,final);
      when et_overload  do e_overload(pentity_overload(psym)^,sym_context,level,final);
      when et_operator  do e_operator(pentity_operator(psym)^,sym_context,level,final);
      when et_var       do e_var(pentity_var(psym)^,sym_context,level,final);
--    when et_alias     do e_alias(pentity_alias(psym)^,level,final);
      when et_type      do e_type(pentity_type(psym)^,sym_context,level,final);
      when et_class     do e_class(pentity_type(psym)^,sym_context,level,final);
      when et_const     do e_const(pentity_const(psym)^,sym_context,level,final);
      when et_enum      do e_enum(pentity_enum(psym)^,sym_context,level,final);
      when et_param     do e_param(pentity_param(psym)^,sym_context,level,final);
      when et_message   do e_message(pentity_message(psym)^,level,final);
      when et_label     do e_label(pentity_label(psym)^,level,final);
      when et_template  do e_template(pentity_template(psym)^,level,final);
      when et_tparam    do e_tparam(pentity_tparam(psym)^,level,final);
      when et_attribute do e_attribute(pentity_attribute(psym)^,level,final);
      when others do verify({VERIFY=}000015,true);
      end case;

    -- povedlo se deklaraci vyhodnotit ?
--  #if #declared dump; #and then; dump then;
--    elevel-2;
--  #end if;
    if psym^.eval=ete_evaluated
      then psym^.evaluated:=level
      else
--      #if #declared dump; #and then; dump then;
--        if o_is_option_by_entity(opt_dump,psym^) then debug_dump({%%TODO(AGGREGATE)fillstr(' ',elevel)+}'Failed.'); end if;
--      #end if;
        end if;

    -- plně vyhodnocené entity analyzovat pro potřeby hlášení různých hintů
    if psym^.evaluated=etd_full and then psym^.etype in ets_enclosing then
      -- nahlasit nepouzite WITH/USE moduly
      check_unused_with(sym_context);
      
      -- nahlasit varování pro nepoužité entity
      check_unused_entities(sym_context);
      end if;

  catch
    when resume_error do
        -- symbol se nepodařilo vyhodnotit a nemá cenu to zkoušet dál
        psym^.eval:=ete_unevaluated;

        -- pokud symbol je nevyhodnocen, musela být během vyhodnocování symbolu hlášena chyba
        verify({VERIFY=}000879,ce^.error_count<=errors);

--        -- chyba
--        ce^.seterror({CCERR=}000240,ce_unevaluated);
--        ce^.setparam(sym_get_qid(psym));
--        ce^.setpos(pos);
--        raise;
        return;

  leave
    -- konec vyhodnocování symbolu
    psym^.compile-tentitycompileset:[etc_evaluating];
    end;

  -- jak to dopadlo ?
  -- je požadováno úplné vyhodnocení entity
  if {final 
  -- a entita není vyhodnocena
  and} psym^.eval not in tentityevalset:[ete_evaluated] then
{
  -- je požadováno uplne vyhodnoceni symbolu
  if final
  -- generický symbol: není vyhodnocen
  and (   (etc_generic     in psym^.compile and psym^.eval not in tentityevalset:[ete_evaluated,ete_generic])
  -- statický symbol:  není vyhodnocen
       or (etc_generic not in psym^.compile and psym^.eval not in tentityevalset:[ete_evaluated]))
  -- => chyba
  then
}
    -- symbol se nepodařilo vyhodnotit a nemá cenu to zkoušet dál
    psym^.eval:=ete_unevaluated;

    -- pokud symbol je nevyhodnocen, musela být během vyhodnocování symbolu hlášena chyba
    verify({VERIFY=}000878,ce^.error_count<=errors);

    -- chyba
--    ce^.seterror({CCERR=}000241,ce_unevaluated);
--    ce^.setparam(sym_get_qid(psym));
--    ce^.setpos(pos);
--    {%%RESUME ce^.raiseerror;}
--    ce^.resumeerror;
    end if;
  end e_symbol;



----------------------------------------------------------------------------------------------------
procedure e_check (
    psym           : in pentity;                 -- překládaný prvek
    pos            : in lexposblock;             -- referenční pozice
    level          : in tentitydeclared;         -- požadovaná úroveň deklarace
    final          : in t_logical;               -- T-výsledek musí být vyhodnocen
    e              : out tentityeval) =          -- zjištěné vyhodnocení
-- Kontrola vyhodnocení symbolu.
----------------------------------------------------------------------------------------------------
begin
  -- požadová úroveň deklarace
  if psym^.declared<level then
    {if final
      -- symbol není deklarován a měl by --> chyba
      then}
        ce^.seterror({CCERR=}000242,ce_incomplete);
        ce^.setparam(sym_get_qid(psym));
        ce^.setpos(pos);
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

      {-- zatím se nic neděje
      else
        if psym^.eval=ete_evaluated
          then e:=ete_none;
          else e:=psym^.eval;
          end if;
        return;
        end if;}
    end if;

  -- ještě se pokusit vyhodnotit nevyhodnocený symbol
  e_symbol(psym,pos,level,final);
  if psym^.eval=ete_evaluated and psym^.evaluated<level
    -- symbol je sice vyhodnocen, ale v nižší než požadované úrovni
    then e:=ete_none
    -- ostatní případy převzít
    else e:=psym^.eval;
    end if;
  end e_check;



----------------------------------------------------------------------------------------------------
procedure e_all_context (
    context        : in tcontext;                -- vyhodnocovaný kontext
    level          : in tentitydeclared;         -- požadovaný uroveň vyhodnocení
    final          : in t_logical;               -- T-výsledek musí být vyhodnocen
    e              : in out tentityeval) =       -- kumulativní vyhodnocení
-- Vyhodnocení všech prvků obsažených v zadaném kontextu a všech subkontextech.
----------------------------------------------------------------------------------------------------
var
  p                : pentity;                    -- vyhodnocovaná entita
  ee               : tentityeval;                -- vyhodnocení entity
  ignore           : t_logical;                  -- ignorovaná návratová hodnota
  region           : pregion;                    -- zpracovávaný region

begin
  -- vyhodnotit všechny symboly
  p:=context.region^.entities.first;
  while p<>nil loop
    -- %%X pozor na cirkulární reference modulů

    -- vyhodnotit symbol
    if etc_generated not in p^.compile and p^.eval<>ete_unevaluated then

      -- vyhodnotit
      e_check(p,p^.pos[etp_header],level,final{true},ee);

      -- započítat do celkového výsledku
      ignore:=e_part(e,ee);
      -- návratová hodnota se ignoruje, entity vyhodnotíme vždy všechny
      end if;

    -- další symbol
    p:=p^.next;
    end loop;

  -- zpracovat subkontexty
  region:=context.region^.regions.first;
  while region<>nil loop
    -- zpracovat
    e_all_context(sym_build_context(context.entity,region),level,final,e);

    -- další region
    region:=region^.next;
    end loop;
  end e_all_context;



----------------------------------------------------------------------------------------------------
procedure e_all =
-- Vyhodnocení všech prvků obsažených v právě překládaném prvku.
----------------------------------------------------------------------------------------------------
begin
  -- předpoklad: vyhodnotí se úplně všechno
  e:=ete_evaluated;

  -- zpracovat všechny regiony
  for rcategory in tregioncategory loop
    -- zpracovat region
    if curr.regions[rcategory]<>nil then
      e_all_context(sym_build_context(^curr,curr.regions[rcategory]),level,final,e);
      end if;
    end loop;
  end e_all;



----------------------------------------------------------------------------------------------------
procedure e_after_extend =
-- Vyhodnocení specifikace předka v klauzuli EXTEND.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype
    when et_module do e_extend_module(pentity_module(entity)^,sym_primary_context(entity^));
    when et_class  do e_extend_class(pentity_type(entity)^,sym_primary_context(entity^));
    when others    do verify({VERIFY=}000726,true);
    end case;
  end e_after_extend;



----------------------------------------------------------------------------------------------------
procedure e_after_expose =
-- Vyhodnocení specifikace interfaců v klauzuli EXPOSE.
----------------------------------------------------------------------------------------------------
begin
  case entity^.etype
    when et_class do e_expose_class(pentity_type(entity)^,sym_primary_context(entity^));
    when others   do verify({VERIFY=}000727,true);
    end case;
  end e_after_expose;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  e_spec_tab[dt_uniint    ]:=^e_spec_unitype;
  e_spec_tab[dt_unireal   ]:=^e_spec_unitype;
  e_spec_tab[dt_unilogical]:=^e_spec_unitype;
  e_spec_tab[dt_unichar   ]:=^e_spec_unitype;
  e_spec_tab[dt_uniarray  ]:=^e_spec_unitype;
  e_spec_tab[dt_uninil    ]:=^e_spec_unitype;
  e_spec_tab[dt_signed    ]:=^e_spec_ordinal;
  e_spec_tab[dt_unsigned  ]:=^e_spec_ordinal;
  e_spec_tab[dt_float     ]:=^e_spec_float;
  e_spec_tab[dt_fixed     ]:=^e_spec_fixed;
  e_spec_tab[dt_char      ]:=^e_spec_ordinal;
  e_spec_tab[dt_logical   ]:=^e_spec_ordinal;
  e_spec_tab[dt_enum      ]:=^e_spec_enum;
  e_spec_tab[dt_string    ]:=^e_spec_string;
  e_spec_tab[dt_ustring   ]:=^e_spec_string;
  e_spec_tab[dt_array     ]:=^e_spec_array;
  e_spec_tab[dt_uarray    ]:=^e_spec_array;
  e_spec_tab[dt_record    ]:=^e_spec_record;
  e_spec_tab[dt_set       ]:=^e_spec_set;
  e_spec_tab[dt_pointer   ]:=^e_spec_pointer;
  e_spec_tab[dt_tag       ]:=^e_spec_tag;
  e_spec_tab[dt_message   ]:=^e_spec_procedure;
  e_spec_tab[dt_procedure ]:=^e_spec_procedure;
  e_spec_tab[dt_task      ]:=^e_spec_procedure;
  end entry;



end cd_eval;
