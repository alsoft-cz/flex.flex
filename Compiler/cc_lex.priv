----------------------------------------------------------------------------------------------------
module private cc_lex =
-- P©eklada‡ Flexu.
-- Lexik ln¡ analyz tor.
----------------------------------------------------------------------------------------------------
-- Ondra : 25.04.2000 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_profile,
#end if;
  cc_var,
  cc_def.cc_codes;

var
  -- aktu ln¡ roz¨¡©en¡ lexik ln¡ anal˜zy
  behavior         : {%%TODO(TASK)} p_lex_behavior;

-- dop©edn‚ deklarace
class abstract c_lexer; type p_lexer = ^class c_lexer;

----------------------------------------------------------------------------------------------------
class public abstract c_lexer = 
-- Lexik ln¡ analyz tor - zdroj lexik ln¡ch element–.
----------------------------------------------------------------------------------------------------

    type
      -- unget buffer na jeden lexik ln¡ element
      lexungetbuffer = record
          valid    : t_logical;                  -- T-obsah bufferu je platn˜
          lex      : lexsym;                     -- lexik ln¡ element
          val      : lexval;                     -- hodnota elementu
          pos      : lexpos;                     -- pozice elementu
          end record;

    var
      -- buffer na posledn¡ lexik ln¡ element
      last         : lexungetbuffer;

      -- buffer na posledn¡ch nˆkolik pozic lexik ln¡ch element–
      last_pos     : array 0..2 of lexpos;       -- kruhov˜ buffer na pozice posledn¡ch t©¡ element–
      last_pos_curr: t_unsigned;                 -- index do kruhov‚ho bufferu

    ------------------------------------------------------------------------------------------------
    virtual discardable return t_logical; 
    -- True, je-li lexik ln¡ analyz tor na jedno pou‘it¡.
    ------------------------------------------------------------------------------------------------
    virtual top_level return t_logical;  
    -- True, je-li to top-level lexik ln¡ analyz tor, kter˜ nesm¡ b˜t odstranˆn bez toho, ‘e by se
    -- p©e¨lo k nad©azen‚mu souboru.
    ------------------------------------------------------------------------------------------------
    virtual abstract get_lex_element;
    -- Z¡sk  ze vstupu jeden lexik ln¡ prvek a napln¡ j¡m slo‘ku [last].
    -- Vr t¡-li lexik ln¡ analyz tor hodnotu [lex_nul], volaj¡c¡ zavol  [get_lex_element] znovu.
    -- Vr t¡-li lexik ln¡ analyz tor hodnotu [lex_eof] a existuje je¨tˆ nˆjak˜ dal¨¡ lexik ln¡
    -- analyz tor, zavol  volaj¡c¡ [lex_pop_lexer] a vol n¡ [get_lex_element] opakuje, jinak
    -- [lex_eof] odpov¡d  skute‡n‚ho konci souboru.
    ------------------------------------------------------------------------------------------------
    static unget_lex_element;
    -- Poslednˆ p©e‡ten˜ element vr t¡ zpˆt do vstupu - obsah unget buffer ozna‡¡ za platn˜.
    ------------------------------------------------------------------------------------------------
    static reget_lex_element;
    -- Simuluje vy‡ten¡ elementu z unget bufferu - obsah unget bufferu ozna‡¡ za neplatn˜.
    ------------------------------------------------------------------------------------------------
    static get_lex_pos (
        level      : in lexlevel;                -- kter˜ element zpˆt n s zaj¡m 
        pos        : out lexpos);                -- z¡skan  pozice
    -- Z¡sk  pozici lexik ln¡ho elementu.
    ------------------------------------------------------------------------------------------------
    virtual optimize_memory (
        val        : in lexval);                 -- hodnota symbolu
    -- Optimalizuje pamˆŸ vyu‘itou poslednˆ vr cen˜m lexik ln¡m elementem.
    ------------------------------------------------------------------------------------------------
    static store_last_position;
    -- Ulo‘i pozici posledn¡ho elementu do bufferu pozic.
    ------------------------------------------------------------------------------------------------

  supervised

    var
      next         : p_lexer;                    -- dal¨¡ lexik ln¡ analyz tor na stacku

    end c_lexer;

----------------------------------------------------------------------------------------------------
class private abstract c_lexer = 
-- Lexik ln¡ analyz tor - zdroj lexik ln¡ch element–.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    virtual discardable =
    -- True, je-li lexik ln¡ analyz tor na jedno pou‘it¡.
    ------------------------------------------------------------------------------------------------
    begin
      result:=true;
      end discardable;



    ------------------------------------------------------------------------------------------------
    virtual top_level =
    -- True, je-li to top-level lexik ln¡ analyz tor, kter˜ nesm¡ b˜t odstranˆn bez toho, ‘e by se
    -- p©e¨lo k nad©azen‚mu souboru.
    ------------------------------------------------------------------------------------------------
    begin
      result:=false;
      end top_level;



    ------------------------------------------------------------------------------------------------
    static unget_lex_element =
    -- Poslednˆ p©e‡ten˜ element vr t¡ zpˆt do vstupu - obsah unget buffer ozna‡¡ za platn˜.
    ------------------------------------------------------------------------------------------------
    begin
      -- ozna‡it obsah unget bufferu za platn˜
      last.valid:=true;

      -- posunout index v bufferu pozic zpˆt
      if last_pos_curr=last_pos:first
        then last_pos_curr:=last_pos:last;
        else pred last_pos_curr;
        end if;
      end unget_lex_element;



    ------------------------------------------------------------------------------------------------
    static reget_lex_element =
    -- Simuluje vy‡ten¡ elementu z unget bufferu - obsah unget bufferu ozna‡¡ za neplatn˜.
    ------------------------------------------------------------------------------------------------
    begin
      -- ozna‡it obsah unget bufferu za neplatn˜
      last.valid:=false;

      -- posunout index v bufferu pozic dop©edu
      last_pos_curr:=(last_pos_curr+1) mod last_pos:length;
      end reget_lex_element;



    ------------------------------------------------------------------------------------------------
    static get_lex_pos =
    -- Z¡sk  pozici lexik ln¡ho elementu.
    ------------------------------------------------------------------------------------------------
    var
      i            : t_unsigned;

    begin
      -- p©ipravit si index pozice
      i:=last_pos_curr;
      if level=ll_prev then
        if i=last_pos:first
          then i:=last_pos:last
          else pred i;
          end if;
        end if;

      -- je pozice k dispozici ?
      if last_pos[i].num<>0

        -- ano => p©edat ven
        then pos:=last_pos[i]

        -- ne => mus¡me se zkusit zeptat p©edka
        else
          -- mus¡ b˜t v¨ak nˆjak˜ p©edek k dispozici
          if next=nil then return end if;

          -- hled me-li p©edchoz¡ element a v tomto lexeru nen¡ k dispozici ani aktu ln¡,
          -- propagovat beze zmˆny n¡‘, jinak v‘dy redukovat na dotaz na aktu ln¡ element
          if level=ll_prev and last_pos[last_pos_curr].num=0
            then next^.get_lex_pos(ll_prev,pos);
            else next^.get_lex_pos(ll_curr,pos);
            end if;
          end if;
      end get_lex_pos;



    ------------------------------------------------------------------------------------------------
    virtual optimize_memory =
    -- Optimalizuje pamˆŸ vyu‘itou poslednˆ vr cen˜m lexik ln¡m elementem.
    ------------------------------------------------------------------------------------------------
    begin 
      -- implicitnˆ nic nedˆlat
      end optimize_memory;



    ------------------------------------------------------------------------------------------------
    static store_last_position =
    -- Ulo‘i pozici posledn¡ho elementu do bufferu pozic.
    ------------------------------------------------------------------------------------------------
    begin
      last_pos_curr:=(last_pos_curr+1) mod last_pos:length;
      last_pos[last_pos_curr]:=last.pos;
      end store_last_position;
  
    end c_lexer;

----------------------------------------------------------------------------------------------------
procedure lex_set_lexer (
    lexer          : in p_lexer);
-- Nastav¡ aktu ln¡ lexik ln¡ analyz tor na zadan˜ [lexer].
----------------------------------------------------------------------------------------------------
procedure lex_pop_lexer;
-- P©ejde od sou‡asn‚ho k p©edchoz¡mu lexik ln¡mu analyz toru.
----------------------------------------------------------------------------------------------------
procedure lex_get_lex_element (
    lex            : out lexsym{;                -- ziskan˜ lexik ln¡ element
    val            : out lexval;                 -- hodnota elementu
    pos            : out lexpos});               -- pozice elementu
-- Z¡sk  ze vstupu jeden lexik ln¡ prvek.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
#separate public cc_lex0;
-- Lexik ln¡ analyz tor, oddˆlen¡ lexik ln¡ch element–.
----------------------------------------------------------------------------------------------------
#separate public cc_pre;
-- Preprocesor. 
----------------------------------------------------------------------------------------------------



var
  -- aktu ln¡ lexik ln¡ analyz tor
  lexer            : {%%TODO(TASK)} p_lexer;

----------------------------------------------------------------------------------------------------
procedure getlex =
-- P©e‡te ze vstupu jeden lexik ln¡ element.
----------------------------------------------------------------------------------------------------
var
  xlex             : lexsym;                     -- ziskany elementu
--xval             : lexval;                     -- hodnota elementu
--xpos             : lexpos;                     -- pozice elementu
  xend             : t_logical;                  -- T-konec ‡ten¡ symbol–

begin
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_start;
  succ _getlex;
#end if;

  loop
    -- p©e‡¡st symbol ze vstupu
    lex_get_lex_element(xlex{,xval,xpos});

    -- je tento symbol zaj¡mav˜ pro preprocesor ?
    if xlex=lex_id or xlex=lex_meta_id {xlex in lexsymset:[lex_meta_id,lex_id]}

      -- ano => zavolat preprocesor
      then cc_pre.p_preprocessor(context,xlex,lexer^.last.val{xval},xend);

      -- ne => konec
      else xend:=true;
      end if;
    until xend;

  -- lexik ln¡ element p©edat ven
  lex:=xlex;

#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_stop(_getlex_t);
#end if;
  end getlex;



----------------------------------------------------------------------------------------------------
procedure ungetlex =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element vr t¡ zpˆt do vstupu.
-- Flex je LL(1), tak‘e se lze vr tit v‘dy jen o jeden symbol.
----------------------------------------------------------------------------------------------------
begin
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_start;
  succ _ungetlex;
#end if;

  lexer^.unget_lex_element;

#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_stop(_ungetlex_t);
#end if;
  end ungetlex;



----------------------------------------------------------------------------------------------------
procedure looklex =
-- P©e‡te ze vstupu jeden lexik ln¡ element, ale neodstran¡ ho ze vstupu (getlex+ungetlex).
----------------------------------------------------------------------------------------------------
begin
  getlex(context,lex);
  ungetlex;
  end looklex;



----------------------------------------------------------------------------------------------------
procedure checklex =
-- Pod¡v  se na n sleduj¡c¡ lexik ln¡ element, a pokud je shodn˜ se zadan˜m, tak vr t¡ True
-- a odstran¡ ho ze vstupu. V opa‡n‚m p©¡padˆ vr t¡ False a vstup nezmˆn¡.
----------------------------------------------------------------------------------------------------
var
  lex1             : lexsym;

begin
  getlex(context,lex1);
  result:=lex=lex1;
  if not result then
    ungetlex;
    end if;
  end checklex;



----------------------------------------------------------------------------------------------------
procedure ignorelex =
-- Je-li n sleduj¡c¡ symbol LEX, tak ho odignoruje, jinak ponech .
----------------------------------------------------------------------------------------------------
var
  lex1             : lexsym;

begin
  getlex(context,lex1);
  if lex<>lex1 then ungetlex; end if;
  end ignorelex;



----------------------------------------------------------------------------------------------------
procedure followlex =
-- P©e‡te ze vstupu lexik ln¡ element a zkontroluje ho proti zadan‚mu. Pokud se shoduj¡, vr t¡
-- False a element odstran¡ ze vstupu. V opa‡n‚m p©¡padˆ vr t¡ True a element a) ponech  ve
-- vstupu, b) odstran¡ ze vstupu, pokud je podobn˜ zadan‚mu.
----------------------------------------------------------------------------------------------------
var
  xlex             : lexsym;

begin
  -- p©e‡¡st symbol
  getlex(context,xlex);
  if lex=xlex

    -- stejn‚, nen¡ co ©e¨it
    then
      result:=false;
      return;

    -- rozd¡ln‚, ur‡itˆ chyba
    else
      result:=true;
      end if;

  -- nejsou podobn‚ ?
  for i in lexsimilar:range loop
    if (lexsimilar[i].l1=lex and lexsimilar[i].l2=xlex)
    or (lexsimilar[i].l1=xlex and lexsimilar[i].l2=lex)
    then return end if;
    end loop;

  {%%X je¨tˆ by to mohl b˜t identifik tor podobn˜ kl¡‡ov‚mu slovu }

  -- jsou rozd¡ln‚, odsimulovat
  ungetlex;
  end followlex;



----------------------------------------------------------------------------------------------------
procedure followendkw =
-- P©e‡te ze vstupu sekvenci "END <kl¡‡ov‚ slovo>".
-- Procedura se chov  obdobnˆ jako FOLLOWLEX.
----------------------------------------------------------------------------------------------------
var
  lex1             : lexsym;                     -- lexik ln¡ symboly
  lex2             : lexsym;                     -- lexik ln¡ symboly

begin
  -- p©e‡¡st prvn¡ symbol (END)
  getlex(context,lex1);
  if lex1 not in lexsymset:[lex_end,lex_id] then
    result:=true;
    ungetlex;
    return
    end if;

  -- p©e‡¡st druh˜ symbol (kl¡‡ov‚ slovo)
  getlex(context,lex2);

  -- END <kl¡‡ov‚ slovo>
  if lex1=lex_end and lex2=kw then
    result:=false

  -- END <st©edn¡k>
  -- <identifik tor> <st©edn¡k>
  elsif lex2=lex_scol then
    result:=true;
    ungetlex;

  -- END <identifik tor>
  -- <identifik tor> <kl¡‡ov‚ slovo>
  -- <identifik tor> <identifik tor>
  -- <jin˜ bl bol>
  else
    result:=true;
    end if;
  end followendkw;



----------------------------------------------------------------------------------------------------
procedure followendid =
-- P©e‡te ze vstupu sekvenci "END <identifik tor>".
-- Procedura se chov  obdobnˆ jako FOLLOWLEX.
----------------------------------------------------------------------------------------------------
var
  lex1             : lexsym;                     -- lexik ln¡ symboly
  lex2             : lexsym;                     -- lexik ln¡ symboly

begin
  -- p©e‡¡st prvn¡ symbol (END)
  getlex(context,lex1);
  if lex1 not in lexsymset:[lex_end,lex_id] then
    result:=true;
    ungetlex;
    return;
    end if;

  -- p©e‡¡st druh˜ symbol (kl¡‡ov‚ slovo)
  getlex(context,lex2);

  -- END <identifik tor>
  if (lex1=lex_end and lex2=lex_id) and then getlexid^=id then
    result:=false

  -- END <st©edn¡k> 
  -- <identifik tor> <st©edn¡k> 
  elsif lex2=lex_scol then
    result:=true;
    ungetlex;

  -- END <kl¡‡ov‚ slovo> 
  -- <identifik tor> <kl¡‡ov‚ slovo>
  -- <identifik tor> <identifik tor> 
  -- <jin˜ bl bol> 
  else
    result:=true;
    end if;
  end followendid;



----------------------------------------------------------------------------------------------------
procedure resumelex =
-- Vy‡¡t  symboly, dokud nenaraz¡ na hledan˜ symbol nebo na termin tor.       
----------------------------------------------------------------------------------------------------
begin
  loop
    -- dal¨¡ symbol 
    getlex(context,xlex);

    -- nalezen LEX 
    if xlex=lex then
      case rl
        when rl_skip  do -- nic
        when rl_leave do ungetlex;
        when others   do verify({VERIFY=}000188,true);
        end case;
      break;

    -- nalezen TERM 
    elsif xlex=term then
      case rt
        when rt_skip   do -- nic
        when rt_leave  do ungetlex;
        when rt_resume do ungetlex; ce^.resumeerror;
        when rt_fail   do ce^.raiseerror;
        when others    do verify({VERIFY=}000189,true);
        end case;
      break;

    -- konec textu 
    elsif xlex=lex_eof then 
      ce^.raiseerror;
      end if;
    end loop;
  end resumelex;



----------------------------------------------------------------------------------------------------
procedure getlexpos =
-- Vr t¡ pozici lexik ln¡ho prvku.
----------------------------------------------------------------------------------------------------
begin
  lexer^.get_lex_pos(level,pos);
  if after then
    pos.col+pos.len;
    pos.len:=0;
    end if;
  end getlexpos;



----------------------------------------------------------------------------------------------------
procedure getlexposall =
-- Vr t¡ pozici lexik ln¡ho prvku (za‡ tek i konec).
----------------------------------------------------------------------------------------------------
begin
  getlexpos(pos.b,level,false);
  getlexpos(pos.e,level,true);
  end getlexposall;



----------------------------------------------------------------------------------------------------
procedure cmplexposb =
-- True <=> POS1 < POS2
----------------------------------------------------------------------------------------------------
begin
  result:=pos1.num=pos2.num and (pos1.line<pos2.line or (pos1.line=pos2.line and pos1.col<pos2.col));
  end cmplexposb;



----------------------------------------------------------------------------------------------------
procedure cmplexposa =
-- True <=> POS1 > POS2
----------------------------------------------------------------------------------------------------
begin
  result:=pos1.num=pos2.num and (pos1.line>pos2.line or (pos1.line=pos2.line and pos1.col>pos2.col));
  end cmplexposa;



----------------------------------------------------------------------------------------------------
procedure getlexid =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: identifik tor.
----------------------------------------------------------------------------------------------------
begin
  result:=lexer^.last.val.id;
  lexer^.last.val.id_used:=true;
  end getlexid;



----------------------------------------------------------------------------------------------------
procedure getlextxt =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: textov˜ tvar lexik ln¡ho elementu ze vstupu.
----------------------------------------------------------------------------------------------------
begin
  result:=lexer^.last.val.txt;
  lexer^.last.val.txt_used:=true;
  end getlextxt;



----------------------------------------------------------------------------------------------------
procedure getlexui =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: hodnota celo‡¡seln‚ho liter lu.
----------------------------------------------------------------------------------------------------
begin
  --%%X Doplnit form ln¡ kontrolu
  result:=lexer^.last.val.ui;
  end getlexui;



----------------------------------------------------------------------------------------------------
procedure getlexur =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: hodnota re ln‚ho liter lu.
----------------------------------------------------------------------------------------------------
begin
  --%%X Doplnit form ln¡ kontrolu
  result:=lexer^.last.val.ur;
  end getlexur;



----------------------------------------------------------------------------------------------------
procedure getlexstring =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: hodnota znakov‚ho agreg tu.
----------------------------------------------------------------------------------------------------
begin
  --%%X Doplnit form ln¡ kontrolu
  result:=lexer^.last.val.str;
  end getlexstring;



----------------------------------------------------------------------------------------------------
procedure getlexcode =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: hodnota dopl¤kov‚ho k¢du.
----------------------------------------------------------------------------------------------------
begin
  --%%X Doplnit form ln¡ kontrolu
  result:=lexer^.last.val.code;
  end getlexcode;



----------------------------------------------------------------------------------------------------
procedure getlexval =
-- Poslednˆ p©e‡ten˜ lexik ln¡ element: cel  hodnota.
----------------------------------------------------------------------------------------------------
begin
  val:=lexer^.last.val;
  end getlexval;



----------------------------------------------------------------------------------------------------
procedure setlex =
-- Zmˆn¡ poslednˆ p©e‡ten˜ lexik ln¡ element.
----------------------------------------------------------------------------------------------------
begin
  lexer^.last.lex:=lex;
  end setlex;



----------------------------------------------------------------------------------------------------
procedure setlexid =
-- Zmˆn¡ identifik tor souvisej¡c¡ s poslednˆ p©e‡ten˜m lexik ln¡m elementem.
----------------------------------------------------------------------------------------------------
begin
  lexer^.last.val.id:=id;
  lexer^.last.val.id_used:=true;
  end setlexid;



----------------------------------------------------------------------------------------------------
procedure setlexval =
-- Zmˆn¡ hodnotu poslednˆ p©e‡ten‚ho lexik ln¡ho symbolu.
----------------------------------------------------------------------------------------------------
begin
  lexer^.last.val:=val;
  lexer^.last.val.id_used:=true;
  lexer^.last.val.txt_used:=true;
  end setlexval;



----------------------------------------------------------------------------------------------------
procedure lex_set_lexer =
-- Nastav¡ aktu ln¡ lexik ln¡ analyz tor na zadan˜ [lexer].
----------------------------------------------------------------------------------------------------
use
  supervised c_lexer;

begin
  -- za©adit do seznamu
  lexer^.next:=current module.lexer;
  current module.lexer:=lexer;
  end lex_set_lexer;



----------------------------------------------------------------------------------------------------
procedure lex_pop_lexer =
-- P©ejde od sou‡asn‚ho k p©edchoz¡mu lexik ln¡mu analyz toru.
----------------------------------------------------------------------------------------------------
use
  supervised c_lexer;

var
  x                : p_lexer;

begin
  -- zamapatovat si aktu ln¡ lexer
  x:=lexer;

  -- p©ej¡t k p©edchoz¡mu
  lexer:=lexer^.next;
  verify({VERIFY=}000637,lexer=nil);

  -- dosavadn¡ zru¨it
  if x^.discardable then 
    discard x;
    end if;
  end lex_pop_lexer;



----------------------------------------------------------------------------------------------------
procedure lex_get_lex_element =
-- Z¡sk  ze vstupu jeden lexik ln¡ prvek.
----------------------------------------------------------------------------------------------------
use
  supervised cc_base.cc_text;

begin
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_start;
  succ _lex_get_lex_element;
#end if;

  loop
    -- p©e‡¡st element
    if lexer^.last.valid

      -- pou‘¡t element z bufferu
      then
        lexer^.reget_lex_element;

      -- na‡¡st ‡erstv˜ element
      else
        lexer^.get_lex_element;
        end if;

    case lexer^.last.lex
      -- identifik tor
      when lex_id do
          -- zkusit vyhledat v tabulce kl¡‡ov˜ch slov
          if behavior<>nil then
            behavior^.search_keyword(lexer^.last.val.id^,lexer^.last.lex,lexer^.last.val);
            end if;
          break;

      -- konec © dku
      when lex_eoln do
          -- hl sit jen je-li to po‘adov no
          if behavior<>nil and then behavior^.report_eol then
            break;
            end if;

      -- je-li to [lex_nul], pak opakujeme
      when lex_nul do -- nic nedˆlat

      -- konec toku element– 
      when lex_eof do
          -- m me v z sobˆ je¨tˆ dal¨¡ analyz tor ? => p©ej¡t k nˆmu
          if not lexer^.top_level then lex_pop_lexer;

          -- byl soubor includovan˜ ? => p©ej¡t k nad©azen‚mu
          elsif cc_base.cc_text.lex_input^.is_include then 
            cc_base.cc_text.text_close;

          -- jinak p©edat konec souboru ven
          else 
            break;
            end if;

      -- je to nˆjak˜ konkr‚tn¡ element ? => vr tit ho
      when others do break;
      end case;
    end loop;

  -- pozici z¡skan‚ho elementu p©esunout do bufferu pozic
  lexer^.store_last_position;

  -- z¡skan˜ element p©edat ven
  lex:=lexer^.last.lex;
{
  val:=lexer^.last.val;
  pos:=lexer^.last.pos;
}
#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_stop(_lex_get_lex_element_t);
#end if;
  end lex_get_lex_element;



----------------------------------------------------------------------------------------------------
procedure lex_set_default_lexer =
-- Rezerva do budoucna: nastav¡ implicitn¡ lexik ln¡ analyz tor. Zat¡m pouze alokuje standardn¡
-- lexik ln¡ analyz tor.
----------------------------------------------------------------------------------------------------
var
  x                : ^cc_lex0;

begin
  -- vytvo©it implicitn¡ lexik ln¡ analyz tor
  new x;

  -- za©adit do zpracov n¡
  lex_set_lexer(x);
  end lex_set_default_lexer;



----------------------------------------------------------------------------------------------------
procedure lex_pop_default_lexer =
-- Zru¨¡ implicitn¡ lexik ln¡ analyz tor.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000775,lexer=nil or else not lexer^.top_level);
  lex_pop_lexer;
  end lex_pop_default_lexer;



----------------------------------------------------------------------------------------------------
class private abstract c_lex_behavior = 
-- Policy t©¡da implementuj¡c¡ modifikaci chov n¡ lexik ln¡ho analyz toru.
----------------------------------------------------------------------------------------------------

    var
      -- p–vodn¡ nastaven  modifikace chov n¡
      saved_behavior : p_lex_behavior;



    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      -- za©adit se na stack modifikac¡ chov n¡
      saved_behavior:=behavior;
      behavior:=^this;
      end entry;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalizace.
    ------------------------------------------------------------------------------------------------
    begin
      -- vy©adit se ze stacku modifikac¡ chov n¡
      behavior:=saved_behavior;
      end exit;

    end c_lex_behavior;



----------------------------------------------------------------------------------------------------
class private c_lex_behavior_flex =
-- Modifikace chov n¡ lexik ln¡ho analyz toru: Flex - nehl s¡ konce © dk–, p©ekl d  kl¡‡ov  slova.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override search_keyword =
    -- Vyhled n¡ kl¡‡ov‚ho slova podle jeho textov‚ reprezentace.
    ------------------------------------------------------------------------------------------------
    with
      standard.characters,
      standard.characters.ascii;

    var
      zac            : lexkeywords:range;
      stred_unsigned : t_unsigned;
      stred          : lexkeywords:range;
      kon            : lexkeywords:range;
      first_c        : tidentchar;

    begin
      -- kl¡‡ov  slova neobsahuj¡ znaky _ a 0..9
      if not val.can_be_kw then 
        return;
        end if;

      -- %%TODO(OVERLOAD) - zmenit ascii_char_to_upper na char_to_upper
      -- zkusit naj¡t kl¡‡ov‚ slovo
      first_c:=ascii_char_to_upper(txt[1]);
      
      if first_c:ord<lexkeywords_index:first or first_c:ord>lexkeywords_index:last then return; end if;

      zac:=lexkeywords_index[first_c:ord].first;
      if zac<>nil {and then txt:length<=lexkeywords_index[first_c:ord].max_length} then
        kon:=lexkeywords_index[first_c:ord].last;
        loop
          stred_unsigned:=(zac+kon) div 2;
          stred:=stred_unsigned;
          if txt>lexkeywords[stred].txt
            then zac:=stred+1
            else kon:=stred
            end if;
          until zac>=kon;
        if txt=lexkeywords[zac].txt
          -- nalezeno
          then lex:=lexkeywords[zac].lex
          -- nenalezeno
          -- else lex:=lex_nul
          end if;
        end if;
      end search_keyword;

    end c_lex_behavior_flex;



----------------------------------------------------------------------------------------------------
class private c_lex_behavior_plain =
-- Modifikace chov n¡ lexik ln¡ho analyz toru: Nic - nehl s¡ konce © dk–, nep©ekl d  kl¡‡ov  slova.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override search_keyword =
    -- Vyhled n¡ kl¡‡ov‚ho slova podle jeho textov‚ reprezentace.
    ------------------------------------------------------------------------------------------------
    begin
      -- nic nedˆlat
      end search_keyword;

    

    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializace
    ------------------------------------------------------------------------------------------------
    begin
      -- povolit hl ¨en¡ konc– © dk–
      report_eol:=true;
      end entry;
    
    end c_lex_behavior_plain;



----------------------------------------------------------------------------------------------------
#separate private cc_lex0;
-- Lexik ln¡ analyz tor, oddˆlen¡ lexik ln¡ch element–.
----------------------------------------------------------------------------------------------------
#separate private cc_pre;
-- Preprocesor. 
----------------------------------------------------------------------------------------------------
          
var
  -- %%TECH instanciovat implicitn¡ modifikaci chov n¡ lexik ln¡ho analyz toru
  default_behavior : c_lex_behavior_flex;

end cc_lex;
