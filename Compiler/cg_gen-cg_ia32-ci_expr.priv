----------------------------------------------------------------------------------------------------
module private ci_expr =
-- Překladač Flexu.
-- Generování výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvořil.
----------------------------------------------------------------------------------------------------
{

-- Dodělat přejmenování AH-AL, BH-BL, ..., aby se nemuselo v LOADREG
   dělat MOV AL,AH

-- Kam patří konverze ? Má je tam přidávat typová kontrola (resp. nějaká
   jiná fáze překladu výrazu), nebo si je má domýšlet až generátor kódu ?

   ad 1) To je asi výhodnější, konverze aritmetických výrazů jsou triviální
         a u manipulací s řetězci/poli/recordy potřebuju vědět na čem jsem,
         abych dokázal zvolit speciální variantu překladu.

   ad 2) V druhém případě by to mělo asi být součástí LOADREG.


-- Optimalizace:
     * zarovnání
     * změna pořadí instrukcí
     * (částečné) rozvíjení cyklů
     * řídící proměnné cyklů do registrů
     * často používané podvýrazy do registrů
     * registry se známou konstantní hodnotou (zpravidla 0 nebo 1)
     * v EDX zbyde při násobení dostatečně malých čísel nula

     * násobení 3 a 5 a 9 pomocí LEA
     * násobení kombinací ADD/SHL/LEA: například 12*EAX: SHL EAX,2 LEA EAX,[EAX+2*EAX]
     * rozpoznání indexu tvaru X*scale, kde scale=2,4,8
     * "if x>0 then x:=-1 else x:=0" --> "cmp eax,1; sbb eax,eax"
     * registr EBP vůbec nepotřebuju k adresaci lokálních proměnných - stačí
       mi na to ESP, vždyť v každém okamžiku vím, co je na stacku
     * málo pravděpodobný kód lze s výhodou umístit do úplně jiné oblasti
       code segmentu:

           read(...,chyba);
           if chyba then
             write('chyba');
             return;
             end if;
           ...
           end proc;

       přeložit jako:

           read(...,chyba);
           if chyba then goto x end if  -- zde se eliminuje jeden skok
           ...
         r:
           end proc;

         x:write('chyba');
           goto r;
     * místo "mov exc,[x]; push eax" dělat jen "push [x]"
     * ve výrazu (s1 & s2)[i] fyzicky nespojovat řetězce ale inteligentně
       přepočítat index
     * příkaz typu:
          loop
            if invariant_vzhledek k cyklu
              then ...
              else ...
              end if
            end loop
       přeložit jako dva cykly s vyhodnocením IFu vně.
     * pro rozsáhlé konstantní množiny generovat membership-test funkce
       (podobně by se daly řešit i další operace na velkými konstantními
       agregáty)

-- Specifické optimalizace pro procesory AMD:
     * místo SHL EAX,1 generovat ADD EAX,EAX - třeba procesor AMD K6 má
       dvě sčítačky a jen jednu shiftovačku - nicméně se tím nastaví
       jiné flagy (AF)
     * na procesoru AMD K6 místo XOR EAX,EAX dělat MOV EAX,0
     * MUL a IMUL nahrazovat za SHL ADD jen do celkové latence 3, pak
       je na AMD rychlejší dělat MUL
     * místo CDQ dělat MOV EDX,EAX SAR EDX,31 - je to rychlejší na dekódování
       (řekl bych, že pro CBW se to nevyplatí, protože MOV AH,AL bude zmatený
       z použití dvou čtvrtek téhož registru - ale je to jen doměnka)
     * místo dělení násobit převrácenou hodnotou - viz 21924.PDF str. 75 (65)

-- Odstranit %%OLD

-- Obsluha agregátů je dost natvrdo (=neoptimálně), protože je to poměrně
   komplikovaná záležitost a babrat se s tím budu až ve 4.0.1.

-- Dodělat:
    +I027 - někde to generuje chybné instrukce
    -I099 - inkluze množiny (< <= > >=)
    +I344 - v proceduře i_gen_load_string_and_last se zdá, že výraz nemá
            dynamické atributy :size ani :last
    -I349 - uvolnění nepoužitého univerzálního registru
     I388 - pokus o zjištění tagu non-tagged typu
    -U115 - konkatenace unconstrained stringů jejímž výsledkem je opět
            unconstrained string
     U122 - volání virtuální metody
    +U132 - množinové + - a * na operandech o nepříznivé velikosti
    +U154 - agregát množiny
    +U170 - porovnání binárního bloku na NIL
    -U173 - nějaký výpočet :last pro "pchararray:=pchar:unchecked;"

     I027 - někde to generuje chybné instrukce
     I093
     I107
     I148 - volání metody předka
     U118
     U140
}
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_base,
  cc_base.cc_type,
  cc_base.cc_util,
  cc_base.cc_rtl,
  cc_base.cc_debug,
  cc_attr,
  cx_expr,
  cx_expr.cx_util,
  cx_expr.cx_imm,
  ci_code,
  ci_code.ci_operand,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_context,
  ci_reg,
  ci_fragment,
  ci_struct,
  cp_cpu.cp_32.cp_metadata,
  cp_cpu.cp_32.cp_util,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_ia32.ci_instr,
  cc_options;

----- %%TECH Režimy generování výrazu --------------------------------------------------------------
-- Generátor výrazů dokáže pracovat v několika režimech, resp. předávat výsledek výpočtu výrazu 
-- v několika různých tvarech.
--   Procedury pro generování různých druhů uzlů ([i_gen_*]) pracují v určitém základním režimu, 
-- který standardně generuje výsledek ve svým způsobem přirozeně minimálním tvaru - součet dvou 
-- celočíselných výrazů vrátí v registru, agregát pole v dočasné proměnné, proměnnou coby 
-- specifikaci její adresy a podobně.
--
-- Procedura [i_load] navíc dovoluje výsledek převést do požadovaného tvaru nebo s ním provést 
-- požadovanou operaci (například uložit na stack).
--   Požadovaný tvar výsledku je specifikován kontextem generování výrazu, zejména proměnnou 
-- [context.mode]. Rozlišují se módy načtení výrazu vedoucí na hodnotu objektu a módy vedoucí na
-- adresu hodnoty objektu. Speciálním případem je mód [lm_gen], který předává výsledek v přirozeném
-- tvaru bez úprav.
--
-- Módy vedoucí na hodnotu objektu:
--
--   [lm_conv]       -- výsledek v přirozeném tvaru je konvertován na požadovaný typ
--   [lm_reg]        -- výsledek je načten do registru (mimo přímých hodnot)
--   [lm_reg_all]    -- výsledek je načten do registru i když je to přímá hodnota
--   [lm_imm8_cl]    -- výsledek je konvertován na osmibitovou přímou hodnotu nebo uložen do CL
--                      (s oříznutím)
--   [lm_reg_eax]    -- výsledek je uložen do EAX
--   [lm_push_value] -- hodnota výrazu je uložena na stack
--   [lm_temp_value] -- hodnotu výrazu je uložena do temporary proměnné, kromě přímé hodnoty, 
--                      která je ponechána v původním stavu
--   [lm_pointer]    -- hodnota výrazu typu pointer je normalizována podle dodaného typu pointer
--                      (=přidá/odstraní/konvertuje dynamické atributy); je vrácen buď původní 
--                      operand nebo adresa temporary proměnné se zkonstruovaným pointerem
--   [lm_pointer_reg]-- jako předchozí, ale lze-li to, tak je pointer vrácen v registru
--
--   Před aplikací hodnotového módu načtení je volána metoda [i_ensure_value], která zajistí, že
--   operand skutečně reprezentuje hodnotu.
-- 
-- Módy vedoucí na adresu hodnoty objektu:
--
--   [lm_addr]       -- adresa objektu určeného podvýrazem; pokud je nastaven preferovaný registr 
--                      (v módu [irm_addr]), načte adresu do něj
--   [lm_addr_attr]  -- adresa objektu obsahujícího dynamické atributy (pokud je podvýraz parametr 
--                      předávaný hodnotou (proměnná s implicitní dereferencí), je výsledkem adresa
--                      pointeru na tento objekt; podrobněji viz dále)
--   [lm_imm_to_rel] -- je-li výsledkem přímá hodnota, je interpretována jako relativní adresa
--   [lm_push_addr]  -- adresa hodnoty výrazu je uložena na stack
--   [lm_push_and_load_addr] -- adresa hodnoty výrazu je uložena na stack a současně vrácena jako 
--                      výsledek výpočtu výrazu
--   [lm_temp_addr]  -- adresa objektu je uložena do temporary proměnné
--
--   Před aplikací adresního módu načtení je volána metoda [i_ensure_address], která zajistí, že
--   operand skutečně reprezentuje hodnotu. Pokud reprezentuje hodnotu bez adresy (například
--   mezivýsledek uložený v registru, přímá hodnota a podobně), uloží ji do pracovní proměnné
--   a vrátí adresu této pracovní proměnné.
--
-- Při generování musí být zvláštní pozornost věnována dynamickým atributům.
-- Požadované dynamické atributy jsou uloženy v proměnné CONTEXT.RTA a jsou
-- přípustné pouze v režimech LM_ADDR_ATTR a LM_PUSH_ADDR.
--   Obsluha dynamických atributů vyžaduje přímo úpravy v procedurách
-- I_GEN_*, nelze ji zahrnout pouze do I_LOAD. Naštěstí je vyžadována jen
-- u konkrétních typů podvýraz. Obecně lze dynamické atributy vyžadovat
-- u těchto typů výrazů:
--   - proměnná libovolného typu  -- pokud je to parametr s dynamickými
--                                   atributy, převezmou se; ostatní atributy
--                                   se určí staticky
--   - dereferencovaný pointer    -- některé atributy jsou součástí pointeru,
--                                   ostatní se určí staticky
--   - výraz kompozitního typu, konkrétně:
--     - zřetězení polí/řetězců   -- :last a :size se vypočítají během
--                                   zřetězování, :tag je určen staticky
--     - množinové operace + - *  -- smysl má pouze atribut :tag a ten je
--                                   určen staticky
--     - agregát                  -- :last a :size se vypočítají při
--                                   konstrukci agregátu, nebo jsou určeny
--                                   staticky
----------------------------------------------------------------------------------------------------

----- %%TECH Generování zkrácených přiřazení -------------------------------------------------------
-- Podle definice jazyka se krácené přiřazení tvaru "A1 op ... op An" chová
-- stejně jako přiřazení tvaru "A1 := A1 op ... op An". Z toho vyplývají
-- omezení pro generátor kódu - když je například op=+, nelze k A1 přičítat
-- hodnoty ostatních operandů, ale musí se hodnota A1 zkopírovat do registru.
--   Podobně třeba při spojování řetězců se musí dát pozor na případ "s & s".
-- Lze sice postupně připojovat operandy vpravo k operandu vlevo, ale nesmí
-- se při tom změnit hodnota :length levého operandu.
----------------------------------------------------------------------------------------------------


var
  op2cc            : const array op_eq..op_ge,t_logical of icond := [
      -- operátor --- UNSIGNED -- SIGNED --
      for op_eq  use [ic_e,       ic_e      ],
      for op_ne  use [ic_ne,      ic_ne     ],
      for op_lt  use [ic_b,       ic_l      ],
      for op_le  use [ic_be,      ic_le     ],
      for op_gt  use [ic_a,       ic_g      ],
      for op_ge  use [ic_ae,      ic_ge     ]];


----------------------------------------------------------------------------------------------------
procedure i_gen (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpnode;                -- strom
    vysl           : out c_operand);             -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------



type
  -- generovací metoda
  topergen         = procedure (
      inst         : in out icodeinst;           -- instance
      info         : in out igeninfo;            -- informace o průběhu generování
      context      : in out iexprcontext;        -- kontext generování výrazu
      expr         : in pexpoper;                -- strom
      vysl         : out c_operand);             -- výsledek
  popergen         = ^topergen;

  -- řídící tabulka generování binárních operátorů
  topertab         = array expopertype,tdatatype of popergen;

var
  opertab          : topertab;



----------------------------------------------------------------------------------------------------
procedure oset11 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end oset11;



----------------------------------------------------------------------------------------------------
procedure oset1s (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=method;
      end if;
    end loop;
  end oset1s;



----------------------------------------------------------------------------------------------------
procedure osets1 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      tab[i,stype]:=method;
      end if;
    end loop;
  end osets1;



----------------------------------------------------------------------------------------------------
procedure osetss (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end osetss;



----------------------------------------------------------------------------------------------------
#separate public ci_rcheck;
#separate private ci_rcheck;
-- behove kontroly
----------------------------------------------------------------------------------------------------
#separate public ci_rta;
#separate private ci_rta;
-- Manipulace s run-time atributy.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_load (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    subcontext     : in out iexprcontext;        -- kontext podvýrazu
    supercontext   : in out iexprcontext;        -- kontext výrazu
    sub            : in pexpnode;                -- generovaný podvýraz
    vysl           : out c_operand) =            -- výsledek
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.begin: ' & sub^.dump);
    end if;
#end if;

  -- nastavit preferenci registrů
  case subcontext.mode
    -- do ECX/CX/CL
    when lm_imm8_cl     do i_setrpref(subcontext,in_ecx,irm_int);

    -- do EAX/AX/AL
    when lm_reg_eax     do i_setrpref(subcontext,in_eax,irm_int);

    -- v ostatních případech preference není (resp. podle původního kontextu)
    end case;

  -- vygenerovat podvýraz
  i_gen(inst,info,subcontext,sub,vysl);

  -- má se načíst hodnota
  if subcontext.mode in lms_value then
    -- zajistit, že se jedná opravdu o hodnotu
    i_ensure_value(inst,info,subcontext,vysl);

  -- má se načíst adresa
  elsif subcontext.mode in lms_addr then
    -- zajistit, že se jedná opravdu o adresu hodnoty
    i_ensure_address(inst,info,subcontext,vysl);

  -- nějaký neznámý režim načtení výrazu
  elsif subcontext.mode<>lm_gen then
    verify({VERIFY=}000877,true);
    end if;

  -- provest behove kontroly dokud je vysledek cerstvy
  {%%X při lms_addr nemají runtime kontroly smysl, ne ? }
  ci_rcheck.i_gen_runtime_checks(inst,info,subcontext,rchcl_load,sub^,vysl);

  -- načíst hodnotu
  case subcontext.mode
    -- pouze generovat
    when lm_gen         do -- nic nedělat

    -- načíst adresu
    when lm_addr        do
        -- zajistit, že se jedná opravdu o adresu hodnoty
        -- i_ensure_address(inst,info,subcontext,vysl);

        -- načíst adresu
        if subcontext.rpref.reg<>in_none and subcontext.rpref.mode=irm_addr
          then i_gen_lea(inst,info,subcontext,vysl,subcontext.rpref.reg);
          else i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;

    -- adresa objektu s dynamickými atributy
    when lm_addr_attr   do
        -- zajistit, že se jedná opravdu o adresu hodnoty
        -- i_ensure_address(inst,info,subcontext,vysl);

    -- konvertovat na typ výsledku
    when lm_conv        do
        -- zajistit, že se jedná opravdu o hodnotu
        -- i_ensure_value(inst,info,subcontext,vysl);
        
        -- liší-li se od velikosti podvýrazu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak změnit velikost konstanty
            then vysl.adjust_size(subcontext.rsize)
            -- ... jinak načíst do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,(vysl.optype=io_cc) and (subcontext.outpref<>iop_cc){false},irm_int);
            end if;
          end if;

    -- konvertovat a načíst do registru
    when lm_reg         do 
        -- zajistit, že se jedná opravdu o hodnotu
        -- i_ensure_value(inst,info,subcontext,vysl);
        
        -- načíst
        i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,false,irm_int);

    -- konvertovat a načíst do registru (i přímou hodnotu)
    when lm_reg_all     do 
        -- zajistit, že se jedná opravdu o hodnotu
        -- i_ensure_value(inst,info,subcontext,vysl);
        
        -- načíst
        i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,true,irm_int);

    -- konvertovat a načíst do CL nebo ponechat const.
    when lm_imm8_cl     do 
        -- zajistit, že se jedná opravdu o hodnotu
        -- i_ensure_value(inst,info,subcontext,vysl);
        
        -- načíst
        i_gen_loadimm8cl(inst,info,subcontext,vysl);

    -- konvertovat a načíst do EAX
    when lm_reg_eax     do 
        -- zajistit, že se jedná opravdu o hodnotu
        -- i_ensure_value(inst,info,subcontext,vysl);
        
        -- načíst
        i_gen_loadeax(inst,info,subcontext,vysl);

    -- konvertovat přímou hodnotu na relativní adresu            
    when lm_imm_to_rel  do                                       --<<<<<<<< ??????
        if vysl.optype=io_imm then
          verify({VERIFY=}000861,vysl.edtype<>edt_address);
          vysl.transform_imm_to_rel;
          end if;

--vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

    -- načíst hodnotu a uložit na stack
    when lm_push_value  do
        -- načíst a normalizovat pointer
        if subcontext.outtyp.stype=dt_pointer then
          i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);
          end if;

        -- uložit na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

    -- načíst adresu a uložit na stack, popřípadě vrátit kopii v registru
    when lm_push_addr, lm_push_and_load_addr do
        -- Ondra 15.5.2002 : Pro dereferenci se načtení adresy mění na načtení hodnoty pointeru,
        -- protože v takovém případě dereference nic nedereferencuje, ale maximálně transformuje
        -- dereferencovaný pointer na výsledný pointer.
        if sub^.ntype<>nt_deref then
          -- načíst adresu
          i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;

        -- uložit na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

        -- pokud není výsledek žádán, tak se ho zbavit
        if subcontext.mode<>lm_push_and_load_addr then
          -- žádný výsledek se vracet nebude
          vysl.free(info,subcontext);
          end if;

    -- uložit hodnotu do temporary proměnné, nebo nechat imm
    when lm_temp_value  do
        -- liší-li se od velikosti podvýrazu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak změnit velikost konstanty
            then vysl.adjust_size(subcontext.rsize)
            -- ... jinak načíst do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,false,irm_int);
            end if;
          end if;

        -- načíst do temporary proměnné
        i_gen_loadtemp(inst,info,subcontext,vysl);

    -- uložit adresu do temporary proměnné
--  when lm_temp_addr   do unimplemented({UNIMP=}000238);

    -- načíst a normalizovat pointer
    when lm_pointer     do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);

    -- načíst a normalizovat pointer, preferovaně uložit do registru
    when lm_pointer_reg do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,true,vysl);

    -- adresa slotu táskové proměnné
    when lm_task_var_slot do -- nic nedelat
    
    when others do verify({VERIFY=}000415,true);
    end case;

  -- převést operand z kontextu podvýrazu do kontextu výrazu
  -- %%X tahle konstrukce se se mi teda vůbec nelíbí, ale zatím jsem to tak
  -- nechal, později odstranit. Dělalo to problém při I_LOAD_EXPR.
  if ^subcontext<>^supercontext then
    --i_retrieve_context(inst,info,subcontext,supercontext,vysl);
    vysl.retrieve(inst,info,subcontext,supercontext);
    end if;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.end');
    end if;
#end if;
  end i_load;



----------------------------------------------------------------------------------------------------
procedure i_load_binary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    outpref        : in ioutputpref;             -- pref. způsob předání pravého op.
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- požadovaný typ podvýrazů
    el             : in pexpnode;                -- podvýrazy
    er             : in pexpnode;                -- podvýrazy
    op1            : out c_operand;              -- výsledek
    op2            : out c_operand) =            -- výsledek
-- Vygeneruje a načte hodnotu dvojice podvýrazů.
-- (svázaných binárním operátorem)
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000134,expr^.arity<>eoa_2);

  if expr^.assign
    -- přiřazení    : opačné pořadí operandů
    -- %%X Chybně, musí se vyhodnocovat zleva --> doprava; nebo ne ?
    -- Asi ne: v AARM je to zdůvodněný: X^:=F(...) a pokud F uvolní
    -- X, tak to musí způsobit chybu (NIL^)
    then
      -- vygenerovat a načíst pravý podvýraz
      i_newcontext(context,newcontext,lm_reg,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg,typ}{expr^.t.getctype},er,op2);

      -- vygenerovat levý podvýraz
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,typ}{expr^.t.getctype},el,op1);

    -- normální pořadí operandů
    -- %%X Rozlišit různé případy
    -- I když, výrazy typu IMM+VAR by na VAR+IMM měl přehazovat optimalizátor
    else
      -- vygenerovat a načíst levý podvýraz
      i_newcontext(context,newcontext,lm_reg_all,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg_all,typ}{expr^.t.getctype},el,op1);

      -- vygenerovat pravý podvýraz
      i_newcontext(context,newcontext,lm_conv,typ{expr^.t.getctype});
      i_setoutpref(context,outpref);
      i_load(inst,info,newcontext,context{lm_conv,typ}{expr^.t.getctype},er,op2);
      end if;

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);
  end i_load_binary;



----------------------------------------------------------------------------------------------------
procedure i_load_binary_pointer (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- požadovaný typ podvýrazů
    el             : in pexpnode;                -- podvýrazy
    er             : in pexpnode;                -- podvýrazy
    op1            : out c_operand;              -- výsledek
    op2            : out c_operand) =            -- výsledek
-- Vygeneruje a načte hodnotu dvojice podvýrazů (svázaných binárním
-- operátorem) typu pointer. Pointery normalizuje podle dodaného typu
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000801,expr^.arity<>eoa_2);
  verify({VERIFY=}000484,typ^.stype<>dt_pointer);

  if expr^.assign

    -- přiřazení    : opačné pořadí operandů
    then
      -- vygenerovat a načíst pravý podvýraz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,er,op2);

      -- vygenerovat levý podvýraz
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,el,op1);

    -- normální pořadí operandů
    else
      -- vygenerovat a načíst levý podvýraz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,el,op1);

      -- vygenerovat pravý podvýraz
      i_newcontext(context,newcontext,lm_pointer,typ);
      i_load(inst,info,newcontext,context,er,op2);
      end if;

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);
  end i_load_binary_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_ordinal : topergen =
-- Porovnávání diskrétních výrazů.
-- Tato procedura se používá i pro porovnání (pouze = <>) obecných birnátní
-- bloků příznivé velikosti (1,2,4; viz I_GEN_OP_COMPARE_BINARY).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  cc               : icond;                      -- kód podmínky
  rest             : typeview;                   -- společný typ operandů

begin
  verify({VERIFY=}000139,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,true,rest);

  -- vygenerovat a načíst operandy
  i_load_binary(inst,info,context,iop_none,expr,rest.getutype,el,er,op1,op2);

  -- porovnat
  addii(inst,info,ii_cmp,op1,op2,op0);

  -- podmínka
  cc:=op2cc[expr^.oper,rest.stype=dt_signed{(el^.t.stype=dt_signed) or (er^.t.stype=dt_signed)}];

  -- zkrácené přiřazení ?
  if expr^.assign then addset(inst,info,context,cc,op1); end if;

  -- výsledek
  vysl.create_condition(cc);

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_op_compare_ordinal;



----------------------------------------------------------------------------------------------------
procedure i_gen_task_var_slot (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexptaskvarslot;         -- strom
    vysl           : out c_operand) =            -- výsledek
-- Selektor slotu táskové proměnné,
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- vygenerovat a načíst adresu slotu táskové proměnné
  i_newcontext(context,newcontext,lm_task_var_slot,nil);
  i_load(inst,info,newcontext,context,expr^.sub,vysl);
  end i_gen_task_var_slot;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_binary : topergen =
-- Porovnávání dvou obecných binárních bloků (e.g. array, record, set) (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : pexpnode) =
    -- Porovná zadaný uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      op1          : c_operand;                  -- adresa levého řetězce v ESI
      size         : t_unsigned32;               -- velikost pole
      tgloop       : itarget;                    -- návěští začátku cyklu
      tgend        : itarget;                    -- návěští konce cyklu

    begin
      -- jak jsme na tom s velikostí operandu ?
      if x_has_dynamic_size(x)

        -- dynamická velikost
        then
          unimplementedx({UNIMP=}000170,expr^.pos);

        -- statická veliksot
        else
          declare var
            opecx  : c_operand;                  -- min(op1length,op2length) v ECX
            opsize : c_operand;                  -- velikost pole

          begin
            -- načíst levý operand
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,x,op1);
            verifyx({VERIFY=}000524,op1.optype<>io_mem,x^.pos);

            -- redukovat počet registrů
            i_gen_reduceop(inst,info,context,op1);

            -- rezervovat ECX
            opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

            -- obnovit registry
            op1.refresh(inst,info,context);
            opecx.refresh(inst,info,context);

            -- zjistit velikost pole
            size:=unidata_size_to_unsigned(x^.t.getsize);

            -- zvolit, jak budeme porovnávat
            #template adjust_operands(denominator);
              opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div denominator));
              op1.shift_by_index(inst,info,context,ir_ecx,denominator);
              op1.unshift_displacement(denominator);
              op1.adjust_size(denominator);
              #end adjust_operands;
            -- dělitelné 4 ? => po čtveřicích
            if size mod 4=0 then
              #expand adjust_operands; #for denominator use; 4 #end adjust_operands;
            -- dělitelné 2 ? => po dvojicích
            elsif size mod 2=0 then
              #expand adjust_operands; #for denominator use; 2 #end adjust_operands;
            -- musíme po bytech
            else
              #expand adjust_operands; #for denominator use; 1 #end adjust_operands;
              end if;

            -- naplnit ECX
            addii(inst,info,ii_mov,opecx,opsize,op0);

          leave
            -- uvolnit operandy
            opsize.free(info,context);
            opecx.free(info,context);
            end declare;
          end if;

      -- alokovat cíle skoku
      newtarget(info,tgloop);
      newtarget(info,tgend);

      -- cíl skoku na toto místo
      settarget(info,tgloop,getaddr(inst));

      -- CMP <prvek pole>,0
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- JNE <tgend>
      addjump(inst,info,context,ic_ne,tgend);

      -- LOOP <tgloop>
      addloop(inst,info,context,tgloop);

      -- cíl skoku na toto místo
      settarget(info,tgend,getaddr(inst));

      -- výsledek
      vysl.create_condition(op2cc[expr^.oper,false]);
          {
              mov   ecx,x:size div 4
          ^2: cmp   [esi+ecx*4-4],0
              jne   ^1
              loop  ^2
          ^1: x=nil  => ic_ne
              x<>nil => ic_e
          }
    leave
      -- uvolnit operand
      op1.free(info,context);
      end cmpnil;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  verify({VERIFY=}000802,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podvýrazy
  expr^.get(el,er);

  -- porovnání operandů s příznivou statickou velikostí
  if x_has_static_size(el) and x_has_static_size(er)
  and (el^.t.getsize=uds_1 or el^.t.getsize=uds_2 or el^.t.getsize=uds_4) then
    -- porovnat principiálně stejně jako ordinální typy
    i_gen_op_compare_ordinal(inst,info,context,expr,vysl);

  ----- (non)ekvivalence s NIL zleva -----
  elsif x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s NIL zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecných polí -----
  else
    -- oba operandy mají statickou velikost
    if x_has_static_size(el) and x_has_static_size(er) then
      declare var
        newcontext : iexprcontext;               -- kontext podvýrazů
        op1        : c_operand;                  -- adresa levého řetězce v ESI
        op2        : c_operand;                  -- adresa pravého řetězce v EDI
        opecx      : c_operand;                  -- min(op1length,op2length) v ECX
        opsize     : c_operand;                  -- velikost pole
        ii         : iinstr;                     -- zvolená porovnávací instrukce
        size       : t_unsigned32;               -- velikost pole

      begin
        -- načíst levý operand do ESI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_esi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- načíst pravý operand do EDI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,er,op2);

        -- obnovit registry
        op1.refresh(inst,info,context);
        op2.refresh(inst,info,context);

        -- rezervovat ECX
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- zjistit velikost polí
        size:=unidata_size_to_unsigned(el^.t.getsize);

        -- zvolit, jak budeme porovnávat
        -- dělitelné 4 ? => po čtveřicích
        if size mod 4=0 then
          ii:=ii_cmpsd;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 4));
        -- dělitelné 2 ? => po dvojicích
        elsif size mod 2=0 then
          ii:=ii_cmpsw;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 2));
        -- musíme po bytech
        else
          ii:=ii_cmpsb;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size));
          end if;

        -- naplnit ECX
        addii(inst,info,ii_mov,opecx,opsize,op0);

        -- shodit Direction Flag - porovnává se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- REPE CMPS
        addip(inst,info,ip_repe);
        addii(inst,info,ii,op0,op0,op0);

        -- a tím by to mělo být hotovo

        -- výsledek
        vysl.create_condition(op2cc[expr^.oper,false]);

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op2.free(info,context);
        opecx.free(info,context);
        opsize.free(info,context);
        end declare;

    -- jeden z operandů má dynamickou velikost
    elsif x_has_dynamic_size(el) xor x_has_dynamic_size(er) then
      unimplemented({UNIMP=}000171);

    -- oba mají dynamickou velikost
    else
      unimplemented({UNIMP=}000172);
      end if;
    end if;
  end i_gen_op_compare_binary;



----------------------------------------------------------------------------------------------------
#separate public ci_integer;
#separate private ci_integer;
-- Celočíselná aritmetika.
----------------------------------------------------------------------------------------------------
#separate public ci_logical;
#separate private ci_logical;
-- Logické operace.
----------------------------------------------------------------------------------------------------
#separate public ci_pointer;
#separate private ci_pointer;
-- Operace s pointery.
----------------------------------------------------------------------------------------------------
#separate public ci_string;
#separate private ci_string;
-- Řetězcové operace.
----------------------------------------------------------------------------------------------------
#separate public ci_set;
#separate private ci_set;
-- Množinové operace.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_array : topergen =
-- Porovnávání recordů (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vyžadují komponenty pole zvláštní porovnávací algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimalizátor IF s konstantní podmínkou neošetří

    -- ano => porovnat po částech
    then
      unimplemented({UNIMP=}000177);

    -- ne => porovnat jako binární bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_record : topergen =
-- Porovnávání množin (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vyžadují komponenty recordu zvláštní porovnávací algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimalizátor IF s konstantní podmínkou neošetří

    -- ano => porovnat po částech
    then
      unimplemented({UNIMP=}000178);

    -- ne => porovnat jako binární bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_record;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign : topergen =
-- Univerzální přiřazení.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000140,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  if x_has_dynamic_size(el)

    -- levý operand má dynamickou velikost
    then
      declare var
        op1        : c_operand;                  -- levý operand
        op1size    : c_operand;                  -- :size levého operandu
        op1edi     : c_operand;                  -- adresa levého operandu v EDI

      begin
        {verify({VERIFY=}000803,not (rta_size in el^.rta_used{%%ATTR}));}

        -- vygenerovat levý operand
        i_newcontext(context,newcontext,lm_addr_attr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- pro atribut bude potřeba registr ECX
        op1size.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
      {
        -- načíst :size
        i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);
      }
        -- je k dispozici přímo :size
        if rta_size in el^.rta_used{%%ATTR} then
          -- načíst :size
          i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);

        -- je k dispozici jen :last
        elsif rta_last in el^.rta_used{%%ATTR} then
          -- načíst :last
          i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_last,op1size);

          -- vynásobit velikostí prvku
          i_gen_mul_reg(inst,info,context,op1size,unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size));

        -- co si máme počít bez dynamického atributu ?
        else
          verify({VERIFY=}000804,true)
          end if;

        -- registr EDI
        op1edi.create_use_register(inst,info,context,edt_address,ir_edi);

        -- načíst adresu proměnné do EDI
        op1.adjust_size(lpointer32);
        addii(inst,info,ii_mov,op1edi,op1,op0);

        if x_is_nil(er) {er^.t.stype=dt_uninil}

          -- přiřazení NIL
          then
            -- uložit NIL
            i_gen_fillz_dynamic(inst,info,context,op1edi,op1size);

          -- přiřazení konkrétní hodnoty
          else
            declare var
              op2     : c_operand;               -- pravý operand
              op2size : c_operand;               -- :size pravého operandu

            begin  
              ---- kontrola velikosti ----
              -- načíst adresu :size pravého operandu
              if x_has_dynamic_size(er)

                -- pravý operand má též dynamickou velikost
                then
                  verify({VERIFY=}000518,not (rta_size in er^.rta_used{%%ATTR}));

                  -- vygenerovat pravý operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_setrpref(newcontext,in_esi,irm_addr);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registry
                  op2.refresh(inst,info,context);

                  -- určit adresu :size
                  i_gen_load_rtattrib_addr(inst,info,context,er^.rta_used{%%ATTR},op2,rta_size,op2size);

                -- pravý operand má statickou velikost
                else
                  -- načíst velikost pravého operandu
                  op2size.create_imm(edt_unsigned,0,unidata_size_to_imm32(er^.t.getsize));
                  end if;

              declare var
                tg_ok : itarget;                 -- cíl skoku po porovnání velikostí

              begin
                -- alokovat cíl skoku
                newtarget(info,tg_ok);

                -- porovnat s ECX
                addii(inst,info,ii_cmp,op1size,op2size,op0);
                addjump(inst,info,context,ic_e,tg_ok);

                -- vyvolat výjimku Constraint_Error
                -- %%X

                -- cíl skoku na toto místo
                settarget(info,tg_ok,getaddr(inst));
                end declare;

              ---- přiřazení hodnoty ----
              if x_has_dynamic_size(er)

                -- pravý operand s dynamickou velikostí => již známe jeho adresu
                then
                  -- nic nedělat, verifikace 518 na "rta_size in er^.rta" už proběhla výše

                -- pravý operand se statickou velikostí => vygenerovat
                else
                  -- vygenerovat pravý operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_load(inst,info,newcontext,context,er,op2);
                  end if;

              -- obnovit registry
              op1.refresh(inst,info,context);
              op2.refresh(inst,info,context);

              -- operandy by neměly spotřebovat moc registrů
              i_gen_reduceop(inst,info,context,op1);
              i_gen_reduceop(inst,info,context,op2);

              -- přesunout (jako pole o prvcích velikosti 1)
              i_gen_move_array(inst,info,context,op2,op1,op1size,1);

            leave
              -- uvolnit operandy
              op2.free(info,context);
              op2size.free(info,context);
              end declare;
            end if;
      leave
        op1.free(info,context);
        op1edi.free(info,context);
        op1size.free(info,context);
        end declare;

    -- levý operand má statickou velikost
    else
      declare var
        op1        : c_operand;                  -- levý operand
        size       : t_unsigned32;               -- velikost operandu
      begin
        -- velikost operandu
        size:=unidata_size_to_unsigned(expr^.t.getsize);

        ----- %%X Připomínky ---------------------------------------------------
        -- -- Co když se levý a pravý operand překrývají ?
        -- -- Když zbývají tři byty, mohu přeci kopírovat předchozí byte podruhé
        --    (ušetří se 4 instrukce, takže penalta za nezarovananý přístup nevadí)
        -- -- Pokud to jde, tak zkusit REP MOVSD - od nějaké velikosti bloku by to
        --    mohlo být rychlejší, i kdybych musel čarovat s registrama (PUSH).
        -- -------------------------------------------------------------------------

        if x_is_nil(er)

          -- přiřazení NIL
          then
            -- vygenerovat levý podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_setrpref(newcontext,in_edi,irm_addr);
            i_load(inst,info,newcontext,context,el,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            -- uložit NIL
            i_gen_fillz_static(inst,info,context,op1,size);

          -- přiřazení konkrétní hodnoty
          else
            declare var
              op2  : c_operand;                  -- pravý operand
            begin
              if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}

                -- příznivá velikost
                then
                  -- vygenerovat a načíst operandy
                  i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);

                  -- přiřazení
                  -- Ondra 11.9.2002 : Hodnota může být reprezentována i kódem podmínky
                  if op2.optype=io_cc
                    then addset(inst,info,context,op2.cc,op1);
                    else addii(inst,info,ii_mov,op1,op2,op0);
                    end if;

                  -- výsledek
                  vysl.transfer(op1);

                -- něco jiného
                else
                  -- vygenerovat a načíst pravý podvýraz (může být i na stacku)
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_setoutpref(newcontext,iop_stack);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- vygenerovat levý podvýraz
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_load(inst,info,newcontext,context,el,op1);

                  -- obnovit registry
                  op1.refresh(inst,info,context);
                  op2.refresh(inst,info,context);

                  -- operandy by neměly spotřebovat moc registrů
                  i_gen_reduceop(inst,info,context,op1);
                  i_gen_reduceop(inst,info,context,op2);

                  -- kopírovat
                  case op2.optype
                    when io_stack do i_gen_pop_static(inst,info,context,op1,size);
                    when io_mem   do i_gen_move_static(inst,info,context,op2,op1,size);
                    when others   do verify({VERIFY=}000488,true);
                    end case;

                  -- %%X A co výsledek ??             
                  end if;

            leave
              -- uvolnit pravý operand
              op2.free(info,context);
              end declare;
            end if;
      leave
        -- uvolnit levý operand
        op1.free(info,context);
        end declare;
      end if;
  end i_gen_op_assign;



----------------------------------------------------------------------------------------------------
procedure i_gen_operator (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpoper;                -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
begin
  case expr^.t.tview
    -- Partial view/Unchecked view
    when tview_partial, tview_unchecked do
        case expr^.oper
          -- přiřazení
          when op_assign do i_gen_op_assign(inst,info,context,expr,vysl);

          when others do verify({VERIFY=}000187,true);
          end case;

    -- Full view
    when tview_full do
        declare var
          stype    : tdatatype;                  -- společný typ operandů

        begin
          -- zjisti společný typ operandů
          stype:=x_resolve_opdtype(expr,true);

          -- mame nejaky generator?
          verifyx({VERIFY=}000099,opertab[expr^.oper,stype]=nil,expr^.pos);

          -- zavolej prislusny generator
          opertab[expr^.oper,stype]^(inst,info,context,expr,vysl);
          end declare;

    when others do verifyx({VERIFY=}000186,true,expr^.pos);
    end case;
  end i_gen_operator;



----------------------------------------------------------------------------------------------------
procedure i_gen_unary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpunary;               -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  op1              : aliased c_operand;          -- operand
  newcontext       : iexprcontext;               -- kontext podvýrazů
  optype           : expunarytype;               -- typ unarniho operatoru
  range_checks_req : t_logical;                  -- T-je treba kontrola mezi

begin
  -- podvýrazy
  expr^.get(el);

  optype:=expr^.oper;
  
  -- "architektura" Intel tíhne k nepříjemným výjimkám,
  -- takže každá instrukce vyžaduje jiné zpracování
  case optype
    -- inkrementace/dekrementace, unární mínus, bitová negace
    when un_succ,un_pred,un_minus,un_bitnot do
        -- je treba kontrola mezi?
        range_checks_req:=t_runtime_check_set:[rch_ordinal_range]*expr^.get_run_checks(rchcl_load)<>t_runtime_check_set:[] or 
          t_runtime_check_set:[rch_ordinal_overflow,rch_ordinal_range]*expr^.get_run_checks(rchcl_gen)<>t_runtime_check_set:[];

        -- podvyraz nemusime nacist do registru jen pokud nepotrebujeme kontrolu mezi,
        -- jinak je treba operaci provest v docasne promenne
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        declare var
          optemp   : aliased c_operand;
          pop      : ^c_operand;

        begin
          pop:=^op1;

          -- pro prirazeni s behovymi kontrolami potrebujeme docasnou promennou na kontrolu vysledku
          if expr^.assign and range_checks_req then
            -- registr na docasny vysledek
            optemp.create_new_register(inst,info,context,op1.edtype,op1.size);

            -- počáteční hodnota
            addii(inst,info,ii_mov,optemp,op1,op0);

            pop:=^optemp;
            end if;

          -- instrukce
          case expr^.oper
            when un_minus  do addii(inst,info,ii_neg,pop^,op0,op0);
            when un_succ   do addii(inst,info,ii_add,pop^,op_1,op0);
            when un_pred   do addii(inst,info,ii_sub,pop^,op_1,op0);
            when un_bitnot do addii(inst,info,ii_not,pop^,op0,op0);
            when others do verify({VERIFY=}000047,true);
            end case;

          -- provest behove kontroly operace operatoru
          ci_rcheck.i_gen_runtime_checks(inst,info,context,rchcl_gen,pexpnode(expr)^,pop^);

          -- provest behove kontroly operace prirazeni
          ci_rcheck.i_gen_runtime_checks(inst,info,context,rchcl_load,pexpnode(expr)^,pop^);
          
          -- docasny vysledek?
          if expr^.assign and range_checks_req then
            -- ANO - priradit
            addii(inst,info,ii_mov,op1,optemp,op0);
            end if;
          
          leave
            optemp.free(info,context);
          end declare;
        
        -- vysledek
        vysl.transfer(op1);

    -- logická negace
    when un_not do
        -- vygenerovat podvýraz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- co je operand zač ?
        case op1.optype
          -- podmínka => znegovat
          when io_cc do op1.set_cc(icondneg[op1.cc]);

          -- registr => xornout hodnotou (true xor false)
          -- %%X Pro typ se specifikací reprezentace True a False se negace
          -- dělá takhle: xor op1,(true xor false)
          when io_reg, io_mem do addii(inst,info,ii_xor,op1,op_1,op0);

          when others do verify({VERIFY=}000470,true);
          end case;

        -- výsledek
        vysl.transfer(op1);

    -- absolutní hodnota
    when un_abs do
        -- %%TODO - nezapomenout na kontroly mezi
        unimplemented({UNIMP=}000029);

    when others do verify({VERIFY=}000046,true);
    end case;

leave
  -- uvolnit operand
  op1.free(info,context);
  end i_gen_unary;



----------------------------------------------------------------------------------------------------
procedure i_gen_rtattrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpnode{component};     -- strom
    vysl           : in c_operand) =             -- výsledek výpočtu výrazu (adresa)
-- Generování dynamických atributů.
-- VYSL obsahuje adresu bloku tvaru:
--     +----------+
--     | atributy | +4 až +n
--     +----------+
--     | adresa   | +0
--     +----------+
-- Atributy jsou z této struktury zkopírovány do obdobné (bez pole adresa),
-- která leží na bázové adrese dané registrem CONTEXT.RTABASE.
----------------------------------------------------------------------------------------------------
var
  opsrc            : c_operand;                  -- ukazatel na zdrojovou oblast
  dattrib          : rtattribset;                -- dynamické atributy výrazu
  srange           : pentity_type;               -- rozsah pole/řetězce
  x                : timm32;

begin
  -- chce to vůbec nějaké atributy ?
  if context.rta=rtattribset:[] then return; end if;

  -- jaké atributy jsou k dispozici ?
  dattrib:=context.rta*expr^.rta_used{%%ATTR};

  -- připravit ukazatel do zdrojové oblasti
  verify({VERIFY=}000333,vysl.optype<>io_mem);
  opsrc.clone(inst,info,context,vysl);
  getrtattribsetsize(expr^.rta_used{%%ATTR},x);
  --%%X Zbytečné přetypování, dodefinovat shift_displacement o TIMM32 hodnotu
  opsrc.shift_displacement(t_signed(imm32_lpointer32+x));  

  -- stack roste shora --> dolů
  for attrib in reverse rtattrib loop
    -- posunout offset ve zdrojové oblasti
    if attrib in expr^.rta_used{%%ATTR} then
      opsrc.unshift_displacement(imm32_to_signed(unidata_size_to_imm32(cpu32_rtattribsize[attrib])));
      end if;

    -- určit velikost atributu
    opsrc.adjust_size(unidata_size_to_unsigned(cpu32_rtattribsize[attrib]));

    -- zkopírovat dynamický atribut
    if attrib in dattrib then
      -- stačí jeden PUSH
      -- %%X Nebude se ten PUSH chovat divně,
      -- kdyby náhodou bylo OPSRC.SIZE<>4 ?
      addii(inst,info,ii_push,opsrc,op0,op0);

    -- určit staticky
    elsif attrib in context.rta then
      declare var
        optemp     : c_operand;                  -- pracovní registr

      begin
        -- připravit druhý operand
        case attrib
          -- ^instance
          when rta_instance do
              -- statický pointer na instanci je zřejmě NIL
              optemp.create_imm(edt_address,0,0);

          -- :tag
          when rta_tag      do
              -- je to tagged typ ?
              if tf_tagged in expr^.t.getctype^.tflags

                -- ano => použít reálný tag
                then
                  optemp.create_imm(edt_unsigned,opsrc.size,0);
                  optemp.set_relo_entity(expr^.t.getctype);

                -- ne => uložit prázdný tag
                else
                  optemp.create_imm(edt_unsigned,0,0);
                  end if;

          -- :size
          when rta_size     do
              optemp.create_imm(edt_unsigned,opsrc.size,unidata_size_to_imm32(expr^.t.getsize));

          -- :last
          when rta_last     do
              -- připravit operand
              optemp.create_imm(edt_unsigned,opsrc.size,0);

              -- liší se pro pole a pro řetězce
              verify({VERIFY=}000335,not t_is_sts(expr^.t,dts_index));
              srange:=expr^.t.getctype^.srange.getctype;
              case expr^.t.stype
                -- pole
                when dt_array, dt_uarray do
                    -- :last odpovídá :length-1
                    optemp.set_imm(uniint_to_imm32(uniint_length(srange^.lval,srange^.hval))-timm32(1));

                -- řetězec
                when dt_string, dt_ustring do
                    -- :last je :last
                    optemp.set_imm(uniint_to_imm32(srange^.hval));

                when others do verify({VERIFY=}000336,true);
                end case;

          when others do verify({VERIFY=}000332,true);
          end case;

        -- uložit
        addii(inst,info,ii_push,optemp,op0,op0);
      leave
        -- uvolnit operand
        optemp.free(info,context);
        end declare;
      end if;
    end loop;

leave
  -- uvolnit operand
  opsrc.free(info,context);
  end i_gen_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_component (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcomponent;           -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu komponenty.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  case expr^.nclass
    -- nic (kvalifikátor) => jen vygenerovat podvýraz
    when nc_none do
        if expr^.sub=nil
          -- nemáme ani podvýraz
          then --nullop(vysl,io_none)

          -- podvýraz je k dispozici => vygenerovat
          else
            -- vygenerovat podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            end if;

    -- proměnná
    when nc_var do
        if expr^.sub=nil or {not} expr^.sub^.nclass {in ncs_value}<>nc_var

          -- přímo proměnná
          then
            verify({VERIFY=}000091,expr^.s.psym=nil);

            declare var
              pvar : pentity_var;                -- proměnná pro zjednodušení

              -- koncový elementární datový typ a velikost operandu - nezávisí na módu proměnné
              final_edtype : t_elementary_data_type;
              final_size   : t_unsigned;

            begin
              -- proměnná pro zjednodušení
              pvar:=pentity_var(expr^.s.psym);

              -- určit koncový elementární datový typ a koncovou velikost
              final_edtype:=edtype_from_expr(expr);
              if expr^.t.hassize
                then final_size:=unidata_size_to_unsigned(expr^.t.getsize);
                else final_size:=0;
                end if;

              case pvar^.mclass
                -- automatická
                when mc_auto do
                    declare var
                      nindex  : t_unsigned;      -- index vnoření proměnné

                      -- počáteční elementární datový typ a velikost operandu - závisí na módu proměnné
                      initial_edtype : t_elementary_data_type;
                      initial_size   : t_unsigned;

                    begin
                      -- nemohla by to být proměnná z nadřazeného podprogramu ?
                      nindex:=0;
                      if inst.nested.nlist<>nil and then inst.nested.nlist^:length<>0 then
                        nindex:=inst.nested.nlist^:length;
                        while nindex<>0 and then inst.nested.nlist^[nindex]<>pvar^.context.entity loop
                          pred nindex;
                          end loop;
                        end if;

                      -- podle módu proměnné určit počáteční elementární datový typ a velikost
                      case pvar^.vmode
                        -- přímý přístup: obojí je identické s koncovými údaji
                        when vm_direct do 
                            initial_edtype:=final_edtype;
                            initial_size  :=final_size;

                        -- přístup přes referenci: obojí je vždy natvrdo stejné
                        when vm_ref    do 
                            initial_edtype:=edt_address;
                            initial_size  :=4;

                        when others    do verify({VERIFY=}000862,true);
                        end case;

                      -- připravit operand
                      if nindex=0

                        -- je to přímo lokální proměnná
                        then
                          declare var
                            disp : timm32;
                          begin
                            -- zjistit adresu proměnné
                            getvaraddr(inst,info,pvar,disp);

                            -- sestavit adresu bázovanou podle frame pointeru
                            vysl.create_memory_address_on_stack(inst,initial_edtype,initial_size,disp);
                            end declare;

                        -- je z nadřazeného podprogramu
                        else
                          declare var
                            optemp : c_operand;
                          begin
                            -- adresa uloženého frame pointeru
                            optemp.create_memory_address_on_stack(inst,edt_address,4,signed_to_imm32(-t_signed(nindex*4)));

                            -- budeme potřebovat registr na frame pointer
                            vysl.create_new_register(inst,info,context,edt_address,4);

                            -- načíst frame pointer
                            addii(inst,info,ii_mov,vysl,optemp,op0);

                          leave
                            -- uvolnit pracovní operand
                            optemp.free(info,context);
                            end declare;

                          -- změnit operand na adresní
                          vysl.transform_reg_to_mem(initial_edtype,initial_size);
                        { %%X
                          Dva zásadní problémy:
                            -- ENTER akceptuje pouze 16bitovou velikost prostoru na stacku -> nutné
                               minimálně ošetřit případ s více než 64 KB lokálních proměnných a také
                               zpětné nastavování hodnoty - někdy 32 jindy 16 bitů,
                            -- v době generování vnořené procedury není ještě vygenerovaná nadřazená
                               procedura -> generovat v opačném pořadí a pro vnořenou volit default
                               konvence.
                        }
                          declare var
                            pcode : pentity_code;  -- nadřazený podprogram
                            disp  : timm32;        -- offset proměnné vzhledem k frame pointeru
                            
                          begin
                            -- nadřazený podprogram
                            pcode:=inst.nested.nlist^[nindex];
                            verify({VERIFY=}000805,picodegen_subprog(pcode^.codegen)^.ifirst<>picodegen_subprog(pcode^.codegen)^.ilast);

                            -- zjistit adresu proměnné
                            getvaraddr(picodegen_subprog(pcode^.codegen)^.ifirst^,info,pvar,disp);

                            -- přičíst posunutí k výsledné adrese
                            vysl.shift_displacement(imm32_to_signed{%%X}(disp));
                            end declare;
                          end if;
                      end declare;

                    -- je to parametr ? => pak musíme upravit množinu
                    -- použitelných run-time atributů
                    -- %%X Tohle je trochu Black Magic a záplata. Správně by se
                    -- to mělo dělat v dvouprůchodové globální analýze, jenže
                    -- tu zatím nemáme a takhle to kupodivu taky funguje.
                    --   Nestane se, že by v CONTEXT.RTA byly i atributy, které
                    -- touto úpravou ztratím, protože při požadavku na takové
                    -- atributy by se vyžádaly i pro tento parametr (aspoň by
                    -- to tak mělo být).
                    verify({VERIFY=}000334,context.rta*(pvar^.rta_avail{allrta}-pvar^.rta_used{usedrta})<>rtattribset:[]);
                    expr^.rta_used{%%ATTR}:=pvar^.rta_used{usedrta};

                    -- chceme uložit i dynamické atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                    -- implicitní dereference
                    if pvar^.vmode=vm_ref and context.mode<>lm_addr_attr then
                      declare var
                        optemp : c_operand;
                      begin
                      {
                        -- opravit typ a velikost operandu (při přípravě jsme 
                        -- možnost [vm_ref] nezohlednili, tak to teď musíme napravit)
                        vysl.adjust_edtype(edt_address);
                        vysl.adjust_size(4);
                      }
                        -- alokovat pracovní registr
                        optemp.create_new_register(inst,info,context,edt_address,4);

                        -- načíst adresu
                        addii(inst,info,ii_mov,optemp,vysl,op0);

                        -- nahradit výsledek právě načtenou adresou
                        vysl.replace(info,context,optemp);

                        -- změnit operand na adresní
                        vysl.transform_reg_to_mem(final_edtype,final_size);
                      leave
                        -- uvolnit pracovní operand
                        optemp.free(info,context);
                        end declare;
                      end if;
                  {
                    -- velikost operandu
                    if expr^.t.hassize
                      then vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
                      else vysl.adjust_size(0);
                      end if;
                  }
                -- statická
                when mc_static do
                    -- adresa proměnné
                    vysl.create_memory_address(inst,info,context,final_edtype,final_size,ir_none,0);
                    vysl.set_relo_entity(expr^.s.psym);

                    -- chceme uložit i dynamické atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                -- tasková proměnná
                when mc_task do
                    if context.mode=lm_task_var_slot 

                      -- adresa slotu taskové proměnné
                      then
                        -- připravit adresu slotu
                        vysl.create_imm(edt_address,4,0);
                        vysl.set_relo_entity(expr^.s.psym);

                      -- hodnota taskové proměnné
                      else
                        declare var
                          slot : c_operand;      -- slot taskové proměnné

                        begin
                          -- na stacku rezervovat prostor pro návratovou hodnotu - adresa hodnoty taskové proměnné
                          addii(inst,info,ii_sub,op_esp,op_4,op0);

                          -- handle taskové proměnné uložit na stack
                          slot.create_memory_address(inst,info,context,edt_unsigned,4,ir_none,0);
                          slot.set_relo_entity(expr^.s.psym);
                          addii(inst,info,ii_push,slot,op0,op0);

                          -- přeložit handle taskové proměnné na adresu její hodnoty
                          addcallrtl(inst,info,context,rtl_get_task_var,true);

                          -- vyzvednout ze stacku adresu hodnoty taskové proměnné
                          vysl.create_new_register(inst,info,context,edt_address,4);
                          addii(inst,info,ii_pop,vysl,op0,op0);
                          vysl.transform_reg_to_mem(edtype_from_expr(expr),unidata_size_to_unsigned(expr^.t.getsize));

                        leave
                          slot.free(info,context);
                          end declare;
                        end if;


                -- proměnná třídy
                when mc_class do
                    -- načíst adresu složky
                    i_load_this_address(inst,info,context,final_edtype,final_size,pvar^.addr,vysl);

                    -- chceme uložit i dynamické atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                when others do verify({VERIFY=}000071,true);
                end case;
              end declare;

          -- selektor
          else
            verify({VERIFY=}000090,(expr^.s.psym=nil) or{and} not (pentity_var(expr^.s.psym)^.mclass in mcs_offset));

            -- vygenerovat podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            verify({VERIFY=}000092,vysl.optype<>io_mem);

            -- adresa
            vysl.shift_displacement(imm32_to_signed{%%X}(unidata_addr_to_imm32(pentity_var(expr^.s.psym)^.addr{pivarlink(pentity_var(expr^.s.psym)^.codegen)^.addr})));

            -- velikost operandu
            vysl.adjust_size(unidata_size_to_unsigned(pentity_var(expr^.s.psym)^.typ.getctype^.size));

            -- chceme uložit i dynamické atributy ?
            if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
              i_gen_rtattrib(inst,info,context,expr,vysl);
              end if;
            end if;

    -- procedura
    when nc_proc do
        -- případný podvýraz určuje instanci, ale co s ní ?
        -- to ať si vyřeší volající procedura

        -- vrátit adresu procedury
        i_gen_subprogram_address(inst,info,context,pentity_subprogram(expr^.getsymbol),false,vysl);

    -- zpráva
    when nc_message     do
        -- na případný podvýraz se kašle, nemá význam

        -- vrátit tag zprávy
        vysl.create_imm(edt_unsigned,0,0);
        vysl.set_relo_entity(expr^.s.psym);

    when others do verify({VERIFY=}000621,true);
    end case;
  end i_gen_component;



----------------------------------------------------------------------------------------------------
procedure i_gen_imm (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpimm;                 -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu přímé hodnoty.
----------------------------------------------------------------------------------------------------
var
  edtype           : t_elementary_data_type;     -- elementární datový typ přímé hodnoty
begin
  -- určit elementární datový typ přímé hodnoty
  edtype:=edtype_from_expr(expr);

  if context.mode in lms_addr

    -- zajímá nás adresa hodnoty
    then
      -- adresa
      vysl.create_memory_address(inst,info,context,edtype,unidata_size_to_unsigned(expr^.t.getsize),ir_none,0);
      vysl.set_relo_imm(expr);

      -- chceme uložit i dynamické atributy ?
      if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
        i_gen_rtattrib(inst,info,context,expr,vysl);
        end if;

    -- zajímá nás hodnota samotná
    else
      case expr^.imm.ic
        -- ordinální hodnota
        when ic_ordinal do
            if t_is_sts(expr^.t,dts_unitype)
              then vysl.create_imm(edtype,0,uniint_to_imm32(expr^.imm.ui));
              else vysl.create_imm(edtype,unidata_size_to_unsigned(expr^.t.getsize),uniint_to_imm32(expr^.imm.ui));
              end if;

         { No a to je právě ten omyl. Tohle se musí řešit s využitím NATTYP
            o úroveň výš (v I_LOAD).

            --..TECH U ordinálních hodnot mi na velikosti nijak zvlášť nesejde.   
            -- Emitor instrukcí se přizpůsobí a kompatibilitu by měly zajistit
            -- předchozí fáze překladu. Nicméně stejně by požadovaná velikost
            -- konstanty měla být alespoň taková, jako je její skutečná velikost.
            {..X Bohužel nemám jak to otestovat... }
            {verify({VERIFY=}000129,not (expr^.t.stype in dts_unitype) and uishrink(expr^.imm.ui,,));}
            vysl.size:=0;
          { Původní, málo funkční verze
            (var(unsigned 32)<=imm(unsigned 16) --> cmp reg32,imm16)

            if expr^.t.stype in dts_unitype
              then vysl.size:=0;
              else udtouint(expr^.t.typ^.size,vysl.size);
              end if;
          }
         }

        -- NIL
        when ic_nil do
            declare var
              x : t_unsigned;
            begin
              x:=unidata_size_to_unsigned(context.outtyp.size);
              verifyx({VERIFY=}000556,x<>1 and x<>2 and x<>4{%%TODO(SET) not (x in [1,2,4])},expr^.pos);
              end declare;
            vysl.create_imm(edtype,0,0);
            -- %%X No a tady bych potřeboval vědět požadovaný typ, nebo ne ?

        -- kondenzované pole nebo agregát
        when ic_condensed,ic_array,ic_set,ic_record do
            {verifyx({VERIFY=}000530,((expr^.imm.ic=ic_set) and (expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize))
                     or ((expr^.imm.ic=ic_array) and (expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize))
                     or ((expr^.imm.ic=ic_record) and (expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize)),expr^.pos);}
            {!!}
            vysl.create_memory_address(inst,info,context,edtype,unidata_size_to_unsigned(expr^.t.getsize),ir_none,0);
            vysl.set_relo_imm(expr);

        -- %%X
        when others do verify({VERIFY=}000072,true);
        end case;
      end if;
  end i_gen_imm;



----------------------------------------------------------------------------------------------------
procedure i_gen_aggregate (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpaggregate;           -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování agregátu.
-- Poznámka: Obsluha agregátů je dost natvrdo (=neoptimálně), protože je to
-- poměrně komplikovaná záležitost a babrat se s tím budu až ve 4.0.1.
----------------------------------------------------------------------------------------------------
var
  opaggr           : c_operand;                  -- pracovní prostor pro agregát
  optemp           : c_operand;                  -- pracovní operand
  arglist          : pexpitem;                   -- seznam argumentů

begin
  -- %%TECH Optimalizátor zajistil, že agregát, který se dostane až sem, má
  -- zcela jistě alespoň jednu nekonstantní složku (ať už hodnotu, či index),
  -- všechny ostatní případy jsou konvertovány na NT_IMM.

  case expr^.t.stype
    -- record
    when dt_record do unimplemented({UNIMP=}000152);

    -- pole
    when dt_array do
      {
        -- alokovat pracovní prostor pro agregát
        nullop(optemp,io_mem);
        optemp.base.reg:=istackframereg[inst.frame];
        optemp.size:=expr^.t.size;
        alloctemp(inst,info,optemp.size,optemp.disp);

        -- do pracovního prostoru nacpat konstantní část agregátu

        -- seznam argumentů
        expr^.getarglist(arglist);

        -- zpracovat všechny složky agregátu
        while arglist<>nil loop

          end loop;
      }
        unimplemented({UNIMP=}000165);


    -- neomezene pole
    when dt_uarray do unimplemented({UNIMP=}000155);

    -- řetězec
    when dt_string,dt_ustring do unimplemented({UNIMP=}000153);

    -- množina
    when dt_set do unimplementedx({UNIMP=}000154,expr^.pos);

    -- ostatní typy tu nemají co dělat
    when others do verify({VERIFY=}000473,true);
    end case
  end i_gen_aggregate;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram_prepare (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    call           : out icallconvention;        -- volací konvence
    pinst          : out picodeinst;             -- instance volané procedury
    ptyp           : out pentity_type) =         -- typ procedury
-- Generování kódu volání procedury: příprava volání.
----------------------------------------------------------------------------------------------------
begin
  -- pro neurčité případy předpokládejme default volací konvenci
  call:=icc_default;

  -- zvolit instanci procedury
  pinst:=nil;
  if pproc<>nil and then pproc^.etype=et_procedure and then pproc^.codegen<>nil then
    -- %%X zvolit instanci procedury
    pinst:=picodegen_subprog(pproc^.codegen)^.ifirst;

    -- volací konvence
    if pinst<>nil
      -- podle zvolené instance
      then call:=pinst^.profile.call;
      -- default konvence pro tuto proceduru
      else call:=get_call_conv(pentity(pproc)^);
      end if;
    end if;

  -- lze-li to, tak získat typ procedury, bude se hodit
  if pproc<>nil

    -- máme k dispozici konkrétní proceduru
    then ptyp:=pproc^.typ.getutype

    -- zřejmě je to pointer na proceduru
    else
      verify({VERIFY=}000510,expr^.sub^.ntype<>nt_deref);
      ptyp:=expr^.sub^.t.getctype;
      call:=get_call_conv(pentity(ptyp)^);
      end if;
  verify({VERIFY=}000511,(ptyp<>nil) and (ptyp^.stype<>dt_procedure));

  -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUTÁ ** záplata !!
  -- Přesunutím SAVEREGS těsně před instrukci CALL zabraňuju rekurzivnímu
  -- pushování stejných registrů, které je zapříčiněno nějakou nedokonalostí
  -- alokátoru registrů, kterou se mi zatím nepodařilo vyřešit. Problém spočívá
  -- v tom, že schováním registru se ztrácí informace o jeho (ne)použití, takže
  -- při rekurzivním volání I_GEN_CALL_SUBPROGRAM se schovává znova, což má za
  -- následek unimplemented({UNIMP=}000212) v I_RETRIEVE.
{
  -- uložit všechny použité registry
  -- %%X Omezit jen na registry skutečně použité ve volané proceduře
  saveregs(inst,info,context);
}
  end i_gen_call_subprogram_prepare;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram_parameters (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    call           : in icallconvention;         -- volací konvence
    pinst          : in picodeinst;              -- instance volané procedury
    ptyp           : in pentity_type;            -- typ procedury
    params_size     : out t_unsigned) =          -- velikost skutecnych parametru v bytech (bez parametru instance)
-- Generování kódu volání procedury: generování skutečných parametrů.
----------------------------------------------------------------------------------------------------
var
  arg              : pexpitem;                   -- skutečný parametr

    ------------------------------------------------------------------------------------------------
    procedure firstarg =
    -- První argument procedury (podle volací konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;

    begin
      -- %%X časem doplnit do stromu dvousměrnej seznam 

      -- první argument v seznamu
      expr^.get(el,arg);

      -- dojet na konec
      if call in iccs_reverse then
        while arg<>nil and then arg^.next<>nil loop arg:=pexpitem(arg^.next); end loop;
        end if;
      end firstarg;



    ------------------------------------------------------------------------------------------------
    procedure nextarg =
    -- Další argument procedury (podle volací konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;
      a            : pexpitem;

    begin
      -- %%X časem doplnit do stromu dvousměrnej seznam

      if call in iccs_reverse

        -- hledat předchozí
        then
          expr^.get(el,a);
          if arg=a
            then arg:=nil
            else
              while a^.next<>arg loop a:=pexpitem(a^.next); end loop;
              arg:=a;
              end if;

        -- další
        else 
          arg:=pexpitem(arg^.next);
          end if;
      end nextarg;

begin
  firstarg;
  while arg<>nil loop
    if arg^.sub<>nil

      -- hodnota je explicitně uvedena
      then
        if pentity_param(arg^.sym)^.pass=pp_value and x_is_nil(arg^.sub)

          -- speciální případ: předává se NIL hodnotou
          then
            i_gen_pushnil(inst,info,context,arg^.t.getctype^.size);
            params_size+unidata_size_to_unsigned(arg^.t.getctype^.size);

          -- všechny ostatní případy
          else
            declare var
              newcontext : iexprcontext;         -- kontext podvýrazů
              rta_size   : timm32;

            begin
              -- připravit kontext
              case pentity_param(arg^.sym)^.pass
                -- hodnotou
                when pp_value     do
                    i_newcontext(context,newcontext,lm_push_value,arg^.t.getutype);
                    i_setoutpref(newcontext,iop_stack);
                    params_size+unidata_size_to_unsigned(arg^.t.getctype^.size);

                -- odkazem
                when pp_ref       do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});
                    params_size+lpointer32;

                -- odkazem, bez typové kontroly
                when pp_unchecked do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});
                    params_size+lpointer32;

                -- odkazem, včetně odvozených typů
                when pp_class     do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});--unimplemented({UNIMP=}000074);
                    params_size+lpointer32;

                -- odkazem, řídící parametr virtuálního volání
                when pp_virtual   do unimplemented({UNIMP=}000082);

                when others do verify({VERIFY=}000063,true);
                end case;

              -- jaké dynamické atributy nás zajímají ?
              newcontext.rta:=pentity_param(arg^.sym)^.rta_used{usedrta};

              -- parametr předaný hodnotou nemá dynamické atributy
              verify({VERIFY=}000327,(pentity_param(arg^.sym)^.pass=pp_value) and (newcontext.rta<>rtattribset:[]));

              -- velikost pouzitych runtime atributu
              getrtattribsetsize(newcontext.rta,rta_size);
              params_size+imm32_to_unsigned(rta_size);

              -- vygenerovat parametr
              declare var
                opnone : c_operand;
              begin
                i_load(inst,info,newcontext,context,arg^.sub,opnone);
              leave
                opnone.free(info,context);
                end declare;
              end declare;
            end if;

      -- použít implicitní hodnotu
      else
        unimplemented({UNIMP=}000176);
        end if;

    -- další parametr
    nextarg;
    end loop;
  end i_gen_call_subprogram_parameters;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání procedury.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  call             : icallconvention;            -- volací konvence
  pinst            : picodeinst;                 -- instance volané procedury
  ptyp             : pentity_type;               -- typ procedury
  newcontext       : iexprcontext;               -- kontext podvýrazů
  params_size      : t_unsigned;                 -- velikost pushlych parametru v bytech
  instance_needed  : t_logical:=false;           -- T-pushuje se instance, F-nepushuje

begin
  ---- (1) příprava volání: zjistit instanci, volací konvenci, typ procedury ----
  i_gen_call_subprogram_prepare(inst,info,context,expr,pproc,call,pinst,ptyp);


  ---- (2) rezervovat místo pro návratovou hodnotu ----
  if expr^.t.tview<>tview_null and call in iccs_ret_stack then
    declare var
      resultsize   : t_unsigned;                 -- velikost návratové hodnoty
      op1          : c_operand;                  -- operand

    begin     
      -- velikost návratové hodnoty
      resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

      if ptyp^.result^.pass in pps_ref
        -- odkazem
        then
          -- alokovat, třeba někde na stacku, prostor pro návratovou hodnotu
          op1.create_temporary(inst,info,edtype_from_expr(expr),resultsize);

          -- získanou adresu převést na absolutní
          i_gen_lea(inst,info,context,op1,in_none);

          -- uložit na stack
          addii(inst,info,ii_push,op1,op0,op0);

        -- hodnotou
        else
          declare var
            alignedsize : t_unsigned32;          -- zarovnaná velikost návratové hodnoty

          begin
            -- zarovnat
            addalign(alignedsize,0,resultsize,istackalign);

            -- zkonvertovat na operand
            op1.create_imm(edt_unsigned,0,unsigned_to_imm32(alignedsize));

            -- snížit hodnotu ESP o velikost proměnné
            addii(inst,info,ii_sub,op_esp,op1,op0);
            end declare;
          end if;

    leave  
      -- uvolnit operand
      op1.free(info,context);
      end declare;
    end if;


  ---- (3) zpracovat argumenty ----
  i_gen_call_subprogram_parameters(inst,info,context,expr,pproc,call,pinst,ptyp,params_size);


  ---- (4) uložit pointer na instanci a načíst adresu procedury ----
  declare var
    nclass         : nodeclass;                  -- převzatá/určená třída jména procedury
    opcall         : c_operand;                  -- adresa volané procedury

  begin
    declare var
      arg          : pexpitem;                   -- argumenty
    begin
      expr^.get(el,arg);
      end declare;
    if el=nil
      then nclass:=nc_proc
      else nclass:=el^.nclass;
      end if;
    case {el^.}nclass
      -- přímo procedura
      when nc_proc do
          verify({VERIFY=}000380,{(el^.ntype<>nt_component) or (pexpcomponent(el)^.s.psym=nil)
                     or} not (pproc^.etype{pexpcomponent(el)^.s.psym^.etype} in ets_subprogram));

          ---- jak je to s pointerem na instanci ? ----
          case pproc^.instance {pentity_subprogram(pexpcomponent(el)^.s.psym)^.instance}
            -- nepředávat
            when tip_none     do { dál již nic nedělat };

            -- volitelně předat, není-li, pak NIL
            when tip_optional do
                instance_needed:=true;

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);

                  if instance<>nil and then instance^.nclass in ncs_value

                    -- je k dispozici => vygenerovat podvýraz
                    then
                      declare var
                        op1 : c_operand;         -- operand
                      begin
                        i_newcontext(context,newcontext,lm_push_addr,nil);
                        i_load(inst,info,newcontext,context,instance,op1);
                      leave
                        op1.free(info,context);
                        end declare;

                    -- není k dispozici => uložit aspoň NIL
                    else
                      addii(inst,info,ii_push,op_0_32bit,op0,op0);
                      end if;
                  end declare;

            -- předat
            when tip_pass     do
                instance_needed:=true;

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy
                  op1      : c_operand;          -- operand

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);
                  verify({VERIFY=}000381,instance=nil);

                  -- vygenerovat podvýraz
                  i_newcontext(context,newcontext,lm_push_addr,nil);
                  i_load(inst,info,newcontext,context,instance,op1);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;

            -- virtuální volání
            when tip_dispatch do
                instance_needed:=true;

                verify({VERIFY=}000527,el^.ntype<>nt_component or else pproc=nil or else pproc^.etype<>et_virtual);

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);
                  verify({VERIFY=}000526,instance=nil);

                  -- vygenerovat podvýraz
                  i_newcontext(context,newcontext,lm_addr,nil);
                  i_load(inst,info,newcontext,context,instance,opcall);
                  end declare;

                -- obnovit registry
                opcall.refresh(inst,info,context);

                -- uložit pointer na instanci na stack
                addii(inst,info,ii_push,opcall,op0,op0);

                -- načíst pointer na instanci do registru
                i_gen_loadreg(inst,info,context,nil,opcall,true,irm_addr);

                -- sestavit adresní operand ukazující na tag
                opcall.transform_reg_to_mem(edt_address,4);
                opcall.shift_displacement(imm32_to_signed{%%X}(cpu32_class_tag));

                -- načíst tag (=adresu deskriptoru typu) do registru
                i_gen_loadreg(inst,info,context,nil,opcall,true,irm_addr);

                -- sestavit adresní operand ukazující na adresu virtuální metody
                declare var
                  _c_class_interface : c_class_interface;
                begin
                  opcall.transform_reg_to_mem(edt_address,4);
                  opcall.shift_displacement(t_signed(t_desc_class:size+_c_class_interface.normalize_vindex(pentity_virtual(pproc)^.vindex)*4));
                                                      -- %%TODO(COMPATIBILITY) %%TODO(620) ^^^^^ nahradit přímo typem místo instance
                  end declare;

            when others do verify({VERIFY=}000509,true);
            end case;

          ---- adresa procedury ----
          if pproc^{pentity_subprogram(pexpcomponent(el)^.s.psym)^}.instance<>tip_dispatch then
            -- máme podvýraz specifikující podprogram ?
            if el<>nil

              -- ano => použijeme ten
              then
                -- vygenerovat podvýraz
                i_newcontext(context,newcontext,lm_imm_to_rel,nil);
                i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

                -- obnovit registry
                opcall.refresh(inst,info,context);

              -- ne => adresu procedury si vygenerujeme přímo
              else
                i_gen_subprogram_address(inst,info,context,pproc,true,opcall);
                end if;
            end if;

      -- pointer na proceduru
      when nc_var,nc_value do
          -- vygenerovat podvýraz
          i_newcontext(context,newcontext,lm_gen,nil);
          i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

          -- obnovit registry
          opcall.refresh(inst,info,context);

          -- pointer budeme zpracovávat po 4bytových kouscích
          opcall.adjust_size(4);

          -- jestliže to není zrovna machine pointer na proceduru, tak se zabývat instancí
          verify({VERIFY=}000806,el^.sub=nil or else not t_is_stype(el^.sub^.t,dt_pointer));
          if pf_machine not in el^.sub^.t.getpflags then
            declare var
              optemp : c_operand;                  -- pracovní registr
              tgcall : itarget;                    -- cíl skoku na volání procedury

            begin
              instance_needed:=true;

              -- bude se hodit jeden registr
              optemp.create_new_register(inst,info,context,edt_address,4);

              -- načíst pointer na instanci
              opcall.shift_displacement(4);
              addii(inst,info,ii_mov,optemp,opcall,op0);
              opcall.unshift_displacement(4);

              -- alokovat návěští skoku
              newtarget(info,tgcall);

              -- zjistit, zda je to platný pointer na instanci
              addii(inst,info,ii_cmp,optemp,op_FFFFFFFF,op0);
              addjump(inst,info,context,ic_e,tgcall);

              -- uložit instanci
              addii(inst,info,ii_push,optemp,op0,op0);

              -- adresa skoku na toto místo
              settarget(info,tgcall,getaddr(inst));

            leave
              -- uvolnit pomocný operand
              optemp.free(info,context);
              end declare;
            end if;

      when others do verify({VERIFY=}000379,true);
      end case;

    -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUTÁ ** záplata !!
    -- Podrobněji viz zakomentované volání SAVEREGS na začátku této procedury
    -- uložit všechny použité registry
    -- %%X Omezit jen na registry skutečně použité ve volané proceduře
    i_reg_save_used(inst,info,context);

    -- instrukce
    addii(inst,info,ii_call,opcall,op0,op0);

    -- ze stacku odstranit parametry, které tam zbyly po úchylných volacích konvencích
    if call in iccs_leave_params then
      if pinst=nil 
        then
        -- Jestliže není k dispozici instance volané procedury, nevíme, o kolik bytů zvýšit
        -- stack pointer. S touto situací není lehké si poradit. Nastává, když volaná procedura
        -- je deklarována uvnitř volající. Důvodem je nevýhodné pořadí generování kódu těchto
        -- dvou procedur. Řešením by mohl být předvýpočet profilu parametrů před vlastním
        -- generováním kódu čehokoliv.
        -- %%HYNEK: Zatim vyreseno tak, ze si sami behem generovani volani spocitame kolik se pushlo.
        --          Neumime zapocitat instanci - napr. dynamicke zjisteni v pripade pointeru na proceduru
        --          je drobet slozitejsi.
        
          if instance_needed then
            unimplemented({UNIMP=}000203);
            end if;

          addopimm(inst,info,context,ii_add,op_esp,params_size);      
        else 
          addopimm(inst,info,context,ii_add,op_esp,pinst^.profile.retfree);
          end if;
      end if;

  leave
    -- uvolnit operand
    opcall.free(info,context);
    end declare;


  ---- (5) převzít výsledek ----
  if expr^.t.tview<>tview_null{stype<>dt_undef} then
    declare var
      resultsize   : t_unsigned;                 -- velikost návratové hodnoty
      resultedtype : t_elementary_data_type;     -- elementární datový typ návratové hodnoty

    begin
      -- velikost výsledku
      resultsize:=unidata_size_to_unsigned(expr^.t.getsize);
      resultedtype:=edtype_from_expr(expr);

      -- na stacku
      if call in iccs_ret_stack then
        if ptyp^.result^.pass in pps_ref

          -- odkazem
          then
            -- registr pro adresu návratové hodnoty
            vysl.create_new_register(inst,info,context,edt_address,4);

            -- vyzvednout ze stacku
            addii(inst,info,ii_pop,vysl,op0,op0);

            -- transformovat na referenci na návratovou hodnotu
            vysl.transform_reg_to_mem(resultedtype,resultsize);

            -- uvolnit prostor na stacku se dá až ve chvíli kdy bude vyzvednuta
            -- hodnota na kterou právě vracíme pointer

          -- na stacku je hodnota
          else
            -- nepreferuje volající určitou metodu předání ?
            if context.outpref=iop_stack

              -- máme štěstí, nadřazená procedura chce výsledek na stacku
              then
                vysl.create_on_stack(resultedtype,resultsize);

              -- jinak s tím něco udělat
              else
                -- nevešel by se výsledek do registru ?
                if resultsize=1 or resultsize=2 or resultsize=4{%%TODO(SET) resultsize in [1,2,4]}

                  then
                    declare var
                      alignedsize : t_unsigned32;    -- zarovnaná velikost návratové hodnoty

                    begin 
                      -- zarovnat
                      addalign(alignedsize,0,resultsize,istackalign);

                      -- připravit registr pro výsledek
                      vysl.create_new_register(inst,info,context,resultedtype,resultsize);

                      -- změnit velikost registru na maximální (nelze tak přímo alokovat qůli ESI, EDI)
                      vysl.adjust_size(alignedsize);

                      -- převzít výsledek, a uvolnit zásobník
                      addii(inst,info,ii_pop,vysl,op0,op0);

                      -- změnit velikost registru na skutečnou
                      vysl.adjust_size(resultsize);
                      end declare;

                  else
                    -- alokovat, třeba někde na stacku, prostor pro výsledek
                    vysl.create_temporary(inst,info,resultedtype,resultsize);

                    -- zkopírovat ze stacku do výsledku
                    i_gen_pop_static(inst,info,context,vysl,resultsize);
                    end if;
                end if;
            end if;

      -- v EAX
      elsif call in iccs_ret_eax then
        -- výsledek
        vysl.create_use_register(inst,info,context,resultedtype,ir_eax);
        vysl.adjust_size(resultsize);

      -- nějaká chyba
      else 
        verify({VERIFY=}000104,false);
        end if;

      -- chceme uložit i dynamické atributy ?
      if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
        i_gen_rtattrib(inst,info,context,expr,vysl);
        end if;
      end declare;
    end if;
  end i_gen_call_subprogram;



----------------------------------------------------------------------------------------------------
procedure i_gen_call (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání procedury.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_subprogram;         -- volaná procedura

begin
  -- nalézt proceduru
  pproc:=pentity_subprogram(expr^.sub^.getsymbol);
  verify({VERIFY=}000513,(pproc<>nil) and not (pproc^.etype in ets_callable));

  -- vygenerovat kód
  i_gen_call_subprogram(inst,info,context,expr,pproc,vysl);
  end i_gen_call;



----------------------------------------------------------------------------------------------------
procedure i_gen_index (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpindex;               -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu indexování pole.
----------------------------------------------------------------------------------------------------
with
  ci_rcheck;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  lval             : timm32;                     -- dolní mez pole
  size             : timm32;                     -- velikost prvku
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el,er);

  -- vygenerovat levý podvýraz
  i_newcontext(context,newcontext,lm_gen,nil);
  i_load(inst,info,newcontext,context,el,op1);
  verify({VERIFY=}000106,op1.optype<>io_mem);

  -- vygenerovat pravý podvýraz
  -- je třeba hodnota velikosti IDEFREGSIZE, takže se typ neuvádí
  i_newcontext(context,newcontext,lm_reg,nil);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);

  -- %%TODO(rch_stringindex_range) - az bude doimplementovana i_gen_stringindex_range_check
  --i_gen_stringindex_range_check(inst,info,context,expr^,op2);

  -- dolní mez pole
  lval:=uniint_to_imm32(el^.t.getctype^.srange.getctype^.lval);

  -- velikost prvku
  size:=unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size);

  -- základ výsledku
  vysl.clone(inst,info,context,op1);
  vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
  verify({VERIFY=}000490,vysl.optype<>io_mem);
  -- Pozor: nutný předpoklad pro správné ošetření IO_CC

  -- sestavit výslednou adresu
  case op2.optype
    -- registr
    when io_reg do
        -- doplnit jako scale*index
        if vysl.index.reg=ir_none and (size=timm32(1) or size=timm32(2) or size=timm32(4) or size=timm32(8)) then
          vysl.shift_by_index(inst,info,context,op2.reg.reg,imm32_to_unsigned(size));

        -- doplnit jako index
        elsif vysl.index.reg=ir_none then
          -- vynásobit velikostí báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako index
          vysl.shift_by_index(inst,info,context,op2.reg.reg,1);

        -- dosadit jako bázi
        elsif vysl.base.reg=ir_none then
          -- vynásobit velikostní báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako bázi
          vysl.shift_by_base(inst,info,context,op2.reg.reg);

        -- přičíst k bázi
        else
          -- vynásobit velikostí báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- přičíst k bázi
          addopreg(inst,info,context,ii_add,op1.base.reg,op2);
          end if;

        -- opravit dolní mez
        vysl.unshift_displacement(imm32_to_signed{%%X}(lval*size));

    -- přímá hodnota
    when io_imm do
        -- offset
        vysl.shift_displacement(imm32_to_signed{%%X}((op2.imm-lval)*size));

    -- proměnná
    when io_mem do
        unimplemented({UNIMP=}000071);

    -- podmínka
    when io_cc do
        -- z verify 490 je jasné, že VYSL je IO_MEM

        declare var
          tg_end   : itarget;                    -- návěští pro skok na konec výpočtu indexu

        begin
          -- návěští pro skok na konec výpočtu adresy
          newtarget(info,tg_end);

          -- je součástí adresy nějaký registr ?
          if vysl.base.reg<>ir_none or (vysl.scale=1 and vysl.index.reg<>ir_none)

            -- ano => přičíst k němu
            then
              -- skok na konec při nesplnění podmínky
              addjump(inst,info,context,icondneg[op2.cc],tg_end);

              declare var
                optemp : c_operand;              -- registr vyseparovaný z levého operandu

              begin
                -- vyseparovat registr
                optemp.create_use_register(inst,info,context,edt_unsigned,vysl.get_register);

                -- jedenkrát přičíst velikost báze
                addaddimm(inst,info,context,optemp,imm32_to_unsigned(size));

              leave
                -- uvolnit pracovní registr
                optemp.free(info,context);
                end declare;

              -- adresa skoku na toto místo
              settarget(info,tg_end,getaddr(inst));

            -- ne => vymyslet registr a zakomponovat ho do adresy
            else
              declare var
                optemp : c_operand;

              begin
                -- alokovat registr
                optemp.create_new_register(inst,info,context,edt_unsigned,4);

                -- nacpat do něj velikost
                addopimm(inst,info,context,ii_mov,optemp,0);

                -- skok na konec při nesplnění podmínky
                addjump(inst,info,context,icondneg[op2.cc],tg_end);

                -- nacpat do registru velikost báze
                addopimm(inst,info,context,ii_mov,optemp,imm32_to_unsigned(size));

                -- adresa skoku na toto místo
                settarget(info,tg_end,getaddr(inst));

                -- registr použít jako bázi
                vysl.shift_by_base(inst,info,context,optemp.reg.reg);

              leave;
                -- uvolnit pracovní registr
                optemp.free(info,context);
                end declare;
              end if;
          end declare;

    when others do verify({VERIFY=}000107,true);
    end case;

  -- posunout o interní část řetězce
  if el^.t.stype in dts_string then
    vysl.shift_displacement(lstrisize32);
    end if;

  -- Ondra 18.12.2002 : chceme uložit i dynamické atributy ?
  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
    i_gen_rtattrib(inst,info,context,expr,vysl);
    end if;

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_index;



----------------------------------------------------------------------------------------------------
procedure i_gen_ref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpref;                 -- reference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu reference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el);

  case expr^.t.getpclass
    -- pointer na data
    when pc_data do
        -- vygenerovat podvýraz
        i_newcontext(context,newcontext,lm_addr,nil);
        i_load(inst,info,newcontext,context,el,vysl);

        -- obnovit registry
        vysl.refresh(inst,info,context);

        -- má pointer obsahovat nějaké run-time atributy ?
        if {context.outtyp.pattrib}expr^.t.getpattrib<>rtattribset:[] 
        
          -- ano => doplnit je do něj
          then
            declare var
              optemp : c_operand;
            begin
              -- alokovat pracovní proměnnou
              optemp.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(expr^.t.getsize));

              -- zkonstruovat celý pointer
              i_gen_compose_pointer(inst,info,context,vysl,expr^.t.getctype^.base.getutype,expr^.t.getctype^.base.getutype,{context.outtyp.pattrib}expr^.t.getpattrib,optemp);

              -- předat výsledek
              vysl.replace(info,context,optemp);

            leave
              -- uvolnit pracovní operand
              optemp.free(info,context);
              end declare;

          -- ne => pouze změnit adresní operand na hodnotový
          else
            -- změnit elementární datový typ na pointer
            verify({VERIFY=}000881,vysl.edtype<>edt_address);
            vysl.adjust_edtype(edt_pointer);

            -- velikost pointeru se měnit nemusí
            verify({VERIFY=}000882,unidata_size_to_unsigned(expr^.t.getsize)<>vysl.size);
            end if;

    -- pointer na proceduru
    when pc_subprogram do
        verify({VERIFY=}000512,el^.ntype<>nt_component or el^.getsymbol=nil);

        declare var
          instance : pexpnode;                   -- výraz určující instanci třídy
          pproc    : pentity_subprogram;         -- referencovaný podprogram

        begin
          -- referencovaný podprogram
          pproc:=pentity_subprogram(el^.getsymbol);
          verify({VERIFY=}000514,not (pproc^.etype in ets_callable));
          if pproc^.etype=et_virtual then unimplemented({UNIMP=}000174); end if;

          -- najít instanci třídy
          x_classinstance(el^.sub,instance);

          -- alokovat pracovní proměnnou
          vysl.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(expr^.t.getsize));

          declare var
            oppart : c_operand;                  -- část pointeru

          begin
            -- operand odpovídající části pointeru, která obsahuje adresu podprogramu
            oppart.clone(inst,info,context,vysl);
            oppart.adjust_size(4);

            declare var
              optemp : c_operand;                -- pracovní proměnná pro zkonstruovaný pointer

            begin
              -- adresa podprogramu
              optemp.create_imm(edt_address,4,0);
              optemp.set_relo_entity(pproc);

              -- uložit adresu na podprogram do pointeru
              addii(inst,info,ii_mov,oppart,optemp,op0);

            leave
              -- uvolnit pracovní operand
              optemp.free(info,context);
              end declare;

            -- adresa pointeru na instanci
            i_gen_load_rtattrib_addr(inst,info,context,{context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_instance,oppart);

            declare var
              optemp : c_operand;                -- pracovní proměnná pro zkonstruovaný pointer

            begin
              -- podprogram se neváže na instanci => uložit FFFFFFFF
              if pproc^.instance=tip_none then
                optemp.create_imm(edt_address,4,unsigned_to_imm32($FFFF_FFFF));

              -- podprogram se váže na instanci, ale nemáme ji => uložit NIL
              elsif pproc^.instance=tip_optional and instance=nil then
                optemp.create_imm(edt_address,4,0);

              -- máme instanci
              elsif instance<>nil and pproc^.instance<>tip_none then
                -- vygenerovat podvýraz
                i_newcontext(context,newcontext,lm_addr,nil);
                i_load(inst,info,newcontext,context,instance,optemp);
                
                -- obnovit registry
                optemp.refresh(inst,info,context);

                -- načíst do registru
                i_gen_loadreg(inst,info,context,inttype_machine_pointer,optemp,false,irm_addr);
                
                --u_nimplemented(43);

              -- jiné případy nemohou nastat
              else
                verify({VERIFY=}000515,true)
                end if;

              -- nacpat do pointeru
              addii(inst,info,ii_mov,oppart,optemp,op0);

            leave
              -- uvolnit pracovní operand
              optemp.free(info,context);
              end declare;

            -- popřípadě uložit :tag
            if rta_tag in {context.outtyp.pattrib}expr^.t.getpattrib then
              -- adresa atributu
              i_gen_load_rtattrib_addr(inst,info,context,{context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_tag,oppart);

              -- vypočítat a uložit
              i_gen_compute_rtattrib(inst,info,context,oppart,rta_tag,expr^.t.getctype^.base.getctype,expr^.t.getctype^.base.getctype);
              end if;

          leave
            -- uvolnit pracovní operand
            oppart.free(info,context);
            end declare;
          end declare;

    -- pointer na task
    when pc_task do unimplemented({UNIMP=}000064);

    -- pointer na zprávu
    when pc_message do unimplemented({UNIMP=}000083);

    when others do verify({VERIFY=}000807,true);
    end case;
  end i_gen_ref;



----------------------------------------------------------------------------------------------------
procedure i_gen_deref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpref;                 -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el);

  -- pro některé režimy načtení výrazu dereference moc nedereferencuje
  case context.mode

    -- uložení adresy a atributů na stack => načíst kompletní hodnotu pointeru
    when lm_push_addr do
        -- připravit kontext
        i_newcontext(context,newcontext,lm_pointer,nil);

        -- zkonstruovat charakteristiku typu výsledku
        declare var
          ptrsize  : tunidata_size;              -- velikost vykonstruovaného pointeru
        begin
          cpu^.getptrsize(context.rta,ptrsize);
          i_compose_outtyp(newcontext,dt_pointer,ptrsize,context.rta,expr^.t.getctype);
          end declare;

        -- vygenerovat podvýraz
        i_load(inst,info,newcontext,context,el,vysl);

    -- adresa pointeru s uloženými atributy => načíst adresu pointeru
    when lm_addr_attr do
        -- vygenerovat podvýraz
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,el,vysl);

    -- cokoliv jiného => dereferencovat
    when others do
        verifyx({VERIFY=}000558,context.mode in lms_addr-iexprloadmodeset:[lm_addr],expr^.pos);

        case el^.t.getpclass
          -- pointer na data
          when pc_data  do
              -- vygenerovat podvýraz (jako unchecked machine pointer, ať se zbavíme runtime atributů)
              i_newcontext(context,newcontext,lm_pointer_reg,inttype_machine_pointer{el^.t.getutype});
              i_load(inst,info,newcontext,context,el,vysl);

              -- adresa
              vysl.transform_reg_to_mem(edtype_from_expr(expr),0);
              if expr^.t.hassize then
                vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
                end if;

          -- pointer na proceduru
          when pc_subprogram do
              -- vygenerovat podvýraz
              i_newcontext(context,newcontext,lm_pointer,el^.t.getutype);
              i_load(inst,info,newcontext,context,el,vysl);

          -- pointer na task
          when pc_task  do unimplemented({UNIMP=}000065);

          -- pointer na zprávu
          when pc_message do unimplemented({UNIMP=}000084);

          when others do verify({VERIFY=}000808,true);
          end case;
    end case;
  end i_gen_deref;



----------------------------------------------------------------------------------------------------
procedure i_gen_attrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpattrib;              -- atribut
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu atributu.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure loadrtattrib (
        rta        : in rtattrib;
        vysl       : out c_operand) =
    -- Načtení konkrétního run-time atributu.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů

    begin
      -- načíst adresu proměnné
      i_newcontext(context,newcontext,lm_addr_attr{lm_gen},nil);
      i_load(inst,info,newcontext,context,expr^.sub,vysl);

      -- udělat z operandu atribut :"rta"
      i_gen_adjust_rta_position(rta,expr^.sub,vysl);

      -- načíst hodnotu do registru
      i_gen_loadreg(inst,info,newcontext,nil,{nil,}vysl,false,irm_int);
      end loadrtattrib;

var
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  case expr^.aclass
    -- statické atributy
    when atc_static  do
        case expr^.ata
        ---- :unchecked
        --ata_var_unchecked : i_load(inst,info,lm_gen,nil,expr^.sub,vysl);

          -- :tag
          when ata_type_tag do
              vysl.create_imm(edt_unsigned,4,0);
              vysl.set_relo_entity(expr^.sub^.t.getctype);

          -- :tag
          when ata_message_tag do
              vysl.create_imm(edt_unsigned,4,0);
              vysl.set_relo_entity(expr^.sub^.getsymbol);

          when others do verifyx({VERIFY=}000148,true,expr^.pos);
          end case;


    -- dynamické atributy
    when atc_dynamic do
        case expr^.ata
          -- :unchecked
          when ata_var_unchecked do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :length
          when ata_string_length do
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

              -- změnit velikost
              vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));

          -- :ord
          when ata_ord_ord do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :last
          when ata_expr_last do loadrtattrib(rta_last,vysl);

          -- :size
          when ata_expr_size do loadrtattrib(rta_size,vysl);

          -- :length neomezeného pole
          when ata_array_length do
              -- načíst atribut :last
              loadrtattrib(rta_last,vysl);

              -- přičíst 1
              addii(inst,info,ii_inc,vysl,op0,op0);

          -- :tag
          when ata_expr_tag do loadrtattrib(rta_tag,vysl);

          -- :tagged
          when ata_expr_tagged do
              declare var
                optemp : c_operand;

              begin
                -- načíst atribut :tag
                loadrtattrib(rta_tag,optemp);

                -- porovnat
                addii(inst,info,ii_cmp,optemp,op_0,op0);

              leave
                -- uvolnit operand
                optemp.free(info,context);
                end declare;

              -- výsledek je podmínka
              vysl.create_condition(ic_ne);

          when others do verify({VERIFY=}000282,true);--u_nimplemented(59);
          end case;

    when others do verify({VERIFY=}000147,true);
    end case;
  end i_gen_attrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  arg              : pexpitem;                   -- argument
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el,arg);
  er:=arg^.sub;

  -- konverze z ...
  case er^.t.tview
    -- ... unchecked na cokoliv
    when tview_unchecked do
        -- vygenerovat
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,er,vysl);

        -- velikost operandu
        vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));

    -- ... Full view ...
    when tview_full     do
        case el^.t.tview
          -- ... na Full view
          when tview_full do
              -- ordinální --> ordinální
              if (er^.t.stype in dts_ordinal) and (el^.t.stype in dts_ordinal) then
                -- načíst hodnotu
                i_newcontext(context,newcontext,lm_conv,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- pointer -> pointer
              elsif (er^.t.stype=dt_pointer) and (el^.t.stype=dt_pointer) then
                -- načíst hodnotu
                i_newcontext(context,newcontext,lm_pointer,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- jiné konverze neumíme
              else 
                verifyx({VERIFY=}000611,true,expr^.pos);
                end if;
            {
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,er,vysl);

              -- %%X Tady chybí konverze !

              -- velikost operandu
              vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
            }


          -- ... Partial view

          when others do verify({VERIFY=}000272,true);
          end case;

    when others do verify({VERIFY=}000149,true);
    end case;

  -- vygenerovat podvýraz
  --i_load(inst,info,,arg^.sub^.t.typ,el,op1);

  --u_nimplemented(56);
  end i_gen_typecast;



----------------------------------------------------------------------------------------------------
procedure i_gen_message_send (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu odeslání zprávy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argument
  opnone           : c_operand;                  -- prázdný výsledek
  newcontext       : iexprcontext;               -- kontext výrazu

begin
  -- podvýrazy
  expr^.get(el,arg);

  -- tag výjimky
  i_newcontext(context,newcontext,lm_push_value,nil);
  i_load(inst,info,newcontext,context,el,opnone);

  -- parametry
  if arg<>nil

    -- má parametry
    then
      unimplemented({UNIMP=}000104);

    -- nemá parametry => na stack dát NIL
    else
      i_gen_pushstack(inst,info,context,op_0);
      end if;

leave
  -- uvolnit operand
  opnone.free(info,context);
  end i_gen_message_send;



----------------------------------------------------------------------------------------------------
procedure i_gen_callspec (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcallspec;            -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání speciální metody.
----------------------------------------------------------------------------------------------------
var
  opnone           : c_operand;                  -- prázdný výsledek
  newcontext       : iexprcontext;               -- kontext výrazu
  el               : pexpnode;                   -- instance třídy (je-li to metoda třídy)
  arglist          : pexpitem;                   -- seznam parametrů

begin
  -- oddělit instanci třídy/modul a parametry
  expr^.get(el,arglist);

  -- je speciální metoda již pevně určena ?
  if (expr^.spec<>nil) and (el=nil)

    -- ano => zavolat ji přímo
    then
      verify({VERIFY=}000581,(arglist=nil) or (el<>nil));

      -- zavolat jako normální podprogram
      i_gen_call_subprogram(inst,info,context,expr,expr^.spec,vysl);

    -- ne => vybrat metodu podle tagu instance třídy/modulu
    else
      verify({VERIFY=}000582,(el=nil) or (arglist<>nil));

      case el^.nclass
        -- podvýraz je instance třídy
        when nc_var     do
            verify({VERIFY=}000583,not el^.t.isclass);

            -- adresu instance uložit na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,el,opnone);

            -- zavolat speciální metodu
            if expr^.spec=nil

              -- a to první dostupnou
              then
                i_dispatch_special(inst,info,context,expr^.spectype);

              -- jinak tu pevně určenou
              else
                declare var
                  op1 : c_operand;               -- operand

                begin
                  -- vrátit adresu procedury
                  i_gen_subprogram_address(inst,info,context,expr^.spec,true,op1);

                  -- zavolat
                  addii(inst,info,ii_call,op1,op0,op0);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;
                end if;

        -- podvýraz je modul
        when nc_module  do
            unimplemented({UNIMP=}000194);

        when others do verify({VERIFY=}000809,true);
        end case;
      end if;

  -- výsledek veškerý žádný
  --nullop(vysl,io_none);

{ Původní verze pouze pro speciální metody třídy:

  if expr^.sub<>nil

    -- máme podvýraz, podívat se, co je zač
    then
      case expr^.sub^.nclass
        -- podvýraz je instance třídy
        when nc_var     do
            -- adresu instance uložit na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,expr^.sub,opnone);

            -- zavolat speciální metody
            i_dispatch_special(inst,info,expr^.spectype);


        -- podvýraz je modul
        when nc_module  do
            unimplemented({UNIMP=}000213);


        when others do verify({VERIFY=}000810,true);
        end case;

    -- podvýraz nemáme, tudíž musíme mít adresu entry rovnou k dispozici
    when others do
      unimplemented({UNIMP=}000125);
      end if;

  -- výsledek veškerý žádný
  nullop(vysl,io_none);
 }
  end i_gen_callspec;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_rtl (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcallrtl;             -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu přímého volání funkce RTL.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_rtl;

var
  pproc            : pentity_subprogram;         -- volaná RTL procedura
  call             : icallconvention;            -- volací konvence
  pinst            : picodeinst;                 -- instance volané procedury
  ptyp             : pentity_type;               -- typ procedury
  newcontext       : iexprcontext;               -- kontext podvýrazů
  params_size      : t_unsigned;

begin
  -- nalézt RTL proceduru
  rtl_get_entity(expr^.rtl_proc,pproc);
  verify({VERIFY=}000718,pproc=nil or else pproc^.etype not in ets_callable);


  ---- (1) příprava volání: zjistit instanci, volací konvenci, typ procedury ----
  i_gen_call_subprogram_prepare(inst,info,context,expr,pproc,call,pinst,ptyp);


  ---- (2) zpracovat argumenty ----
  i_gen_call_subprogram_parameters(inst,info,context,expr,pproc,call,pinst,ptyp,params_size);


  ---- (3) volání ----
  addcallrtl(inst,info,context,expr^.rtl_proc,true);
  end i_gen_call_rtl;



----------------------------------------------------------------------------------------------------
procedure i_gen_this (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpthis;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu THIS.
----------------------------------------------------------------------------------------------------
begin
  -- vygenerovat a načíst adresu instance třídy
  i_load_this_address(inst,info,context,edtype_from_expr(expr),unidata_size_to_unsigned(expr^.t.getsize),uda_0,vysl);
  --verify({VERIFY=}000696,vysl.size<>unidata_size_to_unsigned(expr^.t.getsize));
  end i_gen_this;


    
----------------------------------------------------------------------------------------------------
procedure i_gen_fake_tag (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpfaketag;             -- fake tag interfacu třídy
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu fake tagu interfacu třídy.
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat operand
  vysl.create_imm(edt_unsigned,4,0);

  -- doplnit relokaci
  vysl.set_relo_interface(expr^.interface);
  end i_gen_fake_tag;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
#if #declared ondra; then;
with
  standard.conversions;
#end if;

begin
  verify({VERIFY=}000028,(expr=nil) or (expr^.zprac<>expr^.zprac:last));

  -- vygenerovat výraz
  case expr^.ntype
    -- binární operátor
    when nt_operator  do i_gen_operator(inst,info,context,pexpoper(expr),vysl);

    -- unární operátor
    when nt_unary     do i_gen_unary(inst,info,context,pexpunary(expr),vysl);

    -- komponenta
    when nt_component do i_gen_component(inst,info,context,pexpcomponent(expr),vysl);

    -- přímá hodnota
    when nt_imm       do i_gen_imm(inst,info,context,pexpimm(expr),vysl);

    -- agregát
    when nt_aggregate do i_gen_aggregate(inst,info,context,pexpaggregate(expr),vysl);

    -- volání procedury
    when nt_call      do i_gen_call(inst,info,context,pexplist(expr),vysl);

    -- index pole
    when nt_index     do i_gen_index(inst,info,context,pexpindex(expr),vysl);

    -- reference
    when nt_ref       do i_gen_ref(inst,info,context,pexpref(expr),vysl);

    -- dereference
    when nt_deref     do i_gen_deref(inst,info,context,pexpref(expr),vysl);

    -- atribut
    when nt_attrib    do i_gen_attrib(inst,info,context,pexpattrib(expr),vysl);

    -- přetypování
    when nt_typecast  do i_gen_typecast(inst,info,context,pexplist(expr),vysl);

    -- odeslání zprávy
    when nt_send      do i_gen_message_send(inst,info,context,pexplist(expr),vysl);

    -- volání speciální metody
    when nt_callspec  do i_gen_callspec(inst,info,context,pexpcallspec(expr),vysl);

    -- přímé volání funkce RTL
    when nt_call_rtl  do i_gen_call_rtl(inst,info,context,pexpcallrtl(expr),vysl);

    -- THIS
    when nt_this      do i_gen_this(inst,info,context,pexpthis(expr),vysl);

    -- fake tag interfacu třídy
    when nt_fake_tag  do i_gen_fake_tag(inst,info,context,pexpfaketag(expr),vysl);

    -- selektor slotu taskové proměnné
    when nt_task_var_slot do i_gen_task_var_slot(inst,info,context,pexptaskvarslot(expr),vysl);

    -- jiné symboly tu nemají co dělat
    when others do
      #if #declared ondra; then;
        dumptree(expr);
        debug_dump(unsigned_to_string(expr^.ntype:ord));
      #end if;
        verifyx({VERIFY=}000029,true,expr^.pos);

    end case;
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_gen_expr =
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- připravit kontext
    i_createcontext(context,lm_gen,nil);

    -- vygenerovat výraz
    i_gen(inst,info,context,expr,vysl);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_gen_expr;



----------------------------------------------------------------------------------------------------
procedure i_gen_cond =
-- Generování kódu výrazu.
-- Pokud je cíl skoku nastaven na TGFALLTHRU, tak neskočí nikam.
----------------------------------------------------------------------------------------------------
with
  ci_logical;

var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu
  newcontext       : iexprcontext;               -- kontext podvýrazu

begin
  verify({VERIFY=}000601,(ttarget=tgfallthru) and (ftarget=tgfallthru));

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani podminky ------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat podmínku
    if (expr^.ntype=nt_operator) and (pexpoper(expr)^.oper in expopertypeset:[op_and,op_or,op_and_then,op_or_else])

      -- generovat řetěz konjunkcí/disjunkcí
      then
        -- připravit kontext
        i_createcontext(context,lm_gen,nil);

        -- vygeneovat
        i_gen_logical_chain(inst,info,context,pexpoper(expr),ttarget,ftarget,vysl);

      -- generovat jako obyčejný výraz
      else
        declare var
          cc       : icond;                      -- podmínka

        begin
          declare var
            op1    : c_operand;                  -- operand

          begin
            -- připravit kontext
            i_createcontext(context,lm_gen{reg},expr^.t.getctype);

            -- vygenerovat a načíst výraz
            i_newcontext(context,newcontext,lm_reg,nil);
            i_load(inst,info,newcontext,context,expr,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            if op1.optype=io_cc

              -- přímo podmínka
              then cc:=op1.cc

              -- ještě porovnat
              else
                -- porovnat
                addii(inst,info,ii_cmp,op1,op_0,op0);

                -- podmínka
                cc:=ic_nz;
                end if;

          leave
            -- uvolnit operand
            op1.free(info,context);
            end declare;

          -- výsledný skok
          i_gen_logical_jump(inst,info,context,false,cc,ttarget,ftarget,vysl);
          end declare;
        end if;
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;

leave
  -- uvolnit operand
  vysl.free(info,context);
  end i_gen_cond;



----------------------------------------------------------------------------------------------------
procedure i_load_message_code =
-- Načte kód zprávy do EAX.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu
  newcontext       : iexprcontext;               -- kontext podvýrazu

begin
  verify({VERIFY=}000310,(expr^.ntype<>nt_accept) or not (expr^.sub^.nclass in ncs_message_code));

  begin
    -- připravit kontext
    i_createcontext(context,lm_reg_eax,nil);

    -- vygenerovat výraz
    i_newcontext(context,newcontext,lm_reg_eax,nil);
    i_load(inst,info,newcontext,context,expr^.sub,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;
  end i_load_message_code;



----------------------------------------------------------------------------------------------------
procedure i_load_expr =
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni vyrazu -----------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a načíst výsledek
    i_load(inst,info,{new}context,context,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_expr;



----------------------------------------------------------------------------------------------------
procedure i_load_subexpr =
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni podvyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a načíst výsledek
    i_load(inst,info,subcontext,supercontext,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,supercontext);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subexpr;



----------------------------------------------------------------------------------------------------
procedure i_load_rtattrib =
-- Načte požadovaný run-time atribut daného výrazu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- načíst adresu proměnné
    i_createcontext(context,lm_addr_attr,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- udělat z operandu atribut ":rta"
    i_gen_adjust_rta_position(rta,expr,vysl);
{
    -- načíst hodnotu do registru
    i_gen_loadreg(inst,info,context,{nil,}vysl,false,irm_int);
}
    -- načíst do temporary proměnné
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int);
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_load_subrtattrib =
-- Načte požadovaný run-time atribut daného výrazu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- načíst adresu proměnné
    i_newcontext(supercontext,context,lm_addr_attr,nil);
    i_load(inst,info,context,supercontext,expr,vysl);

    -- udělat z operandu atribut ":rta"
    i_gen_adjust_rta_position(rta,expr,vysl);
  {
    -- načíst hodnotu do registru
    i_gen_loadreg(inst,info,supercontext,{nil,}vysl,false,irm_int);
  }
    -- načíst do temporary proměnné
    if reg
      then i_gen_loadreg(inst,info,supercontext,nil,vysl,false,irm_int);
      else i_gen_loadtemp(inst,info,supercontext,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subrtattrib;



----------------------------------------------------------------------------------------------------
procedure i_load_length =
-- Načte run-time atribut :length daného výrazu.
-- %%X Něco jako záplata. Vymyslet sjednocení s I_LOAD_RTATTRIB asi na bázi
-- sloučení s I_GEN_ATTRIB.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- načíst adresu proměnné
    i_createcontext(context,lm_gen,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- změnit velikost
    vysl.adjust_size(4);

    -- načíst do temporary proměnné
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int)
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_length;



----------------------------------------------------------------------------------------------------
procedure i_load_sublength =
-- Načte run-time atribut :length daného výrazu.
-- %%X Něco jako záplata. Vymyslet sjednocení s I_LOAD_RTATTRIB asi na bázi
-- sloučení s I_GEN_ATTRIB.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- načíst adresu proměnné
    i_newcontext(supercontext,context,lm_gen,nil);
    i_load(inst,info,context,supercontext,expr,vysl);

    -- změnit velikost
    vysl.adjust_size(4);

    -- načíst do temporary proměnné
    if reg
      then i_gen_loadreg(inst,info,supercontext,nil,vysl,false,irm_int)
      else i_gen_loadtemp(inst,info,supercontext,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_sublength;



----------------------------------------------------------------------------------------------------
procedure initopertab =
-- Inicializace řídící tabulky optimalizace binárních operátorů.
----------------------------------------------------------------------------------------------------
with 
  ci_integer,
  ci_logical,
  ci_pointer,
  ci_string,
  ci_set;

begin
  ---- celočíselné ----
  -- *
  oset1s(opertab,op_mul,dts_integer,^i_gen_op_integer_mul);

  -- div mod
  osetss(opertab,[op_idiv,op_imod],dts_integer,^i_gen_op_integer_div_mod);

  -- + - bitové AND OR XOR SHL SHR
  osetss(opertab,[op_add,op_sub,op_bitand,op_bitor,op_bitxor,op_shl,op_shr],dts_integer,^i_gen_op_integer);

  -- :=
  oset1s(opertab,op_assign,dts_integer,^i_gen_op_assign);


  ---- znakové ----
  -- :=
  oset1s(opertab,op_assign,dts_char,^i_gen_op_assign);


  ---- logické ----
  -- AND OR
  osetss(opertab,[op_and_then,op_or_else,op_and,op_or],dts_u_logical,^i_gen_op_logical_and_or);

  -- XOR
  oset1s(opertab,op_xor,dts_u_logical,^i_gen_op_logical_xor);

  -- :=
  oset1s(opertab,op_assign,dts_logical,^i_gen_op_assign_logical);


  ---- výčtové ----
  -- :=
  oset1s(opertab,op_assign,dts_enum,^i_gen_op_assign);


  ---- ordinální typy obecně ----
  -- < <= > >= <> =
  osetss(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dts_ordinal,^i_gen_op_compare_ordinal);


  ---- pointery ----
  -- :=
  oset11(opertab,op_assign,dt_pointer,^i_gen_op_assign_pointer);

  -- <> =
  osetss(opertab,[op_ne,op_eq],dts_pointer,^i_gen_op_compare_pointer);


  ---- řetězce ----
  -- :=
  oset1s(opertab,op_assign,dts_string,^i_gen_op_assign_string);

  -- &
  oset1s(opertab,op_concat,dts_string,^i_gen_op_concat_string);

  -- < <= > >=
  osetss(opertab,[op_lt,op_le,op_gt,op_ge],dts_string,^i_gen_op_order_string);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_string,^i_gen_op_compare_string);

  ---- pole ----
  -- :=
  oset1s(opertab,op_assign,dts_array,^i_gen_op_assign);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_array,^i_gen_op_compare_array);


  ---- množiny ----
  -- :=
  oset11(opertab,op_assign,dt_set,^i_gen_op_assign);

  -- + - *
  osetss(opertab,[op_union,op_diff,op_isect],dts_set,^i_gen_op_set);

  -- IN NOT IN
  osetss(opertab,[op_in,op_notin],dts_u_set,^i_gen_op_in_set);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_set,^i_gen_op_compare_set);


  ---- recordy ----
  -- :=
  oset11(opertab,op_assign,dt_record,^i_gen_op_assign);

  -- = <>
  osets1(opertab,[op_eq,op_ne],dt_record,^i_gen_op_compare_record);


  ---- tagy ----
  -- :=
  oset1s(opertab,op_assign,dts_tag,^i_gen_op_assign);

  -- <> =
  osetss(opertab,[op_ne,op_eq],dts_tag,^i_gen_op_compare_ordinal);

  ---- třídy ----
  -- :=
  oset1s(opertab,op_assign,dts_class,^i_gen_op_assign);

  ---- unchecked ----
  --oset11(opertab,op_assign,st_unchecked,^i_gen_op_assign);
  end initopertab;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initopertab;
  end entry;



end ci_expr;
