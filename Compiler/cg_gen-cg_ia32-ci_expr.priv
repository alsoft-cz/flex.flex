----------------------------------------------------------------------------------------------------
module private ci_expr =
-- Překladač Flexu.
-- Generování výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvořil.
----------------------------------------------------------------------------------------------------
{

-- Dodělat přejmenování AH-AL, BH-BL, ..., aby se nemuselo v LOADREG
   dělat MOV AL,AH

-- Kam patří konverze ? Má je tam přidávat typová kontrola (resp. nějaká
   jiná fáze překladu výrazu), nebo si je má domýšlet až generátor kódu ?

   ad 1) To je asi výhodnější, konverze aritmetických výrazů jsou triviální
         a u manipulací s řetězci/poli/recordy potřebuju vědět na čem jsem,
         abych dokázal zvolit speciální variantu překladu.

   ad 2) V druhém případě by to mělo asi být součástí LOADREG.


-- Optimalizace:
     * zarovnání
     * změna pořadí instrukcí
     * (částečné) rozvíjení cyklů
     * řídící proměnné cyklů do registrů
     * často používané podvýrazy do registrů
     * registry se známou konstantní hodnotou (zpravidla 0 nebo 1)
     * v EDX zbyde při násobení dostatečně malých čísel nula

     * násobení 3 a 5 a 9 pomocí LEA
     * násobení kombinací ADD/SHL/LEA: například 12*EAX: SHL EAX,2 LEA EAX,[EAX+2*EAX]
     * rozpoznání indexu tvaru X*scale, kde scale=2,4,8
     * "if x>0 then x:=-1 else x:=0" --> "cmp eax,1; sbb eax,eax"
     * registr EBP vůbec nepotřebuju k adresaci lokálních proměnných - stačí
       mi na to ESP, vždyť v každém okamžiku vím, co je na stacku
     * málo pravděpodobný kód lze s výhodou umístit do úplně jiné oblasti
       code segmentu:

           read(...,chyba);
           if chyba then
             write('chyba');
             return;
             end if;
           ...
           end proc;

       přeložit jako:

           read(...,chyba);
           if chyba then goto x end if  -- zde se eliminuje jeden skok
           ...
         r:
           end proc;

         x:write('chyba');
           goto r;
     * místo "mov exc,[x]; push eax" dělat jen "push [x]"
     * ve výrazu (s1 & s2)[i] fyzicky nespojovat řetězce ale inteligentně
       přepočítat index
     * příkaz typu:
          loop
            if invariant_vzhledek k cyklu
              then ...
              else ...
              end if
            end loop
       přeložit jako dva cykly s vyhodnocením IFu vně.
     * pro rozsáhlé konstantní množiny generovat membership-test funkce
       (podobně by se daly řešit i další operace na velkými konstantními
       agregáty)

-- Specifické optimalizace pro procesory AMD:
     * místo SHL EAX,1 generovat ADD EAX,EAX - třeba procesor AMD K6 má
       dvě sčítačky a jen jednu shiftovačku - nicméně se tím nastaví
       jiné flagy (AF)
     * na procesoru AMD K6 místo XOR EAX,EAX dělat MOV EAX,0
     * MUL a IMUL nahrazovat za SHL ADD jen do celkové latence 3, pak
       je na AMD rychlejší dělat MUL
     * místo CDQ dělat MOV EDX,EAX SAR EDX,31 - je to rychlejší na dekódování
       (řekl bych, že pro CBW se to nevyplatí, protože MOV AH,AL bude zmatený
       z použití dvou čtvrtek téhož registru - ale je to jen doměnka)
     * místo dělení násobit převrácenou hodnotou - viz 21924.PDF str. 75 (65)

-- Odstranit %%OLD

-- Obsluha agregátů je dost natvrdo (=neoptimálně), protože je to poměrně
   komplikovaná záležitost a babrat se s tím budu až ve 4.0.1.

-- Dodělat:
    +I027 - někde to generuje chybné instrukce
    -I099 - inkluze množiny (< <= > >=)
    +I344 - v proceduře i_gen_load_string_and_last se zdá, že výraz nemá
            dynamické atributy :size ani :last
    -I349 - uvolnění nepoužitého univerzálního registru
     I388 - pokus o zjištění tagu non-tagged typu
    -U115 - konkatenace unconstrained stringů jejímž výsledkem je opět
            unconstrained string
     U122 - volání virtuální metody
    +U132 - množinové + - a * na operandech o nepříznivé velikosti
    +U154 - agregát množiny
    +U170 - porovnání binárního bloku na NIL
    -U173 - nějaký výpočet :last pro "pchararray:=pchar:unchecked;"

     I027 - někde to generuje chybné instrukce
     I093
     I107
     I148 - volání metody předka
     U118
     U140
}
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_base.cc_type,
  cc_base.cc_util,
  cc_base.cc_rtl,
  cc_base.cc_debug,
  cc_attr,
  cx_expr.cx_util,
  cx_expr.cx_imm,
  ci_code.ci_operand,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_context,
  ci_reg,
  ci_fragment,
  ci_fragment.ci_rta,
  ci_struct,
  cp_cpu.cp_32.cp_metadata,
  cp_cpu.cp_32.cp_util,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_ia32.ci_instr,
  cc_options;

----- %%TECH Režimy generování výrazu --------------------------------------------------------------
-- Generátor výrazů dokáže pracovat v několika režimech, resp. předávat výsledek výpočtu výrazu 
-- v několika různých tvarech.
--   Procedury pro generování různých druhů uzlů ([i_gen_*]) pracují v určitém základním režimu, 
-- který standardně generuje výsledek ve svým způsobem přirozeně minimálním tvaru - součet dvou 
-- celočíselných výrazů vrátí v registru, agregát pole v dočasné proměnné, proměnnou coby 
-- specifikaci její adresy a podobně.
--
-- Procedura [i_load] navíc dovoluje výsledek převést do požadovaného tvaru nebo s ním provést 
-- požadovanou operaci (například uložit na stack).
--   Požadovaný tvar výsledku je specifikován kontextem generování výrazu, zejména proměnnou 
-- [context.mode]. Rozlišují se módy načtení výrazu vedoucí na hodnotu objektu a módy vedoucí na
-- adresu hodnoty objektu. Speciálním případem je mód [lm_gen], který předává výsledek v přirozeném
-- tvaru bez úprav.
--
-- Módy vedoucí na hodnotu objektu:
--
--   [lm_conv]       -- výsledek v přirozeném tvaru je konvertován na požadovaný typ
--   [lm_reg]        -- výsledek je načten do registru (mimo přímých hodnot)
--   [lm_reg_all]    -- výsledek je načten do registru i když je to přímá hodnota
--   [lm_imm8_cl]    -- výsledek je konvertován na osmibitovou přímou hodnotu nebo uložen do CL
--                      (s oříznutím)
--   [lm_reg_eax]    -- výsledek je uložen do EAX
--   [lm_push_value] -- hodnota výrazu je uložena na stack
--   [lm_temp_value] -- hodnota výrazu je uložena do temporary proměnné, kromě přímé hodnoty, 
--                      která je ponechána v původním stavu
--   [lm_pointer]    -- výsledek je interpretován jako pointer a informace o run-time atributech 
--                      v operandu, které po vygenerování přirozeného tvaru klasifikují pointer 
--                      samotný, jsou nahrazeny informacemi o run-time atributech v pointeru 
--                      uložených (!!!), tedy klasifikujících objekt, na který pointer odkazuje
--                     
--   Obzlášť POZOR na specifické zacházení módu [lm_pointer] s run-time atributy. Je určen téměř
--   výhradně pro porovnávání pointerů.
--
--   Před aplikací hodnotového módu načtení je volána metoda [i_ensure_value], která zajistí, že
--   operand skutečně reprezentuje hodnotu.
-- 
-- Módy vedoucí na adresu hodnoty objektu:
--
--   [lm_addr]       -- adresa objektu určeného podvýrazem; adresu načte do registru nebo ponechá
--                      konstantní, pokud je nastaven preferovaný registr (v módu [irm_addr]), 
--                      vždy načte adresu do něj (a to i konstantu)
--   [lm_addr_attr]  -- adresa objektu obsahujícího dynamické atributy (pokud je podvýraz parametr 
--                      předávaný hodnotou (proměnná s implicitní dereferencí), je výsledkem adresa
--                      pointeru na tento objekt; podrobněji viz dále); adresa nemusí být nutně
--                      v registru, výsledkem je adresa reference na hodnotu nebo adresa hodnoty
--                      samotné
--   [lm_imm_to_rel] -- je-li výsledkem přímá hodnota, je interpretována jako relativní adresa
--   [lm_push_addr]  -- adresa hodnoty výrazu je uložena na stack
--   [lm_push_and_load_addr] -- adresa hodnoty výrazu je uložena na stack a současně vrácena jako 
--                      výsledek výpočtu výrazu
--   [lm_temp_addr]  -- adresa objektu je uložena do temporary proměnné
--
--   Před aplikací adresního módu načtení je volána metoda [i_ensure_address], která zajistí, že
--   operand skutečně reprezentuje adresu. Pokud reprezentuje hodnotu bez adresy (například
--   mezivýsledek uložený v registru, přímá hodnota a podobně), uloží ji do pracovní proměnné
--   a vrátí adresu této pracovní proměnné.
--     Dva nejdůležitější adresní módu načtení jsou [lm_addr] a [lm_addr_attr]. První z nich načte
--   adresu objeku do registru a je tak vhodný pro použití v situacích, kdy je potřeba manipulovat
--   s obecně velkým objektem (string, pole, record a podobně). Druhý režim ([lm_addr_attr]) je
--   určen pro situace, kdy je potřeba kromě hodnoty zjistit i její dynamické atributy, které jsou
--   typicky uloženy v referenci na hodnotu. V takové situaci je výsledkem právě adresa reference na
--   hodnotu. Po použití dynamických atributů je potřeba zavolat proceduru
--   [i_gen_load_address_to_register_with_dereference], která načte adresu do registru a je-li to
--   potřeba, tak provede dereferenci. Teprve potom je možné zaručeně pracovat s vlastní hodnotou.
--
-- Při generování musí být zvláštní pozornost věnována dynamickým atributům.
-- Požadované dynamické atributy jsou uloženy v proměnné CONTEXT.RTA a jsou
-- přípustné pouze v režimech LM_ADDR_ATTR a LM_PUSH_ADDR.
--   Obsluha dynamických atributů vyžaduje přímo úpravy v procedurách
-- I_GEN_*, nelze ji zahrnout pouze do I_LOAD. Naštěstí je vyžadována jen
-- u konkrétních typů podvýraz. Obecně lze dynamické atributy vyžadovat
-- u těchto typů výrazů:
--   - proměnná libovolného typu  -- pokud je to parametr s dynamickými
--                                   atributy, převezmou se; ostatní atributy
--                                   se určí staticky
--   - dereferencovaný pointer    -- některé atributy jsou součástí pointeru,
--                                   ostatní se určí staticky
--   - výraz kompozitního typu, konkrétně:
--     - zřetězení polí/řetězců   -- :last a :size se vypočítají během
--                                   zřetězování, :tag je určen staticky
--     - množinové operace + - *  -- smysl má pouze atribut :tag a ten je
--                                   určen staticky
--     - agregát                  -- :last a :size se vypočítají při
--                                   konstrukci agregátu, nebo jsou určeny
--                                   staticky
----------------------------------------------------------------------------------------------------

----- %%TECH Generování zkrácených přiřazení -------------------------------------------------------
-- Podle definice jazyka se krácené přiřazení tvaru "A1 op ... op An" chová
-- stejně jako přiřazení tvaru "A1 := A1 op ... op An". Z toho vyplývají
-- omezení pro generátor kódu - když je například op=+, nelze k A1 přičítat
-- hodnoty ostatních operandů, ale musí se hodnota A1 zkopírovat do registru.
--   Podobně třeba při spojování řetězců se musí dát pozor na případ "s & s".
-- Lze sice postupně připojovat operandy vpravo k operandu vlevo, ale nesmí
-- se při tom změnit hodnota :length levého operandu.
----------------------------------------------------------------------------------------------------

var
  op2cc            : const array op_eq..op_ge,t_logical of icond := [
      -- operátor --- UNSIGNED -- SIGNED --
      for op_eq  use [ic_e,       ic_e      ],
      for op_ne  use [ic_ne,      ic_ne     ],
      for op_lt  use [ic_b,       ic_l      ],
      for op_le  use [ic_be,      ic_le     ],
      for op_gt  use [ic_a,       ic_g      ],
      for op_ge  use [ic_ae,      ic_ge     ]];


----------------------------------------------------------------------------------------------------
procedure i_gen (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpnode;                -- strom
    vysl           : out c_operand);             -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------



type
  -- generovací metoda
  topergen         = procedure (
      inst         : in out icodeinst;           -- instance
      info         : in out igeninfo;            -- informace o průběhu generování
      context      : in out iexprcontext;        -- kontext generování výrazu
      expr         : in pexpoper;                -- strom
      vysl         : out c_operand);             -- výsledek
  popergen         = ^topergen;

  -- řídící tabulka generování binárních operátorů
  topertab         = array expopertype,tdatatype of popergen;

var
  opertab          : topertab;



----------------------------------------------------------------------------------------------------
procedure oset11 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end oset11;



----------------------------------------------------------------------------------------------------
procedure oset1s (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=method;
      end if;
    end loop;
  end oset1s;



----------------------------------------------------------------------------------------------------
procedure osets1 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      tab[i,stype]:=method;
      end if;
    end loop;
  end osets1;



----------------------------------------------------------------------------------------------------
procedure osetss (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end osetss;



----------------------------------------------------------------------------------------------------
#separate private ci_rcheck;
-- behove kontroly
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_get_load_mode_by_requested_rta (
    expr           : in pexpnode;                -- generovaný výraz
    rta            : in rtattrib;                -- atribut, který se bude zjišťovat
    addr_otherwise : in t_logical := false)      -- T-pro statické atributy vrátit [lm_addr]
    return iexprloadmode =                       -- doporučený mód načtení výrazu
-- Určí nejvhodnější mód načtení výrazu potřebný pro načtení uvedeného run-time atributu.
----------------------------------------------------------------------------------------------------
begin
  case expr^.rta_modes[rta]
    when rtm_static             do 
        if addr_otherwise
          then result:=lm_addr
          else verify({VERIFY=}001071);
          end if;
    when rtm_stored_in_value    do result:=lm_gen;
    when rtm_stored_in_address  do result:=lm_addr_attr;
    when rtm_stored_in_tag      do result:=i_get_load_mode_by_requested_rta(expr,rta_tag);
    when rtm_computed_from_size do result:=i_get_load_mode_by_requested_rta(expr,rta_size);
    when rtm_computed_from_last do result:=i_get_load_mode_by_requested_rta(expr,rta_last);
    when rtm_invalid            do verify({VERIFY=}001258);
    end case;
  end i_get_load_mode_by_requested_rta;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast_fixed (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- code generation run info
    context        : in out iexprcontext;        -- expression code generation context
    expr           : in pexpnode;                -- expression
    vysl           : in out c_operand);          -- operand
-- Generate fixed-point value type conversion.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_load (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    subcontext     : in out iexprcontext;        -- kontext podvýrazu
    supercontext   : in out iexprcontext;        -- kontext výrazu
    sub            : in pexpnode;                -- generovaný podvýraz
    vysl           : out c_operand) =            -- výsledek
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.begin: ' & sub^.dump);
    end if;
#end if;

  -- nastavit preferenci registrů
  case subcontext.mode
    -- do ECX/CX/CL
    when lm_imm8_cl do i_setrpref(subcontext,in_ecx,irm_int);

    -- do EAX/AX/AL
    when lm_reg_eax do i_setrpref(subcontext,in_eax,irm_int);

    -- v ostatních případech preference není (resp. podle původního kontextu)
    when others     do -- nic nedělat
    end case;

  -- nastavit původní typ výrazu
  i_set_orgtyp(subcontext,sub^.t.getutype);

  -- vygenerovat podvýraz
  i_gen(inst,info,subcontext,sub,vysl);

  -- má se načíst hodnota
  if subcontext.mode in lms_value then
    -- zajistit, že se jedná opravdu o hodnotu
    i_ensure_value(inst,info,subcontext,vysl);

    -- interní kontrola správnosti nastavení elementárního datového typu právě vygenerovaného operandu
    declare var
      edtype       : t_elementary_data_type;     -- elementární datový typ, který by měl operand mít

    begin
      -- jaký elementární datový typ by měl mít tento výraz?
      edtype:=edtype_from_expr(sub);

      -- %%X Kontrola by se dala zpřísnit, pokud by se následující unifikace signed/unsigned
      -- prováděla pouze pokud nadřízený uzel je přetypování.
      
      -- jsou dovoleny volné, obousměrné konverze mezi některými typy
      if edtype in edts_ordinal and vysl.edtype in edts_ordinal then
        edtype:=vysl.edtype;
        end if;

      -- zkontrolovat
      verify({VERIFY=}001073,vysl.edtype<>edtype);
      end declare;

  -- má se načíst adresa
  elsif subcontext.mode in lms_addr then
    -- zajistit, že se jedná opravdu o adresu hodnoty
    i_ensure_address(inst,info,subcontext,vysl);

  -- nějaký neznámý režim načtení výrazu
  elsif subcontext.mode<>lm_gen then
    verify({VERIFY=}000877,true);
    end if;

  -- zafixovat původní typ výrazu do operandu
  if vysl.optype<>io_none then
    vysl.set_orgtyp(subcontext.orgtyp);
    end if;

  -- provest behove kontroly dokud je vysledek cerstvy
  -- %%X při lms_addr nemají runtime kontroly smysl, ne ?
  ci_rcheck.i_gen_runtime_checks(inst,info,subcontext,rchcl_load,sub^,vysl);

  -- načíst hodnotu
  case subcontext.mode

    -- pouze generovat
    when lm_gen         do -- nic nedělat

    ----- Načtení hodnoty --------------------------------------------------------------------------

    -- konvertovat na typ výsledku
    when lm_conv        do
        -- rozhodnout podle datového typu výrazu
        case sub^.t.getctype()^.stype
          -- fixed-point
          when dt_fixed do
              -- generate conversion
              i_gen_typecast_fixed(inst,info,subcontext,sub,vysl);

          -- floating-point
          when dt_float do
              unimplemented({UNIMP=}000302);
              -- generate conversion
              --i_gen_typecast_float(inst,info,subcontext,sub,vysl);
          
          -- ostatní načíst do registru
          -- %%TODO(fixed-point) upravit --- zjistit, co tady muze prijit a udelat vetev when...
          when others do
              -- liší-li se od velikosti podvýrazu...
              if subcontext.rsize<>vysl.size then
                i_gen_load_value_to_register(inst,info,subcontext,sub^.t.getctype,vysl,for force_reg use vysl.optype=io_cc and subcontext.outpref<>iop_cc);
                end if;
          end case;

    -- konvertovat a načíst do registru
    when lm_reg         do i_gen_load_value_to_register(inst,info,subcontext,sub^.t.getctype,vysl);

    -- konvertovat a načíst do registru (i přímou hodnotu)
    when lm_reg_all     do  i_gen_load_value_to_register(inst,info,subcontext,sub^.t.getctype,vysl,for force_reg use true);

    -- konvertovat a načíst do CL nebo ponechat const.
    when lm_imm8_cl     do i_gen_load_value_to_imm8_cl(inst,info,subcontext,vysl);

    -- konvertovat a načíst do EAX
    when lm_reg_eax     do i_gen_load_value_to_eax(inst,info,subcontext,vysl);

    -- načíst hodnotu a uložit na stack
    when lm_push_value  do 
           -- pro konstrukci pointeru budou potřeba run-time atributy referencované hodnoty
           if vysl.edtype=edt_pointer then
             i_rta_set_modes_of_referenced_value(sub,vysl);
             end if;

           -- uložit na stack
           i_gen_store_value(inst,info,subcontext,sub^.t.getctype,vysl,tsd_stack);

    -- uložit hodnotu do temporary proměnné, nebo nechat imm
    when lm_temp_value  do 
           -- pro konstrukci pointeru budou potřeba run-time atributy referencované hodnoty
           if vysl.edtype=edt_pointer then
             i_rta_set_modes_of_referenced_value(sub,vysl);
             end if;

           -- uložit do temporary proměnné
           i_gen_store_value(inst,info,subcontext,sub^.t.getctype,vysl,tsd_temporary);

    -- načíst pointer a informace o v něm uložených run-time atributech
    when lm_pointer     do i_rta_set_modes_of_referenced_value(sub,vysl);

    ----- Načtení adresy ---------------------------------------------------------------------------

    -- načíst adresu
    when lm_addr        do
        -- načíst adresu
        if subcontext.rpref.reg<>in_none and subcontext.rpref.mode=irm_addr
          then i_gen_load_address_to_register_with_dereference(inst,info,subcontext,vysl,for force_reg use true,for pref_reg use subcontext.rpref.reg);
          else i_gen_load_address_to_register_with_dereference(inst,info,subcontext,vysl);
          end if;

    -- adresa objektu s dynamickými atributy
    when lm_addr_attr   do -- nic nedělat
    
    -- načíst adresu a uložit na stack
    when lm_push_addr   do i_gen_store_address(inst,info,subcontext,vysl,tsd_stack);

    -- načíst adresu, uložit na stack a kopii vrátit ven
    when lm_push_and_load_addr do
        -- načíst adresu do registru
        i_gen_load_address_to_register_with_dereference(inst,info,subcontext,vysl);

        -- uložit na stack
        declare var
          optemp   : c_operand;                  -- pracovní kopie výsledku, kterou můžeme zničit

        begin
          -- připravit si kopii výsledku, bude zničena
          optemp.clone(inst,info,subcontext,vysl);

          -- uložit na stack
          i_gen_store_address(inst,info,subcontext,optemp,tsd_stack);

        leave
          -- uvolnit pracovní operand
          optemp.free(info,subcontext);
          end declare;

    -- konvertovat přímou hodnotu na relativní adresu            
    when lm_imm_to_rel  do
        if vysl.optype=io_imm then
          verify({VERIFY=}000861,vysl.edtype<>edt_address);
          vysl.transform_imm_to_rel;
          end if;

    -- adresa slotu táskové proměnné
    when lm_task_var_slot do -- nic nedelat
    
    when others do verify({VERIFY=}000415,true);
    end case;

  -- převést operand z kontextu podvýrazu do kontextu výrazu
  -- %%X tahle konstrukce se se mi teda vůbec nelíbí, ale zatím jsem to tak
  -- nechal, později odstranit. Dělalo to problém při I_LOAD_EXPR.
  if ^subcontext<>^supercontext then
    --i_retrieve_context(inst,info,subcontext,supercontext,vysl);
    vysl.retrieve(inst,info,subcontext,supercontext);
    end if;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.end');
    end if;
#end if;
  end i_load;



----------------------------------------------------------------------------------------------------
procedure i_load_binary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    outpref        : in ioutputpref;             -- pref. způsob předání pravého op.
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- požadovaný typ podvýrazů
    el             : in pexpnode;                -- podvýrazy
    er             : in pexpnode;                -- podvýrazy
    op1            : out c_operand;              -- výsledek
    op2            : out c_operand) =            -- výsledek
-- Vygeneruje a načte hodnotu dvojice podvýrazů.
-- (svázaných binárním operátorem)
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000134,expr^.arity<>eoa_2);

  if expr^.assign
    -- přiřazení : opačné pořadí operandů
    -- %%X Chybně, musí se vyhodnocovat zleva --> doprava; nebo ne ?
    -- Asi ne: v AARM je to zdůvodněný: X^:=F(...) a pokud F uvolní
    -- X, tak to musí způsobit chybu (NIL^)
    then
      -- vygenerovat a načíst pravý podvýraz
      i_newcontext(context,newcontext,lm_reg,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg,typ}{expr^.t.getctype},er,op2);

      -- vygenerovat levý podvýraz
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,typ}{expr^.t.getctype},el,op1);

    -- normální pořadí operandů
    -- %%X Rozlišit různé případy
    -- I když, výrazy typu IMM+VAR by na VAR+IMM měl přehazovat optimalizátor
    else
      -- vygenerovat a načíst levý podvýraz
      i_newcontext(context,newcontext,lm_reg_all,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg_all,typ}{expr^.t.getctype},el,op1);

      -- vygenerovat pravý podvýraz
      i_newcontext(context,newcontext,lm_conv,typ{expr^.t.getctype});
      i_setoutpref(context,outpref);
      i_load(inst,info,newcontext,context{lm_conv,typ}{expr^.t.getctype},er,op2);
      end if;

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);
  end i_load_binary;



----------------------------------------------------------------------------------------------------
procedure i_push_binary : i_load_binary:type =
-- Vygeneruje a uloží na stack hodnotu dvojice podvýrazů.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}001143,expr^.arity<>eoa_2 or expr^.assign);

  -- vygenerovat a uložit na stack levý podvýraz
  i_newcontext(context,newcontext,lm_push_value,typ);
  i_setoutpref(context,iop_stack);
  i_load(inst,info,newcontext,context,el,op1);

  -- vygenerovat a uložit na stack pravý podvýraz
  i_newcontext(context,newcontext,lm_push_value,typ);
  i_setoutpref(context,iop_stack);
  i_load(inst,info,newcontext,context,er,op2);
  end i_push_binary;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_ordinal : topergen =
-- Porovnávání diskrétních výrazů.
-- Tato procedura se používá i pro porovnání (pouze = <>) obecných birnátní
-- bloků příznivé velikosti (1,2,4; viz I_GEN_OP_COMPARE_BINARY).
-- Rovněž se používá pro generování kódu porovnávání fixed-point hodnot.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  cc               : icond;                      -- kód podmínky
  rest             : typeview;                   -- společný typ operandů

begin
  verify({VERIFY=}000139,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,true,rest);

  -- vygenerovat a načíst operandy
  i_load_binary(inst,info,context,iop_none,expr,rest.getutype,el,er,op1,op2);

  -- porovnat
  addii(inst,info,ii_cmp,op1,op2,op0);

  -- podmínka
  cc:=op2cc[expr^.oper,rest.stype in tdatatypeset:[dt_signed,dt_fixed]];

  -- zkrácené přiřazení ?
  if expr^.assign then addset(inst,info,context,cc,op1); end if;

  -- výsledek
  vysl.create_condition(cc);

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_op_compare_ordinal;



----------------------------------------------------------------------------------------------------
procedure i_gen_task_var_slot (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexptaskvarslot;         -- strom
    vysl           : out c_operand) =            -- výsledek
-- Selektor slotu táskové proměnné,
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- vygenerovat a načíst adresu slotu táskové proměnné
  i_newcontext(context,newcontext,lm_task_var_slot,nil);
  i_load(inst,info,newcontext,context,expr^.sub,vysl);
  end i_gen_task_var_slot;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_binary : topergen =
-- Porovnávání dvou obecných binárních bloků (e.g. array, record, set) (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : pexpnode) =
    -- Porovná zadaný uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      op1          : c_operand;                  -- adresa levého řetězce v ESI
      size         : t_unsigned32;               -- velikost pole
      tgloop       : itarget;                    -- návěští začátku cyklu
      tgend        : itarget;                    -- návěští konce cyklu

    begin
      -- jak jsme na tom s velikostí operandu ?
      if x_has_dynamic_size(x)

        -- dynamická velikost
        then
          unimplementedx({UNIMP=}000170,expr^.pos);

        -- statická veliksot
        else
          declare var
            opecx  : c_operand;                  -- min(op1length,op2length) v ECX
            opsize : c_operand;                  -- velikost pole

          begin
            -- načíst levý operand
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,x,op1);
            verifyx({VERIFY=}000524,op1.optype<>io_mem,x^.pos);

            -- redukovat počet registrů
            i_gen_reduceop(inst,info,context,op1);

            -- rezervovat ECX
            opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

            -- obnovit registry
            op1.refresh(inst,info,context);
            opecx.refresh(inst,info,context);

            -- zjistit velikost pole
            size:=value_size_from_expr(x);

            -- zvolit, jak budeme porovnávat
            #template adjust_operands(denominator);
              opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div denominator));
              op1.shift_by_index(inst,info,context,ir_ecx,denominator);
              op1.unshift_displacement(denominator);
              op1.adjust_size(denominator);
              #end adjust_operands;
            -- dělitelné 4 ? => po čtveřicích
            if size mod 4=0 then
              #expand adjust_operands; #for denominator use; 4 #end adjust_operands;
            -- dělitelné 2 ? => po dvojicích
            elsif size mod 2=0 then
              #expand adjust_operands; #for denominator use; 2 #end adjust_operands;
            -- musíme po bytech
            else
              #expand adjust_operands; #for denominator use; 1 #end adjust_operands;
              end if;

            -- naplnit ECX
            addii(inst,info,ii_mov,opecx,opsize,op0);

          leave
            -- uvolnit operandy
            opsize.free(info,context);
            opecx.free(info,context);
            end declare;
          end if;

      -- alokovat cíle skoku
      newtarget(info,tgloop);
      newtarget(info,tgend);

      -- cíl skoku na toto místo
      settarget(info,tgloop,getaddr(inst));

      -- CMP <prvek pole>,0
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- JNE <tgend>
      addjump(inst,info,context,ic_ne,tgend);

      -- LOOP <tgloop>
      addloop(inst,info,context,tgloop);

      -- cíl skoku na toto místo
      settarget(info,tgend,getaddr(inst));

      -- výsledek
      vysl.create_condition(op2cc[expr^.oper,false]);
          {
              mov   ecx,x:size div 4
          ^2: cmp   [esi+ecx*4-4],0
              jne   ^1
              loop  ^2
          ^1: x=nil  => ic_ne
              x<>nil => ic_e
          }
    leave
      -- uvolnit operand
      op1.free(info,context);
      end cmpnil;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  verify({VERIFY=}000802,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podvýrazy
  expr^.get(el,er);

  -- porovnání operandů s příznivou statickou velikostí
  if x_has_static_size(el) and x_has_static_size(er)
  and (el^.t.getsize=uds_1 or el^.t.getsize=uds_2 or el^.t.getsize=uds_4) then
    -- porovnat principiálně stejně jako ordinální typy
    i_gen_op_compare_ordinal(inst,info,context,expr,vysl);

  ----- (non)ekvivalence s NIL zleva -----
  elsif x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s NIL zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecných polí -----
  else
    -- oba operandy mají statickou velikost
    if x_has_static_size(el) and x_has_static_size(er) then
      declare var
        newcontext : iexprcontext;               -- kontext podvýrazů
        op1        : c_operand;                  -- adresa levého řetězce v ESI
        op2        : c_operand;                  -- adresa pravého řetězce v EDI
        opecx      : c_operand;                  -- min(op1length,op2length) v ECX
        opsize     : c_operand;                  -- velikost pole
        ii         : iinstr;                     -- zvolená porovnávací instrukce
        size       : t_unsigned32;               -- velikost pole

      begin
        -- načíst levý operand do ESI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_esi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- načíst pravý operand do EDI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,er,op2);

        -- obnovit registry
        op1.refresh(inst,info,context);
        op2.refresh(inst,info,context);

        -- rezervovat ECX
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- zjistit velikost polí
        size:=value_size_from_expr(el);

        -- zvolit, jak budeme porovnávat
        -- dělitelné 4 ? => po čtveřicích
        if size mod 4=0 then
          ii:=ii_cmpsd;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 4));
        -- dělitelné 2 ? => po dvojicích
        elsif size mod 2=0 then
          ii:=ii_cmpsw;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 2));
        -- musíme po bytech
        else
          ii:=ii_cmpsb;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size));
          end if;

        -- naplnit ECX
        addii(inst,info,ii_mov,opecx,opsize,op0);

        -- shodit Direction Flag - porovnává se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- REPE CMPS
        addip(inst,info,ip_repe);
        addii(inst,info,ii,op0,op0,op0);

        -- a tím by to mělo být hotovo

        -- výsledek
        vysl.create_condition(op2cc[expr^.oper,false]);

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op2.free(info,context);
        opecx.free(info,context);
        opsize.free(info,context);
        end declare;

    -- jeden z operandů má dynamickou velikost
    elsif x_has_dynamic_size(el) xor x_has_dynamic_size(er) then
      unimplemented({UNIMP=}000171);

    -- oba mají dynamickou velikost
    else
      unimplemented({UNIMP=}000172);
      end if;
    end if;
  end i_gen_op_compare_binary;



----------------------------------------------------------------------------------------------------
#separate public ci_integer;
#separate private ci_integer;
-- Celočíselná aritmetika.
----------------------------------------------------------------------------------------------------
#separate public ci_fixed;
#separate private ci_fixed;
-- Fixed-point aritmetika.
----------------------------------------------------------------------------------------------------
#separate public ci_float;
#separate private ci_float;
-- Floating-point aritmetika.
----------------------------------------------------------------------------------------------------
#separate public ci_logical;
#separate private ci_logical;
-- Logické operace.
----------------------------------------------------------------------------------------------------
#separate public ci_pointer;
#separate private ci_pointer;
-- Operace s pointery.
----------------------------------------------------------------------------------------------------
#separate public ci_string;
#separate private ci_string;
-- Řetězcové operace.
----------------------------------------------------------------------------------------------------
#separate public ci_set;
#separate private ci_set;
-- Množinové operace.
----------------------------------------------------------------------------------------------------
#separate public ci_tag;
#separate private ci_tag;
-- Operace s tagy.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_array : topergen =
-- Porovnávání recordů (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vyžadují komponenty pole zvláštní porovnávací algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimalizátor IF s konstantní podmínkou neošetří

    -- ano => porovnat po částech
    then
      unimplemented({UNIMP=}000177);

    -- ne => porovnat jako binární bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_record : topergen =
-- Porovnávání množin (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vyžadují komponenty recordu zvláštní porovnávací algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimalizátor IF s konstantní podmínkou neošetří

    -- ano => porovnat po částech
    then
      unimplemented({UNIMP=}000178);

    -- ne => porovnat jako binární bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_record;


{
-- Zatím nerušit, návrh na nový tvar.
--
-- ----------------------------------------------------------------------------------------------------
-- procedure i_gen_op_assign_nil : topergen =
-- -- Univerzální přiřazení NIL.
-- ----------------------------------------------------------------------------------------------------
-- begin
--   end i_gen_op_assign_nil;
}


----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign : topergen =
-- Univerzální přiřazení.
----------------------------------------------------------------------------------------------------
with
  ci_rcheck;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000140,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

-- Zatím nerušit, návrh na nový tvar.
--
--   -- vyřídit triviální případ přiřazení NIL
--   if x_is_nil(er) then
--     i_gen_op_assign_nil(inst,info,context,expr,vysl);
-- 
--   -- oba operandy mají statickou velikost
--   elsif x_has_static_size(el) and x_has_static_size(er) then
--     declare var
--       size         : t_unsigned32;               -- velikost operandu
-- 
--     begin
--       -- pro zjednodušení velikost operandu
--       size:=unidata_size_to_unsigned(expr^.t.getsize);
-- 
--       if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}
-- 
--         -- příznivá velikost => na to stačí jeden MOV
--         then
--           -- vygenerovat a načíst operandy
--           i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);
-- 
--           -- přiřazení
--           -- Ondra 11.9.2002 : Hodnota může být reprezentována i kódem podmínky
--           if op2.optype=io_cc
--             then addset(inst,info,context,op2.cc,op1);
--             else addii(inst,info,ii_mov,op1,op2,op0);
--             end if;
-- 
--           -- výsledek
--           vysl.transfer(op1);
-- 
--         -- něco jiného => obecná metoda přesunu
--         else
--           -- vygenerovat a načíst pravý podvýraz (může být i na stacku)
--           i_newcontext(context,newcontext,lm_gen,nil);
--           i_setoutpref(newcontext,iop_stack);
--           i_load(inst,info,newcontext,context,er,op2);
-- 
--           -- vygenerovat levý podvýraz
--           i_newcontext(context,newcontext,lm_gen,nil);
--           i_load(inst,info,newcontext,context,el,op1);
-- 
--           -- obnovit registry
--           op1.refresh(inst,info,context);
--           op2.refresh(inst,info,context);
-- 
--           -- operandy by neměly spotřebovat moc registrů
--           i_gen_reduceop(inst,info,context,op1);
--           i_gen_reduceop(inst,info,context,op2);
-- 
--           -- kopírovat
--           case op2.optype
--             when io_stack do i_gen_pop_static(inst,info,context,op1,size);
--             when io_mem   do i_gen_move_static(inst,info,context,op2,op1,size);
--             when others   do verify({VERIFY=}001016,true);
--             end case;
-- 
--           -- %%X A co výsledek ??             
--           end if;
--     leave
--       -- uvolnit operandy
--       op1.free(info,context);
--       op2.free(info,context);
--       end declare;
-- 
--   -- alespoň jeden z operandů má dynamickou velikost
--   else
--     ...
--     end if;  

  if x_has_dynamic_size(el)

    -- levý operand má dynamickou velikost
    then
      declare var
        op1        : c_operand;                  -- levý operand
        op1size    : c_operand;                  -- :size levého operandu
        op1edi     : c_operand;                  -- adresa levého operandu v EDI

      begin
        {verify({VERIFY=}000803,rta_size not in el^.rta_used{%%ATTR});}

        -- vygenerovat levý operand
        i_newcontext(context,newcontext,lm_addr_attr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- pro atribut bude potřeba registr ECX
        -- op1size.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- načíst do ECX dynamickou velikost levého operandu
        i_rta_load(inst,info,context,op1,rta_size,op1size,for no_memory use true,for pref_reg use in_ecx);

        -- registr EDI
        op1edi.create_use_register(inst,info,context,edt_address,ir_edi);

        -- načíst adresu proměnné do EDI
        op1.adjust_size(lpointer32);
        addii(inst,info,ii_mov,op1edi,op1,op0);

        if x_is_nil(er)

          -- přiřazení NIL
          then
            -- uložit NIL
            i_gen_fillz_dynamic(inst,info,context,op1edi,op1size);

          -- přiřazení konkrétní hodnoty
          else
            declare var
              op2     : c_operand;               -- pravý operand
              op2size : c_operand;               -- :size pravého operandu

            begin  
              ---- kontrola velikosti ----
              -- načíst adresu :size pravého operandu
              if x_has_dynamic_size(er)

                -- pravý operand má též dynamickou velikost
                then
                  verify({VERIFY=}000518,not (rta_size in er^.rta_used{%%ATTR}));

                  -- vygenerovat pravý operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_setrpref(newcontext,in_esi,irm_addr);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registry
                  op2.refresh(inst,info,context);

                  -- načíst do ECX dynamickou velikost levého operandu
                  i_rta_load(inst,info,context,op2,rta_size,op2size);

                -- pravý operand má statickou velikost
                else
                  -- načíst velikost pravého operandu
                  op2size.create_imm(edt_unsigned,0,value_size_from_expr(er));
                  end if;

              -- run-time check velikosti přiřazovaného bloku
              i_gen_rcheck_constraint_error_on_compare(inst,info,context,op1size,op2size,ic_ne);

              ---- přiřazení hodnoty ----
              if x_has_dynamic_size(er)

                -- pravý operand s dynamickou velikostí => již známe jeho adresu
                then
                  -- nic nedělat, verifikace 518 na "rta_size in er^.rta" už proběhla výše

                -- pravý operand se statickou velikostí => vygenerovat
                else
                  -- vygenerovat pravý operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_load(inst,info,newcontext,context,er,op2);
                  end if;

              -- obnovit registry
              op1.refresh(inst,info,context);
              op2.refresh(inst,info,context);

              -- operandy by neměly spotřebovat moc registrů
              i_gen_reduceop(inst,info,context,op1);
              i_gen_reduceop(inst,info,context,op2);

              -- přesunout (jako pole o prvcích velikosti 1)
              i_gen_move_array(inst,info,context,op2,op1,op1size,1);

            leave
              -- uvolnit operandy
              op2.free(info,context);
              op2size.free(info,context);
              end declare;
            end if;
      leave
        op1.free(info,context);
        op1edi.free(info,context);
        op1size.free(info,context);
        end declare;

    -- levý operand má statickou velikost
    else
      declare var
        op1        : c_operand;                  -- levý operand
        size       : t_unsigned32;               -- velikost operandu
      begin
        -- velikost operandu
        size:=value_size_from_expr(expr);

        ----- %%X Připomínky ---------------------------------------------------
        -- -- Co když se levý a pravý operand překrývají ?
        -- -- Když zbývají tři byty, mohu přeci kopírovat předchozí byte podruhé
        --    (ušetří se 4 instrukce, takže penalta za nezarovananý přístup nevadí)
        -- -- Pokud to jde, tak zkusit REP MOVSD - od nějaké velikosti bloku by to
        --    mohlo být rychlejší, i kdybych musel čarovat s registrama (PUSH).
        -- -------------------------------------------------------------------------

        if x_is_nil(er)

          -- přiřazení NIL
          then
            -- vygenerovat levý podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_setrpref(newcontext,in_edi,irm_addr);
            i_load(inst,info,newcontext,context,el,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            -- uložit NIL
            i_gen_fillz_static(inst,info,context,op1,size);

          -- přiřazení konkrétní hodnoty
          else
            declare var
              op2  : c_operand;                  -- pravý operand
            begin
              if size=1 or size=2 or size=4 {%%TODO(SET) size in [1,2,4]}

                -- příznivá velikost
                then
                  -- vygenerovat a načíst operandy
                  i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);
                  verify({VERIFY=}001096,op2.edtype=edt_address);

                  -- přiřazení
                  i_gen_simple_assign(inst,info,context,op1,op2);

                  -- výsledek
                  vysl.transfer(op1);

                -- něco jiného
                else
                  -- vygenerovat a načíst pravý podvýraz (může být i na stacku)
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_setoutpref(newcontext,iop_stack);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- vygenerovat levý podvýraz
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_load(inst,info,newcontext,context,el,op1);

                  -- obnovit registry
                  op1.refresh(inst,info,context);
                  op2.refresh(inst,info,context);

                  -- operandy by neměly spotřebovat moc registrů
                  i_gen_reduceop(inst,info,context,op1);
                  i_gen_reduceop(inst,info,context,op2);

                  -- kopírovat
                  case op2.optype
                    when io_stack do i_gen_pop_static(inst,info,context,op1,size);
                    when io_mem   do i_gen_move_static(inst,info,context,op2,op1,size);
                    when others   do verify({VERIFY=}000488,true);
                    end case;

                  -- %%X A co výsledek ??
                  end if;

            leave
              -- uvolnit pravý operand
              op2.free(info,context);
              end declare;
            end if;
      leave
        -- uvolnit levý operand
        op1.free(info,context);
        end declare;
      end if;
  end i_gen_op_assign;



----------------------------------------------------------------------------------------------------
procedure i_gen_operator (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpoper;                -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
begin
  case expr^.t.tview
    -- Partial view/Unchecked view
    when tview_partial, tview_unchecked do
        case expr^.oper
          -- přiřazení
          when op_assign do i_gen_op_assign(inst,info,context,expr,vysl);

          when others do verify({VERIFY=}000187,true);
          end case;

    -- Full view
    when tview_full do
        declare var
          stype    : tdatatype;                  -- společný typ operandů

        begin
          -- zjisti společný typ operandů
          stype:=x_resolve_opdtype(expr,true);

          -- mame nejaky generator?
          verifyx({VERIFY=}000099,opertab[expr^.oper,stype]=nil,expr^.pos);

          -- zavolej prislusny generator
          opertab[expr^.oper,stype]^(inst,info,context,expr,vysl);
          end declare;

    when others do verifyx({VERIFY=}000186,true,expr^.pos);
    end case;
  end i_gen_operator;



----------------------------------------------------------------------------------------------------
procedure i_gen_unary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpunary;               -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  op1              : aliased c_operand;          -- operand
  newcontext       : iexprcontext;               -- kontext podvýrazů
  optype           : expunarytype;               -- typ unarniho operatoru
  range_checks_req : t_logical;                  -- T-je treba kontrola mezi

begin
  -- podvýrazy
  expr^.get(el);

  optype:=expr^.oper;
  
  -- "architektura" Intel tíhne k nepříjemným výjimkám,
  -- takže každá instrukce vyžaduje jiné zpracování
  case optype
    -- inkrementace/dekrementace, unární mínus, bitová negace
    when un_succ,un_pred,un_minus,un_bitnot do
        -- je treba kontrola mezi?
        range_checks_req:=t_runtime_check_set:[rch_ordinal_range]*expr^.get_run_checks(rchcl_load)<>t_runtime_check_set:[] or 
          t_runtime_check_set:[rch_ordinal_overflow,rch_ordinal_range]*expr^.get_run_checks(rchcl_gen)<>t_runtime_check_set:[];

        -- podvyraz nemusime nacist do registru jen pokud nepotrebujeme kontrolu mezi,
        -- jinak je treba operaci provest v docasne promenne
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        declare var
          optemp   : aliased c_operand;
          pop      : ^c_operand;

        begin
          pop:=^op1;

          -- pro prirazeni s behovymi kontrolami potrebujeme docasnou promennou na kontrolu vysledku
          if expr^.assign and range_checks_req then
            -- registr na docasny vysledek
            optemp.create_new_register(inst,info,context,op1.edtype,op1.size);

            -- počáteční hodnota
            addii(inst,info,ii_mov,optemp,op1,op0);

            pop:=^optemp;
            end if;

          -- instrukce
          case expr^.oper
            when un_minus  do addii(inst,info,ii_neg,pop^,op0,op0);
            when un_succ   do addii(inst,info,ii_add,pop^,op_1,op0);
            when un_pred   do addii(inst,info,ii_sub,pop^,op_1,op0);
            when un_bitnot do addii(inst,info,ii_not,pop^,op0,op0);
            when others do verify({VERIFY=}000047,true);
            end case;

          -- provest behove kontroly operace operatoru
          ci_rcheck.i_gen_runtime_checks(inst,info,context,rchcl_gen,pexpnode(expr)^,pop^);

          -- provest behove kontroly operace prirazeni
          ci_rcheck.i_gen_runtime_checks(inst,info,context,rchcl_load,pexpnode(expr)^,pop^);
          
          -- docasny vysledek?
          if expr^.assign and range_checks_req then
            -- ANO - priradit
            addii(inst,info,ii_mov,op1,optemp,op0);
            end if;
          
          leave
            optemp.free(info,context);
          end declare;
        
        -- vysledek
        vysl.transfer(op1);

    -- logická negace
    when un_not do
        -- vygenerovat podvýraz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- co je operand zač ?
        case op1.optype
          -- podmínka => znegovat
          when io_cc do op1.set_cc(icondneg[op1.cc]);

          -- registr => xornout hodnotou (true xor false)
          -- %%X Pro typ se specifikací reprezentace True a False se negace
          -- dělá takhle: xor op1,(true xor false)
          when io_reg, io_mem do addii(inst,info,ii_xor,op1,op_1,op0);

          when others do verify({VERIFY=}000470,true);
          end case;

        -- výsledek
        vysl.transfer(op1);

    -- absolutní hodnota
    when un_abs do
        -- %%TODO - nezapomenout na kontroly mezi
        unimplemented({UNIMP=}000029);

    when others do verify({VERIFY=}000046,true);
    end case;

leave
  -- uvolnit operand
  op1.free(info,context);
  end i_gen_unary;



----------------------------------------------------------------------------------------------------
procedure i_gen_component (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcomponent;           -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu komponenty.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  case expr^.nclass
    -- nic (kvalifikátor) => jen vygenerovat podvýraz
    when nc_none do
        if expr^.sub=nil
          -- nemáme ani podvýraz
          then --nullop(vysl,io_none)

          -- podvýraz je k dispozici => vygenerovat
          else
            -- vygenerovat podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            end if;

    -- proměnná
    when nc_var do
        if expr^.sub=nil or {not} expr^.sub^.nclass {in ncs_value}<>nc_var

          -- přímo proměnná
          then
            verify({VERIFY=}000091,expr^.s.psym=nil);

            declare var
              pvar : pentity_var;                -- proměnná pro zjednodušení

              -- koncový elementární datový typ a velikost operandu - nezávisí na módu proměnné
              final_edtype : t_elementary_data_type;
              final_size   : t_unsigned;

            begin
              -- proměnná pro zjednodušení
              pvar:=pentity_var(expr^.s.psym);

              -- určit koncový elementární datový typ a koncovou velikost
              final_edtype:=edtype_from_expr(expr);
              final_size:=value_size_from_expr(expr);

              case pvar^.mclass
                -- automatická
                when mc_auto do
                    declare var
                      nindex  : t_unsigned;      -- index vnoření proměnné

                      -- počáteční elementární datový typ a velikost operandu - závisí na módu proměnné
                      initial_edtype : t_elementary_data_type;
                      initial_size   : t_unsigned;

                    begin
                      -- nemohla by to být proměnná z nadřazeného podprogramu ?
                      nindex:=0;
                      if inst.nested.nlist<>nil and then inst.nested.nlist^:length<>0 then
                        nindex:=inst.nested.nlist^:length;
                        while nindex<>0 and then inst.nested.nlist^[nindex]<>pvar^.context.entity loop
                          pred nindex;
                          end loop;
                        end if;

                      -- podle módu proměnné určit počáteční elementární datový typ a velikost
                      case pvar^.vmode
                        -- přímý přístup: obojí je identické s koncovými údaji
                        when vm_direct do 
                            initial_edtype:=final_edtype;
                            initial_size  :=final_size;

                        -- přístup přes referenci: obojí je vždy natvrdo stejné
                        when vm_ref    do 
                            initial_edtype:=edt_address;
                            initial_size  :=4;

                        when others    do verify({VERIFY=}000862,true);
                        end case;

                      -- připravit operand
                      if nindex=0

                        -- je to přímo lokální proměnná
                        then
                          declare var
                            disp : timm32;
                          begin
                            -- zjistit adresu proměnné
                            getvaraddr(inst,info,pvar,disp);

                            -- sestavit adresu bázovanou podle frame pointeru
                            vysl.create_memory_address_on_stack(inst,initial_edtype,initial_size,disp);
                            end declare;

                        -- je z nadřazeného podprogramu
                        else
                          declare var
                            optemp : c_operand;
                          begin
                            -- adresa uloženého frame pointeru
                            optemp.create_memory_address_on_stack(inst,edt_address,4,signed_to_imm32(-t_signed(nindex*4)));

                            -- budeme potřebovat registr na frame pointer
                            vysl.create_new_register(inst,info,context,edt_address,4);

                            -- načíst frame pointer
                            addii(inst,info,ii_mov,vysl,optemp,op0);

                          leave
                            -- uvolnit pracovní operand
                            optemp.free(info,context);
                            end declare;

                          -- změnit operand na adresní
                          vysl.transform_reg_to_mem(initial_edtype,initial_size);
                        { %%X
                          Dva zásadní problémy:
                            -- ENTER akceptuje pouze 16bitovou velikost prostoru na stacku -> nutné
                               minimálně ošetřit případ s více než 64 KB lokálních proměnných a také
                               zpětné nastavování hodnoty - někdy 32 jindy 16 bitů,
                            -- v době generování vnořené procedury není ještě vygenerovaná nadřazená
                               procedura -> generovat v opačném pořadí a pro vnořenou volit default
                               konvence.
                        }
                          declare var
                            pcode : pentity_code;  -- nadřazený podprogram
                            disp  : timm32;        -- offset proměnné vzhledem k frame pointeru
                            
                          begin
                            -- nadřazený podprogram
                            pcode:=inst.nested.nlist^[nindex];
                            verify({VERIFY=}000805,picodegen_subprog(pcode^.codegen)^.ifirst<>picodegen_subprog(pcode^.codegen)^.ilast);

                            -- zjistit adresu proměnné
                            getvaraddr(picodegen_subprog(pcode^.codegen)^.ifirst^,info,pvar,disp);

                            -- přičíst posunutí k výsledné adrese
                            vysl.shift_displacement(imm32_to_signed{%%X}(disp));
                            end declare;
                          end if;
                      end declare;

                    -- je to parametr ? => pak musíme upravit množinu
                    -- použitelných run-time atributů
                    -- %%X Tohle je trochu Black Magic a záplata. Správně by se
                    -- to mělo dělat v dvouprůchodové globální analýze, jenže
                    -- tu zatím nemáme a takhle to kupodivu taky funguje.
                    --   Nestane se, že by v CONTEXT.RTA byly i atributy, které
                    -- touto úpravou ztratím, protože při požadavku na takové
                    -- atributy by se vyžádaly i pro tento parametr (aspoň by
                    -- to tak mělo být).
                    verify({VERIFY=}000334,context.rta*(pvar^.rta_avail{allrta}-pvar^.rta_used{usedrta})<>rtattribset:[]);
                    expr^.rta_used{%%ATTR}:=pvar^.rta_used{usedrta};

                    -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
                    i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes,
                        final_edtype,final_size,for deref use pvar^.vmode=vm_ref);

                -- statická
                when mc_static do
                    verify({VERIFY=}000893,pvar^.vmode<>vm_direct);

                    -- adresa proměnné
                    vysl.create_memory_address(inst,info,context,final_edtype,final_size,ir_none,0);
                    vysl.set_relo_entity(pvar);

                    -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
                    i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);

                -- tasková proměnná
                when mc_task do
                    if context.mode=lm_task_var_slot 

                      -- adresa slotu taskové proměnné
                      then
                        -- připravit adresu slotu
                        vysl.create_imm(edt_address,4,0);
                        vysl.set_relo_entity(expr^.s.psym);

                      -- hodnota taskové proměnné
                      else
                        declare var
                          opslot : c_operand;      -- slot taskové proměnné

                        begin
                          -- na stacku rezervovat prostor pro návratovou hodnotu - adresa hodnoty taskové proměnné
                          i_gen_stack_top_reserve(inst,info,context,4);

                          -- handle taskové proměnné uložit na stack
                          opslot.create_memory_address(inst,info,context,edt_unsigned,4,ir_none,0);
                          opslot.set_relo_entity(expr^.s.psym);
                          addii(inst,info,ii_push,opslot,op0,op0);

                          -- přeložit handle taskové proměnné na adresu její hodnoty
                          addcallrtl(inst,info,context,rtl_get_task_var,true);

                          -- vyzvednout ze stacku adresu hodnoty taskové proměnné
                          vysl.create_new_register(inst,info,context,edt_address,4);
                          addii(inst,info,ii_pop,vysl,op0,op0);
                          
                          -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
                          i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes,
                              edtype_from_expr(expr),value_size_from_expr(expr),for deref use true);

                        leave
                          opslot.free(info,context);
                          end declare;
                        end if;


                -- proměnná třídy
                when mc_class do
                    verify({VERIFY=}000894,pvar^.vmode<>vm_direct);

                    -- načíst adresu složky
                    i_load_this_address(inst,info,context,final_edtype,final_size,pvar^.addr,vysl);

                    -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
                    i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);

                when others do verify({VERIFY=}000071,true);
                end case;
              end declare;

          -- selektor
          else
            verify({VERIFY=}000090,(expr^.s.psym=nil) or{and} not (pentity_var(expr^.s.psym)^.mclass in mcs_offset));

            -- vygenerovat podvýraz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            verify({VERIFY=}000092,vysl.optype<>io_mem);

            -- adresa
            vysl.shift_displacement(imm32_to_signed{%%X}(unidata_addr_to_imm32(pentity_var(expr^.s.psym)^.addr{pivarlink(pentity_var(expr^.s.psym)^.codegen)^.addr})));

            -- upravit elementární datový typ a velikost operandu
            vysl.adjust_edtype(edtype_from_expr(expr));
            vysl.adjust_size(value_size_from_expr(expr));

            -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
            i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);
            end if;

    -- procedura
    when nc_proc do
        -- případný podvýraz určuje instanci, ale co s ní ?
        -- to ať si vyřeší volající procedura

        -- vrátit adresu procedury
        i_gen_subprogram_address(inst,info,context,pentity_subprogram(expr^.getsymbol),false,vysl);

    -- zpráva
    when nc_message     do
        -- na případný podvýraz se kašle, nemá význam

        -- vrátit tag zprávy
        vysl.create_imm(edt_unsigned,0,0);
        vysl.set_relo_entity(expr^.s.psym);

    when others do verify({VERIFY=}000621,true);
    end case;
  end i_gen_component;



----------------------------------------------------------------------------------------------------
procedure i_gen_imm (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpimm;                 -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu přímé hodnoty.
----------------------------------------------------------------------------------------------------
var
  edtype           : t_elementary_data_type;     -- elementární datový typ přímé hodnoty

begin
  -- určit elementární datový typ přímé hodnoty
  edtype:=edtype_from_expr(expr);

  if context.mode in lms_addr

    -- zajímá nás adresa hodnoty
    then
      -- adresa
      vysl.create_memory_address(inst,info,context,edtype,value_size_from_expr(expr),ir_none,0);
      vysl.set_relo_imm(expr);

      -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
      i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);

    -- zajímá nás hodnota samotná
    else
      case expr^.imm.ic
        -- ordinální hodnota
        when ic_ordinal do
            if t_is_sts(expr^.t,dts_unitype)
              then vysl.create_imm(edtype,0,uniint_to_imm32(expr^.imm.ui));
              else vysl.create_imm(edtype,value_size_from_expr(expr),uniint_to_imm32(expr^.imm.ui));
              end if;

         { No a to je právě ten omyl. Tohle se musí řešit s využitím NATTYP
            o úroveň výš (v I_LOAD).

            --..TECH U ordinálních hodnot mi na velikosti nijak zvlášť nesejde.   
            -- Emitor instrukcí se přizpůsobí a kompatibilitu by měly zajistit
            -- předchozí fáze překladu. Nicméně stejně by požadovaná velikost
            -- konstanty měla být alespoň taková, jako je její skutečná velikost.
            {..X Bohužel nemám jak to otestovat... }
            {verify({VERIFY=}000129,not (expr^.t.stype in dts_unitype) and uishrink(expr^.imm.ui,,));}
            vysl.size:=0;
          { Původní, málo funkční verze
            (var(unsigned 32)<=imm(unsigned 16) --> cmp reg32,imm16)

            if expr^.t.stype in dts_unitype
              then vysl.size:=0;
              else udtouint(expr^.t.typ^.size,vysl.size);
              end if;
          }
         }

        -- NIL
        when ic_nil do
            declare var
              x : t_unsigned;
            begin
              x:=unidata_size_to_unsigned(context.outtyp.size);
              verifyx({VERIFY=}000556,x<>1 and x<>2 and x<>4{%%TODO(SET) not (x in [1,2,4])},expr^.pos);
              end declare;
            vysl.create_imm(edtype,0,0);
            -- %%X No a tady bych potřeboval vědět požadovaný typ, nebo ne ?

        -- kondenzované pole nebo agregát
        when ic_condensed,ic_array,ic_set,ic_record do
            {verifyx({VERIFY=}000530,((expr^.imm.ic=ic_set) and (expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize))
                     or ((expr^.imm.ic=ic_array) and (expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize))
                     or ((expr^.imm.ic=ic_record) and (expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize)),expr^.pos);}
            {!!}
            vysl.create_memory_address(inst,info,context,edtype,value_size_from_expr(expr),ir_none,0);
            vysl.set_relo_imm(expr);

        -- real number (fixed-point or floating-point)
        when ic_real do
            case edtype
              -- fixed-point
              when edt_fixed do
                  declare var
                    ui     : tuniint;            -- aux. var

                  begin
                    -- convert real value internal representation to fixed-point value
                    unireal_store_fixed(expr^.imm.ur,ui,value_size_from_expr(expr),expr^.t.getctype()^.fxp.fx_inv_delta);

                    -- store value into operand
                    case value_size_from_expr(expr)
                        -- 32-bit fixed-point operand
                        when  4 do vysl.create_imm(edt_fixed,value_size_from_expr(expr),uniint_to_imm32(ui));

                        -- 64-bit fixed-point operand
                        when  8 do unimplemented({UNIMP=}000295);

                        -- 128-bit fixed-point constant value
                        when 16 do unimplemented({UNIMP=}000296);

                        -- other sizes mean an internal error
                        when others do verify({VERIFY=}001404,true);
                      end case;
                    end declare;

              -- floating-point
              when edt_float do
                  declare var
                    ui     : tuniint;            -- aux. var

                  begin
                    -- convert real value internal representation to floating-point value
                    unireal_store_float(expr^.imm.ur,ui,value_size_from_expr(expr));

                    -- store value into operand
                    case value_size_from_expr(expr)
                        -- 32-bit floating-point operand
                        when  4 do vysl.create_imm(edt_float,value_size_from_expr(expr),uniint_to_imm32(ui));

                        -- 64-bit or 80-bit floating-point operand
                        when  8,10 do
                            vysl.create_memory_address(inst,info,context,edt_float,value_size_from_expr(expr),ir_none,0);
                            vysl.set_relo_imm(expr);

                        -- other sizes mean an internal error
                        when others do verify({VERIFY=}001405,true);
                      end case;
                    end declare;

              -- internal error otherwise
              when others do verify({VERIFY=}001393,true);
              end case;

        -- %%X
        when others do verify({VERIFY=}000072,true);
        end case;
      end if;
  end i_gen_imm;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast_fixed =
-- Generate fixed-point value type conversion.
----------------------------------------------------------------------------------------------------
begin
  -- requested size doesn't match operand
  if context.orgtyp^.size<>context.outtyp.size
  -- requested precision doesn't match operand
--  or context.outtyp.base^.fxp.fxdelta<>expr^.t.getctype()^.fxp.fxdelta
  or context.orgtyp^.fxp.fx_inv_delta<>context.outtyp.fx_inv_delta
    -- conversion is necesarry
    then
      ci_fixed.i_gen_convert_fixed(inst,info,context,expr,vysl);

    {else
      -- do nothing}
      end if;
  end i_gen_typecast_fixed;



----------------------------------------------------------------------------------------------------
procedure i_gen_aggregate (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpaggregate;           -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování agregátu.
-- Poznámka: Obsluha agregátů je dost natvrdo (=neoptimálně), protože je to
-- poměrně komplikovaná záležitost a babrat se s tím budu až ve 4.0.1.
----------------------------------------------------------------------------------------------------
var
  opaggr           : c_operand;                  -- pracovní prostor pro agregát
  optemp           : c_operand;                  -- pracovní operand
  arglist          : pexpitem;                   -- seznam argumentů

begin
  -- %%TECH Optimalizátor zajistil, že agregát, který se dostane až sem, má
  -- zcela jistě alespoň jednu nekonstantní složku (ať už hodnotu, či index),
  -- všechny ostatní případy jsou konvertovány na NT_IMM.

  case expr^.t.stype
    -- record
    when dt_record do unimplemented({UNIMP=}000152);

    -- pole
    when dt_array do
      {
        -- alokovat pracovní prostor pro agregát
        nullop(optemp,io_mem);
        optemp.base.reg:=istackframereg[inst.frame];
        optemp.size:=expr^.t.size;
        alloctemp(inst,info,optemp.size,optemp.disp);

        -- do pracovního prostoru nacpat konstantní část agregátu

        -- seznam argumentů
        expr^.getarglist(arglist);

        -- zpracovat všechny složky agregátu
        while arglist<>nil loop

          end loop;
      }
        unimplemented({UNIMP=}000165);


    -- neomezene pole
    when dt_uarray do unimplemented({UNIMP=}000155);

    -- řetězec
    when dt_string,dt_ustring do unimplemented({UNIMP=}000153);

    -- množina
    when dt_set do unimplementedx({UNIMP=}000154,expr^.pos);

    -- ostatní typy tu nemají co dělat
    when others do verify({VERIFY=}000473,true);
    end case
  end i_gen_aggregate;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram_prepare (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    call           : out icallconvention;        -- volací konvence
    pinst          : out picodeinst;             -- instance volané procedury
    ptyp           : out pentity_type) =         -- typ procedury
-- Generování kódu volání procedury: příprava volání.
----------------------------------------------------------------------------------------------------
begin
  -- pro neurčité případy předpokládejme default volací konvenci
  call:=icc_default;

  -- zvolit instanci procedury
  pinst:=nil;
  if pproc<>nil and then pproc^.etype=et_procedure and then pproc^.codegen<>nil then
    -- %%X zvolit instanci procedury
    pinst:=picodegen_subprog(pproc^.codegen)^.ifirst;

    -- volací konvence
    if pinst<>nil
      -- podle zvolené instance
      then call:=pinst^.profile.call;
      -- default konvence pro tuto proceduru
      else call:=get_call_conv(pproc^);
      end if;
    end if;

  -- lze-li to, tak získat typ procedury, bude se hodit
  if pproc<>nil

    -- máme k dispozici konkrétní proceduru
    then ptyp:=pproc^.typ.getutype

    -- zřejmě je to pointer na proceduru
    else
      verify({VERIFY=}000510,expr^.sub^.ntype<>nt_deref);
      ptyp:=expr^.sub^.t.getctype;
      call:=get_call_conv(ptyp^);
      end if;
  verify({VERIFY=}000511,ptyp<>nil and ptyp^.stype<>dt_procedure);

  -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUTÁ ** záplata !!
  -- Přesunutím SAVEREGS těsně před instrukci CALL zabraňuju rekurzivnímu
  -- pushování stejných registrů, které je zapříčiněno nějakou nedokonalostí
  -- alokátoru registrů, kterou se mi zatím nepodařilo vyřešit. Problém spočívá
  -- v tom, že schováním registru se ztrácí informace o jeho (ne)použití, takže
  -- při rekurzivním volání I_GEN_CALL_SUBPROGRAM se schovává znova, což má za
  -- následek unimplemented({UNIMP=}000212) v I_RETRIEVE.
{
  -- uložit všechny použité registry
  -- %%X Omezit jen na registry skutečně použité ve volané proceduře
  saveregs(inst,info,context);
}
  end i_gen_call_subprogram_prepare;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram_parameters (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    call           : in icallconvention;         -- volací konvence
    pinst          : in picodeinst;              -- instance volané procedury
    ptyp           : in pentity_type;            -- typ procedury
    params_size     : out t_unsigned) =          -- velikost skutecnych parametru v bytech (bez parametru instance)
-- Generování kódu volání procedury: generování skutečných parametrů.
----------------------------------------------------------------------------------------------------
var
  arg              : pexpitem;                   -- skutečný parametr

    ------------------------------------------------------------------------------------------------
    procedure firstarg =
    -- První argument procedury (podle volací konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;

    begin
      -- %%X časem doplnit do stromu dvousměrnej seznam 

      -- první argument v seznamu
      expr^.get(el,arg);

      -- dojet na konec
      if call in iccs_reverse then
        while arg<>nil and then arg^.next<>nil loop arg:=pexpitem(arg^.next); end loop;
        end if;
      end firstarg;



    ------------------------------------------------------------------------------------------------
    procedure nextarg =
    -- Další argument procedury (podle volací konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;
      a            : pexpitem;

    begin
      -- %%X časem doplnit do stromu dvousměrnej seznam

      if call in iccs_reverse

        -- hledat předchozí
        then
          expr^.get(el,a);
          if arg=a
            then arg:=nil
            else
              while a^.next<>arg loop a:=pexpitem(a^.next); end loop;
              arg:=a;
              end if;

        -- další
        else 
          arg:=pexpitem(arg^.next);
          end if;
      end nextarg;

begin
  firstarg;
  while arg<>nil loop
    if arg^.sub<>nil

      -- hodnota je explicitně uvedena
      then
        if pentity_param(arg^.sym)^.pass=pp_value and x_is_nil(arg^.sub)

          -- speciální případ: předává se NIL hodnotou
          then
            i_gen_push_nil(inst,info,context,arg^.t.getctype^.size);
            params_size+unidata_size_to_unsigned(arg^.t.getctype^.size);

          -- všechny ostatní případy
          else
            declare var
              newcontext : iexprcontext;         -- kontext podvýrazů
              rta_size   : timm32;

            begin
              -- připravit kontext
              case pentity_param(arg^.sym)^.pass
                -- hodnotou
                when pp_value     do
                    i_newcontext(context,newcontext,lm_push_value,arg^.t.getutype);
                    i_setoutpref(newcontext,iop_stack);
                    params_size+unidata_size_to_unsigned(arg^.t.getctype^.size);

                -- odkazem
                when pp_ref       do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});
                    params_size+lpointer32;

                -- odkazem, bez typové kontroly
                when pp_unchecked do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});
                    params_size+lpointer32;

                -- odkazem, včetně odvozených typů
                when pp_class     do 
                    i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});--unimplemented({UNIMP=}000074);
                    params_size+lpointer32;

                -- odkazem, řídící parametr virtuálního volání
                when pp_virtual   do unimplemented({UNIMP=}000082);

                when others do verify({VERIFY=}000063,true);
                end case;

              -- jaké dynamické atributy nás zajímají ?
              newcontext.rta:=pentity_param(arg^.sym)^.rta_used{usedrta};

              -- parametr předaný hodnotou nemá dynamické atributy
              verify({VERIFY=}000327,(pentity_param(arg^.sym)^.pass=pp_value) and (newcontext.rta<>rtattribset:[]));

              -- do celkového součtu velikostí parametrů započítat i velikost použitých runtime atributů
              getrtattribsetsize(newcontext.rta,rta_size);
              params_size+imm32_to_unsigned(rta_size);

              -- vygenerovat parametr
              declare var
                opnone : c_operand;
              begin
                i_load(inst,info,newcontext,context,arg^.sub,opnone);
              leave
                opnone.free(info,context);
                end declare;
              end declare;
            end if;

      -- použít implicitní hodnotu
      else
        unimplemented({UNIMP=}000176);
        end if;

    -- další parametr
    nextarg;
    end loop;
  end i_gen_call_subprogram_parameters;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volaná procedura
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání procedury.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  call             : icallconvention;            -- volací konvence
  pinst            : picodeinst;                 -- instance volané procedury
  ptyp             : pentity_type;               -- typ procedury
  newcontext       : iexprcontext;               -- kontext podvýrazů
  params_size      : t_unsigned;                 -- velikost pushlych parametru v bytech
  instance_needed  : t_logical:=false;           -- T-pushuje se instance, F-nepushuje

begin
  ---- (1) příprava volání: zjistit instanci, volací konvenci, typ procedury ----
  i_gen_call_subprogram_prepare(inst,info,context,expr,pproc,call,pinst,ptyp);


  ---- (2) rezervovat místo pro návratovou hodnotu ----
  if expr^.t.tview<>tview_null and call in iccs_ret_stack then
    declare var
      resultsize   : t_unsigned;                 -- velikost návratové hodnoty
      op1          : c_operand;                  -- operand

    begin     
      -- velikost návratové hodnoty
      resultsize:=value_size_from_expr(expr);

      if ptyp^.result^.pass in pps_ref
        -- odkazem
        then
          -- alokovat, třeba někde na stacku, prostor pro návratovou hodnotu
          op1.create_temporary(inst,info,edtype_from_expr(expr),resultsize);

          -- získanou adresu převést na absolutní
          i_gen_load_address_to_register(inst,info,context,op1);

          -- uložit na stack
          addii(inst,info,ii_push,op1,op0,op0);

        -- hodnotou
        else
          declare var
            alignedsize : t_unsigned32;          -- zarovnaná velikost návratové hodnoty

          begin
            -- zarovnat
            addalign(alignedsize,0,resultsize,istackalign);

            -- zkonvertovat na operand
            op1.create_imm(edt_unsigned,0,unsigned_to_imm32(alignedsize));

            -- snížit hodnotu ESP o velikost proměnné
            addii(inst,info,ii_sub,op_esp,op1,op0);
            end declare;
          end if;

    leave  
      -- uvolnit operand
      op1.free(info,context);
      end declare;
    end if;


  ---- (3) zpracovat argumenty ----
  i_gen_call_subprogram_parameters(inst,info,context,expr,pproc,call,pinst,ptyp,params_size);

  ---- (4) uložit pointer na instanci a načíst adresu procedury ----
  declare var
    nclass         : nodeclass;                  -- převzatá/určená třída jména procedury
    opcall         : c_operand;                  -- adresa volané procedury

  begin
    declare var
      arg          : pexpitem;                   -- argumenty
    begin
      expr^.get(el,arg);
      end declare;
    if el=nil
      then nclass:=nc_proc
      else nclass:=el^.nclass;
      end if;
    case {el^.}nclass
      -- přímo procedura
      when nc_proc do
          verify({VERIFY=}000380,{(el^.ntype<>nt_component) or (pexpcomponent(el)^.s.psym=nil)
                     or} not (pproc^.etype{pexpcomponent(el)^.s.psym^.etype} in ets_subprogram));

          ---- jak je to s pointerem na instanci ? ----
          case pproc^.instance {pentity_subprogram(pexpcomponent(el)^.s.psym)^.instance}
            -- nepředávat
            when tip_none     do { dál již nic nedělat };

            -- volitelně předat, není-li, pak NIL
            when tip_optional do
                instance_needed:=true;

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);
                  if instance<>nil and then instance^.nclass in ncs_value

                    -- je k dispozici => vygenerovat podvýraz
                    then
                      declare var
                        op1 : c_operand;         -- operand
                      begin
                        i_newcontext(context,newcontext,lm_push_addr,nil);
                        i_load(inst,info,newcontext,context,instance,op1);
                      leave
                        op1.free(info,context);
                        end declare;

                    -- není k dispozici => uložit aspoň NIL
                    else
                      addii(inst,info,ii_push,op_0_32bit,op0,op0);
                      end if;
                  end declare;

            -- předat
            when tip_pass     do
                instance_needed:=true;

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy
                  op1      : c_operand;          -- operand

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);
                  verify({VERIFY=}000381,instance=nil);

                  -- vygenerovat podvýraz
                  i_newcontext(context,newcontext,lm_push_addr,nil);
                  i_load(inst,info,newcontext,context,instance,op1);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;

            -- virtuální volání
            when tip_dispatch do
                instance_needed:=true;

                verify({VERIFY=}000527,el^.ntype<>nt_component or else pproc=nil or else pproc^.etype<>et_virtual);

                declare var
                  instance : pexpnode;           -- výraz určující instanci třídy
                  opinst   : c_operand;          -- operand reprezentující adresu instance

                begin
                  -- najít instanci
                  x_classinstance(el^.sub,instance);
                  verify({VERIFY=}000526,instance=nil);

                  -- vygenerovat podvýraz
                  i_newcontext(context,newcontext,lm_addr,nil);
                  i_load(inst,info,newcontext,context,instance,opinst);

                  -- obnovit registry
                  opinst.refresh(inst,info,context);

                  -- uložit pointer na instanci na stack
                  addii(inst,info,ii_push,opinst,op0,op0);

                  -- vypočítat adresu virtuální metody
                  i_gen_virtual_address(inst,info,context,instance,opinst,pproc,true,opcall);

{
                  -- je instance finální objekt ?
                  if x_is_final_object(instance)

                    -- ano => přímé volání
                    then
                      declare var
                        virt_imp : pentity_code; -- skutečná implementace virtuální metody

                      begin
                        -- Poznámka: Interface cast jistě nebude označen za finální objekt, takže
                        -- se můžeme spolehnout na to, že volaná virtuální metoda patří do nativního
                        -- interface instance.

                        -- nalézt implementaci virtuální metody, která je nejvýše v hierarchii
                        virt_imp:=instance^.t.getctype^.interfaces^.get_native_interface^.get_virtual_method(pentity_virtual(pproc)^.vindex);
                        verify({VERIFY=}001128,(virt_imp^.etype=et_virtual and then virt_imp<>pproc)
                                       or else (virt_imp^.etype=et_override and then pentity_override(virt_imp)^.virt.getcentity<>pproc)
                                       or else virt_imp^.is_abstract);

                        -- sestavit adresu implementace virtuální metody
                        i_gen_subprogram_address(inst,info,context,virt_imp,true,opcall);
                        end declare;

                    -- ne => volání přes virtuální tabulku
                    else
                      -- adresa virtuální metody se postupně odvodí z adresy instance
                      opcall.clone(inst,info,context,opinst);

                      -- načíst pointer na instanci do registru
                      i_gen_load_address_to_register_with_dereference(inst,info,context,opcall);

                      -- sestavit adresní operand ukazující na tag
                      opcall.transform_imm_or_reg_to_mem(edt_address,4);
                      opcall.shift_displacement(imm32_to_signed{%%X}(cpu32_class_tag));

                      -- načíst tag (=adresu deskriptoru typu) do registru
                      i_gen_load_address_to_register_with_dereference(inst,info,context,opcall);

                      -- sestavit adresní operand ukazující na adresu virtuální metody
                      declare var
                        _c_class_interface : c_class_interface;
                      begin
                        opcall.transform_reg_to_mem(edt_address,4);
                        opcall.shift_displacement(t_signed(t_desc_class:size+_c_class_interface.normalize_vindex(pentity_virtual(pproc)^.vindex)*4));
                                                            -- %%TODO(COMPATIBILITY) %%TODO(620) ^^^^^ nahradit přímo typem místo instance
                        end declare;
                      end if;
}
                leave
                  -- uvolnit pracovní operandy
                  opinst.free(info,context);
                  end declare;

            when others do verify({VERIFY=}000509,true);
            end case;

          ---- adresa procedury ----
          if pproc^.instance<>tip_dispatch then
            -- máme podvýraz specifikující podprogram ?
            if el<>nil

              -- ano => použijeme ten
              then
                -- vygenerovat podvýraz
                i_newcontext(context,newcontext,lm_imm_to_rel,nil);
                i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

                -- obnovit registry
                opcall.refresh(inst,info,context);

              -- ne => adresu procedury si vygenerujeme přímo
              else
                i_gen_subprogram_address(inst,info,context,pproc,true,opcall);
                end if;
            end if;

      -- pointer na proceduru
      when nc_var,nc_value do
          -- vygenerovat podvýraz
          i_newcontext(context,newcontext,lm_gen,nil);
          i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

          -- obnovit registry
          opcall.refresh(inst,info,context);

          -- pointer budeme zpracovávat po 4bytových kouscích
          opcall.adjust_size(4);

          -- jestliže to není zrovna machine pointer na proceduru, tak se zabývat instancí
          verify({VERIFY=}000806,el^.sub=nil or else not t_is_stype(el^.sub^.t,dt_pointer));
          if pf_machine not in el^.sub^.t.getpflags then
            declare var
              optemp : c_operand;                  -- pracovní registr
              tgcall : itarget;                    -- cíl skoku na volání procedury

            begin
              instance_needed:=true;

              -- bude se hodit jeden registr
              optemp.create_new_register(inst,info,context,edt_address,4);

              -- načíst pointer na instanci
              opcall.shift_displacement(4);
              addii(inst,info,ii_mov,optemp,opcall,op0);
              opcall.unshift_displacement(4);

              -- alokovat návěští skoku
              newtarget(info,tgcall);

              -- zjistit, zda je to platný pointer na instanci
              addii(inst,info,ii_cmp,optemp,op_FFFFFFFF,op0);
              addjump(inst,info,context,ic_e,tgcall);

              -- uložit instanci
              addii(inst,info,ii_push,optemp,op0,op0);

              -- adresa skoku na toto místo
              settarget(info,tgcall,getaddr(inst));

            leave
              -- uvolnit pomocný operand
              optemp.free(info,context);
              end declare;
            end if;

      when others do verify({VERIFY=}000379,true);
      end case;

    -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUTÁ ** záplata !!
    -- Podrobněji viz zakomentované volání SAVEREGS na začátku této procedury
    -- uložit všechny použité registry
    -- %%X Omezit jen na registry skutečně použité ve volané proceduře
    i_reg_save_used(inst,info,context);

    -- instrukce
    addii(inst,info,ii_call,opcall,op0,op0);

    -- ze stacku odstranit parametry, které tam zbyly po úchylných volacích konvencích
    if call in iccs_leave_params then
      if pinst=nil 
        then
          -- Jestliže není k dispozici instance volané procedury, nevíme, o kolik bytů zvýšit
          -- stack pointer. S touto situací není lehké si poradit. Nastává, když volaná procedura
          -- je deklarována uvnitř volající. Důvodem je nevýhodné pořadí generování kódu těchto
          -- dvou procedur. Řešením by mohl být předvýpočet profilu parametrů před vlastním
          -- generováním kódu čehokoliv.
          -- %%HYNEK: Zatim vyreseno tak, ze si sami behem generovani volani spocitame kolik se pushlo.
          --          Neumime zapocitat instanci - napr. dynamicke zjisteni v pripade pointeru na proceduru
          --          je drobet slozitejsi.
        
          if instance_needed then
            unimplemented({UNIMP=}000203);
            end if;

          addopimm(inst,info,context,ii_add,op_esp,params_size);      
        else 
          addopimm(inst,info,context,ii_add,op_esp,pinst^.profile.retfree);
          end if;
      end if;

  leave
    -- uvolnit operand
    opcall.free(info,context);
    end declare;


  ---- (5) převzít výsledek ----
  if expr^.t.tview<>tview_null{stype<>dt_undef} then
    declare var
      resultsize   : t_unsigned;                 -- velikost návratové hodnoty
      resultedtype : t_elementary_data_type;     -- elementární datový typ návratové hodnoty

    begin
      -- velikost výsledku
      resultsize:=value_size_from_expr(expr);
      resultedtype:=edtype_from_expr(expr);

      -- na stacku
      if call in iccs_ret_stack then
        if ptyp^.result^.pass in pps_ref

          -- odkazem
          then
            -- registr pro adresu návratové hodnoty
            vysl.create_new_register(inst,info,context,edt_address,4);

            -- vyzvednout ze stacku
            addii(inst,info,ii_pop,vysl,op0,op0);

            -- transformovat na referenci na návratovou hodnotu
            vysl.transform_reg_to_mem(resultedtype,resultsize);

            -- uvolnit prostor na stacku se dá až ve chvíli kdy bude vyzvednuta
            -- hodnota na kterou právě vracíme pointer

          -- na stacku je hodnota
          else
            -- nepreferuje volající určitou metodu předání ?
            if context.outpref=iop_stack

              -- máme štěstí, nadřazená procedura chce výsledek na stacku
              then
                vysl.create_on_stack(resultedtype,resultsize);

              -- jinak s tím něco udělat
              else
                -- nevešel by se výsledek do registru ?
                if resultsize=1 or resultsize=2 or resultsize=4

                  then
                    declare var
                      alignedsize : t_unsigned32;    -- zarovnaná velikost návratové hodnoty

                    begin 
                      -- zarovnat
                      addalign(alignedsize,0,resultsize,istackalign);

                      -- připravit registr pro výsledek
                      vysl.create_new_register(inst,info,context,resultedtype,resultsize);

                      -- změnit velikost registru na maximální (nelze tak přímo alokovat qůli ESI, EDI)
                      vysl.adjust_size(alignedsize);

                      -- převzít výsledek, a uvolnit zásobník
                      addii(inst,info,ii_pop,vysl,op0,op0);

                      -- změnit velikost registru na skutečnou
                      vysl.adjust_size(resultsize);
                      end declare;

                  else
                    -- alokovat, třeba někde na stacku, prostor pro výsledek
                    vysl.create_temporary(inst,info,resultedtype,resultsize);

                    -- zkopírovat ze stacku do výsledku
                    i_gen_pop_static(inst,info,context,vysl,resultsize);
                    end if;
                end if;
            end if;

      -- v EAX
      elsif call in iccs_ret_eax then
        -- výsledek
        vysl.create_use_register(inst,info,context,resultedtype,ir_eax);
        vysl.adjust_size(resultsize);

      -- nějaká chyba
      else 
        verify({VERIFY=}000104,false);
        end if;

      -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
      i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);
      end declare;
    end if;
  end i_gen_call_subprogram;



----------------------------------------------------------------------------------------------------
procedure i_gen_call (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání procedury.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_subprogram;         -- volaná procedura

begin
  -- nalézt proceduru
  pproc:=pentity_subprogram(expr^.sub^.getsymbol);
  verify({VERIFY=}000513,(pproc<>nil) and not (pproc^.etype in ets_callable));

  -- vygenerovat kód
  i_gen_call_subprogram(inst,info,context,expr,pproc,vysl);
  end i_gen_call;



----------------------------------------------------------------------------------------------------
procedure i_gen_index (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpindex;               -- strom
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu indexování pole.
----------------------------------------------------------------------------------------------------
with
  ci_rcheck;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  lval             : timm32;                     -- dolní mez pole
  size             : timm32;                     -- velikost prvku
  newcontext       : iexprcontext;               -- kontext podvýrazů
  check_array      : t_logical;                  -- je třeba kontrolovat index do dynamického pole?

begin
  -- podvýrazy
  expr^.get(el,er);

  -- dolní mez pole nebo řetězce
  lval:=uniint_to_imm32(el^.t.getctype^.srange.getctype^.lval);

  -- je to unconstrained pole, u kterého se bude kontrolovat index?
  check_array:=el^.t.stype=dt_uarray and then rch_index_array in expr^.get_run_checks(rchcl_gen);

  -- vygenerovat levý podvýraz
  if check_array
    then i_newcontext(context,newcontext,lm_addr_attr,nil);
    else i_newcontext(context,newcontext,lm_gen,nil);
    end if;
  i_load(inst,info,newcontext,context,el,op1);
  verify({VERIFY=}000106,op1.optype<>io_mem);

  -- vygenerovat pravý podvýraz
  -- je třeba hodnota velikosti IDEFREGSIZE, takže se typ neuvádí
  i_newcontext(context,newcontext,lm_reg,nil);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);

  -- unconstrained array?
  if check_array then
    declare var
      last_op      : c_operand;
      subcontext   : iexprcontext;

    begin
      -- načíst :LAST
      i_rta_load(inst,info,context,op1,rta_last,last_op);

      -- behova kontrola mezi indexu pole
      i_gen_index_array_check(inst,info,context,expr^,lval,last_op,op2);
    leave
      -- zrusit
      last_op.free(info,context);
      end declare;

    -- a pak přejít z adresy na vlastní hodnotu
    i_gen_load_address_to_register_with_dereference(inst,info,context,op1);
    op1.transform_imm_or_reg_to_mem(edtype_from_expr(expr),value_size_from_expr(expr));

  -- string?
  elsif el^.t.stype in dts_string then
    declare var
      length_op    : c_operand;

    begin
      -- nacist :length
      i_rta_load(inst,info,context,op1,rta_length,length_op);

      -- behova kontrola mezi indexu retezce
      i_gen_index_string_check(inst,info,context,expr^,length_op,op2);
    leave
      -- zrusit
      length_op.free(info,context);
      end declare;
    end if;

  -- velikost prvku
  size:=unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size);

  -- základ výsledku
  vysl.clone(inst,info,context,op1);
  verify({VERIFY=}000490,vysl.optype<>io_mem);
  vysl.adjust_edtype(edtype_from_expr(expr));
  vysl.adjust_size(value_size_from_expr(expr));
  -- Pozor: nutný předpoklad pro správné ošetření IO_CC

  -- sestavit výslednou adresu
  case op2.optype
    -- registr
    when io_reg do
        -- doplnit jako scale*index
        if vysl.index.reg=ir_none and (size=timm32(1) or size=timm32(2) or size=timm32(4) or size=timm32(8)) then
          vysl.shift_by_index(inst,info,context,op2.reg.reg,imm32_to_unsigned(size));

        -- doplnit jako index
        elsif vysl.index.reg=ir_none then
          -- vynásobit velikostí báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako index
          vysl.shift_by_index(inst,info,context,op2.reg.reg,1);

        -- dosadit jako bázi
        elsif vysl.base.reg=ir_none then
          -- vynásobit velikostní báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako bázi
          vysl.shift_by_base(inst,info,context,op2.reg.reg);

        -- přičíst k bázi
        else
          -- vynásobit velikostí báze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- přičíst k bázi
          addopreg(inst,info,context,ii_add,op1.base.reg,op2);
          end if;

        -- opravit dolní mez
        vysl.unshift_displacement(imm32_to_signed{%%X}(lval*size));

    -- přímá hodnota
    when io_imm do
        -- offset
        vysl.shift_displacement(imm32_to_signed{%%X}((op2.imm-lval)*size));

    -- proměnná
    when io_mem do
        unimplemented({UNIMP=}000071);

    -- podmínka
    when io_cc do
        -- z verify 490 je jasné, že VYSL je IO_MEM

        declare var
          tg_end   : itarget;                    -- návěští pro skok na konec výpočtu indexu

        begin
          -- návěští pro skok na konec výpočtu adresy
          newtarget(info,tg_end);

          -- je součástí adresy nějaký registr ?
          if vysl.base.reg<>ir_none or (vysl._scale=1 and vysl.index.reg<>ir_none)

            -- ano => přičíst k němu
            then
              -- skok na konec při nesplnění podmínky
              addjump(inst,info,context,icondneg[op2.cc],tg_end);

              declare var
                optemp : c_operand;              -- registr vyseparovaný z levého operandu

              begin
                -- vyseparovat registr
                optemp.create_use_register(inst,info,context,edt_unsigned,vysl.get_register);

                -- jedenkrát přičíst velikost báze
                addaddimm(inst,info,context,optemp,imm32_to_unsigned(size));

              leave
                -- uvolnit pracovní registr
                optemp.free(info,context);
                end declare;

              -- adresa skoku na toto místo
              settarget(info,tg_end,getaddr(inst));

            -- ne => vymyslet registr a zakomponovat ho do adresy
            else
              declare var
                optemp : c_operand;

              begin
                -- alokovat registr
                optemp.create_new_register(inst,info,context,edt_unsigned,4);

                -- nacpat do něj velikost
                addopimm(inst,info,context,ii_mov,optemp,0);

                -- skok na konec při nesplnění podmínky
                addjump(inst,info,context,icondneg[op2.cc],tg_end);

                -- nacpat do registru velikost báze
                addopimm(inst,info,context,ii_mov,optemp,imm32_to_unsigned(size));

                -- adresa skoku na toto místo
                settarget(info,tg_end,getaddr(inst));

                -- registr použít jako bázi
                vysl.shift_by_base(inst,info,context,optemp.reg.reg);

              leave;
                -- uvolnit pracovní registr
                optemp.free(info,context);
                end declare;
              end if;
          end declare;

    when others do verify({VERIFY=}000107,true);
    end case;

  -- posunout o interní část řetězce
  if el^.t.stype in dts_string then
    vysl.shift_displacement(lstrisize32);
    end if;

  -- rozhodnout se, jestli uživatel chce hodnotu nebo referenci na ní
  i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes);

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_index;



----------------------------------------------------------------------------------------------------
procedure i_gen_ref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpref;                 -- reference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu reference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el);

  case expr^.t.getpclass
    -- pointer na data
    when pc_data do
        declare var
          op       : c_operand;                  -- levý operand

        begin
          -- vygenerovat podvýraz
          i_newcontext(context,newcontext,lm_addr_attr,nil);
          i_load(inst,info,newcontext,context,el,op);

          -- obnovit registry
          op.refresh(inst,info,context);

          -- sestavit pointer
          i_gen_compose_pointer(inst,info,context,op,vysl);

        leave
          -- uvolnit operand
          op.free(info,context);
          end declare;

    -- pointer na proceduru
    when pc_subprogram do
        verify({VERIFY=}000512,el^.ntype<>nt_component or el^.getsymbol=nil);
        -- sorry, ale class pointery na procedury neumíme
        verify({VERIFY=}001014,expr^.t.getpattrib-rtattribset:[rta_instance]<>rtattribset:[]{%%TODO(SET) expr^.t.getpattrib>rtattribset:[rta_instance]});

        declare var
          instance : pexpnode;                   -- výraz určující instanci třídy
          pproc    : pentity_subprogram;         -- referencovaný podprogram
          opinst   : c_operand;                  -- adresa instance ukládaná do pointeru

        begin
          -- referencovaný podprogram
          pproc:=pentity_subprogram(el^.getsymbol);
          verify({VERIFY=}000514,pproc^.etype not in ets_callable);
          -- if pproc^.etype=et_virtual then unimplemented({UNIMP=}000174); end if;

          -- najít instanci třídy
          x_classinstance(el^.sub,instance);

          -- alokovat pracovní proměnnou
          vysl.create_temporary(inst,info,edt_pointer,value_size_from_expr(expr));

          ----- (1) pointer na instanci, je-li součástí pointeru -----
          verify({VERIFY=}001171,pproc^.instance<>tip_none and rta_instance not in expr^.t.getpattrib);
          if rta_instance in expr^.t.getpattrib then
            declare var
              opptr  : c_operand;                -- kopie výsledku čistě pro účely úpravu módu získání atributů
              oppart : c_operand;                -- část pointeru

            begin
              -- připravit si kopii výsledku
              opptr.clone(inst,info,context,vysl);

              -- vypočítat módy získání atributů uložených ve výsledku
              i_rta_set_modes_of_referenced_value(expr,opptr);

              -- operand odpovídající části pointeru, která obsahuje adresu podprogramu           
              i_rta_load_address(inst,info,context,opptr,rta_instance,oppart);

              -- podprogram se neváže na instanci => uložit FFFFFFFF
              if pproc^.instance=tip_none then
                opinst.create_imm(edt_address,4,unsigned_to_imm32($FFFF_FFFF));

              -- podprogram se váže na instanci, ale nemáme ji => uložit NIL
              elsif pproc^.instance=tip_optional and instance=nil then
                opinst.create_imm(edt_address,4,0);

              -- máme instanci
              elsif instance<>nil and pproc^.instance<>tip_none then
                -- vygenerovat podvýraz a načíst jeho adresu do registru
                i_newcontext(context,newcontext,lm_addr,nil);
                i_load(inst,info,newcontext,context,instance,opinst);
                
                -- obnovit registry
                opinst.refresh(inst,info,context);

              -- jiné případy nemohou nastat
              else
                verify({VERIFY=}000515,true)
                end if;

              -- nacpat do pointeru
              i_gen_simple_assign(inst,info,context,oppart,opinst);

            leave
              -- uvolnit pracovní operand
              opptr.free(info,context);
              oppart.free(info,context);
              end declare;
            end if;
          
          
          ----- (2) vlastní adresa podprogramu -----
          declare var
            oppart : c_operand;                  -- část pointeru
            optemp : c_operand;                  -- adresa podprogramu

          begin
            -- operand odpovídající části pointeru, která obsahuje adresu podprogramu
            oppart.clone(inst,info,context,vysl);
            oppart.adjust_size(4);

            -- sestavit adresu podprogramu
            if pproc^.instance=tip_dispatch

              -- vypočítat virtuální adresu
              then i_gen_virtual_address(inst,info,context,instance,opinst,pproc,false,optemp);

              -- vypočítat statickou adresu
              else i_gen_subprogram_address(inst,info,context,pproc,false,optemp);
              end if;

            -- uložit adresu na podprogram do pointeru
            i_gen_simple_assign(inst,info,context,oppart,optemp);

          leave
            -- uvolnit pracovní operandy
            oppart.free(info,context);
            optemp.free(info,context);
            end declare;

        leave
          -- uvolnit pracovní operandy
          opinst.free(info,context);
          end declare;

    -- pointer na task
    when pc_task do unimplemented({UNIMP=}000064);

    -- pointer na zprávu
    when pc_message do unimplemented({UNIMP=}000083);

    when others do verify({VERIFY=}000807,true);
    end case;
  end i_gen_ref;



----------------------------------------------------------------------------------------------------
procedure i_gen_deref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpref;                 -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el);

  -- způsob provedení dereference do značné míry závisí na třídě pointeru
  case el^.t.getpclass
    -- pointer na data
    when pc_data  do
        -- vygenerovat podvýraz - na této úrovni nás zajímá hodnota pointeru
        i_newcontext(context,newcontext,lm_gen{???},el^.t.getutype);
        i_load(inst,info,newcontext,context,el,vysl);

        -- rozhodnout se, jestli uživatel chce hodnotu (tj. skutečně provést dereferenci), nebo
        -- jestli ho zajímá pouze pointer samotný
        i_choose_reference_or_value(inst,info,context,vysl,expr^.rta_modes,
            edtype_from_expr(expr),value_size_from_expr(expr),for deref use true);

    -- pointer na proceduru
    when pc_subprogram do
        -- vygenerovat podvýraz
        i_newcontext(context,newcontext,lm_gen{lm_pointer},el^.t.getutype);
        i_load(inst,info,newcontext,context,el,vysl);

    -- pointer na task
    when pc_task  do unimplemented({UNIMP=}000245);

    -- pointer na zprávu
    when pc_message do unimplemented({UNIMP=}000246);

    when others do verify({VERIFY=}000892,true);
    end case;
  end i_gen_deref;



----------------------------------------------------------------------------------------------------
procedure i_gen_attrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpattrib;              -- atribut
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu atributu.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure load_rtattrib (
        rta        : in rtattrib;
        vysl       : out c_operand) =
    -- Načte konkrétní run-time atribut.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      opaddr       : c_operand;                  -- operand reprezentující adresu podvýrazu

    begin
      -- načíst adresu proměnné
      i_newcontext(context,newcontext,i_get_load_mode_by_requested_rta(expr^.sub,rta),nil);
      i_load(inst,info,newcontext,context,expr^.sub,opaddr);

      -- načíst požadovaný atribut
      if context.mode in lms_addr
        then i_rta_load_address(inst,info,context,opaddr,rta,vysl);
        else i_rta_load(inst,info,context,opaddr,rta,vysl,for reuse_reg use true);
        end if;

    leave
      -- uvolnit podvýraz
      opaddr.free(info,context);
      end load_rtattrib;



    ------------------------------------------------------------------------------------------------
    procedure load_rtattrib_direct_from_tag (
        rta        : in rtattrib;
        vysl       : out c_operand) =
    -- Načte konkrétní run-time atribut přímo z dodaného tagu.
    -- Tato procedura je určena pouze pro načítání hodnot atributů [ata_designated_*].
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      optag        : c_operand;                  -- operand reprezentující adresu podvýrazu

    begin
      -- načíst adresu proměnné
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,expr^.sub,optag);

      -- načíst požadovaný atribut
      i_rta_load_direct_from_tag(inst,info,context,optag,rta,vysl,for reuse_reg use true);

    leave
      -- uvolnit podvýraz
      optag.free(info,context);
      end load_rtattrib_direct_from_tag;



    ------------------------------------------------------------------------------------------------
    procedure load_using_rtl (
        rtl_proc   : in t_rtl_entity;
        vysl       : out c_operand) =
    -- Načte nějaký parametr z dodaného tagu pomocí funkce RTL knihovny.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      optag        : c_operand;                  -- operand reprezentující adresu podvýrazu

    begin
      -- načíst adresu proměnné
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,expr^.sub,optag);

      -- rezervovat místo na stacku pro návratovou hodnotu
      i_gen_stack_top_reserve(inst,info,context,4);

      -- nemáme instanci, zjišťujeme přímo z tagu, místo ní předáme prostě NIL
      addii(inst,info,ii_push,op_0,op0,op0);

      -- uložit :tag na stack
      addii(inst,info,ii_push,optag,op0,op0);

      -- zavolat RTL funkci
      addcallrtl(inst,info,context,rtl_proc,for save_regs use true);

      -- registr pro výsledek
      vysl.create_new_register(inst,info,context,edt_unsigned,4);

      -- odebrat výsledek ze stacku
      addii(inst,info,ii_pop,vysl,op0,op0);
    leave
      -- uvolnit operand
      optag.free(info,context);
      end load_using_rtl;


var
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  case expr^.aclass
    -- statické atributy
    when atc_static  do
        case expr^.ata
          -- :tag
          when ata_type_tag do
              vysl.create_imm(edt_unsigned,4,0);
              vysl.set_relo_entity(expr^.sub^.t.getctype);

          -- :tag
          when ata_message_tag do
              vysl.create_imm(edt_unsigned,4,0);
              vysl.set_relo_entity(expr^.sub^.getsymbol);

          -- :as_ancestor
          when ata_expr_as_ancestor do
              -- použít prostě výraz, atribut má vliv pouze na vyhodnocení volání virtuální metody
              i_gen(inst,info,context,expr^.sub,vysl);

          when others do verifyx({VERIFY=}000148,true,expr^.pos);
          end case;


    -- dynamické atributy
    when atc_dynamic do
        case expr^.ata
          -- :unchecked
          when ata_var_unchecked   do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :length
          when ata_string_length   do load_rtattrib(rta_length,vysl);

          -- :ord
          when ata_ord_ord         do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :last
          when ata_expr_last       do load_rtattrib(rta_last,vysl);

          -- :size
          when ata_expr_size       do load_rtattrib(rta_size,vysl);

          -- :length neomezeného pole
          when ata_array_length    do load_rtattrib(rta_length,vysl);

          -- :tag
          when ata_expr_tag        do load_rtattrib(rta_tag,vysl);

          -- :tagged
          when ata_expr_tagged     do
              declare var
                optemp : c_operand;

              begin
                -- načíst atribut :tag
                load_rtattrib(rta_tag,optemp);

                -- porovnat
                addii(inst,info,ii_cmp,optemp,op_0,op0);

              leave
                -- uvolnit operand
                optemp.free(info,context);
                end declare;

              -- výsledek je podmínka
              vysl.create_condition(ic_ne);

          -- :designated
          when ata_tag_designated  do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :designated:size
          when ata_designated_size do load_rtattrib_direct_from_tag(rta_size,vysl);

          -- :designated:first
          when ata_designated_first do load_using_rtl(rtl_get_first_from_tag,vysl);

          -- :designated:last
          when ata_designated_last do load_using_rtl(rtl_get_last_from_tag,vysl);
                                      --load_rtattrib(rta_last,vysl);
                                      --load_rtattrib_direct_from_tag(rta_last,vysl);

          when others do verify({VERIFY=}000282,true);--u_nimplemented(59);
          end case;

    when others do verify({VERIFY=}000147,true);
    end case;
  end i_gen_attrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  arg              : pexpitem;                   -- argument
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el,arg);
  er:=arg^.sub;

  -- konverze z ...
  case er^.t.tview
    -- ... unchecked na cokoliv
    when tview_unchecked do
        -- vygenerovat
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,er,vysl);

        -- upravit velikost a elementární datový typ operandu
        vysl.adjust_edtype(edtype_from_expr(expr));
        vysl.adjust_size(value_size_from_expr(expr));

    -- ... Full view ...
    when tview_full     do
        case el^.t.tview
          -- ... na Full view
          when tview_full do
              -- ordinální --> ordinální
              if er^.t.stype in dts_ordinal and el^.t.stype in dts_ordinal then
                -- načíst hodnotu
                i_newcontext(context,newcontext,lm_conv,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- pointer -> pointer
              elsif er^.t.stype=dt_pointer and el^.t.stype=dt_pointer then
                -- načíst hodnotu
                i_newcontext(context,newcontext,lm_pointer,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

                -- jestliže výsledný pointer obsahuje pouze adresu, stačí upravit velikost
                if el^.t.getpattrib=rtattribset:[] then
                  vysl.adjust_edtype(edt_pointer);
                  vysl.adjust_size(4);

                -- jestliže mají pointery různý fyzický layout, musí se zkonvertovat
                elsif el^.t.getpattrib<>er^.t.getpattrib then
                  declare var
                    optemp : c_operand;          -- dočasná proměnná

                  begin
                    -- založit dočasnou proměnnou
                    optemp.create_temporary(inst,info,edt_pointer,value_size_from_expr(el));

                    -- uložit do ní pointer (tím se provede potřebná konverze run-time atributů)
                    i_gen_store_pointer(inst,info,context,vysl,optemp);

                    -- předat výsledek
                    vysl.replace(info,context,optemp);

                  leave
                    -- uvolnit operand
                    optemp.free(info,context);
                    end declare;
                  end if;

              -- fixed-point --> fixed-point
              elsif er^.t.stype in dts_fixed and el^.t.stype in dts_fixed then
                -- načíst hodnotu
                i_newcontext(context,newcontext,lm_conv,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);
              
              -- floating-point --> floating-point
              elsif er^.t.stype in dts_float and el^.t.stype in dts_float then
                unimplemented({UNIMP=}000301);

              -- jiné konverze neumíme
              else 
                verifyx({VERIFY=}000611,true,expr^.pos);
                end if;

          -- ... Partial view

          when others do verify({VERIFY=}000272,true);
          end case;

    when others do verify({VERIFY=}000149,true);
    end case;
  end i_gen_typecast;



----------------------------------------------------------------------------------------------------
procedure i_gen_message_send (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu odeslání zprávy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argument
  opnone           : c_operand;                  -- prázdný výsledek
  newcontext       : iexprcontext;               -- kontext výrazu

begin
  -- podvýrazy
  expr^.get(el,arg);

  -- tag výjimky
  i_newcontext(context,newcontext,lm_push_value,nil);
  i_load(inst,info,newcontext,context,el,opnone);

  -- parametry
  if arg<>nil

    -- má parametry
    then
      unimplemented({UNIMP=}000104);

    -- nemá parametry => na stack dát NIL
    else
      i_gen_push_value(inst,info,context,op_0);
      end if;

leave
  -- uvolnit operand
  opnone.free(info,context);
  end i_gen_message_send;



----------------------------------------------------------------------------------------------------
procedure i_gen_callspec (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcallspec;            -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu volání speciální metody.
----------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  procedure load_range =
  -- Uloží na zásobník rozsah provádění speciální metody, pokud byl dodán
  --------------------------------------------------------------------------------------------------
  var
    newcontext : iexprcontext;   -- kontext výrazu
    opnone1    : c_operand;      -- prázdný výsledek
    opnone2    : c_operand;      -- prázdný výsledek

  begin
    -- pokud máme rozsah provádění, uložit na zásobník
    if expr^.range_low<>nil then
      -- uložit rozsah provádění
      i_newcontext(context,newcontext,lm_push_value,inttype_size);
      i_load(inst,info,newcontext,context,expr^.range_low,opnone1);
      i_newcontext(context,newcontext,lm_push_value,inttype_size);
      i_load(inst,info,newcontext,context,expr^.range_high,opnone2);
      end if;
  leave
    -- uvolnit operandy
    opnone1.free(info,context);
    opnone2.free(info,context);
    end load_range;

var
  el               : pexpnode;                   -- instance třídy (je-li to metoda třídy)
  arglist          : pexpitem;                   -- seznam parametrů

begin
  -- oddělit instanci třídy/modul a parametry
  expr^.get(el,arglist);

  -- je speciální metoda již pevně určena ?
  if (expr^.spec<>nil) and (el=nil)

    -- ano => zavolat ji přímo
    then
      verify({VERIFY=}000581,(arglist=nil) or (el<>nil));

      -- zavolat jako normální podprogram
      i_gen_call_subprogram(inst,info,context,expr,expr^.spec,vysl);

    -- ne => vybrat metodu podle tagu instance třídy/modulu
    else
      verify({VERIFY=}000582,(el=nil) or (arglist<>nil));
      verify({VERIFY=}001479,(expr^.range_low=nil) xor (expr^.range_high=nil));

      case el^.nclass
        -- podvýraz je proměnná
        when nc_var     do
            --verify({VERIFY=}000583,not el^.t.isclass);

            declare var
              opnone1    : c_operand;            -- prázdný výsledek
              opnone2    : c_operand;            -- prázdný výsledek

            begin
              -- byla zadána odděleně instance+tag, nebo rovnou proměnná (otagovaná) ?
              if expr^.explicit_inst<>nil
                then
                  declare var
                    newcontext : iexprcontext;   -- kontext výrazu

                  begin
                    verify({VERIFY=}001482,expr^.spec<>nil);

                    -- uložit dodaný tag
                    i_newcontext(context,newcontext,lm_push_value,inttype_tag);
                    i_load(inst,info,newcontext,context,el,opnone1);

                    -- uložit adresu instance
                    i_newcontext(context,newcontext,lm_push_value,{expr^.explicit_inst^.t.getctype}inttype_machine_pointer);
                    i_load(inst,info,newcontext,context,expr^.explicit_inst,opnone2);

                    -- uložit rozsah provádění
                    load_range;
                    end declare;

                else
                  declare var
                    newcontext : iexprcontext;
                    opaddr     : c_operand;

                  begin
                    -- pokud nemá tag, nemůže mít žádnou spec. metodu
                    if rta_tag not in el^.rta_avail then
                      return;
                      end if;

                    -- uložit tag (z instance):
                    -- načíst adresu instance
                    i_newcontext(context,newcontext,i_get_load_mode_by_requested_rta(el,rta_tag),nil);
                    i_load(inst,info,newcontext,context,el,opaddr);

                    -- načíst z ní tag na zásobník
                    i_rta_push(inst,info,context,opaddr,rta_tag);

                    -- uložit adresu instance na zásobník
                    i_newcontext(context,newcontext,lm_push_addr,inttype_machine_pointer);
                    i_load(inst,info,newcontext,context,el,opnone1);

                    -- uložit rozsah provádění
                    load_range;

                  leave
                    -- uvolnit operandy
                    opaddr.free(info,context);
                    end declare;
                  end if;
            leave
              -- uvolnit operandy
              opnone2.free(info,context);
              opnone1.free(info,context);
              end declare;

            -- zavolat speciální metodu
            if expr^.spec=nil

              -- a to první dostupnou
              then
                i_dispatch_special(inst,info,context,expr^.spectype,expr^.range_low<>nil);

              -- jinak tu pevně určenou
              else
                declare var
                  op1 : c_operand;               -- operand

                begin
                  -- vrátit adresu procedury
                  i_gen_subprogram_address(inst,info,context,expr^.spec,true,op1);

                  -- zavolat
                  addii(inst,info,ii_call,op1,op0,op0);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;
                end if;

        -- podvýraz je modul
        when nc_module  do
            unimplemented({UNIMP=}000194);

        -- podvýraz je tag
        when nc_tag, nc_value do
            declare var
              opnone1    : c_operand;            -- prázdný výsledek
              opnone2    : c_operand;            -- prázdný výsledek
              newcontext : iexprcontext;         -- kontext výrazu

            begin
              verify({VERIFY=}001467,expr^.explicit_inst=nil or expr^.spec<>nil);
              --verify({VERIFY=}001468,el^....popisuje vyraz typu tag);

              -- uložit tag na zásobník
              i_newcontext(context,newcontext,lm_push_value,inttype_tag);
              i_load(inst,info,newcontext,context,el,opnone1);

              -- uložit adresu instance na zásobník
              i_newcontext(context,newcontext,lm_push_value,inttype_machine_pointer);
              i_load(inst,info,newcontext,context,expr^.explicit_inst,opnone2);

              -- uložit rozsah provádění
              load_range;
            leave
              opnone2.free(info,context);
              opnone1.free(info,context);
              end declare;

            -- zavolat speciální metodu podle tagu
            i_dispatch_special(inst,info,context,expr^.spectype,expr^.range_low<>nil);

        when others do verify({VERIFY=}000809,true);
        end case;
      end if;

  -- výsledek veškerý žádný
  --nullop(vysl,io_none);

{ Původní verze pouze pro speciální metody třídy:

  if expr^.sub<>nil

    -- máme podvýraz, podívat se, co je zač
    then
      case expr^.sub^.nclass
        -- podvýraz je instance třídy
        when nc_var     do
            -- adresu instance uložit na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,expr^.sub,opnone);

            -- zavolat speciální metody
            i_dispatch_special(inst,info,expr^.spectype);


        -- podvýraz je modul
        when nc_module  do
            unimplemented({UNIMP=}000213);


        when others do verify({VERIFY=}000810,true);
        end case;

    -- podvýraz nemáme, tudíž musíme mít adresu entry rovnou k dispozici
    when others do
      unimplemented({UNIMP=}000125);
      end if;

  -- výsledek veškerý žádný
  nullop(vysl,io_none);
 }
  end i_gen_callspec;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_rtl (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpcallrtl;             -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu přímého volání funkce RTL.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_rtl;

var
  pproc            : pentity_subprogram;         -- volaná RTL procedura
  call             : icallconvention;            -- volací konvence
  pinst            : picodeinst;                 -- instance volané procedury
  ptyp             : pentity_type;               -- typ procedury
  newcontext       : iexprcontext;               -- kontext podvýrazů
  params_size      : t_unsigned;

begin
  -- nalézt RTL proceduru
  rtl_get_entity(expr^.rtl_proc,pproc);
  verify({VERIFY=}000718,pproc=nil or else pproc^.etype not in ets_callable);


  ---- (1) příprava volání: zjistit instanci, volací konvenci, typ procedury ----
  i_gen_call_subprogram_prepare(inst,info,context,expr,pproc,call,pinst,ptyp);


  ---- (2) zpracovat argumenty ----
  i_gen_call_subprogram_parameters(inst,info,context,expr,pproc,call,pinst,ptyp,params_size);


  ---- (3) volání ----
  addcallrtl(inst,info,context,expr^.rtl_proc,true);
  end i_gen_call_rtl;



----------------------------------------------------------------------------------------------------
procedure i_gen_this (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpthis;                -- dereference
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu THIS.
----------------------------------------------------------------------------------------------------
begin
  -- vygenerovat a načíst adresu instance třídy
  i_load_this_address(inst,info,context,edtype_from_expr(expr),value_size_from_expr(expr),uda_0,vysl);
  --verify({VERIFY=}000696,vysl.size<>unidata_size_to_unsigned(expr^.t.getsize));
  end i_gen_this;


    
----------------------------------------------------------------------------------------------------
procedure i_gen_fake_tag (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    expr           : in pexpfaketag;             -- fake tag interfacu třídy
    vysl           : out c_operand) =            -- výsledek
-- Generování kódu fake tagu interfacu třídy.
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat operand
  vysl.create_imm(edt_unsigned,4,0);

  -- doplnit relokaci
  vysl.set_relo_interface(expr^.interface);
  end i_gen_fake_tag;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
#if #declared ondra; then;
with
  standard.conversions;
#end if;

begin
  verify({VERIFY=}000028,(expr=nil) or (expr^.zprac<>expr^.zprac:last));

  -- vygenerovat výraz
  case expr^.ntype
    -- binární operátor
    when nt_operator  do i_gen_operator(inst,info,context,pexpoper(expr),vysl);

    -- unární operátor
    when nt_unary     do i_gen_unary(inst,info,context,pexpunary(expr),vysl);

    -- komponenta
    when nt_component do i_gen_component(inst,info,context,pexpcomponent(expr),vysl);

    -- přímá hodnota
    when nt_imm       do i_gen_imm(inst,info,context,pexpimm(expr),vysl);

    -- agregát
    when nt_aggregate do i_gen_aggregate(inst,info,context,pexpaggregate(expr),vysl);

    -- volání procedury
    when nt_call      do i_gen_call(inst,info,context,pexplist(expr),vysl);

    -- index pole
    when nt_index     do i_gen_index(inst,info,context,pexpindex(expr),vysl);

    -- reference
    when nt_ref       do i_gen_ref(inst,info,context,pexpref(expr),vysl);

    -- dereference
    when nt_deref     do i_gen_deref(inst,info,context,pexpref(expr),vysl);

    -- atribut
    when nt_attrib    do i_gen_attrib(inst,info,context,pexpattrib(expr),vysl);

    -- přetypování
    when nt_typecast  do i_gen_typecast(inst,info,context,pexplist(expr),vysl);

    -- odeslání zprávy
    when nt_send      do i_gen_message_send(inst,info,context,pexplist(expr),vysl);

    -- volání speciální metody
    when nt_callspec  do i_gen_callspec(inst,info,context,pexpcallspec(expr),vysl);

    -- přímé volání funkce RTL
    when nt_call_rtl  do i_gen_call_rtl(inst,info,context,pexpcallrtl(expr),vysl);

    -- THIS
    when nt_this      do i_gen_this(inst,info,context,pexpthis(expr),vysl);

    -- fake tag interfacu třídy
    when nt_fake_tag  do i_gen_fake_tag(inst,info,context,pexpfaketag(expr),vysl);

    -- selektor slotu taskové proměnné
    when nt_task_var_slot do i_gen_task_var_slot(inst,info,context,pexptaskvarslot(expr),vysl);

    -- jiné symboly tu nemají co dělat
    when others do
      #if #declared ondra; then;
        dumptree(expr);
        debug_dump(unsigned_to_string(expr^.ntype:ord));
      #end if;
        verifyx({VERIFY=}000029,true,expr^.pos);

    end case;
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_gen_expr =
-- Generování kódu výrazu.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- připravit kontext
    i_createcontext(context,lm_gen,expr^.t.getutype{nil});

    -- vygenerovat výraz
    i_load(inst,info,context,context,expr,vysl);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_gen_expr;



----------------------------------------------------------------------------------------------------
procedure i_gen_cond =
-- Generování kódu výrazu.
-- Pokud je cíl skoku nastaven na TGFALLTHRU, tak neskočí nikam.
----------------------------------------------------------------------------------------------------
with
  ci_logical;

var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu
  newcontext       : iexprcontext;               -- kontext podvýrazu

begin
  verify({VERIFY=}000601,(ttarget=tgfallthru) and (ftarget=tgfallthru));

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani podminky ------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat podmínku
    if (expr^.ntype=nt_operator) and (pexpoper(expr)^.oper in expopertypeset:[op_and,op_or,op_and_then,op_or_else])

      -- generovat řetěz konjunkcí/disjunkcí
      then
        -- připravit kontext
        i_createcontext(context,lm_gen,nil);

        -- vygeneovat
        i_gen_logical_chain(inst,info,context,pexpoper(expr),ttarget,ftarget,vysl);

      -- generovat jako obyčejný výraz
      else
        declare var
          cc       : icond;                      -- podmínka

        begin
          declare var
            op1    : c_operand;                  -- operand

          begin
            -- připravit kontext
            i_createcontext(context,lm_gen{reg},expr^.t.getctype);

            -- vygenerovat a načíst výraz
            i_newcontext(context,newcontext,lm_reg,nil);
            i_load(inst,info,newcontext,context,expr,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            if op1.optype=io_cc

              -- přímo podmínka
              then cc:=op1.cc

              -- ještě porovnat
              else
                -- porovnat
                addii(inst,info,ii_cmp,op1,op_0,op0);

                -- podmínka
                cc:=ic_nz;
                end if;

          leave
            -- uvolnit operand
            op1.free(info,context);
            end declare;

          -- výsledný skok
          i_gen_logical_jump(inst,info,context,false,cc,ttarget,ftarget,vysl);
          end declare;
        end if;
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;

leave
  -- uvolnit operand
  vysl.free(info,context);
  end i_gen_cond;



----------------------------------------------------------------------------------------------------
procedure i_load_message_code =
-- Načte kód zprávy do EAX.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek
  context          : iexprcontext;               -- kontext výrazu
  newcontext       : iexprcontext;               -- kontext podvýrazu

begin
  verify({VERIFY=}000310,(expr^.ntype<>nt_accept) or not (expr^.sub^.nclass in ncs_message_code));

  begin
    -- připravit kontext
    i_createcontext(context,lm_reg_eax,nil);

    -- vygenerovat výraz
    i_newcontext(context,newcontext,lm_reg_eax,nil);
    i_load(inst,info,newcontext,context,expr^.sub,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný výsledek
    vysl.free(info,context);
    end;
  end i_load_message_code;



----------------------------------------------------------------------------------------------------
procedure i_load_expr =
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni vyrazu -----------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a načíst výsledek
    i_load(inst,info,{new}context,context,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_expr;



----------------------------------------------------------------------------------------------------
procedure i_load_subexpr =
-- Vygeneruje a načte hodnotu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni podvyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a načíst výsledek
    i_load(inst,info,subcontext,supercontext,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,supercontext);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subexpr;



----------------------------------------------------------------------------------------------------
procedure i_load_subrtattrib =
-- Načte požadovaný run-time atribut daného výrazu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext výrazu
  op               : c_operand;                  -- operand pro mezivýsledek

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin  
    -- načíst adresu proměnné
    i_newcontext(supercontext,context,i_get_load_mode_by_requested_rta(expr,rta),nil);
    i_load(inst,info,context,supercontext,expr,op);

    -- načíst hodnotu požadovaného atributu
    if reg
      -- do registru (popřípadě ponechat konstantní)
      then i_rta_load(inst,info,supercontext,op,rta,vysl,for no_memory use true,for reuse_reg use true);
      -- do temporary proměnné
      else i_rta_store_to_temporary(inst,info,supercontext,op,rta,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit již nepotřebný operand
    op.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subrtattrib;



----------------------------------------------------------------------------------------------------
procedure initopertab =
-- Inicializace řídící tabulky optimalizace binárních operátorů.
----------------------------------------------------------------------------------------------------
with 
  ci_integer,
  ci_fixed,
  ci_logical,
  ci_pointer,
  ci_string,
  ci_set,
  ci_tag;

begin
  ---- celočíselné ----
  -- *
  oset1s(opertab,op_mul,dts_integer,^i_gen_op_integer_mul);

  -- div mod
  osetss(opertab,[op_idiv,op_imod],dts_integer,^i_gen_op_integer_div_mod);

  -- + - bitové AND OR XOR SHL SHR
  osetss(opertab,[op_add,op_sub,op_bitand,op_bitor,op_bitxor,op_shl,op_shr],dts_integer,^i_gen_op_integer);

  -- :=
  oset1s(opertab,op_assign,dts_integer,^i_gen_op_assign);


  ---- fixed-point ----
  -- *
  oset1s(opertab,op_mul,dts_fixed,^i_gen_op_fixed_mul);

  -- /
  oset1s(opertab,op_div,dts_fixed,^i_gen_op_fixed_div);

  -- +
  oset1s(opertab,op_add,dts_fixed,^i_gen_op_fixed_add);

  -- -
  oset1s(opertab,op_sub,dts_fixed,^i_gen_op_fixed_sub);

  -- :=
  oset1s(opertab,op_assign,dts_fixed,^i_gen_op_assign);


  ---- floating-point ----
  -- :=
  oset1s(opertab,op_assign,dts_float,^i_gen_op_assign);


  ---- znakové ----
  -- :=
  oset1s(opertab,op_assign,dts_char,^i_gen_op_assign);


  ---- logické ----
  -- AND OR
  osetss(opertab,[op_and_then,op_or_else,op_and,op_or],dts_u_logical,^i_gen_op_logical_and_or);

  -- XOR
  oset1s(opertab,op_xor,dts_u_logical,^i_gen_op_logical_xor);

  -- :=
  oset1s(opertab,op_assign,dts_logical,^i_gen_op_assign_logical);


  ---- výčtové ----
  -- :=
  oset1s(opertab,op_assign,dts_enum,^i_gen_op_assign);


  ---- ordinální typy obecně ----
  -- < <= > >= <> =
  osetss(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dts_ordinal,^i_gen_op_compare_ordinal);
  osets1(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dt_unilogical,^i_gen_op_compare_ordinal);


  ---- fixed-point relation operations ----
  -- < <= > >= <> =
  osetss(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dts_fixed,^i_gen_op_compare_ordinal);


  ---- pointery ----
  -- :=
  oset11(opertab,op_assign,dt_pointer,^i_gen_op_assign_pointer);

  -- <> =
  osetss(opertab,[op_ne,op_eq],dts_pointer,^i_gen_op_compare_pointer);


  ---- řetězce ----
  -- :=
  oset1s(opertab,op_assign,dts_string,^i_gen_op_assign_string);

  -- &
  oset1s(opertab,op_concat,dts_string,^i_gen_op_concat_string);

  -- < <= > >=
  osetss(opertab,[op_lt,op_le,op_gt,op_ge],dts_string,^i_gen_op_order_string);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_string,^i_gen_op_compare_string);


  ---- pole ----
  -- :=
  oset1s(opertab,op_assign,dts_array,^i_gen_op_assign);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_array,^i_gen_op_compare_array);


  ---- množiny ----
  -- :=
  oset11(opertab,op_assign,dt_set,^i_gen_op_assign);

  -- + - *
  osetss(opertab,[op_union,op_diff,op_isect],dts_set,^i_gen_op_set);

  -- IN NOT IN
  osetss(opertab,[op_in,op_notin],dts_u_set,^i_gen_op_in_set);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_set,^i_gen_op_compare_set);


  ---- recordy ----
  -- :=
  oset11(opertab,op_assign,dt_record,^i_gen_op_assign);

  -- = <>
  osets1(opertab,[op_eq,op_ne],dt_record,^i_gen_op_compare_record);


  ---- tagy ----
  -- :=
  oset1s(opertab,op_assign,dts_tag,^i_gen_op_assign);

  -- <> = < > <= >=
  osetss(opertab,[op_ne,op_eq,op_lt,op_le,op_gt,op_ge],dts_tag,^i_gen_op_compare_order_tag);


  ---- třídy ----
  -- :=
  oset1s(opertab,op_assign,dts_class,^i_gen_op_assign);


  ---- unchecked ----
  --oset11(opertab,op_assign,st_unchecked,^i_gen_op_assign);
  end initopertab;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initopertab;
  end entry;



end ci_expr;