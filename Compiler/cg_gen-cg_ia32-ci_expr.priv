----------------------------------------------------------------------------------------------------
module private ci_expr =
-- P©eklada‡ Flexu.
-- Generov n¡ v˜razu.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvo©il.
----------------------------------------------------------------------------------------------------
{

-- Dodˆlat p©ejmenov n¡ AH-AL, BH-BL, ..., aby se nemuselo v LOADREG
   dˆlat MOV AL,AH

-- Kam pat©¡ konverze ? M  je tam p©id vat typov  kontrola (resp. nˆjak 
   jin  f ze p©ekladu v˜razu), nebo si je m  dom˜¨let a‘ gener tor k¢du ?

   ad 1) To je asi v˜hodnˆj¨¡, konverze aritmetick˜ch v˜raz– jsou trivi ln¡
         a u manipulac¡ s ©etˆzci/poli/recordy pot©ebuju vˆdˆt na ‡em jsem,
         abych dok zal zvolit speci ln¡ variantu p©ekladu.

   ad 2) V druh‚m p©¡padˆ by to mˆlo asi b˜t sou‡ st¡ LOADREG.


-- Optimalizace:
     * zarovn n¡
     * zmˆna po©ad¡ instrukc¡
     * (‡ ste‡n‚) rozv¡jen¡ cykl–
     * ©¡d¡c¡ promˆnn‚ cykl– do registr–
     * ‡asto pou‘¡van‚ podv˜razy do registr–
     * registry se zn mou konstantn¡ hodnotou (zpravidla 0 nebo 1)
     * v EDX zbyde p©i n soben¡ dostate‡nˆ mal˜ch ‡¡sel nula

     * n soben¡ 3 a 5 a 9 pomoc¡ LEA
     * n soben¡ kombinac¡ ADD/SHL/LEA: nap©¡klad 12*EAX: SHL EAX,2 LEA EAX,[EAX+2*EAX]
     * rozpozn n¡ indexu tvaru X*scale, kde scale=2,4,8
     * "if x>0 then x:=-1 else x:=0" --> "cmp eax,1; sbb eax,eax"
     * registr EBP v–bec nepot©ebuju k adresaci lok ln¡ch promˆnn˜ch - sta‡¡
       mi na to ESP, v‘dyŸ v ka‘d‚m okam‘iku v¡m, co je na stacku
     * m lo pravdˆpodobn˜ k¢d lze s v˜hodou um¡stit do £plnˆ jin‚ oblasti
       code segmentu:

           read(...,chyba);
           if chyba then
             write('chyba');
             return;
             end if;
           ...
           end proc;

       p©elo‘it jako:

           read(...,chyba);
           if chyba then goto x end if  -- zde se eliminuje jeden skok
           ...
         r:
           end proc;

         x:write('chyba');
           goto r;
     * m¡sto "mov exc,[x]; push eax" dˆlat jen "push [x]"
     * ve v˜razu (s1 & s2)[i] fyzicky nespojovat ©etˆzce ale inteligentnˆ
       p©epo‡¡tat index
     * p©¡kaz typu:
          loop
            if invariant_vzhledek k cyklu
              then ...
              else ...
              end if
            end loop
       p©elo‘it jako dva cykly s vyhodnocen¡m IFu vnˆ.
     * pro rozs hl‚ konstantn¡ mno‘iny generovat membership-test funkce
       (podobnˆ by se daly ©e¨it i dal¨¡ operace na velk˜mi konstantn¡mi
       agreg ty)

-- Specifick‚ optimalizace pro procesory AMD:
     * m¡sto SHL EAX,1 generovat ADD EAX,EAX - t©eba procesor AMD K6 m 
       dvˆ s‡¡ta‡ky a jen jednu shiftova‡ku - nicm‚nˆ se t¡m nastav¡
       jin‚ flagy (AF)
     * na procesoru AMD K6 m¡sto XOR EAX,EAX dˆlat MOV EAX,0
     * MUL a IMUL nahrazovat za SHL ADD jen do celkov‚ latence 3, pak
       je na AMD rychlej¨¡ dˆlat MUL
     * m¡sto CDQ dˆlat MOV EDX,EAX SAR EDX,31 - je to rychlej¨¡ na dek¢dov n¡
       (©ekl bych, ‘e pro CBW se to nevyplat¡, proto‘e MOV AH,AL bude zmaten˜
       z pou‘it¡ dvou ‡tvrtek t‚ho‘ registru - ale je to jen domˆnka)
     * m¡sto dˆlen¡ n sobit p©evr cenou hodnotou - viz 21924.PDF str. 75 (65)

-- Odstranit %%OLD

-- Obsluha agreg t– je dost natvrdo (=neoptim lnˆ), proto‘e je to pomˆrnˆ
   komplikovan  z le‘itost a babrat se s t¡m budu a‘ ve 4.0.1.

-- Dodˆlat:
    +I027 - nˆkde to generuje chybn‚ instrukce
    -I099 - inkluze mno‘iny (< <= > >=)
    +I344 - v procedu©e i_gen_load_string_and_last se zd , ‘e v˜raz nem 
            dynamick‚ atributy :size ani :last
    -I349 - uvolnˆn¡ nepou‘it‚ho univerz ln¡ho registru
     I388 - pokus o zji¨tˆn¡ tagu non-tagged typu
    -U115 - konkatenace unconstrained string– jej¡m‘ v˜sledkem je opˆt
            unconstrained string
     U122 - vol n¡ virtu ln¡ metody
    +U132 - mno‘inov‚ + - a * na operandech o nep©¡zniv‚ velikosti
    +U154 - agreg t mno‘iny
    +U170 - porovn n¡ bin rn¡ho bloku na NIL
    -U173 - nˆjak˜ v˜po‡et :last pro "pchararray:=pchar:unchecked;"

     I027 - nˆkde to generuje chybn‚ instrukce
     I093
     I107
     I148 - vol n¡ metody p©edka
     U118
     U140
}
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_base,
  cc_base.cc_debug,
  cc_base.cc_type,
  cc_base.cc_util,
  cc_attr,
  cx_expr,
  cx_expr.cx_util,
  cx_expr.cx_imm,
  ci_code,
  ci_code.ci_operand,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_context,
  ci_reg,
  ci_fragment,
  ci_struct,
  cp_cpu.cp_32.cp_metadata,
  cp_cpu.cp_32.cp_util,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_ia32.ci_instr,
  cc_options;

----- %%TECH Re‘imy generov n¡ v˜razu ------------------------------------
-- Gener tor v˜raz– dok ‘e pracovat v nˆkolika re‘imech, resp. p©ed vat
-- v˜sledek v˜po‡tu v˜razu v nˆkolika r–zn˜ch tvarech.
--   Procedury pro generov n¡ r–zn˜ch druh– uzl– (I_GEN_*) pracuj¡ v jak‚msi
-- z kladn¡m re‘imu, kter˜ standardnˆ generuje v˜sledek v jak‚msi p©irozenˆ
-- minim ln¡m tvaru - sou‡et dvou celo‡¡seln˜ch v˜raz– vr t¡ v registru,
-- agreg t pole v do‡asn‚ promˆnn‚ apod.
--   Procedura I_LOAD nav¡c dovoluje v˜sledek p©ev‚st do po‘adovan‚ho tvaru
-- nebo s n¡m prov‚st po‘adovanou operaci (nap©¡klad ulo‘it na stack).
--   Po‘adovan˜ tvar v˜sledku je specifikov n kontextem generov n¡ v˜razu,
-- zejm‚na promˆnnou CONTEXT.MODE:
--   - lm_gen        -- v˜sledek je v p©irozen‚m tvaru bez £prav
--   - lm_addr       -- adresa objektu ur‡en‚ho podv˜razem (p©edpokl d  se,
--                      ‘e podv˜raz ur‡uje objekt; je-li to hodnota, bude
--                      v˜sledkem pravdˆpodobnˆ chybn  interpretace hodnoty)
--                        Pokud je nastaven preferovan˜ registr (v m¢du
--                      IRM_ADDR), na‡te adresu do nˆj.
--   - lm_addr_attr  -- adresa objektu obsahuj¡c¡ho dynamick‚ atributy (pokud
--                      je podv˜raz parametr p©ed van˜ hodnotou (promˆnn 
--                      s implicitn¡ dereferenc¡), je v˜sledkem adresa
--                      pointeru na tento objekt; podrobnˆji viz d le)
--   - lm_conv       -- v˜sledek v p©irozen‚m tvaru je konvertov n na
--                      po‘adovan˜ typ
--   - lm_reg        -- v˜sledek je na‡ten do registru (mimo p©¡m˜ch hodnot)
--   - lm_reg_all    -- v˜sledek je na‡ten do registru i kdy‘ je to p©¡m 
--                      hodnota
--   - lm_imm8_cl    -- v˜sledek je konvertov n na osmibitovou p©¡mou hodnotu
--                      nebo ulo‘en do CL (s o©¡znut¡m)
--   - lm_reg_eax    -- v˜sledek je ulo‘en do EAX
--   - lm_imm_to_rel -- je-li v˜sledkem p©¡m  hodnota, je interpretov na jako
--                      relativn¡ adresa
--   - lm_push_value -- hodnota v˜razu je ulo‘ena na stack
--   - lm_push_addr  -- adresa hodnoty v˜razu je ulo‘ena na stack
--   - lm_push_and_load_addr -- adresa hodnoty v˜razu je ulo‘ena na stack
--                      a sou‡asnˆ vr cena jako v˜sledek v˜po‡tu v˜razu
--   - lm_temp_value -- hodnotu v˜razu ulo‘¡ do temporary promˆnn‚, kromˆ
--                      p©¡m‚ hodnoty, kterou nech  v p–vodn¡m stavu
--   - lm_temp_addr  -- adresu objektu ulo‘¡ do temporary promˆnn‚
--   - lm_pointer,   -- hodnotu v˜razu typu pointer normalizuje podle
--                      dodan‚ho typu pointer (=p©id /odstran¡/konvertuje
--                      dynamick‚ atributy) a vr t¡ buƒ p–vodn¡ operand, nebo
--                      ulo‘¡ do temporary promˆnn‚ a vr t¡ jej¡ adresu
--   - lm_pointer_reg-- jako p©edchoz¡, ale lze-li to, tak vr t¡ pointer
--                      v registru
--
-- P©i generov n¡ mus¡ b˜t zvl ¨tn¡ pozornost vˆnov na dynamick˜m atribut–m.
-- Po‘adovan‚ dynamick‚ atributy jsou ulo‘eny v promˆnn‚ CONTEXT.RTA a jsou
-- p©¡pustn‚ pouze v re‘imech LM_ADDR_ATTR a LM_PUSH_ADDR.
--   Obsluha dynamick˜ch atribut– vy‘aduje p©¡mo £pravy v procedur ch
-- I_GEN_*, nelze ji zahrnout pouze do I_LOAD. Na¨tˆst¡ je vy‘adov na jen
-- u konkr‚tn¡ch typ– podv˜raz. Obecnˆ lze dynamick‚ atributy vy‘adovat
-- u tˆchto typ– v˜raz–:
--   - promˆnn  libovoln‚ho typu  -- pokud je to parametr s dynamick˜mi
--                                   atributy, p©evezmou se; ostatn¡ atributy
--                                   se ur‡¡ staticky
--   - dereferencovan˜ pointer    -- nˆkter‚ atributy jsou sou‡ st¡ pointeru,
--                                   ostatn¡ se ur‡¡ staticky
--   - v˜raz kompozitn¡ho typu, konkr‚tnˆ:
--     - z©etˆzen¡ pol¡/©etˆzc–   -- :last a :size se vypo‡¡taj¡ bˆhem
--                                   z©etˆzov n¡, :tag je ur‡en staticky
--     - mno‘inov‚ operace + - *  -- smysl m  pouze atribut :tag a ten je
--                                   ur‡en staticky
--     - agreg t                  -- :last a :size se vypo‡¡taj¡ p©i
--                                   konstrukci agreg tu, nebo jsou ur‡eny
--                                   staticky
--------------------------------------------------------------------------

----- %%TECH Generov n¡ zkr cen˜ch p©i©azen¡ -----------------------------
-- Podle definice jazyka se kr cen‚ p©i©azen¡ tvaru "A1 op ... op An" chov 
-- stejnˆ jako p©i©azen¡ tvaru "A1 := A1 op ... op An". Z toho vypl˜vaj¡
-- omezen¡ pro gener tor k¢du - kdy‘ je nap©¡klad op=+, nelze k A1 p©i‡¡tat
-- hodnoty ostatn¡ch operand–, ale mus¡ se hodnota A1 zkop¡rovat do registru.
--   Podobnˆ t©eba p©i spojov n¡ ©etˆzc– se mus¡ d t pozor na p©¡pad "s & s".
-- Lze sice postupnˆ p©ipojovat operandy vpravo k operandu vlevo, ale nesm¡
-- se p©i tom zmˆnit hodnota :length lev‚ho operandu.
--------------------------------------------------------------------------


var
  op2cc            : const array op_eq..op_ge,t_logical of icond := [
      -- oper tor --- UNSIGNED -- SIGNED --
      for op_eq  use [ic_e,       ic_e      ],
      for op_ne  use [ic_ne,      ic_ne     ],
      for op_lt  use [ic_b,       ic_l      ],
      for op_le  use [ic_be,      ic_le     ],
      for op_gt  use [ic_a,       ic_g      ],
      for op_ge  use [ic_ae,      ic_ge     ]];


----------------------------------------------------------------------------------------------------
procedure i_gen (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpnode;                -- strom
    vysl           : out c_operand);             -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------



type
  -- generovac¡ metoda
  topergen         = procedure (
      inst         : in out icodeinst;           -- instance
      info         : in out igeninfo;            -- informace o pr–bˆhu generov n¡
      context      : in out iexprcontext;        -- kontext generov n¡ v˜razu
      expr         : in pexpoper;                -- strom
      vysl         : out c_operand);             -- v˜sledek
  popergen         = ^topergen;

  -- ©¡d¡c¡ tabulka generov n¡ bin rn¡ch oper tor–
  topertab         = array expopertype,tdatatype of popergen;

var
  opertab          : topertab;



----------------------------------------------------------------------------------------------------
procedure oset11 (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertype;             -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end oset11;



----------------------------------------------------------------------------------------------------
procedure oset1s (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertype;             -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=method;
      end if;
    end loop;
  end oset1s;



----------------------------------------------------------------------------------------------------
procedure osets1 (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertypeset;          -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      tab[i,stype]:=method;
      end if;
    end loop;
  end osets1;



----------------------------------------------------------------------------------------------------
procedure osetss (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertypeset;          -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end osetss;



----------------------------------------------------------------------------------------------------
procedure i_load (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    subcontext     : in out iexprcontext;        -- kontext podv˜razu
    supercontext   : in out iexprcontext;        -- kontext v˜razu
    sub            : in pexpnode;                -- generovan˜ podv˜raz
    vysl           : out c_operand) =            -- v˜sledek
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.begin: ' & sub^.dump);
    end if;
#end if;

  -- nastavit preferenci registr–
  case subcontext.mode
    -- do ECX/CX/CL
    when lm_imm8_cl     do i_setrpref(subcontext,in_ecx,irm_int);

    -- do EAX/AX/AL
    when lm_reg_eax     do i_setrpref(subcontext,in_eax,irm_int);

    -- v ostatn¡ch p©¡padech preference nen¡ (resp. podle p–vodn¡ho kontextu)
    end case;

  -- vygenerovat podv˜raz
  i_gen(inst,info,subcontext,sub,vysl);

  -- na‡¡st hodnotu
  case subcontext.mode
    -- pouze generovat
    when lm_gen         do -- nic nedˆlat

    -- na‡¡st adresu
    when lm_addr        do
        if (subcontext.rpref.reg<>in_none) and (subcontext.rpref.mode=irm_addr)
          then i_gen_lea(inst,info,subcontext,vysl,subcontext.rpref.reg);
          else i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;

    -- adresa objektu s dynamick˜mi atributy
    when lm_addr_attr   do -- nic nedˆlat

    -- konvertovat na typ v˜sledku
    when lm_conv        do
        -- li¨¡-li se od velikosti podv˜razu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak zmˆnit velikost konstanty
            then vysl.adjust_size(subcontext.rsize)
            -- ... jinak na‡¡st do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,(vysl.optype=io_cc) and (subcontext.outpref<>iop_cc){false},irm_int);
            end if;
          end if;

    -- konvertovat a na‡¡st do registru
    when lm_reg         do i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,false,irm_int);

    -- konvertovat a na‡¡st do registru (i p©¡mou hodnotu)
    when lm_reg_all     do i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,true,irm_int);

    -- konvertovat a na‡¡st do CL nebo ponechat const.
    when lm_imm8_cl     do i_gen_loadimm8cl(inst,info,subcontext,vysl);

    -- konvertovat a na‡¡st do EAX
    when lm_reg_eax     do i_gen_loadeax(inst,info,subcontext,vysl);

    -- konvertovat p©¡mou hodnotu na relativn¡ adresu
    when lm_imm_to_rel  do if vysl.optype=io_imm then
        vysl.transform_imm_to_rel;
        end if;

    -- na‡¡st hodnotu a ulo‘it na stack
    when lm_push_value  do
        -- na‡¡st a normalizovat pointer
        if subcontext.outtyp.stype=dt_pointer then
          i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);
          end if;

        -- ulo‘it na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

        -- uvolnit nepot©ebn˜ v˜sledek
        --i_free(info,subcontext,vysl);

        -- ‘ dn˜ v˜sledek se vracet nebude
        --nullop(vysl,io_none);

    -- na‡¡st adresu a ulo‘it na stack, pop©¡padˆ vr tit kopii v registru
    when lm_push_addr, lm_push_and_load_addr do
        -- Ondra 15.5.2002 : Pro dereferenci se na‡ten¡ adresy mˆn¡ na na‡ten¡ hodnoty pointeru,
        -- proto‘e v takov‚ p©¡padˆ dereference nic nedereferencuje, ale maxim lnˆ transformuje
        -- dereferencovan˜ pointer na v˜sledn˜ pointer.
        if sub^.ntype<>nt_deref then
          -- na‡¡st adresu
          i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;

        -- ulo‘it na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

        -- pokud nen¡ v˜sledek ‘ d n, tak se ho zbavit
        if subcontext.mode<>lm_push_and_load_addr then
          -- uvolnit nepot©ebn˜ v˜sledek
          --i_free(info,subcontext,vysl);

          -- ‘ dn˜ v˜sledek se vracet nebude
          --nullop(vysl,io_none);
          vysl.free(info,subcontext);
          end if;

    -- ulo‘it hodnotu do temporary promˆnn‚, nebo nechat imm
    when lm_temp_value  do
        -- li¨¡-li se od velikosti podv˜razu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak zmˆnit velikost konstanty
            then vysl.adjust_size(subcontext.rsize)
            -- ... jinak na‡¡st do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,false,irm_int);
            end if;
          end if;

        -- na‡¡st do temporary promˆnn‚
        i_gen_loadtemp(inst,info,subcontext,vysl);

    -- ulo‘it adresu do temporary promˆnn‚
    when lm_temp_addr   do ;

    -- na‡¡st a normalizovat pointer
    when lm_pointer     do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);

    -- na‡¡st a normalizovat pointer, preferovanˆ ulo‘it do registru
    when lm_pointer_reg do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,true,vysl);

    when others do verify(415,true);
    end case;

  -- p©ev‚st operand z kontextu podv˜razu do kontextu v˜razu
  -- %%X tahle konstrukce se se mi teda v–bec nel¡b¡, ale zat¡m jsem to tak
  -- nechal, pozdˆji odstranit. Dˆlalo to probl‚m p©i I_LOAD_EXPR.
  if ^subcontext<>^supercontext then
    --i_retrieve_context(inst,info,subcontext,supercontext,vysl);
    vysl.retrieve(inst,info,subcontext,supercontext);
    end if;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('    -- i_load.end');
    end if;
#end if;
  end i_load;



----------------------------------------------------------------------------------------------------
procedure i_load_binary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    outpref        : in ioutputpref;             -- pref. zp–sob p©ed n¡ prav‚ho op.
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- po‘adovan˜ typ podv˜raz–
    el             : in pexpnode;                -- podv˜razy
    er             : in pexpnode;                -- podv˜razy
    op1            : out c_operand;              -- v˜sledek
    op2            : out c_operand) =            -- v˜sledek
-- Vygeneruje a na‡te hodnotu dvojice podv˜raz–.
-- (sv zan˜ch bin rn¡m oper torem)
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(134,expr^.arity<>eoa_2);

  if expr^.assign
    -- p©i©azen¡    : opa‡n‚ po©ad¡ operand–
    -- %%X Chybnˆ, mus¡ se vyhodnocovat zleva --> doprava; nebo ne ?
    -- Asi ne: v AARM je to zd–vodnˆn˜: X^:=F(...) a pokud F uvoln¡
    -- X, tak to mus¡ zp–sobit chybu (NIL^)
    then
      -- vygenerovat a na‡¡st prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_reg,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg,typ}{expr^.t.getctype},er,op2);

      -- vygenerovat lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,typ}{expr^.t.getctype},el,op1);

    -- norm ln¡ po©ad¡ operand–
    -- %%X Rozli¨it r–zn‚ p©¡pady
    -- I kdy‘, v˜razy typu IMM+VAR by na VAR+IMM mˆl p©ehazovat optimaliz tor
    else
      -- vygenerovat a na‡¡st lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_reg_all,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg_all,typ}{expr^.t.getctype},el,op1);

      -- vygenerovat prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_conv,typ{expr^.t.getctype});
      i_setoutpref(context,outpref);
      i_load(inst,info,newcontext,context{lm_conv,typ}{expr^.t.getctype},er,op2);
      end if;

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);
  end i_load_binary;



----------------------------------------------------------------------------------------------------
procedure i_load_binary_pointer (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- po‘adovan˜ typ podv˜raz–
    el             : in pexpnode;                -- podv˜razy
    er             : in pexpnode;                -- podv˜razy
    op1            : out c_operand;              -- v˜sledek
    op2            : out c_operand) =            -- v˜sledek
-- Vygeneruje a na‡te hodnotu dvojice podv˜raz– (sv zan˜ch bin rn¡m
-- oper torem) typu pointer. Pointery normalizuje podle dodan‚ho typu
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(433,expr^.arity<>eoa_2);
  verify(484,typ^.stype<>dt_pointer);

  if expr^.assign

    -- p©i©azen¡    : opa‡n‚ po©ad¡ operand–
    then
      -- vygenerovat a na‡¡st prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,er,op2);

      -- vygenerovat lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,el,op1);

    -- norm ln¡ po©ad¡ operand–
    else
      -- vygenerovat a na‡¡st lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,el,op1);

      -- vygenerovat prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer,typ);
      i_load(inst,info,newcontext,context,er,op2);
      end if;

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);
  end i_load_binary_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_ordinal : topergen =
-- Porovn v n¡ diskr‚tn¡ch v˜raz–.
-- Tato procedura se pou‘¡v  i pro porovn n¡ (pouze = <>) obecn˜ch birn tn¡
-- blok– p©¡zniv‚ velikosti (1,2,4; viz I_GEN_OP_COMPARE_BINARY).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  cc               : icond;                      -- k¢d podm¡nky
  rest             : typeview;                   -- spole‡n˜ typ operand–

begin
  verify(139,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  -- vypo‡¡tat spole‡n˜ typ operand–
  x_resolve(el^.t,er^.t,true,rest);

  -- vygenerovat a na‡¡st operandy
  i_load_binary(inst,info,context,iop_none,expr,rest.getutype,el,er,op1,op2);

  -- porovnat
  addii(inst,info,ii_cmp,op1,op2,op0);

  -- podm¡nka
  cc:=op2cc[expr^.oper,rest.stype=dt_signed{(el^.t.stype=dt_signed) or (er^.t.stype=dt_signed)}];

  -- zkr cen‚ p©i©azen¡ ?
  if expr^.assign then addset(inst,info,context,cc,op1); end if;

  -- v˜sledek
  vysl.create_condition(cc);

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_op_compare_ordinal;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_binary : topergen =
-- Porovn v n¡ dvou obecn˜ch bin rn¡ch blok– (e.g. array, record, set) (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : pexpnode) =
    -- Porovn  zadan˜ uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podv˜raz–
      op1          : c_operand;                  -- adresa lev‚ho ©etˆzce v ESI
      size         : t_unsigned32;               -- velikost pole
      tgloop       : itarget;                    -- n vˆ¨t¡ za‡ tku cyklu
      tgend        : itarget;                    -- n vˆ¨t¡ konce cyklu

    begin
      -- jak jsme na tom s velikost¡ operandu ?
      if x_has_dynamic_size(x)

        -- dynamick  velikost
        then
          unimplementedx(170,expr^.pos);

        -- statick  veliksot
        else
          declare var
            opecx  : c_operand;                  -- min(op1length,op2length) v ECX
            opsize : c_operand;                  -- velikost pole

          begin
            -- na‡¡st lev˜ operand
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,x,op1);
            verifyx(524,op1.optype<>io_mem,x^.pos);

            -- redukovat po‡et registr–
            i_gen_reduceop(inst,info,context,op1);

            -- rezervovat ECX
            opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

            -- obnovit registry
            op1.refresh(inst,info,context);
            opecx.refresh(inst,info,context);

            -- zjistit velikost pole
            size:=unidata_size_to_unsigned(x^.t.getsize);

            -- zvolit, jak budeme porovn vat
            #template adjust_operands(denominator);
              opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div denominator));
              op1.shift_by_index(inst,info,context,ir_ecx,denominator);
              op1.unshift_displacement(denominator);
              op1.adjust_size(denominator);
              #end adjust_operands;
            -- dˆliteln‚ 4 ? => po ‡tve©ic¡ch
            if size mod 4=0 then
              #expand adjust_operands; #for denominator use; 4 #end adjust_operands;
            -- dˆliteln‚ 2 ? => po dvojic¡ch
            elsif size mod 2=0 then
              #expand adjust_operands; #for denominator use; 2 #end adjust_operands;
            -- mus¡me po bytech
            else
              #expand adjust_operands; #for denominator use; 1 #end adjust_operands;
              end if;

            -- naplnit ECX
            addii(inst,info,ii_mov,opecx,opsize,op0);

          leave
            -- uvolnit operandy
            opsize.free(info,context);
            opecx.free(info,context);
            end declare;
          end if;

      -- alokovat c¡le skoku
      newtarget(info,tgloop);
      newtarget(info,tgend);

      -- c¡l skoku na toto m¡sto
      settarget(info,tgloop,getaddr(inst));

      -- CMP <prvek pole>,0
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- JNE <tgend>
      addjump(inst,info,context,ic_ne,tgend);

      -- LOOP <tgloop>
      addloop(inst,info,context,tgloop);

      -- c¡l skoku na toto m¡sto
      settarget(info,tgend,getaddr(inst));

      -- v˜sledek
      vysl.create_condition(op2cc[expr^.oper,false]);
          {
              mov   ecx,x:size div 4
          ^2: cmp   [esi+ecx*4-4],0
              jne   ^1
              loop  ^2
          ^1: x=nil  => ic_ne
              x<>nil => ic_e
          }
    leave
      -- uvolnit operand
      op1.free(info,context);
      end cmpnil;

var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz

begin
  verify(501,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podv˜razy
  expr^.get(el,er);

  -- porovn n¡ operand– s p©¡znivou statickou velikost¡
  if x_has_static_size(el) and x_has_static_size(er)
  and (el^.t.getsize=uds_1 or el^.t.getsize=uds_2 or el^.t.getsize=uds_4) then
    -- porovnat principi lnˆ stejnˆ jako ordin ln¡ typy
    i_gen_op_compare_ordinal(inst,info,context,expr,vysl);

  ----- (non)ekvivalence s NIL zleva -----
  elsif x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s NIL zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecn˜ch pol¡ -----
  else
    -- oba operandy maj¡ statickou velikost
    if x_has_static_size(el) and x_has_static_size(er) then
      declare var
        newcontext : iexprcontext;               -- kontext podv˜raz–
        op1        : c_operand;                  -- adresa lev‚ho ©etˆzce v ESI
        op2        : c_operand;                  -- adresa prav‚ho ©etˆzce v EDI
        opecx      : c_operand;                  -- min(op1length,op2length) v ECX
        opsize     : c_operand;                  -- velikost pole
        ii         : iinstr;                     -- zvolen  porovn vac¡ instrukce
        size       : t_unsigned32;               -- velikost pole

      begin
        -- na‡¡st lev˜ operand do ESI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_esi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- na‡¡st prav˜ operand do EDI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,er,op2);

        -- obnovit registry
        op1.refresh(inst,info,context);
        op2.refresh(inst,info,context);

        -- rezervovat ECX
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- zjistit velikost pol¡
        size:=unidata_size_to_unsigned(el^.t.getsize);

        -- zvolit, jak budeme porovn vat
        -- dˆliteln‚ 4 ? => po ‡tve©ic¡ch
        if size mod 4=0 then
          ii:=ii_cmpsd;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 4));
        -- dˆliteln‚ 2 ? => po dvojic¡ch
        elsif size mod 2=0 then
          ii:=ii_cmpsw;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size div 2));
        -- mus¡me po bytech
        else
          ii:=ii_cmpsb;
          opsize.create_imm(edt_unsigned,0,unsigned_to_imm32(size));
          end if;

        -- naplnit ECX
        addii(inst,info,ii_mov,opecx,opsize,op0);

        -- shodit Direction Flag - porovn v  se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- REPE CMPS
        addip(inst,info,ip_repe);
        addii(inst,info,ii,op0,op0,op0);

        -- a t¡m by to mˆlo b˜t hotovo

        -- v˜sledek
        vysl.create_condition(op2cc[expr^.oper,false]);

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op2.free(info,context);
        opecx.free(info,context);
        opsize.free(info,context);
        end declare;

    -- jeden z operand– m  dynamickou velikost
    elsif x_has_dynamic_size(el) xor x_has_dynamic_size(er) then
      unimplemented(171);

    -- oba maj¡ dynamickou velikost
    else
      unimplemented(172);
      end if;
    end if;
  end i_gen_op_compare_binary;



----------------------------------------------------------------------------------------------------
#separate public ci_integer;
#separate private ci_integer;
-- Celo‡¡seln  aritmetika.
----------------------------------------------------------------------------------------------------
#separate public ci_logical;
#separate private ci_logical;
-- Logick‚ operace.
----------------------------------------------------------------------------------------------------
#separate public ci_pointer;
#separate private ci_pointer;
-- Operace s pointery.
----------------------------------------------------------------------------------------------------
#separate public ci_string;
#separate private ci_string;
-- žetˆzcov‚ operace.
----------------------------------------------------------------------------------------------------
#separate public ci_set;
#separate private ci_set;
-- Mno‘inov‚ operace.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_array : topergen =
-- Porovn v n¡ record– (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vy‘aduj¡ komponenty pole zvl ¨tn¡ porovn vac¡ algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimaliz tor IF s konstantn¡ podm¡nkou neo¨et©¡

    -- ano => porovnat po ‡ stech
    then
      unimplemented(177);

    -- ne => porovnat jako bin rn¡ bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_record : topergen =
-- Porovn v n¡ mno‘in (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vy‘aduj¡ komponenty recordu zvl ¨tn¡ porovn vac¡ algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimaliz tor IF s konstantn¡ podm¡nkou neo¨et©¡

    -- ano => porovnat po ‡ stech
    then
      unimplemented(178);

    -- ne => porovnat jako bin rn¡ bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_record;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign : topergen =
-- Univerz ln¡ p©i©azen¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(140,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  if x_has_dynamic_size(el)

    -- lev˜ operand m  dynamickou velikost
    then
      declare var
        op1        : c_operand;                  -- lev˜ operand
        op1size    : c_operand;                  -- :size lev‚ho operandu
        op1edi     : c_operand;                  -- adresa lev‚ho operandu v EDI

      begin
        {verify(517,not (rta_size in el^.rta_used{%%ATTR}));}

        -- vygenerovat lev˜ operand
        i_newcontext(context,newcontext,lm_addr_attr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- pro atribut bude pot©eba registr ECX
        op1size.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
      {
        -- na‡¡st :size
        i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);
      }
        -- je k dispozici p©¡mo :size
        if rta_size in el^.rta_used{%%ATTR} then
          -- na‡¡st :size
          i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);

        -- je k dispozici jen :last
        elsif rta_last in el^.rta_used{%%ATTR} then
          -- na‡¡st :last
          i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_last,op1size);

          -- vyn sobit velikost¡ prvku
          i_gen_mul_reg(inst,info,context,op1size,unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size));

        -- co si m me po‡¡t bez dynamick‚ho atributu ?
        else
          verify(517,true)
          end if;

        -- registr EDI
        op1edi.create_use_register(inst,info,context,edt_address,ir_edi);

        -- na‡¡st adresu promˆnn‚ do EDI
        op1.adjust_size(lpointer32);
        addii(inst,info,ii_mov,op1edi,op1,op0);

        if x_is_nil(er) {er^.t.stype=dt_uninil}

          -- p©i©azen¡ NIL
          then
            -- ulo‘it NIL
            i_gen_fillz_dynamic(inst,info,context,op1edi,op1size);

          -- p©i©azen¡ konkr‚tn¡ hodnoty
          else
            declare var
              op2     : c_operand;               -- prav˜ operand
              op2size : c_operand;               -- :size prav‚ho operandu

            begin  
              ---- kontrola velikosti ----
              -- na‡¡st adresu :size prav‚ho operandu
              if x_has_dynamic_size(er)

                -- prav˜ operand m  t‚‘ dynamickou velikost
                then
                  verify(518,not (rta_size in er^.rta_used{%%ATTR}));

                  -- vygenerovat prav˜ operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_setrpref(newcontext,in_esi,irm_addr);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registry
                  op2.refresh(inst,info,context);

                  -- ur‡it adresu :size
                  i_gen_load_rtattrib_addr(inst,info,context,er^.rta_used{%%ATTR},op2,rta_size,op2size);

                -- prav˜ operand m  statickou velikost
                else
                  -- na‡¡st velikost prav‚ho operandu
                  op2size.create_imm(edt_unsigned,0,unidata_size_to_imm32(er^.t.getsize));
                  end if;

              declare var
                tg_ok : itarget;                 -- c¡l skoku po porovn n¡ velikost¡
              begin
                -- alokovat c¡l skoku
                newtarget(info,tg_ok);

                -- porovnat s ECX
                addii(inst,info,ii_cmp,op1size,op2size,op0);
                addjump(inst,info,context,ic_e,tg_ok);

                -- vyvolat v˜jimku Constraint_Error
                -- %%X

                -- c¡l skoku na toto m¡sto
                settarget(info,tg_ok,getaddr(inst));
                end declare;

              ---- p©i©azen¡ hodnoty ----
              if x_has_dynamic_size(er)

                -- prav˜ operand s dynamickou velikost¡ => ji‘ zn me jeho adresu
                then
                  -- nic nedˆlat, verifikace 518 na "rta_size in er^.rta" u‘ probˆhla v˜¨e

                -- prav˜ operand se statickou velikost¡ => vygenerovat
                else
                  -- vygenerovat prav˜ operand
                  i_newcontext(context,newcontext,lm_addr_attr,nil);
                  i_load(inst,info,newcontext,context,er,op2);
                  end if;

              -- obnovit registry
              op1.refresh(inst,info,context);
              op2.refresh(inst,info,context);

              -- operandy by nemˆly spot©ebovat moc registr–
              i_gen_reduceop(inst,info,context,op1);
              i_gen_reduceop(inst,info,context,op2);

              -- p©esunout (jako pole o prvc¡ch velikosti 1)
              i_gen_move_array(inst,info,context,op2,op1,op1size,1);

            leave
              -- uvolnit operandy
              op2.free(info,context);
              op2size.free(info,context);
              end declare;
            end if;
      leave
        op1.free(info,context);
        op1edi.free(info,context);
        op1size.free(info,context);
        end declare;

    -- lev˜ operand m  statickou velikost
    else
      declare var
        op1        : c_operand;                  -- lev˜ operand
        size       : t_unsigned32;               -- velikost operandu
      begin
        -- velikost operandu
        size:=unidata_size_to_unsigned(expr^.t.getsize);

        ----- %%X P©ipom¡nky ---------------------------------------------------
        -- -- Co kdy‘ se lev˜ a prav˜ operand p©ekr˜vaj¡ ?
        -- -- Kdy‘ zb˜vaj¡ t©i byty, mohu p©eci kop¡rovat p©edchoz¡ byte podruh‚
        --    (u¨et©¡ se 4 instrukce, tak‘e penalta za nezarovanan˜ p©¡stup nevad¡)
        -- -- Pokud to jde, tak zkusit REP MOVSD - od nˆjak‚ velikosti bloku by to
        --    mohlo b˜t rychlej¨¡, i kdybych musel ‡arovat s registrama (PUSH).
        -- -------------------------------------------------------------------------

        if x_is_nil(er)

          -- p©i©azen¡ NIL
          then
            -- vygenerovat lev˜ podv˜raz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_setrpref(newcontext,in_edi,irm_addr);
            i_load(inst,info,newcontext,context,el,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            -- ulo‘it NIL
            i_gen_fillz_static(inst,info,context,op1,size);

          -- p©i©azen¡ konkr‚tn¡ hodnoty
          else
            declare var
              op2  : c_operand;                  -- prav˜ operand
            begin
              if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}

                -- p©¡zniv  velikost
                then
                  -- vygenerovat a na‡¡st operandy
                  i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);

                  -- p©i©azen¡
                  -- Ondra 11.9.2002 : Hodnota m–‘e b˜t reprezentov na i k¢dem podm¡nky
                  if op2.optype=io_cc
                    then addset(inst,info,context,op2.cc,op1);
                    else addii(inst,info,ii_mov,op1,op2,op0);
                    end if;

                  -- v˜sledek
                  vysl.transfer(op1);

                -- nˆco jin‚ho
                else
                  -- vygenerovat a na‡¡st prav˜ podv˜raz (m–‘e b˜t i na stacku)
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_setoutpref(newcontext,iop_stack);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- vygenerovat lev˜ podv˜raz
                  i_newcontext(context,newcontext,lm_gen,nil);
                  i_load(inst,info,newcontext,context,el,op1);

                  -- obnovit registry
                  op1.refresh(inst,info,context);
                  op2.refresh(inst,info,context);

                  -- operandy by nemˆly spot©ebovat moc registr–
                  i_gen_reduceop(inst,info,context,op1);
                  i_gen_reduceop(inst,info,context,op2);

                  -- kop¡rovat
                  case op2.optype
                    when io_stack do i_gen_pop_static(inst,info,context,op1,size);
                    when io_mem   do i_gen_move_static(inst,info,context,op2,op1,size);
                    when others   do verify(488,true);
                    end case;

                  -- %%X A co v˜sledek ??             
                  end if;

            leave
              -- uvolnit prav˜ operand
              op2.free(info,context);
              end declare;
            end if;
      leave
        -- uvolnit lev˜ operand
        op1.free(info,context);
        end declare;
      end if;
  end i_gen_op_assign;



----------------------------------------------------------------------------------------------------
procedure i_gen_operator (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpoper;                -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
begin
  case expr^.t.tview
    -- Partial view/Unchecked view
    when tview_partial, tview_unchecked do
        case expr^.oper
          -- p©i©azen¡
          when op_assign do i_gen_op_assign(inst,info,context,expr,vysl);

          when others do verify(187,true);
          end case;

    -- Full view
    when tview_full do
        declare var
          stype    : tdatatype;                  -- spole‡n˜ typ operand–

        begin
          -- zjistit typ spole‡n˜ typ operand–
          stype:=x_resolve_opdtype(expr,true);

          -- vygenerovat
          verifyx(99,^opertab[expr^.oper,stype]=nil,expr^.pos);
          opertab[expr^.oper,stype]^(inst,info,context,expr,vysl);
          end declare;

    when others do verifyx(186,true,expr^.pos);
    end case;
  end i_gen_operator;



----------------------------------------------------------------------------------------------------
procedure i_gen_unary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpunary;               -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  op1              : c_operand;                  -- operand
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el);

  -- "architektura" Intel t¡hne k nep©¡jemn˜m v˜jimk m,
  -- tak‘e ka‘d  instrukce vy‘aduje jin‚ zpracov n¡
  case expr^.oper
    -- inkrementace/dekrementace, un rn¡ m¡nus, bitov  negace
    when un_succ,un_pred,un_minus,un_bitnot do
        -- vygenerovat podv˜raz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- instrukce
        declare var
          ii       : iinstr;                     -- instrukce
        begin
          case expr^.oper
            when un_minus  do ii:=ii_neg;
            when un_succ   do ii:=ii_inc;
            when un_pred   do ii:=ii_dec;
            when un_bitnot do ii:=ii_not;
            when others do verify(47,true);
            end case;
          addii(inst,info,ii,op1,op0,op0);
          end declare;

        -- v˜sledek
        vysl.transfer(op1);

    -- logick  negace
    when un_not do
        -- vygenerovat podv˜raz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- co je operand za‡ ?
        case op1.optype
          -- podm¡nka => znegovat
          when io_cc do op1.set_cc(icondneg[op1.cc]);

          -- registr => xornout hodnotou (true xor false)
          -- %%X Pro typ se specifikac¡ reprezentace True a False se negace
          -- dˆl  takhle: xor op1,(true xor false)
          when io_reg, io_mem do addii(inst,info,ii_xor,op1,op_1,op0);

          when others do verify(470,true);
          end case;

        -- v˜sledek
        vysl.transfer(op1);

    -- absolutn¡ hodnota
    when un_abs do
        unimplemented(29);

    when others do verify(46,true);
    end case;

leave
  -- uvolnit operand
  op1.free(info,context);
  end i_gen_unary;



----------------------------------------------------------------------------------------------------
procedure i_gen_rtattrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpnode{component};     -- strom
    vysl           : in c_operand) =             -- v˜sledek v˜po‡tu v˜razu (adresa)
-- Generov n¡ dynamick˜ch atribut–.
-- VYSL obsahuje adresu bloku tvaru:
--     +----------+
--     | atributy | +4 a‘ +n
--     +----------+
--     | adresa   | +0
--     +----------+
-- Atributy jsou z t‚to struktury zkop¡rov ny do obdobn‚ (bez pole adresa),
-- kter  le‘¡ na b zov‚ adrese dan‚ registrem CONTEXT.RTABASE.
----------------------------------------------------------------------------------------------------
var
  opsrc            : c_operand;                  -- ukazatel na zdrojovou oblast
  dattrib          : rtattribset;                -- dynamick‚ atributy v˜razu
  srange           : pentity_type;               -- rozsah pole/©etˆzce
  x                : timm32;

begin
  -- chce to v–bec nˆjak‚ atributy ?
  if context.rta=rtattribset:[] then return; end if;

  -- jak‚ atributy jsou k dispozici ?
  dattrib:=context.rta*expr^.rta_used{%%ATTR};

  -- p©ipravit ukazatel do zdrojov‚ oblasti
  verify(333,vysl.optype<>io_mem);
  opsrc.clone(inst,info,context,vysl);
  getrtattribsetsize(expr^.rta_used{%%ATTR},x);
  --%%X Zbyte‡n‚ p©etypov n¡, dodefinovat shift_displacement o TIMM32 hodnotu
  opsrc.shift_displacement(t_signed(imm32_lpointer32+x));  

  -- stack roste shora --> dol–
  for attrib in reverse rtattrib loop
    -- posunout offset ve zdrojov‚ oblasti
    if attrib in expr^.rta_used{%%ATTR} then
      opsrc.unshift_displacement(imm32_to_signed(unidata_size_to_imm32(cpu32_rtattribsize[attrib])));
      end if;

    -- ur‡it velikost atributu
    opsrc.adjust_size(unidata_size_to_unsigned(cpu32_rtattribsize[attrib]));

    -- zkop¡rovat dynamick˜ atribut
    if attrib in dattrib then
      -- sta‡¡ jeden PUSH
      -- %%X Nebude se ten PUSH chovat divnˆ,
      -- kdyby n hodou bylo OPSRC.SIZE<>4 ?
      addii(inst,info,ii_push,opsrc,op0,op0);

    -- ur‡it staticky
    elsif attrib in context.rta then
      declare var
        optemp     : c_operand;                  -- pracovn¡ registr

      begin
        -- p©ipravit druh˜ operand
        case attrib
          -- ^instance
          when rta_instance do
              -- statick˜ pointer na instanci je z©ejmˆ NIL
              optemp.create_imm(edt_address,0,0);

          -- :tag
          when rta_tag      do
              -- je to tagged typ ?
              if tf_tagged in expr^.t.getctype^.tflags

                -- ano => pou‘¡t re ln˜ tag
                then
                  optemp.create_imm(edt_unsigned,opsrc.size,0);
                  optemp.set_relo_entity(expr^.t.getctype);

                -- ne => ulo‘it pr zdn˜ tag
                else
                  optemp.create_imm(edt_unsigned,0,0);
                  end if;

          -- :size
          when rta_size     do
              optemp.create_imm(edt_unsigned,opsrc.size,unidata_size_to_imm32(expr^.t.getsize));

          -- :last
          when rta_last     do
              -- p©ipravit operand
              optemp.create_imm(edt_unsigned,opsrc.size,0);

              -- li¨¡ se pro pole a pro ©etˆzce
              verify(335,not t_is_sts(expr^.t,dts_index));
              srange:=expr^.t.getctype^.srange.getctype;
              case expr^.t.stype
                -- pole
                when dt_array, dt_uarray do
                    -- :last odpov¡d  :length-1
                    optemp.set_imm(uniint_to_imm32(uniint_length(srange^.lval,srange^.hval))-timm32(1));

                -- ©etˆzec
                when dt_string, dt_ustring do
                    -- :last je :last
                    optemp.set_imm(uniint_to_imm32(srange^.hval));

                when others do verify(336,true);
                end case;

          when others do verify(332,true);
          end case;

        -- ulo‘it
        addii(inst,info,ii_push,optemp,op0,op0);
      leave
        -- uvolnit operand
        optemp.free(info,context);
        end declare;
      end if;
    end loop;

leave
  -- uvolnit operand
  opsrc.free(info,context);
  end i_gen_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_component (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpcomponent;           -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du komponenty.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  case expr^.nclass
    -- nic (kvalifik tor) => jen vygenerovat podv˜raz
    when nc_none do
        if expr^.sub=nil
          -- nem me ani podv˜raz
          then --nullop(vysl,io_none)

          -- podv˜raz je k dispozici => vygenerovat
          else
            -- vygenerovat podv˜raz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            end if;

    -- promˆnn 
    when nc_var do
        if (expr^.sub=nil) or {not} (expr^.sub^.nclass {in ncs_value}<>nc_var)

          -- p©¡mo promˆnn 
          then
            verify(91,expr^.s.psym=nil);

            declare var
              pvar : pentity_var;                -- promˆnn  pro zjednodu¨en¡

            begin
              -- promˆnn  pro zjednodu¨en¡
              pvar:=pentity_var(expr^.s.psym);

              case pvar^.mclass
                -- automatick 
                when mc_auto do
                    declare var
                      nindex : t_unsigned;         -- index vno©en¡ promˆnn‚

                    begin
                      -- nemohla by to b˜t promˆnn  z nad©azen‚ho podprogramu ?
                      nindex:=0;
                      if inst.nested.nlist<>nil and then inst.nested.nlist^:length<>0 then
                        nindex:=inst.nested.nlist^:length;
                        while nindex<>0 and then inst.nested.nlist^[nindex]<>pvar^.context.entity loop
                          pred nindex;
                          end loop;
                        end if;

                      -- p©ipravit operand
                      if nindex=0

                        -- je to p©¡mo lok ln¡ promˆnn 
                        then
                          declare var
                            disp : timm32;
                          begin
                            -- zjistit adresu promˆnn‚
                            getvaraddr(inst,info,pvar,disp);

                            -- sestavit adresu b zovanou podle frame pointeru
                            vysl.create_memory_address_on_stack(inst,edt_binary,0,disp);
                            end declare;

                        -- je z nad©azen‚ho podprogramu
                        else
                          declare var
                            optemp : c_operand;
                          begin
                            -- adresa ulo‘en‚ho frame pointeru
                            optemp.create_memory_address_on_stack(inst,edt_address,4,signed_to_imm32(-t_signed(nindex*4)));

                            -- budeme pot©ebovat registr na frame pointer
                            vysl.create_new_register(inst,info,context,edt_address,4);

                            -- na‡¡st frame pointer
                            addii(inst,info,ii_mov,vysl,optemp,op0);

                          leave
                            -- uvolnit pracovn¡ operand
                            optemp.free(info,context);
                            end declare;

                          -- zmˆnit operand na adresn¡
                          vysl.transform_reg_to_mem(edt_binary,0);
                        { %%X
                          Dva z sadn¡ probl‚my:
                            -- ENTER akceptuje pouze 16bitovou velikost prostoru na stacku -> nutn‚
                               minim lnˆ o¨et©it p©¡pad s v¡ce ne‘ 64 KB lok ln¡ch promˆnn˜ch a tak‚
                               zpˆtn‚ nastavov n¡ hodnoty - nˆkdy 32 jindy 16 bit–,
                            -- v dobˆ generov n¡ vno©en‚ procedury nen¡ je¨tˆ vygenerovan  nad©azen 
                               procedura -> generovat v opa‡n‚m po©ad¡ a pro vno©enou volit default
                               konvence.
                        }
                          declare var
                            pcode : pentity_code;  -- nad©azen˜ podprogram
                            disp  : timm32;        -- offset promˆnn‚ vzhledem k frame pointeru
                            
                          begin
                            -- nad©azen˜ podprogram
                            pcode:=inst.nested.nlist^[nindex];
                            verify(501,picodegen_subprog(pcode^.codegen)^.ifirst<>picodegen_subprog(pcode^.codegen)^.ilast);

                            -- zjistit adresu promˆnn‚
                            getvaraddr(picodegen_subprog(pcode^.codegen)^.ifirst^,info,pvar,disp);

                            -- p©i‡¡st posunut¡ k v˜sledn‚ adrese
                            vysl.shift_displacement(imm32_to_signed{%%X}(disp));
                            end declare;
                          end if;
                      end declare;

                    -- je to parametr ? => pak mus¡me upravit mno‘inu
                    -- pou‘iteln˜ch run-time atribut–
                    -- %%X Tohle je trochu Black Magic a z plata. Spr vnˆ by se
                    -- to mˆlo dˆlat v dvoupr–chodov‚ glob ln¡ anal˜ze, jen‘e
                    -- tu zat¡m nem me a takhle to kupodivu taky funguje.
                    --   Nestane se, ‘e by v CONTEXT.RTA byly i atributy, kter‚
                    -- touto £pravou ztrat¡m, proto‘e p©i po‘adavku na takov‚
                    -- atributy by se vy‘ daly i pro tento parametr (aspo¤ by
                    -- to tak mˆlo b˜t).
                    verify(334,context.rta*(pvar^.rta_avail{allrta}-pvar^.rta_used{usedrta})<>rtattribset:[]);
                    expr^.rta_used{%%ATTR}:=pvar^.rta_used{usedrta};

                    -- chceme ulo‘it i dynamick‚ atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                    ----- %%TECH Implicitn¡ dereference --------------------
                    --
                    --------------------------------------------------------
                    if (pvar^.vmode=vm_ref)
                    and (context.mode<>lm_addr_attr) then
                      declare var
                        optemp : c_operand;
                      begin
                        -- opravit typ a velikost operandu (p©i p©¡pravˆ jsme 
                        -- mo‘nost [vm_ref] nezohlednili, tak to teƒ mus¡me napravit)
                        vysl.adjust_edtype(edt_address);
                        vysl.adjust_size(4);

                        -- alokovat pracovn¡ registr
                        optemp.create_new_register(inst,info,context,edt_address,4);

                        -- na‡¡st adresu
                        addii(inst,info,ii_mov,optemp,vysl,op0);

                        -- nahradit v˜sledek pr vˆ na‡tenou adresou
                        vysl.replace(info,context,optemp);

                        -- zmˆnit operand na adresn¡
                        vysl.transform_reg_to_mem(edt_binary,0);
                      leave
                        -- uvolnit pracovn¡ operand
                        optemp.free(info,context);
                        end declare;
                      end if;

                    -- velikost operandu
                    if expr^.t.hassize
                      then vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
                      else vysl.adjust_size(0);
                      end if;

                -- statick 
                when mc_static do
                    -- adresa promˆnn‚
                    vysl.create_memory_address(inst,info,context,edt_binary,unidata_size_to_unsigned(expr^.t.getsize),ir_none,0);
                    vysl.set_relo_entity(expr^.s.psym);

                    -- chceme ulo‘it i dynamick‚ atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                -- promˆnn  t©¡dy
                when mc_class do
                    -- na‡¡st adresu slo‘ky
                    i_load_this_address(inst,info,context,expr^.t.getsize,pvar^.addr,vysl);

                    -- chceme ulo‘it i dynamick‚ atributy ?
                    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                      i_gen_rtattrib(inst,info,context,expr,vysl);
                      end if;

                -- %%X
                when others do verify(71,true);
                end case;
              end declare;

          -- selektor
          else
            verify(90,(expr^.s.psym=nil) or{and} not (pentity_var(expr^.s.psym)^.mclass in mcs_offset));

            -- vygenerovat podv˜raz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            vysl.refresh(inst,info,context);
            verify(92,vysl.optype<>io_mem);

            -- adresa
            vysl.shift_displacement(imm32_to_signed{%%X}(unidata_addr_to_imm32(pentity_var(expr^.s.psym)^.addr{pivarlink(pentity_var(expr^.s.psym)^.codegen)^.addr})));

            -- velikost operandu
            vysl.adjust_size(unidata_size_to_unsigned(pentity_var(expr^.s.psym)^.typ.getctype^.size));

            -- chceme ulo‘it i dynamick‚ atributy ?
            if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
              i_gen_rtattrib(inst,info,context,expr,vysl);
              end if;
            end if;

    -- procedura
    when nc_proc do
        -- p©¡padn˜ podv˜raz ur‡uje instanci, ale co s n¡ ?
        -- to aŸ si vy©e¨¡ volaj¡c¡ procedura

        -- vr tit adresu procedury
        i_gen_subprogram_address(inst,info,context,pentity_subprogram(expr^.getsymbol),false,vysl);

    -- zpr va
    when nc_message     do
        -- na p©¡padn˜ podv˜raz se ka¨le, nem  v˜znam

        -- vr tit ‡¡slo zpr vy
        vysl.create_imm(edt_unsigned,0,0);
        vysl.set_relo_entity(expr^.s.psym);

    when others do verify(621,true);
    end case;
  end i_gen_component;



----------------------------------------------------------------------------------------------------
procedure i_gen_imm (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpimm;                 -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du p©¡m‚ hodnoty.
----------------------------------------------------------------------------------------------------
begin
  if context.mode in lms_addr

    -- zaj¡m  n s adresa hodnoty
    then
      -- adresa
      vysl.create_memory_address(inst,info,context,edt_binary,unidata_size_to_unsigned(expr^.t.getsize),ir_none,0);
      vysl.set_relo_imm(expr);

      -- chceme ulo‘it i dynamick‚ atributy ?
      if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
        i_gen_rtattrib(inst,info,context,expr,vysl);
        end if;

    -- zaj¡m  n s hodnota samotn 
    else
      case expr^.imm.ic
        -- ordin ln¡ hodnota
        when ic_ordinal do
            if t_is_sts(expr^.t,dts_unitype)
              then vysl.create_imm(edt_unsigned,0,uniint_to_imm32(expr^.imm.ui));
              else vysl.create_imm(edt_unsigned,unidata_size_to_unsigned(expr^.t.getsize),uniint_to_imm32(expr^.imm.ui));
              end if;

         { No a to je pr vˆ ten omyl. Tohle se mus¡ ©e¨it s vyu‘it¡m NATTYP
            o £rove¤ v˜¨ (v I_LOAD).

            --..TECH U ordin ln¡ch hodnot mi na velikosti nijak zvl ¨Ÿ nesejde.   
            -- Emitor instrukc¡ se p©izp–sob¡ a kompatibilitu by mˆly zajistit
            -- p©edchoz¡ f ze p©ekladu. Nicm‚nˆ stejnˆ by po‘adovan  velikost
            -- konstanty mˆla b˜t alespo¤ takov , jako je jej¡ skute‡n  velikost.
            {..X Bohu‘el nem m jak to otestovat... }
            {verify(129,not (expr^.t.stype in dts_unitype) and uishrink(expr^.imm.ui,,));}
            vysl.size:=0;
          { P–vodn¡, m lo funk‡n¡ verze
            (var(unsigned 32)<=imm(unsigned 16) --> cmp reg32,imm16)

            if expr^.t.stype in dts_unitype
              then vysl.size:=0;
              else udtouint(expr^.t.typ^.size,vysl.size);
              end if;
          }
         }

        -- NIL
        when ic_nil do
            declare var
              x : t_unsigned;
            begin
              x:=unidata_size_to_unsigned(context.outtyp.size);
              verifyx(556,x<>1 and x<>2 and x<>4{%%TODO(SET) not (x in [1,2,4])},expr^.pos);
              end declare;
            vysl.create_imm(edt_binary,0,0);
            -- %%X No a tady bych pot©eboval vˆdˆt po‘adovan˜ typ, nebo ne ?

        -- kondenzovan‚ pole nebo agreg t
        when ic_condensed,ic_array,ic_set,ic_record do
            {verifyx(530,((expr^.imm.ic=ic_set) and (expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize))
                     or ((expr^.imm.ic=ic_array) and (expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize))
                     or ((expr^.imm.ic=ic_record) and (expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize)),expr^.pos);}
            {!!}
            vysl.create_memory_address(inst,info,context,edt_binary,unidata_size_to_unsigned(expr^.t.getsize),ir_none,0);
            vysl.set_relo_imm(expr);

        -- %%X
        when others do verify(72,true);
        end case;
      end if;
  end i_gen_imm;



----------------------------------------------------------------------------------------------------
procedure i_gen_aggregate (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpaggregate;           -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ agreg tu.
-- Pozn mka: Obsluha agreg t– je dost natvrdo (=neoptim lnˆ), proto‘e je to
-- pomˆrnˆ komplikovan  z le‘itost a babrat se s t¡m budu a‘ ve 4.0.1.
----------------------------------------------------------------------------------------------------
var
  opaggr           : c_operand;                  -- pracovn¡ prostor pro agreg t
  optemp           : c_operand;                  -- pracovn¡ operand
  arglist          : pexpitem;                   -- seznam argument–

begin
  -- %%TECH Optimaliz tor zajistil, ‘e agreg t, kter˜ se dostane a‘ sem, m 
  -- zcela jistˆ alespo¤ jednu nekonstantn¡ slo‘ku (aŸ u‘ hodnotu, ‡i index),
  -- v¨echny ostatn¡ p©¡pady jsou konvertov ny na NT_IMM.

  case expr^.t.stype
    -- record
    when dt_record do unimplemented(152);

    -- pole
    when dt_array do
      {
        -- alokovat pracovn¡ prostor pro agreg t
        nullop(optemp,io_mem);
        optemp.base.reg:=istackframereg[inst.frame];
        optemp.size:=expr^.t.size;
        alloctemp(inst,info,optemp.size,optemp.disp);

        -- do pracovn¡ho prostoru nacpat konstantn¡ ‡ st agreg tu

        -- seznam argument–
        expr^.getarglist(arglist);

        -- zpracovat v¨echny slo‘ky agreg tu
        while arglist<>nil loop

          end loop;
      }
        unimplemented(165);


    -- neomezene pole
    when dt_uarray do unimplemented(155);

    -- ©etˆzec
    when dt_string,dt_ustring do unimplemented(153);

    -- mno‘ina
    when dt_set do unimplementedx(154,expr^.pos);

    -- ostatn¡ typy tu nemaj¡ co dˆlat
    when others do verify(473,true);
    end case
  end i_gen_aggregate;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volan  procedura
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du vol n¡ procedury.
----------------------------------------------------------------------------------------------------
var
  arg              : pexpitem;                   -- skute‡n˜ parametr
  call             : icallconvention;            -- volac¡ konvence

    ------------------------------------------------------------------------------------------------
    procedure firstarg =
    -- Prvn¡ argument procedury (podle volac¡ konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;

    begin
      -- %%X ‡asem doplnit do stromu dvousmˆrnej seznam 

      -- prvn¡ argument v seznamu
      expr^.get(el,arg);

      -- dojet na konec
      if call in iccs_reverse then
        while (arg<>nil) and (arg^.next<>nil) loop arg:=pexpitem(arg^.next); end loop;
        end if;
      end firstarg;



    ------------------------------------------------------------------------------------------------
    procedure nextarg =
    -- Dal¨¡ argument procedury (podle volac¡ konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;
      a            : pexpitem;

    begin
      -- %%X ‡asem doplnit do stromu dvousmˆrnej seznam

      if call in iccs_reverse

        -- hledat p©edchoz¡
        then
          expr^.get(el,a);
          if arg=a
            then arg:=nil
            else
              while a^.next<>arg loop a:=pexpitem(a^.next); end loop;
              arg:=a;
              end if;

        -- dal¨¡
        else 
          arg:=pexpitem(arg^.next);
          end if;
      end nextarg;

var
  el               : pexpnode;                   -- lev˜ podv˜raz
  pinst            : picodeinst;                 -- instance volan‚ procedury
  ptyp             : pentity_type;               -- typ procedury
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- pro neur‡it‚ p©¡pady p©edpokl dejme default volac¡ konvenci
  call:=icc_default;

  -- zvolit instanci procedury
  pinst:=nil;
  if pproc<>nil and then pproc^.etype=et_procedure and then pproc^.codegen<>nil then
    -- %%X zvolit instanci procedury
    pinst:=picodegen_subprog(pproc^.codegen)^.ifirst;

    -- volac¡ konvence
    if pinst<>nil
      -- podle zvolen‚ instance
      then call:=pinst^.profile.call;
      -- default konvence pro tuto proceduru
      else call:=picodegen_subprog(pproc^.codegen)^.def_call;
      end if;
    end if;

  -- lze-li to, tak z¡skat typ procedury, bude se hodit
  if pproc<>nil

    -- m me k dispozici konkr‚tn¡ proceduru
    then ptyp:=pproc^.typ.getutype

    -- z©ejmˆ je to pointer na proceduru
    else
      verify(510,expr^.sub^.ntype<>nt_deref);
      ptyp:=expr^.sub^.t.getctype;
      end if;
  verify(511,(ptyp<>nil) and (ptyp^.stype<>dt_procedure));

  -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUT ** z plata !!
  -- P©esunut¡m SAVEREGS tˆsnˆ p©ed instrukci CALL zabra¤uju rekurzivn¡mu
  -- pushov n¡ stejn˜ch registr–, kter‚ je zap©¡‡inˆno nˆjakou nedokonalost¡
  -- alok toru registr–, kterou se mi zat¡m nepoda©ilo vy©e¨it. Probl‚m spo‡¡v 
  -- v tom, ‘e schov n¡m registru se ztr c¡ informace o jeho (ne)pou‘it¡, tak‘e
  -- p©i rekurzivn¡m vol n¡ I_GEN_CALL_SUBPROGRAM se schov v  znova, co‘ m  za
  -- n sledek unimplemented(118) v I_RETRIEVE.
{
  -- ulo‘it v¨echny pou‘it‚ registry
  -- %%X Omezit jen na registry skute‡nˆ pou‘it‚ ve volan‚ procedu©e
  saveregs(inst,info,context);
}

  ---- rezervovat m¡sto pro n vratovou hodnotu ----
  if expr^.t.tview<>tview_null and call in iccs_ret_stack then
    declare var
      resultsize   : t_unsigned;                 -- velikost n vratov‚ hodnoty
      op1          : c_operand;                  -- operand

    begin     
      -- velikost n vratov‚ hodnoty
      resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

      if ptyp^.result^.pass in pps_ref
        -- odkazem
        then
          -- alokovat, t©eba nˆkde na stacku, prostor pro n vratovou hodnotu
          op1.create_temporary(inst,info,edt_binary,resultsize);

          -- z¡skanou adresu p©ev‚st na absolutn¡
          i_gen_lea(inst,info,context,op1,in_none);

          -- ulo‘it na stack
          addii(inst,info,ii_push,op1,op0,op0);

        -- hodnotou
        else
          declare var
            alignedsize : t_unsigned32;          -- zarovnan  velikost n vratov‚ hodnoty

          begin
            -- zarovnat
            addalign(alignedsize,0,resultsize,istackalign);

            -- zkonvertovat na operand
            op1.create_imm(edt_unsigned,0,unsigned_to_imm32(alignedsize));
            end declare;

          -- sn¡‘it hodnotu ESP o velikost promˆnn‚
          addii(inst,info,ii_sub,op_esp,op1,op0);
          end if;

    leave  
      -- uvolnit operand
      op1.free(info,context);
      end declare;
    end if;

  ---- zpracovat argumenty ----
  firstarg;
  while arg<>nil loop
    if arg^.sub<>nil

      -- hodnota je explicitnˆ uvedena
      then
        if (pentity_param(arg^.sym)^.pass=pp_value) and x_is_nil(arg^.sub)

          -- speci ln¡ p©¡pad: p©ed v  se NIL hodnotou
          then
            i_gen_pushnil(inst,info,context,arg^.t.getctype^.size);

          -- v¨echny ostatn¡ p©¡pady
          else
            -- p©ipravit kontext
            case pentity_param(arg^.sym)^.pass
              -- hodnotou
              when pp_value     do
                  i_newcontext(context,newcontext,lm_push_value,arg^.t.getutype);
                  i_setoutpref(newcontext,iop_stack);

              -- odkazem
              when pp_ref       do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});

              -- odkazem, bez typov‚ kontroly
              when pp_unchecked do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});

              -- odkazem, v‡etnˆ odvozen˜ch typ–
              when pp_class     do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});--unimplemented(74);

              -- odkazem, ©¡d¡c¡ parametr virtu ln¡ho vol n¡
              when pp_virtual   do unimplemented(82);

              when others do verify(63,true);
              end case;

            -- jak‚ dynamick‚ atributy n s zaj¡maj¡ ?
            newcontext.rta:=pentity_param(arg^.sym)^.rta_used{usedrta};

            -- parametr p©edan˜ hodnotou nem  dynamick‚ atributy
            verify(327,(pentity_param(arg^.sym)^.pass=pp_value) and (newcontext.rta<>rtattribset:[]));

            -- vygenerovat parametr
            declare var
              opnone : c_operand;
            begin
              i_load(inst,info,newcontext,context,arg^.sub,opnone);
            leave
              opnone.free(info,context);
              end declare;
            end if;

      -- pou‘¡t implicitn¡ hodnotu
      else
        unimplemented(176);
        end if;

    -- dal¨¡ parametr
    nextarg;
    end loop;

  ---- ulo‘it pointer na instanci a na‡¡st adresu procedury ----
  declare var
    nclass         : nodeclass;                  -- p©evzat /ur‡en  t©¡da jm‚na procedury
    opcall         : c_operand;                  -- adresa volan‚ procedury

  begin
    expr^.get(el,arg);
    if el=nil
      then nclass:=nc_proc
      else nclass:=el^.nclass;
      end if;
    case {el^.}nclass
      -- p©¡mo procedura
      when nc_proc do
          verify(380,{(el^.ntype<>nt_component) or (pexpcomponent(el)^.s.psym=nil)
                     or} not (pproc^.etype{pexpcomponent(el)^.s.psym^.etype} in ets_subprogram));

          ---- jak je to s pointerem na instanci ? ----
          case pproc^.instance {pentity_subprogram(pexpcomponent(el)^.s.psym)^.instance}
            -- nep©ed vat
            when tip_none     do { d l ji‘ nic nedˆlat };

            -- volitelnˆ p©edat, nen¡-li, pak NIL
            when tip_optional do
                declare var
                  instance : pexpnode;           -- v˜raz ur‡uj¡c¡ instanci t©¡dy

                begin
                  -- naj¡t instanci
                  x_classinstance(el^.sub,instance);

                  if instance<>nil

                    -- je k dispozici => vygenerovat podv˜raz
                    then
                      declare var
                        op1 : c_operand;         -- operand
                      begin
                        i_newcontext(context,newcontext,lm_push_addr,nil);
                        i_load(inst,info,newcontext,context,instance,op1);
                      leave
                        op1.free(info,context);
                        end declare;

                    -- nen¡ k dispozici => ulo‘it aspo¤ NIL
                    else
                      addii(inst,info,ii_push,op_0_32bit,op0,op0);
                      end if;
                  end declare;

            -- p©edat
            when tip_pass     do
                declare var
                  instance : pexpnode;           -- v˜raz ur‡uj¡c¡ instanci t©¡dy
                  op1      : c_operand;          -- operand

                begin
                  -- naj¡t instanci
                  x_classinstance(el^.sub,instance);
                  verify(381,instance=nil);

                  -- vygenerovat podv˜raz
                  i_newcontext(context,newcontext,lm_push_addr,nil);
                  i_load(inst,info,newcontext,context,instance,op1);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;

            -- virtu ln¡ vol n¡
            when tip_dispatch do
                verify(527,el^.ntype<>nt_component or else pproc=nil or else pproc^.etype<>et_virtual);

                declare var
                  instance : pexpnode;           -- v˜raz ur‡uj¡c¡ instanci t©¡dy

                begin
                  -- naj¡t instanci
                  x_classinstance(el^.sub,instance);
                  verify(526,instance=nil);

                  -- vygenerovat podv˜raz
                  i_newcontext(context,newcontext,lm_addr,nil);
                  i_load(inst,info,newcontext,context,instance,opcall);
                  end declare;

                -- obnovit registry
                opcall.refresh(inst,info,context);

                -- ulo‘it pointer na instanci na stack
                addii(inst,info,ii_push,opcall,op0,op0);

                -- na‡¡st pointer na instanci do registru
                i_gen_loadreg(inst,info,context,nil,opcall,true,irm_addr);

                -- sestavit adresn¡ operand ukazuj¡c¡ na tag
                opcall.transform_reg_to_mem(edt_address,4);
                opcall.shift_displacement(imm32_to_signed{%%X}(cpu32_class_tag));

                -- na‡¡st tag (=adresu deskriptoru typu) do registru
                i_gen_loadreg(inst,info,context,nil,opcall,true,irm_addr);

                -- sestavit adresn¡ operand ukazuj¡c¡ na adresu virtu ln¡ metody
                declare var
                  _c_class_interface : c_class_interface;
                begin
                  opcall.transform_reg_to_mem(edt_address,4);
                  opcall.shift_displacement(t_signed(t_desc_class:size+_c_class_interface.normalize_vindex(pentity_virtual(pproc)^.vindex)*4));
                                                      -- %%TODO(COMPATIBILITY) %%TODO(620) ^^^^^ nahradit p©¡mo typem m¡sto instance
                  end declare;

            when others do verify(509,true);
            end case;

          ---- adresa procedury ----
          if pproc^{pentity_subprogram(pexpcomponent(el)^.s.psym)^}.instance<>tip_dispatch then
            -- m me podv˜raz specifikuj¡c¡ podprogram ?
            if el<>nil

              -- ano => pou‘ijeme ten
              then
                -- vygenerovat podv˜raz
                i_newcontext(context,newcontext,lm_imm_to_rel,nil);
                i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

                -- obnovit registry
                opcall.refresh(inst,info,context);

              -- ne => adresu procedury si vygenerujeme p©¡mo
              else
                i_gen_subprogram_address(inst,info,context,pproc,true,opcall);
                end if;
            end if;

      -- pointer na proceduru
      when nc_var,nc_value do
          -- vygenerovat podv˜raz
          i_newcontext(context,newcontext,lm_gen,nil);
          i_load(inst,info,newcontext,context,el{expr^.sub},opcall);

          -- obnovit registry
          opcall.refresh(inst,info,context);

          -- pointer budeme zpracov vat po 4bytov˜ch kousc¡ch
          opcall.adjust_size(4);

          declare var
            optemp : c_operand;                  -- pracovn¡ registr
            tgcall : itarget;                    -- c¡l skoku na vol n¡ procedury

          begin
            -- bude se hodit jeden registr
            optemp.create_new_register(inst,info,context,edt_address,4);

            -- na‡¡st pointer na instanci
            opcall.shift_displacement(4);
            addii(inst,info,ii_mov,optemp,opcall,op0);
            opcall.unshift_displacement(4);

            -- alokovat n vˆ¨t¡ skoku
            newtarget(info,tgcall);

            -- zjistit, zda je to platn˜ pointer na instanci
            addii(inst,info,ii_cmp,optemp,op_FFFFFFFF,op0);
            addjump(inst,info,context,ic_e,tgcall);

            -- ulo‘it instanci
            addii(inst,info,ii_push,optemp,op0,op0);

            -- adresa skoku na toto m¡sto
            settarget(info,tgcall,getaddr(inst));

          leave
            -- uvolnit pomocn˜ operand
            optemp.free(info,context);
            end declare;

      when others do verify(379,true);
      end case;

    -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUT ** z plata !!
    -- Podrobnˆji viz zakomentovan‚ vol n¡ SAVEREGS na za‡ tku t‚to procedury
    -- ulo‘it v¨echny pou‘it‚ registry
    -- %%X Omezit jen na registry skute‡nˆ pou‘it‚ ve volan‚ procedu©e
    i_reg_save_used(inst,info,context);

    -- instrukce
    addii(inst,info,ii_call,opcall,op0,op0);

    -- ze stacku odstranit parametry, kter‚ tam zbyly po £chyln˜ch volac¡ch konvenc¡ch
    if call in iccs_leave_params then
      unimplemented(203);
      --addopimm(inst,info,ii_add,op_esp, );
      end if;

  leave
    -- uvolnit operand
    opcall.free(info,context);
    end declare;

  ---- p©evz¡t v˜sledek ----
  if expr^.t.tview<>tview_null{stype<>dt_undef} then
    declare var
      resultsize   : t_unsigned;                 -- velikost n vratov‚ hodnoty

    begin
      -- velikost v˜sledku
      resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

      -- na stacku
      if call in iccs_ret_stack then
        if ptyp^.result^.pass in pps_ref

          -- odkazem
          then
            -- registr pro adresu n vratov‚ hodnoty
            vysl.create_new_register(inst,info,context,edt_address,4);

            -- vyzvednout ze stacku
            addii(inst,info,ii_pop,vysl,op0,op0);

            -- transformovat na referenci na n vratovou hodnotu
            vysl.transform_reg_to_mem(edt_binary,resultsize);

            -- uvolnit prostor na stacku se d  a‘ ve chv¡li kdy bude vyzvednuta
            -- hodnota na kterou pr vˆ vrac¡me pointer

          -- na stacku je hodnota
          else
            -- nepreferuje volaj¡c¡ ur‡itou metodu p©ed n¡ ?
            if context.outpref=iop_stack

              -- m me ¨tˆst¡, nad©azen  procedura chce v˜sledek na stacku
              then
                vysl.create_on_stack(edt_binary,resultsize);

              -- jinak s t¡m nˆco udˆlat
              else
                -- neve¨el by se v˜sledek do registru ?
                if resultsize=1 or resultsize=2 or resultsize=4{%%TODO(SET) resultsize in [1,2,4]}

                  then
                    declare var
                      alignedsize : t_unsigned32;    -- zarovnan  velikost n vratov‚ hodnoty

                    begin 
                      -- zarovnat
                      addalign(alignedsize,0,resultsize,istackalign);

                      -- vyzvednout adresu v˜sledku (nem me n hodou kopii ?)
                      vysl.create_new_register(inst,info,context,edt_binary,resultsize);

                      -- zmˆnit velikost registru na maxim ln¡ (nelze tak p©¡mo alokovat q–li ESI, EDI)
                      vysl.adjust_size(alignedsize);

                      -- p©evz¡t v˜sledek, a uvolnit z sobn¡k
                      addii(inst,info,ii_pop,vysl,op0,op0);

                      -- zmˆnit velikost registru na skute‡nou
                      vysl.adjust_size(resultsize);
                      end declare;

                  else
                    -- alokovat, t©eba nˆkde na stacku, prostor pro v˜sledek
                    vysl.create_temporary(inst,info,edt_binary,resultsize);

                    -- zkop¡rovat ze stacku do v˜sledku
                    i_gen_pop_static(inst,info,context,vysl,resultsize);
                    end if;
                end if;
            end if;

      -- v EAX
      elsif call in iccs_ret_eax then
        -- v˜sledek
        vysl.create_use_register(inst,info,context,edt_binary,ir_eax);
        vysl.adjust_size(resultsize);

      -- nˆjak  chyba
      else 
        verify(104,false);
        end if;

      -- chceme ulo‘it i dynamick‚ atributy ?
      if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
        i_gen_rtattrib(inst,info,context,expr,vysl);
        end if;
      end declare;
    end if;
  end i_gen_call_subprogram;



----------------------------------------------------------------------------------------------------
procedure i_gen_call (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du vol n¡ procedury.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_subprogram;         -- volan  procedura

begin
  -- nal‚zt proceduru
  pproc:=pentity_subprogram(expr^.sub^.getsymbol);
  verify(513,(pproc<>nil) and not (pproc^.etype in ets_callable));

  -- vygenerovat k¢d
  i_gen_call_subprogram(inst,info,context,expr,pproc,vysl);
  end i_gen_call;



----------------------------------------------------------------------------------------------------
procedure i_gen_index (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpindex;               -- strom
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du indexov n¡ pole.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  lval             : timm32;                     -- doln¡ mez pole
  size             : timm32;                     -- velikost prvku
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el,er);

  -- vygenerovat lev˜ podv˜raz
  i_newcontext(context,newcontext,lm_gen,nil);
  i_load(inst,info,newcontext,context,el,op1);
  verify(106,op1.optype<>io_mem);

  -- vygenerovat prav˜ podv˜raz
  -- je t©eba hodnota velikosti IDEFREGSIZE, tak‘e se typ neuv d¡
  i_newcontext(context,newcontext,lm_reg,nil);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);

  -- doln¡ mez pole
  lval:=uniint_to_imm32(el^.t.getctype^.srange.getctype^.lval);

  -- velikost prvku
  size:=unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size);

  -- z klad v˜sledku
  vysl.clone(inst,info,context,op1);
  vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
  verify(490,vysl.optype<>io_mem);
  -- Pozor: nutn˜ p©edpoklad pro spr vn‚ o¨et©en¡ IO_CC

  -- sestavit v˜slednou adresu
  case op2.optype
    -- registr
    when io_reg do
        -- doplnit jako scale*index
        if vysl.index.reg=ir_none and (size=timm32(1) or size=timm32(2) or size=timm32(4) or size=timm32(8)) then
          vysl.shift_by_index(inst,info,context,op2.reg.reg,imm32_to_unsigned(size));

        -- doplnit jako index
        elsif vysl.index.reg=ir_none then
          -- vyn sobit velikost¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako index
          vysl.shift_by_index(inst,info,context,op2.reg.reg,1);

        -- dosadit jako b zi
        elsif vysl.base.reg=ir_none then
          -- vyn sobit velikostn¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako b zi
          vysl.shift_by_base(inst,info,context,op2.reg.reg);

        -- p©i‡¡st k b zi
        else
          -- vyn sobit velikost¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- p©i‡¡st k b zi
          addopreg(inst,info,context,ii_add,op1.base.reg,op2);
          end if;

        -- opravit doln¡ mez
        vysl.unshift_displacement(imm32_to_signed{%%X}(lval*size));

    -- p©¡m  hodnota
    when io_imm do
        -- offset
        vysl.shift_displacement(imm32_to_signed{%%X}((op2.imm-lval)*size));

    -- promˆnn 
    when io_mem do
        unimplemented(71);

    -- podm¡nka
    when io_cc do
        -- z verify 490 je jasn‚, ‘e VYSL je IO_MEM

        declare var
          tg_end   : itarget;                    -- n vˆ¨t¡ pro skok na konec v˜po‡tu indexu

        begin
          -- n vˆ¨t¡ pro skok na konec v˜po‡tu adresy
          newtarget(info,tg_end);

          -- je sou‡ st¡ adresy nˆjak˜ registr ?
          if vysl.base.reg<>ir_none or (vysl.scale=1 and vysl.index.reg<>ir_none)

            -- ano => p©i‡¡st k nˆmu
            then
              -- skok na konec p©i nesplnˆn¡ podm¡nky
              addjump(inst,info,context,icondneg[op2.cc],tg_end);

              declare var
                optemp : c_operand;              -- registr vyseparovan˜ z lev‚ho operandu

              begin
                -- vyseparovat registr
                optemp.create_use_register(inst,info,context,edt_unsigned,vysl.get_register);

                -- jedenkr t p©i‡¡st velikost b ze
                addaddimm(inst,info,context,optemp,imm32_to_unsigned(size));

              leave
                -- uvolnit pracovn¡ registr
                optemp.free(info,context);
                end declare;

              -- adresa skoku na toto m¡sto
              settarget(info,tg_end,getaddr(inst));

            -- ne => vymyslet registr a zakomponovat ho do adresy
            else
              declare var
                optemp : c_operand;

              begin
                -- alokovat registr
                optemp.create_new_register(inst,info,context,edt_unsigned,4);

                -- nacpat do nˆj velikost
                addopimm(inst,info,context,ii_mov,optemp,0);

                -- skok na konec p©i nesplnˆn¡ podm¡nky
                addjump(inst,info,context,icondneg[op2.cc],tg_end);

                -- nacpat do registru velikost b ze
                addopimm(inst,info,context,ii_mov,optemp,imm32_to_unsigned(size));

                -- adresa skoku na toto m¡sto
                settarget(info,tg_end,getaddr(inst));

                -- registr pou‘¡t jako b zi
                vysl.shift_by_base(inst,info,context,optemp.reg.reg);

              leave;
                -- uvolnit pracovn¡ registr
                optemp.free(info,context);
                end declare;
              end if;
          end declare;

    when others do verify(107,true);
    end case;

  -- posunout o intern¡ ‡ st ©etˆzce
  if el^.t.stype in dts_string then
    vysl.shift_displacement(lstrisize32);
    end if;

  -- Ondra 18.12.2002 : chceme ulo‘it i dynamick‚ atributy ?
  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
    i_gen_rtattrib(inst,info,context,expr,vysl);
    end if;

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_index;



----------------------------------------------------------------------------------------------------
procedure i_gen_ref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpref;                 -- reference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du reference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el);

  case expr^.t.getpclass
    -- pointer na data
    when pc_data do
        -- vygenerovat podv˜raz
        i_newcontext(context,newcontext,lm_addr,nil);
        i_load(inst,info,newcontext,context,el,vysl);

        -- obnovit registry
        vysl.refresh(inst,info,context);

        -- doplnit p©¡padn‚ runtime atributy
        if {context.outtyp.pattrib}expr^.t.getpattrib<>rtattribset:[] then
          declare var
            optemp : c_operand;
          begin
            -- alokovat pracovn¡ promˆnnou
            optemp.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(expr^.t.getsize));

            -- zkonstruovat cel˜ pointer
            i_gen_compose_pointer(inst,info,context,vysl,expr^.t.getctype^.base.getutype,expr^.t.getctype^.base.getutype,{context.outtyp.pattrib}expr^.t.getpattrib,optemp);

            -- p©edat v˜sledek
            vysl.replace(info,context,optemp);

          leave
            -- uvolnit pracovn¡ operand
            optemp.free(info,context);
            end declare;
          end if;

    -- pointer na proceduru
    when pc_subprogram do
        verify(512,(el^.ntype<>nt_component) or (el^.getsymbol=nil));

        declare var
          instance : pexpnode;                   -- v˜raz ur‡uj¡c¡ instanci t©¡dy
          pproc    : pentity_subprogram;         -- referencovan˜ podprogram

        begin
          -- referencovan˜ podprogram
          pproc:=pentity_subprogram(el^.getsymbol);
          verify(514,not (pproc^.etype in ets_callable));
          if pproc^.etype=et_virtual then unimplemented(174); end if;

          -- naj¡t instanci t©¡dy
          x_classinstance(el^.sub,instance);

          -- alokovat pracovn¡ promˆnnou
          vysl.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(expr^.t.getsize));

          declare var
            oppart : c_operand;                  -- ‡ st pointeru

          begin
            -- operand odpov¡daj¡c¡ ‡ sti pointeru, kter  obsahuje adresu podprogramu
            oppart.clone(inst,info,context,vysl);
            oppart.adjust_size(4);

            declare var
              optemp : c_operand;                -- pracovn¡ promˆnn  pro zkonstruovan˜ pointer

            begin
              -- adresa podprogramu
              optemp.create_imm(edt_address,4,0);
              optemp.set_relo_entity(pproc);

              -- ulo‘it adresu na podprogram do pointeru
              addii(inst,info,ii_mov,oppart,optemp,op0);

            leave
              -- uvolnit pracovn¡ operand
              optemp.free(info,context);
              end declare;

            -- adresa pointeru na instanci
            i_gen_load_rtattrib_addr(inst,info,context,{context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_instance,oppart);

            declare var
              optemp : c_operand;                -- pracovn¡ promˆnn  pro zkonstruovan˜ pointer

            begin
              -- podprogram se nev ‘e na instanci => ulo‘it FFFFFFFF
              if pproc^.instance=tip_none then
                optemp.create_imm(edt_address,4,unsigned_to_imm32($FFFF_FFFF));

              -- podprogram se v ‘e na instanci, ale nem me ji => ulo‘it NIL
              elsif pproc^.instance=tip_optional and instance=nil then
                optemp.create_imm(edt_address,4,0);

              -- m me instanci
              elsif instance<>nil and pproc^.instance<>tip_none then
                -- vygenerovat podv˜raz
                i_newcontext(context,newcontext,lm_addr,nil);
                i_load(inst,info,newcontext,context,instance,optemp);
                
                -- obnovit registry
                optemp.refresh(inst,info,context);

                -- na‡¡st do registru
                i_gen_loadreg(inst,info,context,inttype_machine_pointer,optemp,false,irm_addr);
                
                --u_nimplemented(43);

              -- jin‚ p©¡pady nemohou nastat
              else
                verify(515,true)
                end if;

              -- nacpat do pointeru
              addii(inst,info,ii_mov,oppart,optemp,op0);

            leave
              -- uvolnit pracovn¡ operand
              optemp.free(info,context);
              end declare;

            -- pop©¡padˆ ulo‘it :tag
            if rta_tag in {context.outtyp.pattrib}expr^.t.getpattrib then
              -- adresa atributu
              i_gen_load_rtattrib_addr(inst,info,context,{context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_tag,oppart);

              -- vypo‡¡tat a ulo‘it
              i_gen_compute_rtattrib(inst,info,context,oppart,rta_tag,expr^.t.getctype^.base.getctype,expr^.t.getctype^.base.getctype);
              end if;

          leave
            -- uvolnit pracovn¡ operand
            oppart.free(info,context);
            end declare;
          end declare;

    -- pointer na task
    when pc_task do unimplemented(64);

    -- pointer na zpr vu
    when pc_message do unimplemented(83);

    when others do verify(112,true);
    end case;
  end i_gen_ref;



----------------------------------------------------------------------------------------------------
procedure i_gen_deref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpref;                 -- dereference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el);

  -- pro nˆkter‚ re‘imy na‡ten¡ v˜razu dereference moc nedereferencuje
  case context.mode

    -- ulo‘en¡ adresy a atribut– na stack => na‡¡st kompletn¡ hodnotu pointeru
    when lm_push_addr do
        -- p©ipravit kontext
        i_newcontext(context,newcontext,lm_pointer,nil);

        -- zkonstruovat charakteristiku typu v˜sledku
        declare var
          ptrsize  : tunidata_size;              -- velikost vykonstruovan‚ho pointeru
        begin
          cpu^.getptrsize(context.rta,ptrsize);
          i_compose_outtyp(newcontext,dt_pointer,ptrsize,context.rta,expr^.t.getctype);
          end declare;

        -- vygenerovat podv˜raz
        i_load(inst,info,newcontext,context,el,vysl);

    -- adresa pointeru s ulo‘en˜mi atributy => na‡¡st adresu pointeru
    when lm_addr_attr do
        -- vygenerovat podv˜raz
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,el,vysl);

    -- cokoliv jin‚ho => dereferencovat
    when others do
        verifyx(558,context.mode in lms_addr-iexprloadmodeset:[lm_addr],expr^.pos);

        case el^.t.getpclass
          -- pointer na data
          when pc_data  do
              -- vygenerovat podv˜raz (jako unchecked machine pointer, aŸ se zbav¡me runtime atribut–)
              i_newcontext(context,newcontext,lm_pointer_reg,inttype_machine_pointer{el^.t.getutype});
              i_load(inst,info,newcontext,context,el,vysl);

              -- adresa
              vysl.transform_reg_to_mem(edt_binary,0);
              if expr^.t.hassize then
                vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));
                end if;

          -- pointer na proceduru
          when pc_subprogram do
              -- vygenerovat podv˜raz
              i_newcontext(context,newcontext,lm_pointer,el^.t.getutype);
              i_load(inst,info,newcontext,context,el,vysl);

          -- pointer na task
          when pc_task  do unimplemented(65);

          -- pointer na zpr vu
          when pc_message do unimplemented(84);

          when others do verify(112,true);
          end case;
    end case;
  end i_gen_deref;



----------------------------------------------------------------------------------------------------
procedure i_gen_attrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpattrib;              -- atribut
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du atributu.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure loadrtattrib (
        rta        : in rtattrib;
        vysl       : out c_operand) =
    -- Na‡ten¡ konkr‚tn¡ho run-time atributu.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podv˜raz–

    begin
      -- na‡¡st adresu promˆnn‚
      i_newcontext(context,newcontext,lm_addr_attr{lm_gen},nil);
      i_load(inst,info,newcontext,context,expr^.sub,vysl);

      -- udˆlat z operandu atribut :"rta"
      i_gen_adjust_rta_position(rta,expr^.sub,vysl);

      -- na‡¡st hodnotu do registru
      i_gen_loadreg(inst,info,newcontext,nil,{nil,}vysl,false,irm_int);
      end loadrtattrib;

var
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  case expr^.aclass
    -- statick‚ atributy
    when atc_static  do
        case expr^.ata
        ---- :unchecked
        --ata_var_unchecked : i_load(inst,info,lm_gen,nil,expr^.sub,vysl);

          -- :tag
          when ata_type_tag{ata_expr_tag} do
              vysl.create_imm(edt_unsigned,4,0);
              vysl.set_relo_entity(expr^.sub^.t.getctype);

          when others do verifyx(148,true,expr^.pos);
          end case;


    -- dynamick‚ atributy
    when atc_dynamic do
        case expr^.ata
          -- :unchecked
          when ata_var_unchecked do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :length
          when ata_string_length do
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

              -- zmˆnit velikost
              vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));

          -- :ord
          when ata_ord_ord do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

          -- :last
          when ata_expr_last do loadrtattrib(rta_last,vysl);

          -- :size
          when ata_expr_size do loadrtattrib(rta_size,vysl);

          -- :length neomezen‚ho pole
          when ata_array_length do
              -- na‡¡st atribut :last
              loadrtattrib(rta_last,vysl);

              -- p©i‡¡st 1
              addii(inst,info,ii_inc,vysl,op0,op0);

          -- :tag
          when ata_expr_tag do loadrtattrib(rta_tag,vysl);

          -- :tagged
          when ata_expr_tagged do
              declare var
                optemp : c_operand;

              begin
                -- na‡¡st atribut :tag
                loadrtattrib(rta_tag,optemp);

                -- porovnat
                addii(inst,info,ii_cmp,optemp,op_0,op0);

              leave
                -- uvolnit operand
                optemp.free(info,context);
                end declare;

              -- v˜sledek je podm¡nka
              vysl.create_condition(ic_ne);

          when others do verify(282,true);--u_nimplemented(59);
          end case;

    when others do verify(147,true);
    end case;
  end i_gen_attrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  arg              : pexpitem;                   -- argument
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el,arg);
  er:=arg^.sub;

  -- konverze z ...
  case er^.t.tview
    -- ... unchecked na cokoliv
    when tview_unchecked do
        -- vygenerovat
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,er,vysl);

        -- velikost operandu
        vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));

    -- ... Full view ...
    when tview_full     do
        case el^.t.tview
          -- ... na Full view
          when tview_full do
              -- ordin ln¡ --> ordin ln¡
              if (er^.t.stype in dts_ordinal) and (el^.t.stype in dts_ordinal) then
                -- na‡¡st hodnotu
                i_newcontext(context,newcontext,lm_conv,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- pointer -> pointer
              elsif (er^.t.stype=dt_pointer) and (el^.t.stype=dt_pointer) then
                -- na‡¡st hodnotu
                i_newcontext(context,newcontext,lm_pointer,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- jin‚ konverze neum¡me
              else 
                verifyx(611,true,expr^.pos);
                end if;
            {
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,er,vysl);

              -- %%X Tady chyb¡ konverze !

              -- velikost operandu
              vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
            }


          -- ... Partial view

          when others do verify(272,true);
          end case;

    when others do verify(149,true);
    end case;

  -- vygenerovat podv˜raz
  --i_load(inst,info,,arg^.sub^.t.typ,el,op1);

  --u_nimplemented(56);
  end i_gen_typecast;



----------------------------------------------------------------------------------------------------
procedure i_gen_message_send (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- dereference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du odesl n¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arg              : pexpitem;                   -- argument
  opnone           : c_operand;                  -- pr zdn˜ v˜sledek
  newcontext       : iexprcontext;               -- kontext v˜razu

begin
  -- podv˜razy
  expr^.get(el,arg);

  -- parametry
  if arg<>nil

    -- m  parametry
    then
      unimplemented(104);

    -- nem  parametry => na stack d t NIL
    else
      i_gen_pushstack(inst,info,context,op_0);
      end if;

  -- ‡¡slo v˜jimky
  i_newcontext(context,newcontext,lm_push_value,nil);
  i_load(inst,info,newcontext,context,el,opnone);

  -- tag
  -- %%X
  i_gen_pushstack(inst,info,context,op_0);

leave
  -- uvolnit operand
  opnone.free(info,context);
  end i_gen_message_send;



----------------------------------------------------------------------------------------------------
procedure i_gen_callspec (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpcallspec;            -- dereference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du odesl n¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  opnone           : c_operand;                  -- pr zdn˜ v˜sledek
  newcontext       : iexprcontext;               -- kontext v˜razu
  el               : pexpnode;                   -- instance t©¡dy (je-li to metoda t©¡dy)
  arglist          : pexpitem;                   -- seznam parametr–

begin
  -- oddˆlit instanci t©¡dy/modul a parametry
  expr^.get(el,arglist);

  -- je speci ln¡ metoda ji‘ pevnˆ ur‡ena ?
  if (expr^.spec<>nil) and (el=nil)

    -- ano => zavolat ji p©¡mo
    then
      verify(581,(arglist=nil) or (el<>nil));

      -- zavolat jako norm ln¡ podprogram
      i_gen_call_subprogram(inst,info,context,expr,expr^.spec,vysl);

    -- ne => vybrat metodu podle tagu instance t©¡dy/modulu
    else
      verify(582,(el=nil) or (arglist<>nil));

      case el^.nclass
        -- podv˜raz je instance t©¡dy
        when nc_var     do
            verify(583,not el^.t.isclass);

            -- adresu instance ulo‘it na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,el,opnone);

            -- zavolat speci ln¡ metodu
            if expr^.spec=nil

              -- a to prvn¡ dostupnou
              then
                i_dispatch_special(inst,info,context,expr^.spectype);

              -- jinak tu pevnˆ ur‡enou
              else
                declare var
                  op1 : c_operand;               -- operand

                begin
                  -- vr tit adresu procedury
                  i_gen_subprogram_address(inst,info,context,expr^.spec,true,op1);

                  -- zavolat
                  addii(inst,info,ii_call,op1,op0,op0);

                leave
                  -- uvolnit operand
                  op1.free(info,context);
                  end declare;
                end if;

        -- podv˜raz je modul
        when nc_module  do
            unimplemented(194);

        when others do verify(406,true);
        end case;
      end if;

  -- v˜sledek ve¨ker˜ ‘ dn˜
  --nullop(vysl,io_none);

{ P–vodn¡ verze pouze pro speci ln¡ metody t©¡dy:

  if expr^.sub<>nil

    -- m me podv˜raz, pod¡vat se, co je za‡
    then
      case expr^.sub^.nclass
        -- podv˜raz je instance t©¡dy
        when nc_var     do
            -- adresu instance ulo‘it na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,expr^.sub,opnone);

            -- zavolat speci ln¡ metody
            i_dispatch_special(inst,info,expr^.spectype);


        -- podv˜raz je modul
        when nc_module  do
            unimplemented(407);


        when others do verify(406,true);
        end case;

    -- podv˜raz nem me, tud¡‘ mus¡me m¡t adresu entry rovnou k dispozici
    when others do
      unimplemented(125);
      end if;

  -- v˜sledek ve¨ker˜ ‘ dn˜
  nullop(vysl,io_none);
 }
  end i_gen_callspec;



----------------------------------------------------------------------------------------------------
procedure i_gen_this (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpthis;                -- dereference
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du THIS.
----------------------------------------------------------------------------------------------------
begin
  -- vygenerovat a na‡¡st adresu instance t©¡dy
  i_load_this_address(inst,info,context,expr^.t.getsize,uda_0,vysl);
  --verify(696,vysl.size<>unidata_size_to_unsigned(expr^.t.getsize));
  end i_gen_this;


    
----------------------------------------------------------------------------------------------------
procedure i_gen_fake_tag (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpfaketag;             -- fake tag interfacu t©¡dy
    vysl           : out c_operand) =            -- v˜sledek
-- Generov n¡ k¢du fake tagu interfacu t©¡dy.
----------------------------------------------------------------------------------------------------
begin
  -- inicializovat operand
  vysl.create_imm(edt_unsigned,4,0);

  -- doplnit relokaci
  vysl.set_relo_interface(expr^.interface);
  end i_gen_fake_tag;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
#if #declared ondra; then;
with
  standard.conversions;
#end if;

begin
  verify(28,(expr=nil) or (expr^.zprac<>expr^.zprac:last));

  -- vygenerovat v˜raz
  case expr^.ntype
    -- bin rn¡ oper tor
    when nt_operator  do i_gen_operator(inst,info,context,pexpoper(expr),vysl);

    -- un rn¡ oper tor
    when nt_unary     do i_gen_unary(inst,info,context,pexpunary(expr),vysl);

    -- komponenta
    when nt_component do i_gen_component(inst,info,context,pexpcomponent(expr),vysl);

    -- p©¡m  hodnota
    when nt_imm       do i_gen_imm(inst,info,context,pexpimm(expr),vysl);

    -- agreg t
    when nt_aggregate do i_gen_aggregate(inst,info,context,pexpaggregate(expr),vysl);

    -- vol n¡ procedury
    when nt_call      do i_gen_call(inst,info,context,pexplist(expr),vysl);

    -- index pole
    when nt_index     do i_gen_index(inst,info,context,pexpindex(expr),vysl);

    -- reference
    when nt_ref       do i_gen_ref(inst,info,context,pexpref(expr),vysl);

    -- dereference
    when nt_deref     do i_gen_deref(inst,info,context,pexpref(expr),vysl);

    -- atribut
    when nt_attrib    do i_gen_attrib(inst,info,context,pexpattrib(expr),vysl);

    -- p©etypov n¡
    when nt_typecast  do i_gen_typecast(inst,info,context,pexplist(expr),vysl);

    -- odesl n¡ zpr vy
    when nt_send      do i_gen_message_send(inst,info,context,pexplist(expr),vysl);

    -- vol n¡ speci ln¡ metody
    when nt_callspec  do i_gen_callspec(inst,info,context,pexpcallspec(expr),vysl);

    -- THIS
    when nt_this      do i_gen_this(inst,info,context,pexpthis(expr),vysl);

    -- fake tag interfacu t©¡dy
    when nt_fake_tag  do i_gen_fake_tag(inst,info,context,pexpfaketag(expr),vysl);

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others do
      #if #declared ondra; then;
        dumptree(expr);
        debug_dump(unsigned_to_string(expr^.ntype:ord));
      #end if;
        verify(29,true);

    end case;
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_gen_expr =
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- v˜sledek
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- p©ipravit kontext
    i_createcontext(context,lm_gen,nil);

    -- vygenerovat v˜raz
    i_gen(inst,info,context,expr,vysl);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit ji‘ nepot©ebn˜ v˜sledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_gen_expr;



----------------------------------------------------------------------------------------------------
procedure i_gen_cond =
-- Generov n¡ k¢du v˜razu.
-- Pokud je c¡l skoku nastaven na TGFALLTHRU, tak nesko‡¡ nikam.
----------------------------------------------------------------------------------------------------
with
  ci_logical;

var
  vysl             : c_operand;                  -- v˜sledek
  context          : iexprcontext;               -- kontext v˜razu
  newcontext       : iexprcontext;               -- kontext podv˜razu

begin
  verify(601,(ttarget=tgfallthru) and (ftarget=tgfallthru));

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani podminky ------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat podm¡nku
    if (expr^.ntype=nt_operator) and (pexpoper(expr)^.oper in expopertypeset:[op_and,op_or,op_and_then,op_or_else])

      -- generovat ©etˆz konjunkc¡/disjunkc¡
      then
        -- p©ipravit kontext
        i_createcontext(context,lm_gen,nil);

        -- vygeneovat
        i_gen_logical_chain(inst,info,context,pexpoper(expr),ttarget,ftarget,vysl);

      -- generovat jako oby‡ejn˜ v˜raz
      else
        declare var
          cc       : icond;                      -- podm¡nka

        begin
          declare var
            op1    : c_operand;                  -- operand

          begin
            -- p©ipravit kontext
            i_createcontext(context,lm_gen{reg},expr^.t.getctype);

            -- vygenerovat a na‡¡st v˜raz
            i_newcontext(context,newcontext,lm_reg,nil);
            i_load(inst,info,newcontext,context,expr,op1);

            -- obnovit registry
            op1.refresh(inst,info,context);

            if op1.optype=io_cc

              -- p©¡mo podm¡nka
              then cc:=op1.cc

              -- je¨tˆ porovnat
              else
                -- porovnat
                addii(inst,info,ii_cmp,op1,op_0,op0);

                -- podm¡nka
                cc:=ic_nz;
                end if;

          leave
            -- uvolnit operand
            op1.free(info,context);
            end declare;

          -- v˜sledn˜ skok
          i_gen_logical_jump(inst,info,context,false,cc,ttarget,ftarget,vysl);
          end declare;
        end if;
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit ji‘ nepot©ebn˜ v˜sledek
    vysl.free(info,context);
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;

leave
  -- uvolnit operand
  vysl.free(info,context);
  end i_gen_cond;



----------------------------------------------------------------------------------------------------
procedure i_load_message_code =
-- Na‡te k¢d zpr vy do EAX.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- v˜sledek
  context          : iexprcontext;               -- kontext v˜razu
  newcontext       : iexprcontext;               -- kontext podv˜razu

begin
  verify(310,(expr^.ntype<>nt_accept) or not (expr^.sub^.nclass in ncs_message_code));

  begin
    -- p©ipravit kontext
    i_createcontext(context,lm_reg_eax,nil);

    -- vygenerovat v˜raz
    i_newcontext(context,newcontext,lm_reg_eax,nil);
    i_load(inst,info,newcontext,context,expr^.sub,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

  leave
    -- uvolnit ji‘ nepot©ebn˜ v˜sledek
    vysl.free(info,context);
    end;
  end i_load_message_code;



----------------------------------------------------------------------------------------------------
procedure i_load_expr =
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni vyrazu -----------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a na‡¡st v˜sledek
    i_load(inst,info,{new}context,context,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,context);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_expr;



----------------------------------------------------------------------------------------------------
procedure i_load_subexpr =
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Nacteni podvyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a na‡¡st v˜sledek
    i_load(inst,info,subcontext,supercontext,expr,vysl);

    -- obnovit registry
    vysl.refresh(inst,info,supercontext);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subexpr;



----------------------------------------------------------------------------------------------------
procedure i_load_rtattrib =
-- Na‡te po‘adovan˜ run-time atribut dan‚ho v˜razu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_createcontext(context,lm_addr_attr,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- udˆlat z operandu atribut ":rta"
    i_gen_adjust_rta_position(rta,expr,vysl);
  {
    -- na‡¡st hodnotu do registru
    i_gen_loadreg(inst,info,context,{nil,}vysl,false,irm_int);
  }
    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int);
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_load_subrtattrib =
-- Na‡te po‘adovan˜ run-time atribut dan‚ho v˜razu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_newcontext(supercontext,context,lm_addr_attr,nil);
    i_load(inst,info,context,supercontext,expr,vysl);

    -- udˆlat z operandu atribut ":rta"
    i_gen_adjust_rta_position(rta,expr,vysl);
  {
    -- na‡¡st hodnotu do registru
    i_gen_loadreg(inst,info,supercontext,{nil,}vysl,false,irm_int);
  }
    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,supercontext,nil,vysl,false,irm_int);
      else i_gen_loadtemp(inst,info,supercontext,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subrtattrib;



----------------------------------------------------------------------------------------------------
procedure i_load_length =
-- Na‡te run-time atribut :length dan‚ho v˜razu.
-- %%X Nˆco jako z plata. Vymyslet sjednocen¡ s I_LOAD_RTATTRIB asi na b zi
-- slou‡en¡ s I_GEN_ATTRIB.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_createcontext(context,lm_gen,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- zmˆnit velikost
    vysl.adjust_size(4);

    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int)
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_length;



----------------------------------------------------------------------------------------------------
procedure i_load_sublength =
-- Na‡te run-time atribut :length dan‚ho v˜razu.
-- %%X Nˆco jako z plata. Vymyslet sjednocen¡ s I_LOAD_RTATTRIB asi na b zi
-- slou‡en¡ s I_GEN_ATTRIB.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_newcontext(supercontext,context,lm_gen,nil);
    i_load(inst,info,context,supercontext,expr,vysl);

    -- zmˆnit velikost
    vysl.adjust_size(4);

    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,supercontext,nil,vysl,false,irm_int)
      else i_gen_loadtemp(inst,info,supercontext,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;
    end;

#if dump then;
  if o_is_option_by_entity(opt_dump_code,info.entity^) then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_sublength;



----------------------------------------------------------------------------------------------------
procedure initopertab =
-- Inicializace ©¡d¡c¡ tabulky optimalizace bin rn¡ch oper tor–.
----------------------------------------------------------------------------------------------------
with 
  ci_integer,
  ci_logical,
  ci_pointer,
  ci_string,
  ci_set;

begin
  ---- celo‡¡seln‚ ----
  -- *
  oset1s(opertab,op_mul,dts_integer,^i_gen_op_integer_mul);

  -- div mod
  osetss(opertab,[op_idiv,op_imod],dts_integer,^i_gen_op_integer_div_mod);

  -- + - bitov‚ AND OR XOR SHL SHR
  osetss(opertab,[op_add,op_sub,op_bitand,op_bitor,op_bitxor,op_shl,op_shr],dts_integer,^i_gen_op_integer);

  -- :=
  oset1s(opertab,op_assign,dts_integer,^i_gen_op_assign);


  ---- znakov‚ ----
  -- :=
  oset1s(opertab,op_assign,dts_char,^i_gen_op_assign);


  ---- logick‚ ----
  -- AND OR
  osetss(opertab,[op_and_then,op_or_else,op_and,op_or],dts_u_logical,^i_gen_op_logical_and_or);

  -- XOR
  oset1s(opertab,op_xor,dts_u_logical,^i_gen_op_logical_xor);

  -- :=
  oset1s(opertab,op_assign,dts_logical,^i_gen_op_assign_logical);


  ---- v˜‡tov‚ ----
  -- :=
  oset1s(opertab,op_assign,dts_enum,^i_gen_op_assign);


  ---- ordin ln¡ typy obecnˆ ----
  -- < <= > >= <> =
  osetss(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dts_ordinal,^i_gen_op_compare_ordinal);


  ---- pointery ----
  -- :=
  oset11(opertab,op_assign,dt_pointer,^i_gen_op_assign_pointer);

  -- <> =
  osetss(opertab,[op_ne,op_eq],dts_pointer,^i_gen_op_compare_pointer);


  ---- ©etˆzce ----
  -- :=
  oset1s(opertab,op_assign,dts_string,^i_gen_op_assign_string);

  -- &
  oset1s(opertab,op_concat,dts_string,^i_gen_op_concat_string);

  -- < <= > >=
  osetss(opertab,[op_lt,op_le,op_gt,op_ge],dts_string,^i_gen_op_order_string);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_string,^i_gen_op_compare_string);

  ---- pole ----
  -- :=
  oset1s(opertab,op_assign,dts_array,^i_gen_op_assign);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_array,^i_gen_op_compare_array);


  ---- mno‘iny ----
  -- :=
  oset11(opertab,op_assign,dt_set,^i_gen_op_assign);

  -- + - *
  osetss(opertab,[op_union,op_diff,op_isect],dts_set,^i_gen_op_set);

  -- IN NOT IN
  osetss(opertab,[op_in,op_notin],dts_u_set,^i_gen_op_in_set);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_set,^i_gen_op_compare_set);


  ---- recordy ----
  -- :=
  oset11(opertab,op_assign,dt_record,^i_gen_op_assign);

  -- = <>
  osets1(opertab,[op_eq,op_ne],dt_record,^i_gen_op_compare_record);


  ---- tagy ----
  -- :=
  oset1s(opertab,op_assign,dts_tag,^i_gen_op_assign);


  ---- t©¡dy ----
  -- :=
  oset1s(opertab,op_assign,dts_class,^i_gen_op_assign);

  ---- unchecked ----
  --oset11(opertab,op_assign,st_unchecked,^i_gen_op_assign);
  end initopertab;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initopertab;
  end entry;



end ci_expr;