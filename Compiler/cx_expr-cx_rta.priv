----------------------------------------------------------------------------------------------------
module private cx_rta =
-- Překladač Flexu.
-- Výběr dynamických atributů pro různé typy uzlů.
----------------------------------------------------------------------------------------------------
-- Ondra : 01.03.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_attr;

----------------------------------------------------------------------------------------------------
procedure x_rta_provided_attributes =
-- Pro zadaný uzel naplní množinu dynamických atributů, které je schopen
-- poskytnout svému kontextu.
----------------------------------------------------------------------------------------------------
var
  pvar             : pentity_var;                -- související proměnná
  partyp           : typeview;

begin
  case expr^.ntype
    -- komponenta
    when nt_component do
        -- související symbol
        pentity(pvar):=pexpcomponent(expr)^.s.psym;
        verify({VERIFY=}000520,pvar=nil);

        -- zajímají nás jen proměnné
        if expr^.nclass in ncs_value and pvar^.etype=et_var then
          -- %%LANG Komponenta může mít dynamické atributy pokud splňuje
          -- následující:
          --   -- je to parametr typu třída, pak má dynamické atributy :tag
          --      a :size (musí se ošetřit takhle explicitně, protože pro
          --      parametry typu třída se dynamické atributy neuvádějí),
          if pvar^.vimplements=vi_parameter and t_is_stype(expr^.t,dt_class) then
            expr^.rta_avail+rtattribset:[rta_size];
            expr^.rta_avail+rtattribset:[rta_tag];

          --   -- je to parametr, pak má dynamické atributy parametru,
          elsif pvar^.vimplements=vi_parameter then
            expr^.rta_avail:=pvar^.imp_param^.rta_avail;

          --   -- proměnná typu třída => :tag (jen :tag, u proměnné lze
          --      velikost staticky zjistit.
          elsif t_is_sts(expr^.t,dts_class) then
            expr^.rta_avail+rtattribset:[rta_tag];
            end if;

          --   -- ref proměnná constrained typu => :tag,
          --   -- ref proměnná unconstrained typu => :size, :last, :tag.
          -- %%TODO(TAG) Ref proměnné nejsou v této verzi podporovány

        {
          --   -- unchecked parametr bez uvedeného typu => :size, :tag,
          if (pvar^.pparam<>nil) and (pvar^.pparam^.pass=pp_unchecked) and not pvar^.pparam^.typ.isset then
            expr^.rta_avail+[rta_size];
            expr^.rta_avail+[rta_tag];

          --   -- unchecked parametr s uvedeným constrained typem => :tag,
          --   -- unchecked parametr s uvedeným unconstrained typem => :size,
          --      :last, :tag
          elsif (pvar^.pparam<>nil) and (pvar^.pparam^.pass=pp_unchecked)
          and pvar^.pparam^.typ.isset then
            expr^.rta_avail+[rta_tag];
            if t_is_sts(expr^.t,dts_unconstrained) then
              expr^.rta_avail+[rta_size];
              expr^.rta_avail+[rta_last];
              end if;

          --   -- class/virtual parametr constrained typu => :size, :tag,
          --   -- class/virtual parametr unconstrained typu => :size, :last,
          --      :tag,
          elsif (pvar^.pparam<>nil) and (pvar^.pparam^.pass in [pp_class,pp_virtual]) then
            expr^.rta_avail+[rta_size];
            expr^.rta_avail+[rta_tag];
            if t_is_sts(expr^.t,dts_unconstrained) then
              expr^.rta_avail+[rta_last];
              end if;
        }
          end if;

    -- selektor pole
    when nt_index do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Prvek pole typu třída má dynamický atribut :tag.
          if t_is_sts(expr^.t,dts_class) then
            expr^.rta_avail+rtattribset:[rta_tag];
            end if;
          end if;

    -- reference
    when nt_ref do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Reference může mít všechny dynamické atributy, které
          -- obsahuje výsledný typ pointer. Ten je přebírán od referencovaného
          -- podvýrazu.
          expr^.rta_avail:=expr^.t.getpattrib;
          end if;

    -- dereference
    when nt_deref do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Dereference může mít všechny dynamické atributy, které
          -- definuje typ dereferencovaného pointeru. Dereference pointeru na
          -- třídu navíc zpřístupňuje atributy :tag a :size.
          expr^.rta_avail:=expr^.sub^.t.getpattrib;
          if t_is_stype(expr^.sub^.t.getbase(curr),dt_class) then
            expr^.rta_avail+rtattribset:[rta_size];
            expr^.rta_avail+rtattribset:[rta_tag];
            end if;
          end if;

    -- operátor
    when nt_operator do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Operátor zřetězení s unconstrained typem výsledku má
          -- dynamické atributy :size a :last.
          if (pexpoper(expr)^.oper=op_concat) and t_is_stype(expr^.t,dt_uarray) then
            expr^.rta_avail+rtattribset:[rta_size];
            expr^.rta_avail+rtattribset:[rta_last];
            end if;
          end if;

    -- this
    when nt_this do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG THIS odkazující na instanci třídy má dynamické atributy
          -- :size a :tag.
          if t_is_stype(expr^.t,dt_class) then
            expr^.rta_avail+rtattribset:[rta_size];
            expr^.rta_avail+rtattribset:[rta_tag];
            end if;
          end if;

    -- přetypování
    when nt_typecast do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Přetypování objektu, který má dynamické atributy :size nebo
          -- :last, na unconstrained typ má atributy :size a :last.
          if t_is_sts(expr^.t,dts_unconstrained) and (expr^.sub^.next^.rta_avail*rtattribset:[rta_size,rta_last]<>rtattribset:[]) then
            expr^.rta_avail+rtattribset:[rta_size];
            expr^.rta_avail+rtattribset:[rta_last];
            end if;
          end if;

    -- atribut
    when nt_attrib do
        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- %%LANG Atribut :unchecked aplikovaný na objekt, který má dynamické
          -- atributy :size nebo :last, má dynamický atribut :size
          if (pexpattrib(expr)^.ata=ata_var_unchecked) and (expr^.sub^.rta_avail*rtattribset:[rta_size,rta_last]<>rtattribset:[]) then
            expr^.rta_avail+rtattribset:[rta_size];
            end if;
          end if;

    -- u ostatních typů uzlů nemají dynamické atributy smysl
    end case;
  end x_rta_provided_attributes;



----------------------------------------------------------------------------------------------------
procedure x_rta_require_attribute =
-- Ověří, zda je zadaný výraz schopen poskytnout požadovaný dynamický atribut
-- svému kontextu a zařadí jej do množiny použitých dynamických atributů.
-- Procedura uspěje i v situaci, kdy požadovaný atribut sice není k dispozici,
-- ale je k dispozici jiný atribut, ze kterého je požadovaný odvoditelný.
-- Pokud požadovaný atribut není k dispozici, způsobí chybu.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

var
  rta              : rtattrib;

begin
  rta:=_rta;

  -- není-li v množině dostupných, zkusit jiný, ze kterého je odvoditelný
  if rta not in expr^.rta_avail then
    case rta
      -- :size
      when rta_size     do
          -- %%LANG Dynamický atribut :size je odvoditelný z :last a pro
          -- constrained typy i z:tag
          if rta_last in expr^.rta_avail then 
            rta:=rta_last
          elsif t_is_sts(expr^.t,dts_constrained) and (rta_tag in expr^.rta_avail) then 
            rta:=rta_tag; 
            end if;

      -- :last
      when rta_last     do
          -- %%LANG Dynamický atribut :last je odvoditelný poze ze :size. Na
          -- rozdíl od :last ho nelze odvodit z :tag, protože ten nemusí
          -- nutně reprezentovat constrained typ.
          if rta_size in expr^.rta_avail then 
            rta:=rta_size; 
            end if;

      -- ostatní atributy nelze odvozovat
      end case;
    end if;

  -- je v množině dostupných atributů ?
  if rta not in expr^.rta_avail then
    ce^.seterror({CCERR=}000506,ce_nortattr);
    ce^.setparam(rtattribtxt[rta]);
    expr^.errpos;
    ce^.resumeerror;
    end if;

  -- ještě nebyl použit ?
  if rta not in expr^.rta_used then
    -- zařadit mezi použité
    --%%TODO(UNION) zatím neumíme sjednocení množin
    --expr^.rta_used+rtattribset:[rta];
    bit_set(expr^.rta_used,t_bit_index(rta:ord));

    -- prošířit do podvýrazu
    case expr^.ntype
      -- atribut
      when nt_attrib    do
          if rta in rtattribset:[rta_size,rta_last] then
            x_rta_require_attribute(curr,expr^.sub,rta);
            end if;

      -- přetypování
      when nt_typecast  do
          if rta in rtattribset:[rta_size,rta_last] then
            x_rta_require_attribute(curr,expr^.sub^.next,rta);
            end if;

      -- U ostatních typů uzlů není potřeba nic prošiřovat. Je pravda, že
      -- sice takové zřetězení může mít jako podvýraz opět zřetězení, to se
      -- ale ošetří při postupném trasování stromu zdola nahoru v typové
      -- kontrole voláním X_RTA_CHECK_ATTRIBUTE. Zde se skutečně jedná jen o
      -- prošíření jednoho jedniného fyzického dynamického atribut z nižších
      -- pater stromu výš a ne o zajištění existence hodnot, které na výpočet
      -- takového atributu vedou.
      end case;
    end if;
  end x_rta_require_attribute;



----------------------------------------------------------------------------------------------------
procedure x_rta_check_attributes =
-- Ověří, zda podvýrazy zadaného uzlu mají všechny potřebné dynamické
-- atributy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  er               : pexpnode;                   -- podvýrazy
  arg              : pexpitem;                   -- argument volání procedury

begin
  case expr^.ntype
    -- operátor
    when nt_operator do
        verify({VERIFY=}000521,pexpoper(expr)^.arity<>eoa_2);

        -- zajímají nás jen hodnoty
        if expr^.nclass in ncs_value then
          -- získat podvýrazy
          pexpoper(expr)^.get(el,er);

          case pexpoper(expr)^.oper
            -- přiřazení
            when op_assign do
                -- %%LANG Musí být splněno:
                --   -- je-li výraz na levé straně beztypový unchecked objekt,
                --      či je-li pod ním unconstrained typ (tj. výraz je
                --      atribut :unchecked), musí mít atribut :size,
                if (el^.t.tview=tview_unchecked) and ((el^.t.getutype=nil)
                or ((el^.ntype=nt_attrib) and t_is_sts(el^.sub^.t,dts_unconstrained))) then
                  x_rta_require_attribute(curr,el,rta_size);
                --   -- je-li výraz na levé straně unconstrained typu, musí mít
                --      atribut :last,
                elsif t_is_sts(el^.t,dts_unconstrained) then
                  x_rta_require_attribute(curr,el,rta_last);
                  end if;
                --   -- je-li výraz na pravé straně beztypový unchecked objekt,
                --      či je-li pod ním unconstrained typ (tj. výraz je
                --      atribut :unchecked), musí mít atribut :size,
                if (er^.t.tview=tview_unchecked) and ((er^.t.getutype=nil)
                or ((er^.ntype=nt_attrib) and t_is_sts(er^.sub^.t,dts_unconstrained))) then
                  x_rta_require_attribute(curr,er,rta_size);
                --   -- je-li výraz na pravé straně unconstrained array a není
                --      přímá hodnota, musí mít atribut :last.
                elsif t_is_stype(er^.t,dt_uarray) and (er^.ntype<>nt_imm) then
                  x_rta_require_attribute(curr,er,rta_last);
                  end if;

            -- zřetězení
            when op_concat do
                -- %%LANG Musí být splněno:
                --   -- je-li to přiřazovací operátor a levý operand je
                --      unconstrained typu a není sám o sobě přiřazovací
                --      operátor, pak musí mít atribut :last,
                --   -- levý operand typu unconstrained array musí mít atribut
                --      :last.
                if pexpoper(expr)^.assign and ((el^.ntype<>nt_operator) or not pexpoper(el)^.assign)
                and t_is_sts(el^.t,dts_unconstrained) then
                  x_rta_require_attribute(curr,el,rta_last);
                elsif t_is_stype(el^.t,dt_uarray) then
                  x_rta_require_attribute(curr,el,rta_last);
                  end if;
                --   -- pravý operand typu unconstrained array musí mít atribut
                --      :last.
                if t_is_stype(er^.t,dt_uarray) then
                  x_rta_require_attribute(curr,er,rta_last);
                  end if;

            -- porovnání
            when op_eq, op_ne do
                -- %%LANG Musí být splněno:
                --   -- operand typu unconstrained array musí mít atribut :last
                if t_is_stype(el^.t,dt_uarray) then
                  x_rta_require_attribute(curr,el,rta_last);
                  end if;
                if t_is_stype(er^.t,dt_uarray) then
                  x_rta_require_attribute(curr,er,rta_last);
                  end if;

            -- pro ostatní operandy nejsou dynamické atributy potřeba
            end case;
          end if;

    -- volání procedury
    when nt_call do
        -- %%LANG Pro každý formální parametr, který má nějaké dynamické
        -- atributy, musí skutečný atribut buď též mít tyto dynamické
        -- atributy, nebo musí být staticky vypočítatelné.
        pexplist(expr)^.get(el,arg);
        while arg<>nil loop
          verify({VERIFY=}000854,pentity_param(arg^.sym)^.rta_used-rtattribset:[rta_size,rta_last,rta_tag]<>rtattribset:[]);

          -- :tag
          if (rta_tag in pentity_param(arg^.sym)^.rta_used) and x_rta_is_available(arg^.sub,rta_tag) then
            x_rta_require_attribute(curr,arg^.sub,rta_tag);
            end if;

          -- :size
          if rta_size in pentity_param(arg^.sym)^.rta_used then
            -- má-li :size => použít
            if x_rta_is_available(arg^.sub,rta_size) then
              x_rta_require_attribute(curr,arg^.sub,rta_size);

            -- má-li :last => použít
            elsif x_rta_is_available(arg^.sub,rta_last) then
              x_rta_require_attribute(curr,arg^.sub,rta_last);

            -- má-li tag a je-li constrained typu => použít
            elsif x_rta_is_available(arg^.sub,rta_tag) and t_is_sts(arg^.sub^.t,dts_constrained) then
              x_rta_require_attribute(curr,arg^.sub,rta_tag);

            -- nemá nic => musí být constrained nebo univerzální nebo s utajenou strukturou
            elsif not t_is_sts(arg^.sub^.t,dts_constrained+dts_unitype) and arg^.sub^.t.tview<>tview_partial then
              ce^.seterror({CCERR=}000507,ce_nortattr);
              ce^.setparam(rtattribtxt[rta_size]);
              arg^.sub^.errpos;
              ce^.resumeerror;
              end if;
            end if;

          -- :last
          if rta_last in pentity_param(arg^.sym)^.rta_used then
            -- má-li :last => použít
            if x_rta_is_available(arg^.sub,rta_last) then
              x_rta_require_attribute(curr,arg^.sub,rta_last);

            -- má-li :size => použít
            elsif x_rta_is_available(arg^.sub,rta_size) then
              x_rta_require_attribute(curr,arg^.sub,rta_size);

            -- má-li tag a je-li constrained typu => použít
            elsif x_rta_is_available(arg^.sub,rta_tag) and t_is_sts(arg^.sub^.t,dts_constrained) then
              x_rta_require_attribute(curr,arg^.sub,rta_tag);

            -- nemá nic => musí být constrained nebo univerzální nebo s utajenou strukturou
            elsif not t_is_sts(arg^.sub^.t,dts_constrained+dts_unitype) and arg^.sub^.t.tview<>tview_partial then
              ce^.seterror({CCERR=}000508,ce_nortattr);
              ce^.setparam(rtattribtxt[rta_last]);
              arg^.sub^.errpos;
              ce^.resumeerror;
              end if;
            end if;

          -- další parametr
          arg:=pexpitem(arg^.next);
          end loop;

    -- index pole
    when nt_index do
        -- %%LANG Unconstrained array může (ale nemusí) mít atribut :last,
        -- podle kterého se validuje hodnota indexu.
        if t_is_stype(expr^.sub^.t,dt_uarray) and x_rta_is_available(expr^.sub,rta_last) then
          x_rta_require_attribute(curr,expr^.sub,rta_last);
          end if;

    -- pro ostatní typy uzlů se nic nevynucuje
    end case;
  end x_rta_check_attributes;



----------------------------------------------------------------------------------------------------
procedure x_rta_is_available =
-- True, jestliže zadaný výraz poskytuje uvedený dynamický atribut.
----------------------------------------------------------------------------------------------------
begin
  case rta
    -- :size
    when rta_size do result:=rtattribset:[rta_size,rta_last,rta_tag]*expr^.rta_avail<>rtattribset:[];
                                     {%%X ^^^^^^^ A co unconstrained typy ? To snad nejde, ne ? }
    -- :last
    when rta_last do result:=rtattribset:[rta_size,rta_last]*expr^.rta_avail<>rtattribset:[];

    -- pro ostatní atributy není definována zastupitelnost
    when others do result:=rta in expr^.rta_avail;
    end case;
  end x_rta_is_available;



end cx_rta;
