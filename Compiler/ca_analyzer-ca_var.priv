----------------------------------------------------------------------------------------------------
module private ca_var =
-- Překladač Flexu.
-- Generování výrazů pro inicializaci a finalizaci proměnných.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.11.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_var,
  cc_base,
  cc_base.cc_sym,
  cc_base.cc_type,
  cc_attr,
  cx_expr.cx_make,
  cb_block,
  cb_block.cb_make,
  ca_analyzer.ca_util,
  ca_analyzer.ca_type;

type
  -- operace nad proměnnou (inicializace, volání ENTRY/EXIT)
  ttraceop         = procedure (
      curr         : in tcontext;                -- aktuální kontext  
      list         : in out bllist;              -- kam se budou příkazy ukládat
      binfo        : in out blinfo;              -- kontext
      xinfo        : in out expinfo;             -- kontext
      pvar         : in pentity_var);            -- proměnná
  ptraceop         = ^ttraceop;

----------------------------------------------------------------------------------------------------
procedure list_append (
    list           : in out bllist;              -- kam se budou příkazy ukládat
    bl             : in pblnode) =               -- zařazovaný příkaz
-- Zařadí příkaz BL na konec seznamu příkazů.
----------------------------------------------------------------------------------------------------
begin
  -- zařadit
  if list.first=nil
    then list.first:=bl;
    else list.last^.next:=bl;
    end if;
  list.last:=bl;
  end list_append;



----------------------------------------------------------------------------------------------------
procedure traceop_init : ttraceop =
-- Inicializace proměnné.
----------------------------------------------------------------------------------------------------
var
  x_imm            : pexpimm;                    -- počáteční hodnota proměnné
  ptyp             : pentity_type;               -- typ proměnné
  crange           : texecuterange;              -- rozsah provádění

begin
  -- pro zjednodušení si zjistit typ proměnné
  ptyp:=pvar^.typ.getutype;

  -- je k dispozici inicializační metoda pro tento typ ?
  if ptyp<>nil and then ptyp^.tinit=ti_complex {ptyp^.stable[tst_init].isset and ((ptyp^.stype in dts_component) or (ptyp^.derive=td_private_extension))}

    -- ano => použít
    then
      verify({VERIFY=}000571,not ptyp^.stable[tst_init].isset);

      -- u indexovaného typu zjistime rozsah
      get_index_type_range(curr,xinfo,ptyp,crange);

      -- tohle by se stávat nemělo
      if ptyp^.stype in dts_unconstrained then
        verify({VERIFY=}000739,true);
        end if;

      -- zavolat metodu
      a_list_append(list,
        a_type_make_call(curr,binfo,xinfo,tst_init,ptyp^,crange,
          x_make_component_var(curr,xinfo,pvar)
          )
        );

    -- ne => přímo přiřadit počáteční hodnotu
    else
      -- má proměnná počáteční hodnotu ?
      if pvar^.init.isset then
        x_imm:=x_make_imm(curr,xinfo,pvar^.typ.getutype,pvar^.init.getimm^,iek_imm)

      -- má typ proměnné počáteční hodnotu ?
      elsif pvar^.typ.isset and pvar^.typ.getctype^.init.isset then
        x_imm:=x_make_imm(curr,xinfo,pvar^.typ.getutype,pvar^.typ.getctype^.init.getimm^,iek_imm);

      -- inicializovat na NIL
      else
        x_imm:=x_make_imm_nil(curr,xinfo,pvar^.typ.getutype);
        end if;

      -- PVAR := IMM
      a_list_append(list,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,pvar),
            x_imm
            )
          )
        );
      end if;
  end traceop_init;



----------------------------------------------------------------------------------------------------
procedure tracecheck_init =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, které je třeba
-- inicializovat pomocí TRACEOP_INIT.
----------------------------------------------------------------------------------------------------
begin
  result:=mclass in psym^.tra_var_cache[tst_init];
  end tracecheck_init;



----------------------------------------------------------------------------------------------------
procedure prefix_var : tprefixproc =
-- Generátor prefixu proměnná.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_component_var(curr,xinfo,pentity_var(_data));
  end prefix_var;



----------------------------------------------------------------------------------------------------
procedure traceop_call_special (
    curr           : in tcontext;                -- aktuální kontext   
    list           : in out bllist;              -- kam se budou příkazy ukládat
    binfo          : in blinfo;                  -- kontext
    xinfo          : in expinfo;                 -- kontext
    pvar           : in pentity_var;             -- proměnná
    tst            : in tspectype) =             -- volaná speciální metoda
-- Volání zadané speciální metody
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;               -- typ proměnné
  crange           : texecuterange;              -- rozsah provádění

begin
  -- pro zjednodušení si zjistit typ proměnné
  ptyp:=pvar^.typ.getctype;

  -- není to náhodou rovnou instance třídy ?
  if ptyp^.stype=dt_class

    -- ano => volat přímo požadovanou speciální metodu třídy
    then
      case tst
        when tst_entry    do a_type_class_entry   (curr,^prefix_var,pvar,ptyp,list,binfo,xinfo);
        when tst_exit     do a_type_class_exit    (curr,^prefix_var,pvar,ptyp,list,binfo,xinfo);
        when tst_adjust   do a_type_class_adjust  (curr,^prefix_var,pvar,ptyp,list,binfo,xinfo);
        when tst_rollback do a_type_class_rollback(curr,^prefix_var,pvar,ptyp,list,binfo,xinfo);
        when tst_commit   do a_type_class_commit  (curr,^prefix_var,pvar,ptyp,list,binfo,xinfo);
        when others do verify({VERIFY=}000614,true);
        end case;

    -- ne => volat požadovanou obalující speciální metodu typu
    else
      verify({VERIFY=}000572,not t_contains_class(ptyp^) or not ptyp^.stable[tst].isset);

      -- u indexovaného typu zjistime rozsah
      get_index_type_range(curr,xinfo,ptyp,crange);

      -- tohle by se stávat nemělo
      if ptyp^.stype in dts_unconstrained then
        verify({VERIFY=}000740,true);
        end if;

      -- zavolat metodu
      a_list_append(list,
        a_type_make_call(curr,binfo,xinfo,tst,ptyp^,crange,
          x_make_component_var(curr,xinfo,pvar)
          )
        );
      end if;
  end traceop_call_special;



----------------------------------------------------------------------------------------------------
procedure traceop_entry : ttraceop =
-- Volání ENTRY proměnné.
----------------------------------------------------------------------------------------------------
begin
  -- nereprezentuje náhodou proměnná instanci interfacu ?
  if pvar^.vimplements=vi_interface
    -- instance interfaců se řeší trochu jinak
    then a_type_interface_entry(curr,{^prefix_var,pvar,}pentity_type(pvar^.context.entity)^.interfaces^.find_interface(pvar^.typ.getctype),list,binfo,xinfo);
    -- všechny ostatní případy ošetřit standardním způsobem
    else traceop_call_special(curr,list,binfo,xinfo,pvar,tst_entry);
    end if;
  end traceop_entry;



----------------------------------------------------------------------------------------------------
procedure tracecheck_entry =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, pro které je
-- třeba volat ENTRY pomocí TRACEOP_ENTRY.
----------------------------------------------------------------------------------------------------
begin
  result:=mclass in psym^.tra_var_cache[tst_entry];
  end tracecheck_entry;



----------------------------------------------------------------------------------------------------
procedure traceop_exit : ttraceop =
-- Volání EXIT proměnné.
----------------------------------------------------------------------------------------------------
begin
  -- parametry se (nikdy) neexitují
  if pvar^.vimplements<>vi_parameter then
    traceop_call_special(curr,list,binfo,xinfo,pvar,tst_exit);
    end if;
  end traceop_exit;



----------------------------------------------------------------------------------------------------
procedure tracecheck_exit =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, pro které je
-- třeba volat EXIT pomocí TRACEOP_EXIT.
----------------------------------------------------------------------------------------------------
begin
  result:=mclass in psym^.tra_var_cache[tst_exit];
  end tracecheck_exit;



----------------------------------------------------------------------------------------------------
procedure traceop_adjust : ttraceop =
-- Volání ADJUST proměnné.
----------------------------------------------------------------------------------------------------
begin
  traceop_call_special(curr,list,binfo,xinfo,pvar,tst_adjust);
  end traceop_adjust;



----------------------------------------------------------------------------------------------------
procedure tracecheck_adjust =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, pro které je
-- třeba volat ADJUST pomocí TRACEOP_adjust.
----------------------------------------------------------------------------------------------------
begin
  -- %% podmínka je stejná jako pro entry - je to správně ? 
  result:=mclass in psym^.tra_var_cache[tst_entry];
  end tracecheck_adjust;



----------------------------------------------------------------------------------------------------
procedure traceop_rollback : ttraceop =
-- Volání ROLLBACK proměnné.
----------------------------------------------------------------------------------------------------
begin
  traceop_call_special(curr,list,binfo,xinfo,pvar,tst_rollback);
  end traceop_rollback;



----------------------------------------------------------------------------------------------------
procedure tracecheck_rollback =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, pro které je
-- třeba volat ROLLBACK pomocí TRACEOP_ROLLBACK.
----------------------------------------------------------------------------------------------------
begin
  result:=mclass in psym^.tra_var_cache[tst_rollback];
  end tracecheck_rollback;



----------------------------------------------------------------------------------------------------
procedure traceop_commit : ttraceop =
-- Volání COMMIT proměnné.
----------------------------------------------------------------------------------------------------
begin
  traceop_call_special(curr,list,binfo,xinfo,pvar,tst_commit);
  end traceop_commit;



----------------------------------------------------------------------------------------------------
procedure tracecheck_commit =
-- Kontrola, zda symbol PSYM obsahuje proměnné třídy MCLASS, pro které je
-- třeba volat COMMIT pomocí TRACEOP_COMMIT.
----------------------------------------------------------------------------------------------------
begin
  result:=mclass in psym^.tra_var_cache[tst_commit];
  end tracecheck_commit;



----------------------------------------------------------------------------------------------------
--!!! tohle je uplne blbe, ma to byt jinde
procedure a_init_task_var (
    curr           : in tcontext;                -- kontext
    list           : in out bllist) =            -- kam se budou příkazy ukládat      
-- Volani RTL funkce pro ziskani handle task promenne
----------------------------------------------------------------------------------------------------
with 
  cc_def.cc_unitype,
  cd_decl.cd_create,
  cc_base.cc_attr,
  cc_base.cc_rtl;

var   
  xinfo        : expinfo;
  binfo        : blinfo; 
  entity       : pentity;
  region       : pregion;
  srch         : tentitysearch;
  pproc        : pentity_procedure;
  x_param      : pexpnode;

begin
  entity:=curr.region^.entities.first;
  while entity<>nil loop
    --if entity^.id<>nil then debug_dump('a_init_task_var - '&entityident_to_string(entity^.id^)) end if;
    if entity^.etype=et_var and then pentity_var(entity)^.mclass=mc_task then
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- RTL funkce
      rtl_get_entity(rtl_alloc_task_var_id,pproc);

      -- 1. parametr - 
      srch.find_et_first(pentity_type(pproc^.typ.getctype),rc_primary,et_param,[]);
      x_param:=x_make_param(curr,xinfo,
                 x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag,inttype_tag,
                   x_make_component_type(curr,xinfo,pentity_var(entity)^.typ.getctype)),
                 pentity_param(srch.psym)
                 );

      -- 2. parametr
      srch.find_et_next;
      x_param^.next:=x_make_param(curr,xinfo,
                       x_make_task_var_slot(curr,xinfo,
                         x_make_component_var(curr,xinfo,entity),
                         pentity_param(srch.psym)^.typ.getctype),
                       pentity_param(srch.psym)
                       );

      -- 3. parametr
      srch.find_et_next;
      x_param^.next^.next:=x_make_param(curr,xinfo,
                             x_make_imm_nil(curr,xinfo,pentity_type(srch.psym)),
                             pentity_param(srch.psym)
                             );

      -- 4. parametr
      srch.find_et_next;
      x_param^.next^.next^.next:=x_make_param(curr,xinfo,
                                   x_make_imm_nil(curr,xinfo,pentity_type(srch.psym)),
                                   pentity_param(srch.psym)
                                   );

      -- 5. parametr
      srch.find_et_next;
      x_param^.next^.next^.next^.next:=x_make_param(curr,xinfo,
                                         x_make_imm_nil(curr,xinfo,pentity_type(srch.psym)),
                                         pentity_param(srch.psym)
                                         );

      -- samotny prikaz volani RTL funkce
      a_list_append(list,
        b_make_cmd(curr,binfo,
          x_make_call_rtl(curr,xinfo,rtl_alloc_task_var_id,x_param))
        );
    end if;

  entity:=entity^.next;
  end loop;

  region:=curr.region^.regions.first;
  while region<>nil loop
    -- protrasovat
    a_init_task_var(sym_build_context(curr.entity,region),list);
    -- další region
    region:=region^.next;
    end loop;
  end a_init_task_var;
    


----------------------------------------------------------------------------------------------------
--!!! tohle je uplne blbe, ma to byt jinde
procedure a_exit_task_var (
    curr           : in tcontext;                 -- kontext
    list           : in out bllist) =            -- kam se budou příkazy ukládat      
-- Volani RTL funkce pro uvolneni task promenne
----------------------------------------------------------------------------------------------------
with 
  cc_def.cc_unitype,
  cd_decl.cd_create,
  cc_base.cc_attr,
  cc_base.cc_rtl;

var   
  xinfo        : expinfo;
  binfo        : blinfo; 
  entity       : pentity;
  region       : pregion;
  srch         : tentitysearch;
  pproc        : pentity_procedure;
  x_param      : pexpnode;

begin
  entity:=curr.region^.entities.first;
  while entity<>nil loop
    if entity^.etype=et_var and then pentity_var(entity)^.mclass=mc_task then
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- RTL funkce
      rtl_get_entity(rtl_free_task_var_id,pproc);

      -- parametr
      srch.find_et_first(pentity_type(pproc^.typ.getctype),rc_primary,et_param,[]);
      x_param:=x_make_param(curr,xinfo,
                 x_make_task_var_slot(curr,xinfo,
                   x_make_component_var(curr,xinfo,entity{srch.psym}),
                   pentity_param(srch.psym)^.typ.getctype),
                 pentity_param(srch.psym)
                 );

      -- samotny prikaz volani RTL funkce
      a_list_append(list,
        b_make_cmd(curr,binfo,
          x_make_call_rtl(curr,xinfo,rtl_free_task_var_id,x_param))
        );
    end if;
  entity:=entity^.next;
  end loop;

  region:=curr.region^.regions.first;
  while region<>nil loop
    -- protrasovat
    a_exit_task_var(sym_build_context(curr.entity,region),list);
    -- další region
    region:=region^.next;
    end loop;
  end a_exit_task_var;



----------------------------------------------------------------------------------------------------
procedure trace (
    curr           : in tcontext;                -- aktuální kontext  
    list           : in out bllist;              -- kam se budou příkazy ukládat
    binfo          : in out blinfo;              -- kontext
    xinfo          : in out expinfo;             -- kontext
    mclass         : in memclass;                -- paměťová třída
    recursive      : in t_logical;               -- T-prohledávat rekurzivně
    classonly      : in t_logical;               -- T-pouze proměnné obsahující třídy
    op             : in ptraceop;                -- operace nad proměnnou
    check          : in ptracecheck) =           -- kontrola paměťové třídy
-- Vyhledá v tabulce symbolů všechny proměnné dané paměťové třídy a zavolá
-- na ně metodu OP. Je-li RECURSIVE=True, prohledává i vnořené podprogramy;
-- pro MCLASS=MC_STATIC i vnořené třídy.
----------------------------------------------------------------------------------------------------
use
  ca_analyzer.ca_analyze;

var
  psym             : pentity;                    -- zkoumaná entita
  ptyp             : pentity_type;               -- typ proměnné
  region           : pregion;

begin
  psym:=curr.region^.entities.first;
  while psym<>nil loop
{
    if psym^.etype=et_var then 
      if  pentity_var(psym)^.mclass=mclass then 
        -- a není to parametr (kromě OUT parametrů)
        if (pentity_var(psym)^.pparam=nil or pentity_var(psym)^.pparam^.mode=pm_out) then

          -- a je to třída, je-li tak požadováno
          if (not classonly or (pentity_var(psym)^.typ.isset and t_contains_class(pentity_var(psym)^.typ.getctype^))
                               {(pentity_var(psym)^.typ.isset and (pentity_var(psym)^.typ.getctype^.ptype=et_class))}) then 
            -- a není to symbol generovaný kompilátorem k technických účelům
            if etc_generated not in psym^.compile then psym:=psym end if;
            end if;
          end if;
        end if;
      end if;
}
    -- proměnná požadované paměťové třídy
    if psym^.etype=et_var and then pentity_var(psym)^.mclass=mclass
    -- a není to parametr (kromě OUT parametrů)
    and then (pentity_var(psym)^.vimplements<>vi_parameter or else pentity_var(psym)^.imp_param^.mode=pm_out)
    -- a není to symbol generovaný kompilátorem k technických účelům
    and then etc_generated not in psym^.compile
{
    -- a je to třída, je-li tak požadováno
    and (not classonly or (pentity_var(psym)^.typ.isset and then 
      (t_contains_class(pentity_var(psym)^.typ.getctype^) or (pentity_var(psym)^.typ.getctype^.tinit=ti_complex)))
                         {(pentity_var(psym)^.typ.isset and (pentity_var(psym)^.typ.getctype^.ptype=et_class))})
}
    -- => zkoumat dál
    then
      -- pro zjednodušení zjistit typ proměnné
      ptyp:=pentity_var(psym)^.typ.getutype;
      
      -- analyzovat typ proměnné (kromě tříd)
      if ptyp<>nil then
        if ptyp^.etype=et_type
          then a_type(ptyp);
          else ca_analyzer.ca_analyze.a_entity(ptyp);
          end if;
        end if;

      -- má smysl provádět požadovanou operaci ?
      if not classonly or else (ptyp<>nil and then t_contains_class(ptyp^)) then
        -- provést operaci
        op^(curr,list,binfo,xinfo,pentity_var(psym));
        end if;
      end if;

    -- rekurzivně trasovat podprogramy
    if recursive and ((psym^.etype in ets_subprogram and check^(psym,mclass))
    or (mclass=mc_static and psym^.etype=et_class and check^(psym,mclass))) then
      trace(sym_primary_context(psym^),list,binfo,xinfo,mclass,recursive,classonly,op,check);
      end if;

    -- další symbol
    psym:=psym^.next;
{
    -- další symbol
    if recursive and (((psym^.etype in ets_subprogram) and check^(psym,mclass))
    or ((mclass=mc_static) and (psym^.etype=et_class) and check^(psym,mclass)))

      -- rekurzivně trasovat podprogramy
      then psym:=psym^.regions.std_region.entities.first

      -- další symbol nebo návrat na předchozí úroveň
      else
        while (psym^.next=nil) and (psym^.context.entity<>^curr) loop psym:=psym^.context.entity; end loop;
        psym:=psym^.next;
        end if;
}
    end loop;

  -- trasovat vnořené regiony
  if recursive then
    region:=curr.region^.regions.first;
    while region<>nil loop
      -- protrasovat
      trace(sym_build_context(curr.entity,region),list,binfo,xinfo,mclass,recursive,classonly,op,check);
      
      -- další region
      region:=region^.next;
      end loop;
    end if;
  end trace;



----------------------------------------------------------------------------------------------------
procedure a_var_init =
-- Vygeneruje příkazy pro inicializaci proměnných.
-- Je-li CLASSONLY=True, inicializuje pouze instance tříd (například při
-- MCLASS=MC_STATIC jsou ostatní proměnné inicializované loaderem).
----------------------------------------------------------------------------------------------------
begin
  -- task proměnná ?
  --!!! tohle je uplne blbe, ma to byt jinde
  if mclass=mc_task then
    a_init_task_var(curr,list);
    end if;

  trace(curr,list,binfo,xinfo,mclass,recursive,classonly,^traceop_init,^tracecheck_init);
  end a_var_init;



----------------------------------------------------------------------------------------------------
procedure a_var_entry =
-- Vygeneruje příkazy na volání ENTRY proměnných.
----------------------------------------------------------------------------------------------------
begin
  trace(curr,list,binfo,xinfo,mclass,recursive,true,^traceop_entry,^tracecheck_entry);
  end a_var_entry;



----------------------------------------------------------------------------------------------------
procedure a_var_exit =
-- Vygeneruje příkazy na volání EXIT proměnných.
----------------------------------------------------------------------------------------------------
begin
  -- task proměnná ?
  --!!! tohle je uplne blbe, ma to byt jinde
  if mclass=mc_task then
    a_exit_task_var(curr,list)
    end if;

  trace(curr,list,binfo,xinfo,mclass,recursive,true,^traceop_exit,^tracecheck_exit);
  end a_var_exit;



----------------------------------------------------------------------------------------------------
procedure a_var_adjust =
-- Vygeneruje příkazy na volání ADJUST proměnných.
----------------------------------------------------------------------------------------------------
begin
  trace(curr,list,binfo,xinfo,mclass,recursive,true,^traceop_adjust,^tracecheck_adjust);
  end a_var_adjust;



----------------------------------------------------------------------------------------------------
procedure a_var_rollback =
-- Vygeneruje příkazy na volání rollback proměnných.
----------------------------------------------------------------------------------------------------
begin
  trace(curr,list,binfo,xinfo,mclass,recursive,true,^traceop_rollback,^tracecheck_rollback);
  end a_var_rollback;



----------------------------------------------------------------------------------------------------
procedure a_var_commit =
-- Vygeneruje příkazy na volání ADJUST proměnných.
----------------------------------------------------------------------------------------------------
begin
  trace(curr,list,binfo,xinfo,mclass,recursive,true,^traceop_commit,^tracecheck_rollback);
  end a_var_commit;




end ca_var;
