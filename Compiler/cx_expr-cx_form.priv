----------------------------------------------------------------------------------------------------
module private cx_form =
-- Překladač Flexu.
-- Formální analýza výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 29.08.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_lexsym,cc_sym,
  cd_decl,cd_decl.cd_unit,
  cx_util,cx_rta;


----------------------------------------------------------------------------------------------------
procedure a_form_imm (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpimm;             -- výraz
    info           : in expinfo);                -- informace o průběhu analýzy
-- Formální kontrola přímé hodnoty.
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
procedure checkeval (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- související výraz
    srch           : in out tentitysearch;       -- vyhledaný kontrolovaný symbol
    id             : in pentityident;            -- identifikátor symbolu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Kontrola vyhodnocení symbolu. Nevyhodnocený symbol se pokusí vyhodnotit
-- alespoň do úrovně deklarace symbolu.
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

begin
  -- entita není k dispozici, ale ona se měla nalézt => je to chyba
  if srch.psym=nil then
    declare var
      undef         : pentity;               -- zástupce za nedefinovanou entitu
      undef_context : tcontext;              -- kontext zástupce za nedefinovanou entitu

    begin
      -- ohlásit chybu
      ce^.seterror({CCERR=}000429,ce_undeclared);
      ce^.setparam(entityident_to_string(id^));
      expr^.errpos;

      -- založit symbol typu ET_UNDEF coby prostředek zotavení z chyby
      d_create_internal(curr,undef,undef_context,et_undef,id);
      d_end_internal(undef^,false);

      -- nastavit jako výsledek 
      srch.set_entity(undef);

      -- poslat chybu výš
      ce^.resumeerror;
      end declare;
    end if;
  end checkeval;



----------------------------------------------------------------------------------------------------
procedure checkclass (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- související výraz
    nclass         : in nodeclassset;            -- povolené třídy operandu
    code           : in terrorcode;              -- kód chyby
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Kontrola třídy podvýrazu.
----------------------------------------------------------------------------------------------------
begin
  if expr^.nclass not in nclass then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000430,code);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checkclass;



----------------------------------------------------------------------------------------------------
procedure checksts (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- související výraz
    sts            : in tdatatypeset;            -- povolené typy operandu
    code           : in terrorcode;              -- kód chyby
    hint           : in t_char32ustr;            -- hint
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Kontrola typu podvýrazu.
----------------------------------------------------------------------------------------------------
begin
  if not t_is_sts(expr^.t,sts) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000431,code);
    ce^.setinfo(hint);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checksts;



----------------------------------------------------------------------------------------------------
procedure checkview (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- související výraz
    tview          : in ttypeviewset;            -- povolené pohledy na typ operandu
    code           : in terrorcode;              -- kód chyby
    hint           : in t_char32ustr;            -- hint
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Kontrola pohledu na typ podvýrazu.
----------------------------------------------------------------------------------------------------
begin
  if expr^.t.tview not in tview then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000432,code);
    ce^.setinfo(hint);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checkview;



----------------------------------------------------------------------------------------------------
procedure checkresolve (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Je-li to potřeba, tak vyhodnotí nejednoznačný výraz.
----------------------------------------------------------------------------------------------------
with
  cx_resolve;
  
begin
  if expr^.ntype in nts_ambiguous then
    a_resolve(curr,pexpambiguous(expr),ptyp,info);
    end if;
  end checkresolve;



------------------------------------------------------------------------------------------------
procedure check_aliased (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpnode;                -- obalující výraz
    sub            : in pexpnode) =              -- kontrolovaný podvýraz
-- Kontrola, zda je povolen ALIASED přístup k podvýrazu.
-- V případech, jako je přetypování, volá rekurzivně samo sebe.
------------------------------------------------------------------------------------------------
begin
  case sub^.ntype
    -- komponenta
    when nt_component do
        verify({VERIFY=}000834,sub^.getsymbol=nil or else sub^.getsymbol^.etype<>et_var);
        
        -- na proměnnou lze získat referenci jen tehdy, je-li aliased
        if not pentity_var(sub^.getsymbol)^.valiased then
          ce^.seterror({CCERR=}000433,ce_i_reference);
          expr^.errpos;
          ce^.resumeerror;
          end if;

    -- index pole nebo řetězce
    when nt_index do
        -- na složku pole nebo řetězce lze získat referenci jen tehdy, je-li aliased
        if not sub^.sub^.t.getctype^.saliased then
          ce^.seterror({CCERR=}000434,ce_i_reference);
          expr^.errpos;
          ce^.resumeerror;
          end if;

    -- dereference
    when nt_deref do 
        -- nic nedělat, reference je inverze dereference

    -- přetypování 
    when nt_typecast do 
        check_aliased(curr,expr,sub^.sub^.next^.sub);

    -- interface cast
    when nt_interface_cast do 
        -- nic nedělat, reference je vždy dovolena

    -- THIS
    when nt_this do 
        -- nic nedělat, reference je vždy dovolena

    -- atribut
    when nt_attrib do
        check_aliased(curr,expr,sub^.sub);

      { Aha, a co takové věci jako :unchechek, že?
        -- nelze získat referenci na atribut, a to ani na dynamický, protože obecně
        -- může být vypočtený
        ce^.seterror({CCERR=}000435,ce_i_reference);
        expr^.errpos;
        ce^.resumeerror;
      }
{
    -- volání procedury resp. její návratová hodnota
    when nt_call do

    --
    when nt_operator, nt_unary do
}
    -- pro ostatní případy nemá reference smysl
    -- %%TECH Až to tady zdechne na interní chybu, tak viz též poznámka na konci [a_form_call]
    -- ve výpočtu třídy uzlu.
    when others do verify({VERIFY=}000704,true);
    end case;
  end check_aliased;



----- %%TECH ---------------------------------------------------------------------------------------
-- Pravidla typové kompatibility jsou popsána rozhodovací funkcí
--     t : <operátor, datový typ, datový typ> -> <akce>
-- která pro trojici operátor, typ levého operandu, typ pravého operandu
-- zvolí akci, která se má nad operátorem provést, nebo vrátí chybu
-- (v takovém případě jsou operandy nekompatibilní).
--
-- Postup při přidávání nových akcí:
--   1. do TOPERACTION přidat identifikátor (dále odkazovaný jako xxx)
--   2. do procedury INITOPERTAB doplnit související pravidla
--   3. obsluhu akce dát do A_TYPE_OPERATOR
----------------------------------------------------------------------------------------------------

type
  -- akce
  tunaryaction  = enum
      una_error;                                 -- nekompatibilní operandy
      una_el;                                    -- převzít typ levého podvýrazu
      end enum;

  -- řídící tabulka typové kontroly binárních operátorů
  tunarytab        = array expunarytype,tdatatype of tunaryaction;

var
  unarytab         : tunarytab;

----------------------------------------------------------------------------------------------------
procedure uset11 (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytype;            -- operátor
    stype          : in tdatatype;               -- typ výrazu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=action;
  end uset11;



----------------------------------------------------------------------------------------------------
procedure usetss (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytypeset;         -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expunarytype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=action;
          end if;
        end loop;
      end if;
    end loop;
  end usetss;



----------------------------------------------------------------------------------------------------
procedure uset1s (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytype;            -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=action;
      end if;
    end loop;
  end uset1s;



----------------------------------------------------------------------------------------------------
procedure usets1 (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytypeset;         -- operátor
    stype          : in tdatatype;               -- typ výrazu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expunarytype loop
    if i in op then
      tab[i,stype]:=action;
      end if;
    end loop;
  end usets1;



----------------------------------------------------------------------------------------------------
procedure initunarytab =
-- Inicializace řídící tabulky typové kontroly unárních operátorů.
----------------------------------------------------------------------------------------------------
begin
  ---- + ----
  uset1s(unarytab,un_plus          ,dts_u_numeric,una_el);

  ---- - ----
  uset11(unarytab,un_minus         ,dt_signed    ,una_el);
  uset11(unarytab,un_minus         ,dt_uniint    ,una_el);
  uset1s(unarytab,un_minus         ,dts_u_float  ,una_el);

  ---- NOT ----
  uset1s(unarytab,un_not           ,dts_u_logical,una_el);

  ---- BIT NOT ----
  uset11(unarytab,un_bitnot        ,dt_unsigned  ,una_el);
  uset11(unarytab,un_bitnot        ,dt_uniint    ,una_el);

  ---- SET NOT ----
  uset11(unarytab,un_setnot        ,dt_set       ,una_el);

  ---- ABS ----
  uset11(unarytab,un_abs           ,dt_signed    ,una_el);
  uset11(unarytab,un_abs           ,dt_uniint    ,una_el);
  uset1s(unarytab,un_abs           ,dts_u_float  ,una_el);

  ---- SUCC/PRED ----
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_integer,una_el);
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_char   ,una_el);
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_logical,una_el);
  usets1(unarytab,expunarytypeset:[un_succ,un_pred],dt_enum      ,una_el);
  end initunarytab;



----------------------------------------------------------------------------------------------------
procedure checkparam (
    curr           : in tcontext;                -- překládaný prvek
    param          : in pentity_param;           -- formální parametr
    expr           : in pexpnode;                -- skutečný parametr
    typ            : in typeview;                -- typ výrazu
    ok             : out t_logical) =            -- T-parametry si odpovídají
-- Kontrola formálního a skutečného parametru přetížené procedury.
----------------------------------------------------------------------------------------------------
var
  argt             : typeview;                   -- typ argumentu
  oclass           : toperclass;                 -- třída operace předání parametru

begin
  -- předpoklad: nedopadne to dobře
  ok:=false;

  -- ověřit třídu výrazu
  case param^.pass
    -- hodnotou nebo referencí
    when pp_value, pp_ref do
        case param^.mode
          -- IN => hodnota
          when pm_in            do 
              -- podvýraz musí být hodnota
              -- %%X nebo typ, když je to tag!
              if expr^.nclass not in ncs_value then return; end if;

              -- předání obyčeného IN parametru
              oclass:=toc_param_in;

          -- [ IN ] OUT => proměnná
          when pm_out, pm_inout do 
              -- podvýraz musí být proměnná
              if expr^.nclass not in ncs_var then return; end if;

              -- předání obyčejného OUT parametru
              oclass:=toc_param_out;

          when others   do verify({VERIFY=}000294,true);
          end case;

    -- referencí, bez typové kontroly
    when pp_unchecked do 
        -- podvýraz musí být proměnná
        if expr^.nclass not in ncs_var then return; end if;

        -- předání UNCHECKED parametru
        oclass:=toc_param_unchecked;

    -- referencí, včetně odvozených typů
    when pp_class     do
        -- podvýraz musí být proměnná
        if expr^.nclass not in ncs_var then return; end if;

        -- předání CLASS nebo VIRTUAL parametru
        oclass:=toc_param_class;

    -- referencí, řídící parametr virtuálního volání
    when pp_virtual   do 
        -- podvýraz musí být proměnná
        if expr^.nclass not in ncs_var then return; end if;

        -- předání CLASS nebo VIRTUAL parametru
        oclass:=toc_param_class;

    when others do verify({VERIFY=}000835,true);
    end case;

  -- ověřit kompatibilitu typů
  verify({VERIFY=}000293,param^.pass=pp_unchecked);
  argt.init(curr,param^.typ.getctype);
  if t_get_compatibility_level(curr,toc_param_class{oclass},false,argt,typ)<tcl_static_identical then return; end if;

  -- OK, kompatibilní
  ok:=true;

catch
  when others do
      expr^.errpos;
      raise;
  end checkparam;



----------------------------------------------------------------------------------------------------
procedure a_form_operator (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola operátoru.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý a pravý podvýraz
  er               : pexpnode;                   -- levý a pravý podvýraz
  elt              : ptypeview;                  -- typy podvýrazů
  ert              : ptypeview;                  -- typy podvýrazů
  rest             : typeview;                   -- typ výsledku
  level            : tcomplevel;                 -- úroveň kompatibility operandů
  restype          : tresulttype;                -- typ výsledku
  lop              : expopertype;                -- jazykem definovaný operátor
  oop              : tooperator;                 -- přetížitelný operátor
  srch             : tentitysearch;              -- hledátko
  srchparam        : tentitysearch;              -- hledátko parametrů                          
  param            : pentity_param;              -- formální parametr                           
  pdesc            : poverloaddesc;              -- pro zjednodušení: popis přetížené procedury 
  pproc            : pentity_subprogram;         -- pro zjednodušení: přetížená procedura       
  ptyp             : pentity_type;               -- pro zjednodušení: typ procedury (operátoru) 
  ok               : t_logical;                  -- T-skutečný a formální parametr si odpovídají
  ui               : tuniint;

begin
  -- rozdělit podvýrazy 
  expr^.split(el,er);

  -- formální kontrola levého podvýrazu 
  a_form(curr,el,info);

  -- formální kontrola pravého podvýrazu 
  a_form(curr,er,info);

  -- sloučit 
  expr^.join(el,er);

  -- povedla se formální kontrola podvýrazů 
  if (el^.zprac<>ep_form) or (er^.zprac<>ep_form) then return; end if;

  -- speciální případ: porovnání typů 
  if (el^.nclass=nc_type) and (er^.nclass=nc_type) then
    unimplementedx({UNIMP=}000078,el^.pos);
{
  -- speciální případ: operátory IN a NOT IN 
  elsif expr^.oper in [op_in,op_notin] then
    unimplemented({UNIMP=}000230);
}
  -- speciální případ: Výraz IN Konstruktor rozsahu 
  elsif (expr^.oper in expopertypeset:[op_in,op_notin]) and (er^.nclass=nc_composite) then
    unimplementedx({UNIMP=}000231,expr^.pos);

  -- speciální případ: Výraz IN Jméno typu
  elsif (expr^.oper in expopertypeset:[op_in,op_notin]) and (er^.nclass=nc_type) then
    unimplementedx({UNIMP=}000080,expr^.pos);

  -- všechny ostatní případy 
  else
    -- podvýrazy musí být hodnoty 
    checkclass(curr,el,ncs_value,ce_i_expr,info);
    checkclass(curr,er,ncs_value,ce_i_expr,info);

    ----- %%X Optimalizace vyhledávání přetížených operátorů -------------
    -- 1. Při deklaraci operátoru se do typu poznamená, že k němu existuje
    --    přetížený operátor a vyhledávat se bude jen pro takové operandy,    
    --    které mají univerzální typy, nebo typy s možným přetížením.         
    -- 2. Kromě ukládání do tabulky symbolů zavést v každém symbolu ještě     
    --    speciální tabulku operátorů a odkazy na všechny dále viditelné      
    --    podobné tabulky (v nadřazených symbolech nebo přes WITH/USE).       
    ----------------------------------------------------------------------

    -- zjistit si odpovídající přetížitelný operátor 
    oop:=expoperinfo[expr^.oper].oop;

    -- iterace přes všechny dvojice typů podvýrazů 
    for eli in 0..el^.gettypecount-1 loop
      for eri in 0..er^.gettypecount-1 loop
        -- typy 
        el^.gettype(eli,elt);
        er^.gettype(eri,ert);

        -- upřesnit operátor 
        x_refine_binary(expr^.oper,elt^,ert^,lop);

        -- zkusit jazykem definovaný operátor 
        t_typecheck(curr,expoperinfo[lop].oc,expr^.assign,elt^,ert^,level,restype);
        if level<>tcl_incompatible then
          -- typ výsledku 
          case restype
            -- nic 
            when trt_none       do expr^.addtype(nulltype,eli,eri,nil);

            -- typ levého operandu (T1)
            when trt_left       do expr^.addtype(elt^,eli,eri,nil);

            -- typ pravého operandu (T2)
            when trt_right      do expr^.addtype(ert^,eli,eri,nil);

            -- rozhodnout mezi T1 a T2
            when trt_resolve    do
                x_resolve(elt^,ert^,false,rest);
                expr^.addtype(rest,eli,eri,nil);
          {
            -- odvodit constrained string
            when trt_string    do
                -- vypočítat el:length+er:length
                ui:=elt^.getrange(curr).gethval+ert^.getrange(curr).gethval;

                -- odvodit typ
                t_derive_string(curr,ui,elt^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);

            -- odvodit constrained string z levého operandu
            when trt_string_el1 do
                -- vypočítat el:length+1
                ui:=elt^.getrange(curr).gethval+ui_1;

                -- odvodit typ
                t_derive_string(curr,ui,elt^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);

            -- odvodit constrained string z pravého operandu
            when trt_string_er1 do
                -- vypočítat er:length+1
                ui:=ert^.getrange(curr).gethval+ui_1;

                -- odvodit typ
                t_derive_string(curr,ui,ert^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);
          }
            -- univerzální real
            when trt_unireal    do
                rest.init(curr,def_unireal);
                expr^.addtype(rest,eli,eri,nil);

            -- univerzální logical
            when trt_unilogical do
                rest.init(curr,def_unilogical);
                expr^.addtype(rest,eli,eri,nil);

            when others do verify({VERIFY=}000221,true);
            end case;
          end if;

        -- hledat přetížený operátor (je-li to přetížitelný operátor... 
        if (oop<>oop_none)
        -- ... a alespoň jeden operand je neuniverzálního typu) 
        and not (t_is_sts(elt^,dts_unitype) and t_is_sts(ert^,dts_unitype)) then
          -- %%X Tenhle algoritmus je až na drobnosti stejný, 
          -- jako v A_FORM_UNARY. Nešlo by to zobecnit ?     

          -- prohledat všechny přetížené operátory
          srch.find_id_first(curr,^ooperinfo[oop].txt);
          while srch.psym<>nil loop

            -- prohledat všechny přetížené procedury 
            for i in pentity_overload(srch.psym)^.table^:range loop
              -- popis přetížené procedury 
              pdesc:=^pentity_overload(srch.psym)^.table^[i];

              -- zajímají nás jen binární (ne)přiřazovací operátory 
              if pdesc^.arity=toa_binary and pdesc^.assign=expr^.assign then
                -- přetížená procedura 
                pproc:=pentity_subprogram(pdesc^.psym.getcentity);

                -- nebyla již procedura jednou úspěšně zpracována ? 
                if not expr^.checktype(pproc) then

                  -- typ procedury 
                  ptyp:=pproc^.typ.getctype;

                  -- kontrola prvního parametru 
                  srchparam.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
                  verify({VERIFY=}000836,srchparam.psym=nil);
                  checkparam(curr,pentity_param(srchparam.psym),el,elt^,ok);

                  -- první parametr odpovídá, OK zkusit další 
                  if ok then
                    -- kontrola druhého parametru 
                    srchparam.find_et_next;
                    verify({VERIFY=}000291,srchparam.psym=nil);
                    checkparam(curr,pentity_param(srchparam.psym),er,ert^,ok);

                    -- druhý parametr též odpovídá, OK zařadit na seznam 
                    if ok then
                      if expr^.assign

                        -- zkrácené přiřazení => výsledek má typ levého op. 
                        then expr^.addtype(elt^,eli,eri,pproc)

                        -- normální operátor => výsledek podle operátoru 
                        else
                          -- sestavit pohled na výsledek 
                          rest.init(curr,ptyp^.result^.typ.getctype);

                          -- parametry si odpovídají, zařadit další možný typ uzlu 
                          expr^.addtype(rest,eli,eri,pproc);
                          end if;
                      end if;
                    end if;
                  end if;
                end if;
              end loop;

            -- zkusit další operátor 
            srch.find_id_next;
            end loop;
          end if;
        end loop;
      end loop;

    -- nalezl se alespoň jeden typ ? 
    if expr^.gettypecount=0 then
      {%%X zpřesnit chybové hlášení }
      ce^.seterror({CCERR=}000436,ce_incompatible);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;}
      ce^.resumeerror;
      end if;

    -- třída uzlu: hodnota 
    expr^.nclass:=nc_value;
    end if;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_operator;



----------------------------------------------------------------------------------------------------
procedure a_form_unary (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpunary;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola unárního operátoru.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý a pravý podvýraz
  elt              : ptypeview;                  -- typy podvýrazů
  rest             : typeview;                   -- typ výsledku
  lop              : expunarytype;               -- jazykem definovaný operátor                 
  oop              : tooperator;                 -- přetížitelný operátor                       
  srch             : tentitysearch;              -- hledátko
  srchparam        : tentitysearch;              -- hledátko parametrů                          
  param            : pentity_param;              -- formální parametr                           
  pdesc            : poverloaddesc;              -- pro zjednodušení: popis přetížené procedury 
  pproc            : pentity_subprogram;         -- pro zjednodušení: přetížená procedura       
  ptyp             : pentity_type;               -- pro zjednodušení: typ procedury (operátoru) 
  ok               : t_logical;                  -- T-skutečný a formální parametr si odpovídají

begin
  -- rozdělit podvýraz 
  expr^.split(el);

  -- formální kontrola podvýrazu 
  a_form(curr,el,info);

  -- sloučit 
  expr^.join(el);

  -- povedla se formální kontrola podvýrazů 
  if el^.zprac<>ep_form then return; end if;

  -- podvýraz musí být hodnota 
  checkclass(curr,el,ncs_value,ce_i_expr,info);

  -- zjistit si odpovídající přetížitelný operátor 
  oop:=expunaryinfo[expr^.oper].oop;

  -- iterace přes všechny typy podvýrazu 
  for eli in 0..el^.gettypecount-1 loop
    -- typ 
    el^.gettype(eli,elt);

    -- zkusit jazykem definovaný operátor 
    if t_is_sts(elt^,dts_all-dts_special) then
      -- upřesnit operátor 
      x_refine_unary(expr^.oper,elt^,lop);

      -- typová kontrola 
      case unarytab[lop,elt^.stype]
        -- chyba
        when una_error  do ;

        -- zvolit typ levého podvýrazu
        when una_el     do expr^.addtype(elt^,eli,0,nil);

        when others     do verify({VERIFY=}000837,true);
        end case;
      end if;

    -- hledat přetížený operátor (je-li to přetížitelný operátor... 
    if (oop<>oop_none)
    -- ... a operand je neuniverzálního typu) 
    and not t_is_sts(elt^,dts_unitype) then
      -- %%X Tenhle algoritmus je až na drobnosti stejný,
      -- jako v A_FORM_OPERATOR. Nešlo by to zobecnit ?  

      -- prohledat všechny přetížené operátory 
      srch.find_id_first(curr,^ooperinfo[oop].txt);
      while srch.psym<>nil loop

        -- prohledat všechny přetížené procedury 
        for i in pentity_overload(srch.psym)^.table^:range loop
          -- popis přetížené procedury 
          pdesc:=^pentity_overload(srch.psym)^.table^[i];

          -- zajímají nás jen binární (ne)přiřazovací operátory 
          if (pdesc^.arity=toa_unary) and (pdesc^.assign=expr^.assign) then
            -- přetížená procedura 
            pproc:=pentity_subprogram(pdesc^.psym.getcentity);

            -- typ procedury 
            ptyp:=pproc^.typ.getctype;

            -- kontrola prvního parametru 
            srchparam.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
            verify({VERIFY=}000838,srchparam.psym=nil);
            checkparam(curr,pentity_param(srchparam.psym),el,elt^,ok);

            -- první parametr odpovídá, OK zařadit na seznam 
            if ok then
              if expr^.assign

                -- zkrácené přiřazení => výsledek má typ levého op. 
                then expr^.addtype(elt^,eli,0,pproc)

                -- normální operátor => výsledek podle operátoru 
                else
                  -- sestavit pohled na výsledek 
                  rest.init(curr,ptyp^.result^.typ.getctype);

                  -- parametry si odpovídají, zařadit další možný typ uzlu 
                  expr^.addtype(rest,eli,0,pproc);
                  end if;
              end if;
            end if;
          end loop;

        -- zkusit další operátor 
        srch.find_id_next;
        end loop;
      end if;
    end loop;

  -- nalezl se alespoň jeden typ ? 
  if expr^.gettypecount=0 then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000437,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

{ Stará verze bez přetížení:

  -- podvýraz musí být hodnota 
  checkclass(curr,el,ncs_value,ce_i_expr,info);

  -- a musí mít typ 
  checksts(curr,el,dts_all-dts_special,ce_i_expr,'',info);

  -- změnit operand NOT --> BIT_NOT/SET_NOT 
  if expr^.oper=un_not then
    if t_is_sts(el^.t,dts_u_integer)  then x_setbitop(expr)
    elsif t_is_sts(el^.t,dts_u_set) then x_setsetop(expr); end if;
    end if;

  -- typová kontrola 
  case unarytab[expr^.oper,el^.t.stype]
    -- chyba
    when una_error do
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000438,ce_incompatible);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end;

    -- zvolit typ levého podvýrazu
    when una_el do expr^.t:=el^.t;

    when others do verify({VERIFY=}000839,true);
    end case;
}
  -- třída uzlu: hodnota 
  expr^.nclass:=nc_value;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_unary;



----------------------------------------------------------------------------------------------------
procedure a_form_param (
    curr           : in tcontext;                -- překládaný prvek
    arg            : in out pexpitem;            -- skutečný parametr
    param          : in pentity_param;           -- formální parametr
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola skutečného parametru procedury.                          
----------------------------------------------------------------------------------------------------
begin
  --verify({VERIFY=}000701,arg^.itype not in expitemtypeset:[ei_expr,ei_ident]);

  -- podvýraz musí mít jednoznačný typ 
  if param^.pass=pp_unchecked
    then checkresolve(curr,arg^.sub,nulltype,info)
    else checkresolve(curr,arg^.sub,arg^.t,info);
    end if;

  -- kontrola třídy podvýrazu a kompatibility typů v závislosti na způsobu předání parametru
  case param^.pass
    -- hodnotou nebo referencí
    when pp_value, pp_ref do
        case param^.mode
          -- IN
          when pm_in do
              -- podvýraz musí být hodnota
              checkclass(curr,arg^.sub,ncs_value,ce_i_expr,info);

              -- typy musí být kompatibilní
              if not t_compatible(curr,toc_param_in,false,arg^.t,arg^.sub^.t) then
                {%%X zpřesnit chybové hlášení }
                ce^.seterror({CCERR=}000439,ce_incompatible);
                arg^.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

          -- [ IN ] OUT
          when pm_out,pm_inout do
              -- podvýraz musí být proměnná
              checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

              -- typy musí být kompatibilní
              if not t_compatible(curr,toc_param_out,false,arg^.t,arg^.sub^.t) then
                {%%X zpřesnit chybové hlášení }
                ce^.seterror({CCERR=}000440,ce_incompatible);
                arg^.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;
              --u_nimplemented(13);

          when others do verify({VERIFY=}000292,true);
          end case;

    -- referencí, bez typové kontroly
    when pp_unchecked do
        -- podvýraz musí být proměnná
        checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

        -- typy musí být kompatibilní
        if not t_compatible(curr,toc_param_unchecked,false,arg^.t,arg^.sub^.t) then
          {%%X zpřesnit chybové hlášení }
          ce^.seterror({CCERR=}000441,ce_incompatible);
          arg^.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;
{
        -- %%X Doplnit kontrolu násobku velikostu pro unconstrained array
        -- a unconstrained string a dynamické kontroly

        -- má formální parametr typ ?
        if arg^.t.hassize

          -- má => skutečný parametr musí mít stejnou velikost
          then
            -- %%X u_nimplemented(14);

          -- nemá => na typu skutečného parametru nezáleží
          else
            { nic nedělat };
            end if;
}
    -- referencí, včetně odvozených typů
    when pp_class     do
        -- podvýraz musí být proměnná
        checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

        -- typy musí být kompatibilní
        if not t_compatible(curr,toc_param_class,false,arg^.t,arg^.sub^.t) then
          {%%X zpřesnit chybové hlášení }
          ce^.seterror({CCERR=}000442,ce_incompatible);
          arg^.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;
        --u_nimplemented(72);

    -- referencí, řídící parametr virtuálního volání
    when pp_virtual   do unimplemented({UNIMP=}000081);

    when others do verify({VERIFY=}000059,true);
    end case;
{
  -- kontrola aliased přístupu pro aliased parametry
  if param^.paliased then
    check_aliased(curr,arg,arg^.sub);
    end if;
}
  end a_form_param;



----------------------------------------------------------------------------------------------------
procedure a_form_call (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola volání procedury.
----------------------------------------------------------------------------------------------------
var
  proc             : pentity_type;               -- typ procedury

begin
  ----- %%LANG Pořadí vyhodnocování parametrů ------------------------------------------------------
  -- Poziční parametry se vyhodnocují zleva doprava. Klíčové parametry nemají přesné pořadí
  -- vyhodnocování definováno - kompilátor si je může přeskládat tak, jak se mu budou nejlépe
  -- ukládat na stack.
  --------------------------------------------------------------------------------------------------

  ----- %%TECH Přerovnání skutečných parametrů -----------------------------------------------------
  -- Překladač přerovnává skutečné parametry podle pořadí deklarace formálních parametrů, a to
  -- včetně klíčových parametrů. Při generování kódu se volí směr zpracování parametrů (zleva
  -- doprava nebo naopak) podle volací konvence.
  --------------------------------------------------------------------------------------------------

  -- typ procedury 
  proc:=expr^.sub^.t.getutype;



  ----- Zpracovat všechny formální parametry procedury ---------------------------------------------
  declare var
    el                : pexpnode;                -- jméno procedury
    org_arglist       : pexpitem;                -- původní seznam skutečných parametrů
    new_arglist_first : pexpitem;                -- setříděný seznam skutečných parametrů
    new_arglist_last  : pexpitem;                -- setříděný seznam skutečných parametrů
    arg               : pexpitem;                -- jeden skutečný parametr procedury
    param             : pentity_param;           -- formální parametry procedury
    param_srch        : tentitysearch;           -- vyhledávátko 

      ----------------------------------------------------------------------------------------------
      procedure param_available return t_logical =
      -- True, je-li k dispozici nějaký formální parametr a zároveň to není parametr reprezentující
      -- návratovou hodnotu.
      ----------------------------------------------------------------------------------------------
      begin
        result:=param_srch.psym<>nil and then param_srch.psym<>proc^.result;
        end param_available;


  
      ----------------------------------------------------------------------------------------------
      procedure get_actual_arg =
      -- Oddělí první skutečný parametr ze seznamu skutečných parametrů [org_arglist] do [arg].
      ----------------------------------------------------------------------------------------------
      begin
        arg:=org_arglist;
        org_arglist:=org_arglist^.next;
        arg^.next:=nil;
        end get_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure find_actual_arg (
          id       : in tentityident) =
      -- Nalezne skutečný parametr [arg] podle identifikátoru mezi klíčovými parametry na seznamu
      -- skutečných parametrů [org_arglist]. Nalezený parametr ze seznamu odstraní. Pokud nic
      -- nenajde, vrátí v [arg] nil a seznam nemění.
      ----------------------------------------------------------------------------------------------
      var
        parg       : pexpitem;                   -- předchozí skutečný parametr na seznamu

      begin
        -- najít parametr podle identifikátoru 
        parg:=nil;
        arg:=org_arglist;
        while arg<>nil loop
          verify({VERIFY=}000840,arg^.itype<>ei_ident);

          -- je to on ?
          if arg^.id^=id then break end if;

          -- zkusit další
          parg:=arg;
          arg:=arg^.next;
          end loop;

        -- našlo-li se, vyřadit ze seznamu
        if arg<>nil then
          if parg<>nil
            then parg^.next:=arg^.next
            else org_arglist:=arg^.next
            end if;
          end if;
        end find_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure put_actual_arg =
      -- Umístí právě zpracovávaný skutečný parametr [arg] do nového seznamu skutečných parametrů 
      -- [new_arglist].
      ----------------------------------------------------------------------------------------------
      begin
        -- pokud dojde k chybě při používání implicitní hodnoty, 
        -- nemusí být skutečný parametr vůbec znám
        if arg=nil then return end if;

        -- převzít příznak zpracování
        if not arg^.erroneous and (arg^.sub=nil or else arg^.sub^.zprac>=ep_form) then
          arg^.zprac:=ep_form;
          end if;

        -- zařadit na seznam
        if new_arglist_last<>nil
          then new_arglist_last^.next:=arg
          else new_arglist_first:=arg
          end if;
        new_arglist_last:=arg;
        end put_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure pair_args =
      -- Spáruje skutečný parametr [arg] s formálním parametrem [param].
      ----------------------------------------------------------------------------------------------
      begin
        -- ke skutečnému parametru přiřadit formální parametr, ať se to příště lépe hledá 
        arg^.sym:=param;

        -- požadovaný typ parametru 
        x_set_param_type(curr,param,arg);
        end pair_args;



      ----------------------------------------------------------------------------------------------
      procedure check_default_value =
      -- Zkontroluje, jestli má formální parametr [param] implicitní hodnotu.
      ----------------------------------------------------------------------------------------------
      begin
        if param^.mode<>pm_in or not param^.init.isset then
          ce^.seterror({CCERR=}000443,ce_param_no_default_value);
          ce^.setparam(entityident_to_string(param^.id^));
          if arg<>nil 
            then arg^.errpos 
            else el^.errpos
            end if;
          ce^.resumeerror;
          end if;
        end check_default_value;



      ----------------------------------------------------------------------------------------------
      procedure add_default_value =
      -- Do skutečného parametru doplní implicitní hodnotu.
      ----------------------------------------------------------------------------------------------
      with 
        cx_expr.cx_imm;

      begin
        -- založit nový uzel reprezentující implicitní hodnotu
        newnode(arg^.sub,info,nt_imm);

        -- typ uzlu
        arg^.sub^.settype(curr,param^.typ.getctype);

        -- druh přímé hodnoty
        pexpimm(arg^.sub)^.immkind:=iek_imm;

        -- hodnota
        store_imm(pexpimm(arg^.sub)^.imm,param^.init.getimm^);

        -- formální kontrola nově vzniklé hodnoty ([a_form_param] kontrolu podvýrazů 
        -- nevolá, protože to zajišťuje nadřazená rutina ještě nad [a_form_call])
        a_form_imm(curr,arg^.sub,info);
        
        -- formální kontrola nově vzniklého parametru
        a_form_param(curr,arg,param,info);
        end add_default_value;

      

      ----------------------------------------------------------------------------------------------
      procedure create_default_arg =
      -- Pro aktuální formální parametr [param] sestaví implicitní skutečný parametr [arg].
      ----------------------------------------------------------------------------------------------
      begin
        arg:=nil;

        -- formální parametr musí mít implicitní hodnotu
        check_default_value;

        -- založit nový uzel reprezentující implicitní hodnotu
        newnode(arg,info,nt_item);

        -- typ parametru
        arg^.itype:=ei_empty;

        -- spárovat skutečný a formální parametr
        pair_args;

        -- doplnit implicitní hodnotu do skutečného parametru
        add_default_value;

      catch
        -- případnou chybu zachytit a nepustit dál
        when resume_error do 
            -- případně vzniklý argument označit za chybný
            if arg<>nil then arg^.erroneous:=true; end if;
        end create_default_arg;

  begin
    -- rozdělit podvýrazy 
    expr^.split(el,org_arglist);
 
    -- inicializovat hledání parametrů
    param_srch.find_et_first(proc,rc_primary,et_param,[]);


    ----- 1. Zpracovat všechny poziční parametry ---------------------------------------------------
    while (param_available and org_arglist<>nil) and then org_arglist^.itype in expitemtypeset:[ei_expr,ei_empty] loop
      -- pro zjednodušení formální parametr
      param:=param_srch.psym;

      -- oddělit jeden skutečný parametr
      get_actual_arg;

      -- spárovat skutečný a formální parametr
      pair_args;

      -- zpracovat 
      case arg^.itype
        -- implicitní parametr
        when ei_empty do
            begin
              -- formální parametr musí mít implicitní hodnotu
              check_default_value;

              -- doplnit implicitní hodnotu do skutečného parametru
              add_default_value;

            catch
              -- případnou chybu zachytit a nepustit dál
              when resume_error do 
                  -- označit argument za chybný
                  arg^.erroneous:=true;
              end;

        -- poziční parametr
        when ei_expr do
            -- formální kontrola parametru
            a_form_param(curr,arg,param,info);

        when others do verify({VERIFY=}000249,true);
        end case;

      -- umístit právě zpracovaný skutečný parametr na seznam skutečných parametrů
      put_actual_arg;

      -- další formální parametr
      param_srch.find_et_next;
      end loop;


    ----- 2. Zpracovat všechny klíčové parametry ---------------------------------------------------
    while (param_available and org_arglist<>nil) and then org_arglist^.itype=ei_ident loop
      -- pro zjednodušení formální parametr
      param:=param_srch.psym;
      
      -- dohledat parametr podle identifikátoru
      find_actual_arg(param^.id^);

      -- našel se skutečný parameter ?
      if arg<>nil 
      
        -- ano => zkontrolovat
        then
          -- spárovat skutečný a formální parametr
          pair_args;

          -- formální kontrola parametru
          a_form_param(curr,arg,param,info);

        -- ne => použít implicitní hodnotu
        else
          -- sestavit implicitní parametr
          create_default_arg;
          end if;

      -- umístit právě zpracovaný skutečný parametr na seznam skutečných parametrů
      put_actual_arg;

      -- další formální parametr
      param_srch.find_et_next;
      end loop;


    ----- 3. Dořešit přebytky ----------------------------------------------------------------------
    -- zbyly nějaké formální parametry ? => použít implicitní hodnoty
    while param_available loop
      -- pro zjednodušení formální parametr
      param:=param_srch.psym;
      
      -- sestavit implicitní parametr
      create_default_arg;

      -- umístit právě zpracovaný skutečný parametr na seznam skutečných parametrů
      put_actual_arg;

      -- další formální parametr
      param_srch.find_et_next;
      end loop;

    -- zbyly nějaké skutečné parametry ? => ohlásit chyby
    while org_arglist<>nil loop
      -- oddělit jeden skutečný parametr
      get_actual_arg;

      -- zpracovat
      case arg^.itype
        -- implicitní nebo poziční parametr
        when ei_expr,ei_empty do
            -- ohlásit nabytečný parametr
            ce^.seterror({CCERR=}000444,ce_param_excessive);
            arg^.errpos;

        -- klíčový parametr
        when ei_ident do
            -- existuje parametr tohoto jména ? 
            param_srch.find_local_all(sym_primary_context(proc^),arg^.id^);
            if param_srch.psym<>nil

              -- ano => pak byla jeho hodnota již určena, ohlásit duplicitní parametr
              then
                ce^.seterror({CCERR=}000445,ce_param_duplicate);
                ce^.setparam(entityident_to_string(arg^.id^));
                arg^.errpos;

              -- ne => ohlásit neexistující parametr
              else
                ce^.seterror({CCERR=}000446,ce_param_unknown);
                ce^.setparam(entityident_to_string(arg^.id^));
                arg^.errpos;
                end if;

        -- nic jiného neumíme
        when others do verify({VERIFY=}000702,true);
        end case;     
      end loop;


    -- sloučit podvýrazy
    expr^.join(el,new_arglist_first);
    end declare;



  ----- Zpracovat návratovou hodnotu ---------------------------------------------------------------
  if proc^.result<>nil

    -- procedura má návratovou hodnotu 
    then
      -- typ výrazu 
      expr^.settype(curr,proc^.result^.typ.getutype);

      -- třída uzlu : hodnota 
      expr^.nclass:=nc_value;

      -- %%TECH Pokud se zde někdy kvůli předávání návratové hodnoty referencí změní třída uzlu na
      -- [nc_var], tak se s tím musí počítat v [a_form_ref]! Reference návratové hodnoty procedury
      -- pochopitelně nemá smysl. Zatím se v takovém případě v [a_form_ref] ohlásí interní chyba,
      -- ale je to pouze vedlejší efekt kontroly povolení ALIASED přístupu.

    -- procedura nemá návratovou hodnotu 
    else
      -- třída uzlu : nic 
      expr^.nclass:=nc_none;
      end if;

  -- změnit typ uzlu 
  expr^.ntype:=nt_call;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_call;



----------------------------------------------------------------------------------------------------
procedure a_form_message_send (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola odeslání zprávy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- parametry
  arg              : pexpitem;                   -- parametr

begin
  -- %%TECH Předpokládá se, že formální kontrola prefixu i parametrů již byla
  -- provedena a že typ podvýrazu je zpráva.

  -- oddělit prefix a parametry 
  expr^.get(el,arglist);

  -- prefix musí mít jednoznačný typ 
  checkresolve(curr,el,nulltype,info);

  -- prefix musí být typu zpráva 
  checksts(curr,el,dts_message,ce_i_prefix,hint_prefix_message,info);

  -- prefix musí být zpráva 
  checkclass(curr,el,ncs_prefix_send,ce_i_prefix,info);

  -- kontrola parametrů 
  arg:=arglist;
  while arg<>nil loop
    unimplementedx({UNIMP=}000232,arg^.sub^.pos);
    end loop;

  -- změnit typ uzlu 
  expr^.ntype:=nt_send;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_message_send;



----------------------------------------------------------------------------------------------------
procedure a_form_message_accept (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola přijetí zprávy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- parametry
  arg              : pexpitem;                   -- parametr                                    

begin
  -- %%TECH Předpokládá se, že formální kontrola prefixu i parametrů již byla
  -- provedena a že typ podvýrazu je zpráva.

  -- oddělit prefix a parametry 
  expr^.get(el,arglist);

  -- prefix musí mít jednoznačný typ 
  checkresolve(curr,el,nulltype,info);

  -- prefix musí být typu zpráva 
  checksts(curr,el,dts_message,ce_i_prefix,hint_prefix_message,info);

  -- prefix musí být zpráva 
  checkclass(curr,el,ncs_prefix_accept,ce_i_prefix,info);

  -- kontrola parametrů 
  arg:=arglist;
  while arg<>nil loop
    unimplementedx({UNIMP=}000233,arg^.sub^.pos);
    end loop;

  -- změnit typ uzlu 
  expr^.ntype:=nt_accept;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_message_accept;



----------------------------------------------------------------------------------------------------
procedure a_form_deref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpderef;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Dereference.
----------------------------------------------------------------------------------------------------
var
  base             : typeview;                   -- bázový typ
  el               : pexpnode;                   -- podvýraz                                    

begin
  -- rozdělit podvýrazy 
  expr^.split(el);

  -- formální kontrola podvýrazu 
  a_form(curr,el,info);

  -- sloučit podvýrazy 
  expr^.join(el);

  -- povedla se formální kontrola podvýrazů 
  if el^.zprac<>ep_form then return; end if;

  -- podvýraz musí být jednoznačný 
  checkresolve(curr,el,nulltype,info);

  -- kontrola třídy podvýrazu 
  checkclass(curr,el,ncs_prefix_deref,ce_i_prefix,info);

  -- kontrola typu podvýrazu 
  checksts(curr,el,dts_pointer,ce_i_prefix,'',info);

  -- typ výrazu 
  base:=el^.t.getbase(curr);
  verify({VERIFY=}000110,(el^.t.getpbase<>pb_unchecked) and (base.tview=tview_null));
  if base.tview<>tview_null
    -- typ báze je určen (není UNCHECKED i když PBASE=PB_UNCHECKED)
    then expr^.t:=base
    -- typ báze není určen, dosadit jako unchecked
    else expr^.setunchecked(curr,base);
    end if;

  -- třída uzlu: podle podvýrazu 
  expr^.nclass:=x_get_deref_nclass(el);

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_deref;



----------------------------------------------------------------------------------------------------
procedure a_form_this (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpthis;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- THIS.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  -- získat kontejner, bude se hodit
  psym:=sym_get_container(curr.entity);

  -- musíme být někde v třídě 
  if psym^.etype<>et_class then 
    -- %%X zpřesnit chybové hlášení
    ce^.seterror({CCERR=}000447,ce_i_this);
    expr^.errpos;
    ce^.resumeerror;
    end if;

  -- třída výrazu: proměnné 
  expr^.nclass:=nc_var;

  -- typ výrazu: nalezená třída 
  expr^.settype(curr,pentity_type(psym));

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_this;



----------------------------------------------------------------------------------------------------
procedure a_form_component_finalize (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcomponent;       -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Dokončení formální kontroly komponenty.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure create_this =
    -- Coby EXPR^.SUB doplní uzel reprezentující THIS.
    ------------------------------------------------------------------------------------------------
    begin
      -- vznikl novy uzel 
      newnode(expr^.sub,info,nt_this);

      -- formální kontrola 
      a_form_this(curr,pexpthis(expr^.sub),info);
      end create_this;

var
  ptyp             : pentity_type;               -- typ proměnné                                
  pproc            : pentity_subprogram;         -- procedura (pro zjednodušení)

begin
  -- zvýšit počet použití symbolu
  succ expr^.s.psym^.stat_usage;

  -- zjistit o symbolu různé zajímavé údaje 
  case expr^.s.psym^.etype
    -- nedefinovaný symbol (zotavení z chyby)
    when et_undef do
        -- chyba již byla hlášena, jen přeskočit tento výraz
        ce^.resumeerror;

    -- proměnná
    when et_var do
        -- typ výrazu
        ptyp:=pentity_var(expr^.s.psym)^.typ.getutype;
        if ptyp<>nil
          -- typovaný výraz
          then expr^.settype(curr,pentity_var(expr^.s.psym)^.typ.getutype)
          -- unchecked výraz
          else expr^.settypeunchecked(curr,ptyp);
          end if;

        -- třída uzlu
        -- složka třídy
        if (expr^.sub=nil) and (pentity_var(expr^.s.psym)^.mclass=mc_class) and sym_check_container(curr.entity,et_class) then
          -- třída: proměnné
          expr^.nclass:=nc_var;

          -- doplnit THIS
          create_this;

        -- složka typu
        elsif (expr^.sub<>nil) and (expr^.sub^.nclass=nc_type)
        and (pentity_var(expr^.s.psym)^.mclass in mcs_offset) then
          -- třída: typ
          expr^.nclass:=nc_type

        -- složka recordu
        elsif (expr^.sub=nil) and (pentity_var(expr^.s.psym)^.mclass=mc_record) then
          expr^.nclass:=nc_type;

        -- jinak je to opravdu proměnná
        else
          verify({VERIFY=}000465,(pentity_var(expr^.s.psym)^.mclass in mcs_offset) and (expr^.sub=nil));

          -- třída: proměnné
          expr^.nclass:=nc_var;
          end if;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- konstanta
    when et_const do
        -- typ výrazu
        expr^.settype(curr,pentity_const(expr^.s.psym)^.typ.getctype);

        -- třída uzlu: typ
        expr^.nclass:=nc_value;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- výčtový prvek
    when et_enum do
        -- typ výrazu
        expr^.settype(curr,pentity_enum(expr^.s.psym)^.typ);

        -- třída uzlu: typ
        expr^.nclass:=nc_value;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- parametr procedury
    when et_param do
        -- typ výrazu
        ptyp:=pentity_param(expr^.s.psym)^.typ.getutype;
        if ptyp<>nil
          -- typovaný výraz
          then expr^.settype(curr,pentity_var(expr^.s.psym)^.typ.getutype)
          -- unchecked výraz
          else expr^.settypeunchecked(curr,ptyp)
          end if;

        -- třída uzlu: typ
        expr^.nclass:=nc_type;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- typ/třída
    when et_type, et_class do
        -- typ výrazu
        expr^.settype(curr,pentity_type(expr^.s.psym));

        -- třída uzlu: typ
        expr^.nclass:=nc_type;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- procedura, metoda
    when et_procedure, et_static, et_virtual do
        -- pro zjednodušení
        pproc:=pentity_procedure(expr^.s.psym);

        -- typ výrazu
        expr^.settype(curr,pproc^.typ.getutype);

        -- třída uzlu se určí podle způsobu předávání a dostupnosti instance
        case pproc^.instance
          -- nepředávat => třída: procedura
          when tip_none     do expr^.nclass:=nc_proc;

          -- volitelně => třída: procedura
          when tip_optional do
              -- třída: procedura
              expr^.nclass:=nc_proc;

              -- pokud nemáme explicitně uvedenu instanci
              -- a je-li to v třídě, tak doplnit THIS
              if (expr^.sub=nil) and sym_check_container(curr.entity,et_class) then
                create_this;
                end if;

          -- předávat => třída: procedura nebo nic podle dostupnosti instance
          when tip_pass,tip_dispatch do
              -- rozhodnout se podle podvýrazu
              -- podvýraz není, nejsme v třídě ?
              if expr^.sub=nil then
                -- je to v třídě ?
                if sym_check_container(curr.entity,et_class)

                  -- ano => třída: procedura + doplnit THIS
                  then
                    expr^.nclass:=nc_proc;
                    create_this;

                  -- ne => třída: nic
                  else
                    expr^.nclass:=nc_none;
                    end if;

              -- podvýraz je proměnná => máme instanci => třída: procedura
              elsif expr^.sub^.nclass in ncs_value then 
                expr^.nclass:=nc_proc;

              -- podvýraz je, ale není to proměnná => třída: nic
              else
                expr^.nclass:=nc_none;
                end if;

          when others do verify({VERIFY=}000378,true);
          end case;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

        -- doplnit implicitní volání
        -- Ondra 13.11.2003 Výraz samozřejmě musí být třídy [nc_proc]
        if expr^.nclass=nc_proc and then ((nf_name in expr^.nflags
        and (nf_top not in expr^.nflags or info.kind not in eks_proc)
        -- Ondra 18.9.2001 : Pouze pokud nechceme referenci na proceduru
        and nf_reference not in expr^.nflags)
        -- Ondra 11.10.2001 : Nebo pokud se výsledek bude dereferencovat }
        or nf_dereference in expr^.nflags) then
          -- zvýšit strom
          newtree(pexpnode(expr),info,nt_call);

          -- formální kontrola volání
          a_form_call(curr,pexplist(pexpnode(expr)),info);
          end if;

    -- zpráva
    when et_message     do
        -- typ výrazu
        expr^.settype(curr,pentity_message(expr^.s.psym)^.typ.getutype);

        -- třída uzlu: zpráva
        expr^.nclass:=nc_message;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

        -- může to být send/accept
        if info.kind in eks_message and {%%TODO(IN) (nodeflagset:[nf_name,nf_top]<=expr^.nflags)}
        nf_name in expr^.nflags and nf_top in expr^.nflags then
          -- zvýšit strom
          newtree(pexpnode(expr),info,nt_list);

          -- formální kontrola
          case info.kind
            -- odeslání zprávy
            when ek_context_send   do a_form_message_send(curr,pexplist(pexpnode(expr)),info);

            -- přijmutí zprávy
            when ek_context_accept do a_form_message_accept(curr,pexplist(pexpnode(expr)),info);

            when others do verify({VERIFY=}000305,true);
            end case;
          end if;

    -- přetížení

    -- speciální metoda

    -- generický parametr

    -- modul
    when et_module do
        -- třída uzlu: modul
        expr^.nclass:=nc_module;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- program
    when et_program     do
        -- třída uzlu: nic
        expr^.nclass:=nc_none;

        -- formální kontrola úspěšně dokončena
        expr^.zprac:=ep_form;

    -- jiné symboly neumím zpracovat
    when others do
        ce^.seterror({CCERR=}000448,ce_i_symbol);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;
  end a_form_component_finalize;



----------------------------------------------------------------------------------------------------
procedure a_form_component (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcomponent;       -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola komponenty.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- nalezený symbol

    ------------------------------------------------------------------------------------------------
    procedure find_in_class =
    -- Vyhledání komponenty v třídě.
    ------------------------------------------------------------------------------------------------
    var
      sv           : tentityvisibleset;          -- povolené úrovně viditelnosti

    begin
      -- povolené úrovně viditelnosti hledaného symbolu
      sym_get_visibility(curr.entity,expr^.sub^.t.getutype,sv);

      -- nejsou povoleny žádné úrovně viditelnosti => hledání (selektor) je zakázáno
      if sv=tentityvisibleset:[] then
        ce^.seterror({CCERR=}000449,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      --%%TODO(Ondra): Pokud je EXPR^.SUB^.T.GETUTYPE^ roven CURR.ENTITY, popřípadě nějaké nadřazené
      -- entita, tak by se správně měl dohledat kontext podle kontextu CURR, protože jinak například
      -- P.X může být něco jiného než prosté X.

      -- vyhledat
      srch.find_local(sym_primary_context(expr^.sub^.t.getutype^),expr^.id^,sv);
      end find_in_class;



    ------------------------------------------------------------------------------------------------
    procedure find_in_entity =
    -- Vyhledání komponenty v související entitě.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym.cc_advanced;

    var
      sv           : tentityvisibleset;          -- povolené úrovně viditelnosti

    begin
      -- podvýraz musí být komponenta nebo atribut s určeným souvisejícím symbolem
      if expr^.sub^.ntype not in nodetypeset:[nt_component,nt_attrib] or else expr^.sub^.getsymbol=nil then
        ce^.seterror({CCERR=}000450,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      -- povolené úrovně viditelnosti hledaného symbolu
      sym_get_visibility(curr.entity,expr^.sub^.getsymbol,sv);

      -- jestliže nejsou povoleny žádné úrovně viditelnosti
      if sv=tentityvisibleset:[]
      -- a překládaný výraz bude použit jako jméno v nějaké vazební klauzuli
      and info.kind in eks_link
      -- a podvýraz reprezentuje modul nebo třídu
      and expr^.sub^.getsymbol^.etype in ets_modular
      -- můžeme to zkusit zachránit automatickým USE
      then
        -- automatické USE
        sym_add_with(curr,expr^.sub,expr^.sub^.getsymbol,twm_use,twl_normal,true);

        -- a zkusit zjistit viditelnost ještě jednou
        sym_get_visibility(curr.entity,expr^.sub^.getsymbol,sv);
        end if;

      -- nejsou povoleny žádné úrovně viditelnosti => hledání (selektor) je zakázáno
      if sv=tentityvisibleset:[] then
        ce^.seterror({CCERR=}000451,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      --%%TODO(Ondra): Pokud je EXPR^.SUB^.GETSYMBOL^ rovna CURR.ENTITY, popřípadě nějaké nadřazené
      -- entitě, tak by se správně měl dohledat kontext podle kontextu CURR, protože jinak například
      -- P.X může být něco jiného než prosté X.

      -- vyhledat
      srch.find_local(sym_primary_context(expr^.sub^.getsymbol^),expr^.id^,sv);
      end find_in_entity;

begin
  -- formální kontrola podvýrazu 
  if expr^.sub<>nil then
    -- formální kontrola podvýrazu 
    a_form(curr,expr^.sub,info);

    -- povedla se formální kontrola podvýrazu ? 
    if expr^.sub^.zprac<ep_form then return; end if;

    -- podvýraz musí mít jednoznačný typ 
    checkresolve(curr,expr^.sub,nulltype,info);

    -- kontrola třídy podvýrazu 
    checkclass(curr,expr^.sub,ncs_prefix_component,ce_i_prefix,info);
    end if;

  -- vyhledat symbol (není-li již určen) 
  if expr^.s.psym=nil then
    ----- %%TECH/%%LANG ----- Vyhledání symbolu ----------------------------------------------------
    -- Symbol se hledá podle kontextu viditelnosti. Pokud pod aktuálním uzlem 
    -- není jiný uzel, hledá se vzhledem k překládanému prvku. Pokud je       
    -- uveden kontext (expr^.sub<>nil), řídí se vyhledávání typem podvýrazu.  
    --   Pro generické podvýrazy nezbývá než ukončit formální kontrolu výrazu 
    -- pro tento uzel.                                                        
    ------------------------------------------------------------------------------------------------
    if expr^.sub=nil

      -- nekvalifikovany identifikator 
      then
        -- vyhledat 
        srch.find_global(curr,expr^.id^);

        -- v určitém kontextu by to mohlo být jméno dosud nepřeloženého modulu 
        if srch.psym=nil and info.kind in eks_link then
          -- zkusit přeložit soubor
          p_loadmodule(curr,expr^.id^);

          -- a zkusit ještě jednou vyhledat
          srch.find_global(curr,expr^.id^);
          end if;

      -- kvalifikovany identifikator 
      else
        case expr^.sub^.t.tview
          -- beztypový výraz
          when tview_null do find_in_entity;

          -- Full view
          when tview_full do
              case expr^.sub^.t.stype
                -- record
                when dt_record    do srch.find_local(sym_primary_context(expr^.sub^.t.getutype^),expr^.id^,tentityvisibleset:[etv_public]);

                -- třída
                when dt_class     do find_in_class;

                -- procedura
                when dt_procedure do find_in_entity;

                -- v ostatních případech není co hledat
                when others do
                    ce^.seterror({CCERR=}000452,ce_i_selector);
                    --%%TODO(LIB) ce^.setinfo(formats(hint_prefix_component,nptostr(datatypename,ord(expr^.sub^.t.stype))));
                    expr^.errpos;
                    ce^.resumeerror;
                end case;

          -- Incomplete view
          when tview_incomplete do
              if expr^.sub^.t.isclass

                -- třída, to je OK
                then
                  find_in_class;

                -- pro jiné typy to nelze
                else
                  -- není co hledat
                  ce^.seterror({CCERR=}000453,ce_i_selector);
                  ce^.setinfo(hint_prefix_component_hidden);
                  expr^.errpos;
                  ce^.resumeerror;
                  end if;

          -- Partial view/Unchecked view
          when tview_partial, tview_unchecked do
              -- není co hledat
              ce^.seterror({CCERR=}000454,ce_i_selector);
              ce^.setinfo(hint_prefix_component_hidden);
              expr^.errpos;
              ce^.resumeerror;

          when others do verify({VERIFY=}000185,true);
          end case;
        end if;

    -- kontrola vyhodnocení
    checkeval(curr,expr,srch,expr^.id,info);
    end if;

  -- nyní již je jistě entita k dispozici
  verify({VERIFY=}000018,srch.psym=nil);

  -- poznamenat symbol 
  expr^.s:=srch;

  -- dokončit kontrolu 
  a_form_component_finalize(curr,expr,info);
  end a_form_component;



----------------------------------------------------------------------------------------------------
procedure a_form_imm =
-- Formální kontrola přímé hodnoty.
----------------------------------------------------------------------------------------------------
with
  cx_imm;
  
begin
  verify({VERIFY=}000225,expr^.sub<>nil);

  -- odvodit univerzální typ
  case expr^.immkind
    -- obecná přímá hodnota
    when iek_imm                 do -- nic nedělat, typ je již určen

    -- univerzální integer
    when iek_integer_literal     do expr^.settype(curr,def_uniint);

    -- univerzální reálné číslo
    when iek_real_literal        do expr^.settype(curr,def_unireal);

    -- univerzální znak
    when iek_character_literal   do expr^.settype(curr,def_unichar);

    -- univerzální NIL
    when iek_nil_literal         do expr^.settype(curr,def_uninil);

    -- znakový agregát
    when iek_character_aggregate do expr^.settype(curr,def_unistr);

    -- univerzální logical
    when iek_logical_metaliteral do expr^.settype(curr,def_unilogical);

    when others do verify({VERIFY=}000841,true);
    end case;
{
  -- odvodit univerzální typ
  case expr^.imm.ic
    -- univerzální integer
    when ic_ordinal   do expr^.settype(curr,def_uniint);

    -- univerzální reálné číslo
    when ic_real      do expr^.settype(curr,def_unireal);

    -- znakový agregát (v této fázi to nemůže být nic jiného)
    when ic_condensed do
        -- podle délky se odhadne typ
        if expr^.imm.citems.len=1

          -- jednoprvkový znakový agregát => univerzální znak
          then
            expr^.settype(curr,def_unichar);
            imm_mutestr(expr^.imm);

          -- ostatní znakové agregáty => univerzální pole of UNICHAR
          else
            expr^.settype(curr,def_unistr); --x_unistr(curr,expr,def_unichar);
            end if;

{%%X mělo nějaký smysl nastavovat velikost typu na počet prvků ?

    begin
        -- jako velikost se použije počet prvků
        udload(ud,expr^.imm.pocet);

        -- string
        expr^.newtype(curr,dt_unistr,ud);

        -- of char
        {%%X a co vyhodnocení ? (pspecunistr(...)^.base.e:=ete_evaluated)}
        expr^.t.typ^.base._t:=def_unichar;
        end;
}
    -- univerzální konstanta
    when ic_nil         do expr^.settype(curr,def_uninil);

    -- co jiné hodnoty ?
    end case;
}
  -- třída uzlu: hodnota
  expr^.nclass:=nc_value;

  -- formální kontrola úspěšně dokončena
  expr^.zprac:=ep_form;
  end a_form_imm;



----------------------------------------------------------------------------------------------------
procedure a_form_typecast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola přetypování.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  er               : pexpnode;                   -- podvýrazy
  arglist          : pexpitem;                   -- seznam argumentů                            

begin
  -- rozdělit podvýrazy 
  expr^.split(el,arglist);

  -- nesplet si někdo přetypování a volání procedury ? 
  if (arglist=nil) or (arglist^.next<>nil) or (arglist^.itype<>ei_expr) then
    ce^.seterror({CCERR=}000455,ce_x_name_proc);
    expr^.join(el,arglist);
    el^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- získat opravdový pravý podvýraz 
  verify({VERIFY=}000130,arglist^.sub=nil);

  -- formální kontrola levého podvýrazu 
  a_form(curr,el,info,catch_mode_catch);

  -- formální kontrola pravého podvýrazu 
  a_form(curr,arglist^.sub,info);
  arglist^.zprac:=arglist^.sub^.zprac;
  er:=arglist^.sub;
  
  -- sloučit 
  expr^.join(el,arglist);

  -- povedla se formální kontrola podvýrazů ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- podvýrazy musí mít jednoznačný typ 
  checkresolve(curr,el,nulltype,info);
  checkresolve(curr,er,nulltype,info);

  -- kontrola třídy podvýrazů 
  checkclass(curr,el,ncs_prefix_typecast,ce_i_prefix,info);
  checkclass(curr,er,ncs_value,ce_i_expr,info);

  -- levý podvýraz musí mít typ s Partial či Full view 
  checkview(curr,el,ttypeviewset:[tview_partial,tview_full],ce_i_prefix,hint_prefix_view,info);

  -- levý podvýraz s Full view musí mít regulární typ
  if el^.t.tview=tview_full then
    checksts(curr,el,dts_regular,ce_i_prefix,hint_prefix_regular,info);
    end if;

  -- typy musí být kompatibilní 
  if not t_compatible(curr,toc_typecast,false,el^.t,er^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000456,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- změnit typ uzlu 
  expr^.ntype:=nt_typecast;

  -- typ výrazy 
  expr^.t:=el^.t;

  -- třída výrazu 
  {%%X Tohle je zřejmě dost zjednodušené, co }
  -- dynamické přetypování na základě tagu ?  
  case er^.nclass
    -- hodnota --> hodnota 
    when nc_value do expr^.nclass:=nc_value;

    -- proměnná --> proměnná nebo hodnota
    when nc_var   do
        --%%X Tohle by mělo vyplývat z výsledku typové kontroly v třídě typecast

        -- jeden z podvýrazů nemá velikost => třída proměnná
        if not el^.t.hassize or not er^.t.hassize then expr^.nclass:=nc_var

        -- cílový typ je unconstrained => třída proměnná
        elsif t_is_sts(el^.t,dts_unconstrained) then expr^.nclass:=nc_var

        -- podvýrazy mají stejnou velikost => třída proměnná
        elsif el^.t.getsize=er^.t.getsize then expr^.nclass:=nc_var

        -- podvýrazy mají různou velikost či co => třída hodnota
        else expr^.nclass:=nc_value;
        end if;

    when others do verify({VERIFY=}000281,true);
    end case;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_typecast;



----------------------------------------------------------------------------------------------------
procedure a_form_list (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola seznamu argumentů.
----------------------------------------------------------------------------------------------------
var
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty
  el               : pexpnode;                   -- podvýraz
  arglist          : pexpitem;                   -- argumenty
  x                : pexpitem;

begin
  ----- %%TECH -------------------------------------------------------------------------------------
  -- Formální kontrolu mohu provést nezávisle pro prefix i pro všechny argumenty, takže se případné 
  -- nevyhodnocení detekuje až po zpracování všech podvýrazů.                                                         
  -- Srovnej s CX_TYPE.A_TYPE_CALL, CX_OPT.A_OPT_CALL                         
  --                                                                          
  -- %%X a přeci - nemělo by se to pro každý typ dělat znova ? Třeba ve formální kontrole volání 
  -- procedury se stejně v cyklu kontrolují parametry.                                                               
  --------------------------------------------------------------------------------------------------

  -- rozdělit 
  expr^.split(el,arglist);

  -- formální kontrola řídícího výrazu 
  a_form(curr,el,info);
  vyhodnoceno:=el^.zprac>=ep_form;

  -- vyhodnotit argumenty 
  x:=arglist;
  while x<>nil loop
    verify({VERIFY=}000105,x^.ntype<>nt_item);
    if x^.sub<>nil then
      -- formální kontrola 
      a_form(curr,x^.sub,info,catch_mode_catch);
      vyhodnoceno:=vyhodnoceno and (x^.sub^.zprac>=ep_form);

      -- pro zjednodušení převzít typ a třídu podvýrazu 
      x^.t:=x^.sub^.t;
      x^.nclass:=x^.sub^.nclass;
      end if;

    -- další podvýraz 
    x:=pexpitem(x^.next);
    end loop;

  -- sloučit 
  expr^.join(el,arglist);

  -- povedla se formální kontrola podvýrazů ? 
  if not vyhodnoceno then return; end if;

  -- řídící výraz musí mít jednoznačný typ 
  checkresolve(curr,el,nulltype,info);

  case el^.nclass
    -- typ -->
    when nc_type do
        if t_is_sts(el^.t,dts_message)

          -- --> cosi se zprávou
          then
            case info.kind
              -- odeslání zprávy
              when ek_context_send   do a_form_message_send(curr,expr,info);

              -- přijetí zprávy
              when ek_context_accept do a_form_message_accept(curr,expr,info);

              when others do verify({VERIFY=}000304,true);
              end case;

          -- --> přetypování
          else
            a_form_typecast(curr,expr,info);
            end if;

    -- adresa procedury --> volání procedury
    when nc_proc do a_form_call(curr,expr,info);

    -- adresa proměnné --> chyba
    when nc_var do
        if t_is_sts(el^.t,tdatatypeset:[dt_procedure])

          -- je to pointer na proceduru
          then a_form_call(curr,expr,info)

          -- je to něco jiného
          else
            -- typ: procedura -- chybí ^
            -- jinak chybí :TYPE
            ce^.seterror({CCERR=}000457,ce_x_name_proc_type);
            el^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

    -- tag
    when nc_tag do
        -- místo :TAG mělo být :TYPE
        ce^.seterror({CCERR=}000458,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

    -- výraz nemá uveden typ
    when nc_none do
        ce^.seterror({CCERR=}000459,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

    when nc_undef do verify({VERIFY=}000050,true);

    -- jiné třídy jsou chyba a neumím dát žádnou nápovědu
    when others do
        ce^.seterror({CCERR=}000460,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;
  end a_form_list;



----------------------------------------------------------------------------------------------------
procedure a_form_interface_cast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpinterfacecast;   -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola interface castu
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  -- rozdělit podvýrazy 
  expr^.split(el,er);

  -- formální kontrola levého podvýrazu 
  a_form(curr,el,info);

  -- formální kontrola pravého podvýrazu 
  a_form(curr,er,info);
  
  -- sloučit 
  expr^.join(el,er);

  -- povedla se formální kontrola podvýrazů ? 
  if el^.zprac<ep_form or er^.zprac<ep_form then return; end if;

  -- podvýrazy musí mít jednoznačný typ 
  checkresolve(curr,el,nulltype,info);
  checkresolve(curr,er,nulltype,info);

  -- kontrola třídy podvýrazů 
  checkclass(curr,el,ncs_prefix_typecast,ce_i_prefix,info);
  checkclass(curr,er,ncs_var,ce_i_expr,info);

  -- levý podvýraz musí mít typ s Incomplete či Full view 
  checkview(curr,el,ttypeviewset:[tview_incomplete,tview_full],ce_i_prefix,hint_prefix_view,info);

  -- typy musí být kompatibilní 
  if not t_compatible(curr,toc_interface_cast,false,el^.t,er^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000461,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typ výrazy 
  expr^.t:=el^.t;

  -- třída výrazu 
  expr^.nclass:=nc_var;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_form_range (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexprange;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola seznamu argumentů.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý a pravý podvýraz
  er               : pexpnode;                   -- levý a pravý podvýraz
  elt              : ptypeview;                  -- typy podvýrazů
  ert              : ptypeview;                  -- typy podvýrazů
  ranget           : typeview;                   -- typ rozsahu                                 

begin
  {%%X}{%%RESOLVE}

  -- rozdělit podvýrazy 
  expr^.split(el,er);

  -- formální kontrola levého podvýrazu 
  a_form(curr,el,info);

  -- formální kontrola pravého podvýrazu 
  a_form(curr,er,info);

  -- sloučit podvýrazy 
  expr^.join(el,er);

  -- povedla se formální kontrola podvýrazů ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- podvýrazy musí být hodnoty 
  checkclass(curr,el,ncs_value,ce_i_expr,info);
  checkclass(curr,er,ncs_value,ce_i_expr,info);

  -- iterace přes všechny dvojice typů podvýrazů 
  for eli in 0..el^.gettypecount-1 loop
    for eri in 0..er^.gettypecount-1 loop
      -- typy 
      el^.gettype(eli,elt);
      er^.gettype(eri,ert);

      -- jsou oba typy diskrétní ? 
      if t_is_sts(elt^,dts_u_ordinal) and t_is_sts(ert^,dts_u_ordinal)
      -- a jsou kompatibilní ? 
      and t_compatible(curr,toc_range,false,elt^,ert^) then
        -- odvodit typ rozsahu 
        x_resolve(elt^,ert^,false,ranget);

        -- zařadit jako výsledek 
        expr^.addtype(ranget,eli,eri,nil);
        end if;
      end loop;
    end loop;

{ Stará verze bez přetížení:

  -- typy podvýrazů musí být diskrétní 
  checksts(curr,el,dts_u_ordinal,ce_x_ord,'',info);
  checksts(curr,er,dts_u_ordinal,ce_x_ord,'',info);

  -- a musí být i kompatibilní 
  if not t_compatible(curr,toc_range,false,el^.t,er^.t) then
    {%%X upřesnit chybové hlášení }
    ce^.seterror({CCERR=}000462,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- odvodit typ rozsahu 
  x_resolve(el^.t,er^.t,expr^.t);
}
  -- třída uzlu 
  expr^.nclass:=nc_composite;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_range;



----------------------------------------------------------------------------------------------------
procedure a_form_index (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpindex;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Formální kontrola indexu pole.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý a pravý podvýraz
  er               : pexpnode;                   -- levý a pravý podvýraz
  rtype            : typeview;                   -- typ rozsahu pole/řetězce

begin
  -- rozdělit podvýrazy 
  expr^.split(el,er);

  -- formální kontrola levého podvýrazu 
  a_form(curr,el,info);

  -- formální kontrola pravého podvýrazu 
  a_form(curr,er,info);

  -- sloučit podvýrazy 
  expr^.join(el,er);

  -- povedla se formální kontrola podvýrazů ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- levý podvýraz musí být jednoznačný 
  checkresolve(curr,el,nulltype,info);

  -- kontrola třídy levého podvýrazu 
  checkclass(curr,el,ncs_prefix_index,ce_i_prefix,info);

  -- pravý podvýraz musí být výběr 
  checkclass(curr,er,ncs_choice,ce_i_expr,info);

  -- levý podvýraz musí být pole nebo řetězec 
  -- Ondra 6.8.2002 : Kdyby to nebylo v Pascalu, ale třeba ve Flexu nebo
  -- v Algolu, tak máme o chybu méně. Nelze se dotazovat na STYPE levého
  -- operandu, protože to může být unchecked typ. %%X Zatím jen zrušen hint.
  checksts(curr,el,dts_u_index,ce_i_prefix,{%%TODO(LIB) formats(}''{hint_prefix_index}{%%TODO(LIB),nptostr(datatypename,ord(el^.t.stype)))},info);
  -- Poznámka: Kdyby to bylo v Algolu, tak budu parametr HINT předávat jako   
  -- Call-by-name, aby se to FORMATS nevyhodnocovalo pokaždé, ale jen když    
  -- opravdu nastane chyba.                                                   
  --   Kdyby to bylo ve Flexu, tak 1) použiju textovou substituci, 2) nebo    
  -- použiju #pragma smart_inline(checksts);, 3) nebo proceduru CHECKSTS      
  -- deklaraju v režimu #syntax algol; a kompilátor si to nějak přebere.      
  -- Závěr: Ještě že nejsme v Algolu (viz N:\DOC\SW\JAZYKY\ALGOL).            

  -- typ rozsahu 
  rtype:=el^.t.getrange(curr);

  -- pravý podvýraz musí být jednoznačný 
  checkresolve(curr,er,rtype,info);

  -- typ pravého podvýrazu musí být kompatibilní 
  if not t_compatible(curr,toc_transform,false,rtype,er^.t) then
    ce^.seterror({CCERR=}000463,ce_incompatible);
    er^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- určit typ indexu 
  if er^.nclass in ncs_range
    then expr^.itype:=eix_slice
    else expr^.itype:=eix_component;
    end if;

  -- typ výrazu 
  case expr^.itype
    -- jedna komponenta
    when eix_component  do expr^.t:=el^.t.getbase(curr);

    -- řez pole
    when eix_slice      do unimplementedx({UNIMP=}000112,expr^.pos);

    when others         do verify({VERIFY=}000329,true);
    end case;

  -- třída uzlu 
  expr^.nclass:=el^.nclass;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_index;



----------------------------------------------------------------------------------------------------
procedure a_form_ref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpref;             -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Reference.
----------------------------------------------------------------------------------------------------
with
  cx_phase;

var
  el               : pexpnode;                   -- podvýraz

begin
   -- rozdelit podvýrazy 
  expr^.split(el);

  -- vyhodnotit prefix 
  x_phase_next(curr,el,nulltype,eu_none,ep_type,info);

  -- sloučit 
  expr^.join(el);

  -- povedlo se vyhodnocení podvýrazu?
  if el^.zprac<ep_type then return; end if;

  -- podvýraz musí být jednoznačný 
  checkresolve(curr,el,nulltype,info);

  -- podvýraz musí být proměnná nebo procedura 
  checkclass(curr,el,ncs_ref,ce_i_expr,info);

  -- kontrola typu pohledu na typ podvýrazu
  case el^.nclass
    -- proměnná
    when nc_var  do
        -- kontrola typu pohledu
        checkview(curr,el,ttypeviewset:[tview_full,tview_partial,tview_unchecked,tview_incomplete],ce_i_expr,'',info);

        -- musí to být regulární typ
        case el^.t.tview
          -- Unchecked view
          when tview_unchecked  do
              -- Regulární jistě bude
              -- Důkaz: Unchecked view lze zkonstruovat jen pomocí :unchecked
              -- a tento atribut lze aplikovat jen na podvýraz regulárního
              -- typu.

          -- Partial view
          when tview_partial    do
              -- Regulární jistě bude
              -- Důkaz: Pokud je u typu podezření, že na něj může být
              -- vytvořeno Partial view, je definitoricky prohlášen za
              -- regulární. Dopředná deklarace nelze dokončit definicí
              -- singulárního typu.

          -- Incomplete view => class
          when tview_incomplete do
              -- %%X Nemůže se stát, že by typ byl singulární? Snad ne, protože  
              -- jinak by od něj neexistovala instance v podobě proměnné, ne? 

          -- Full view => class
          when tview_full       do
              -- podvýraz musí být regulární typ
              checksts(curr,el,dts_regular,ce_i_expr,'',info);

          when others do verify({VERIFY=}000227,true);
          end case;

    -- procedura
    when nc_proc do
        -- Pohled je jistě Full view
        -- Důkaz    : Procedura se deklarauje buďto implicitní definicí
        -- procedurálního typu (je ihned SD_DECLARED => Full view, Partial
        -- view být nemůže - nemá jak), nebo uvedením Full view nějakého
        -- procedurálního typu.
        --   Typ procedury je singulární typ, takže na něj nejde ani
        -- :unchecked => nemůže být Unchecked view
        verify({VERIFY=}000842,el^.t.tview<>tview_full);

    -- zpráva
    when nc_message     do
        -- Pohled je jistě Full view
        -- Důkaz    : viz varianta pro proceduru
        verify({VERIFY=}000843,el^.t.tview<>tview_full);

    when others do verify({VERIFY=}000109,true);
    end case;

  -- pro referenci na objekt zkontrolovat povolení reference
  if el^.nclass=nc_var then
    check_aliased(curr,expr,el);
    end if;

  -- vypočítat typ reference a třídu výrazu
  x_set_ref_type(curr,expr);

  -- formální kontrola úspěšně dokončena
  expr^.zprac:=ep_form;
  end a_form_ref;



----------------------------------------------------------------------------------------------------
procedure a_form_attrib (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpattrib;          -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Atribut.
----------------------------------------------------------------------------------------------------
with
  cc_attr,
  cx_phase;
  
var
  base             : pentity_type;               -- bázový typ
  check            : t_logical;

type
  -- výsledný typ atributu
  ttype            = enum
      tt_sub;                                    -- typ podvýrazu
      tt_range;                                  -- rozsah typu podvýrazu
      tt_size;                                   -- typ dynamického atributu :size
      tt_ancestor;                               -- :ancestor typu
      tt_root_ancestor;                          -- :root_ancestor typu
      tt_module_ancestor;                        -- :ancestor modulu
      tt_module_root_ancestor;                   -- :root_ancestor modulu
      tt_base;                                   -- :base                                       
      tt_root_base;                              -- :root_base                                  
      tt_ord;                                    -- odvodit typ ordinální hodnoty               
      tt_uarray_length;                          -- :length neomezeného pole                    
      tt_string_length;                          -- řetězcový :length                           
      tt_tag;                                    -- :tag                                        
      tt_uniint;                                 -- univerzální celé číslo                      
      tt_unireal;                                -- univerzální reálné číslo                    
      tt_unilogical;                             -- univerzální boolean                         
      tt_unistr;                                 -- univerzální řetězec znaků
      tt_unchecked;                              -- :unchecked
      end enum;                                  

var
  out_typ          : ttype;

    ------------------------------------------------------------------------------------------------
    procedure ct (
        typ        : in tdatatypeset;            -- povolené typy
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: <výraz typu TYP>:atribut --> :out_attr, atc_static.
    ------------------------------------------------------------------------------------------------
    begin
      result:=t_is_sts(expr^.sub^.t,typ) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ct;



    ------------------------------------------------------------------------------------------------
    procedure ctg (
        typ        : in tdatatypeset;            -- povolené typy
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
        return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: <výraz tagged typu TYP>:atribut --> :out_attr, atc_static.
    ------------------------------------------------------------------------------------------------
    begin
      result:=ct(typ,level,out_attr,_out_typ,out_class) and then tf_tagged in expr^.sub^.t.getctype^.tflags;
      end ctg;



    ------------------------------------------------------------------------------------------------
    procedure cd (
        rta        : in rtattrib;                -- požadovaný run-time atribut
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Test na dynamický atribut.
    ------------------------------------------------------------------------------------------------
    begin
      result:=x_rta_is_available(expr^.sub,rta);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_dynamic;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cd;



    ------------------------------------------------------------------------------------------------
    procedure cdt (
        typ        : in tdatatypeset;            -- povolené typy
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        rta        : in rtattrib;                -- požadovaný run-time atribut
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Jako CT plus test na dynamický atribut.
    ------------------------------------------------------------------------------------------------
    begin
      result:=ct(typ,level,out_attr,_out_typ,out_class) and x_rta_is_available(expr^.sub,rta);
      if result then
        expr^.aclass:=atc_dynamic;
        end if;
      end cdt;



    ------------------------------------------------------------------------------------------------
    procedure cn (
        ntype      : in nodetype;                -- povolený typ uzlu
        typ        : in tdatatypeset;            -- povolené typy
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, navíc výraz typu NTYPE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.ntype=ntype) and ct(typ,level,out_attr,_out_typ,out_class);
      end cn;



    ------------------------------------------------------------------------------------------------
    procedure cc (
        nclass     : in nodeclass;               -- povolená třída uzlu
        typ        : in tdatatypeset;            -- povolené typy
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
        out_aclass : in tattrclass;              -- třída atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, navíc výraz třídy NCLASS.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.nclass=nclass) and ct(typ,level,out_attr,_out_typ,out_class);
      if result then
        expr^.aclass:=out_aclass;
        end if;
      end cc;



    ------------------------------------------------------------------------------------------------
    procedure ctv (
        nclass     : in nodeclass;               -- povolená třída uzlu
        tview      : in ttypeviewset;            -- povolené pohledy na typ
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
        out_aclass : in tattrclass;              -- třída atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, navíc výraz třídy NCLASS.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.nclass=nclass) and (expr^.sub^.t.tview in tview) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=out_aclass;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ctv;



    ------------------------------------------------------------------------------------------------
    procedure ctvx (
        tview      : in ttypeviewset;            -- povolené pohledy na typ
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        out_attr   : in tattractual;             -- výsledný skutečný atribut
        out_aclass : in tattrclass;              -- třída atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CTV, ale bez kontroly třídy uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.t.tview in tview) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=out_aclass;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ctvx;



    ------------------------------------------------------------------------------------------------
    procedure cv (
        level      : in tentitydeclared;         -- požadovené vyhodnocení typu
        mclass     : in memclassset;             -- povolené paměťové třídy
        out_attr   : in tattractual;             -- výsledný skutečný atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- třída uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: výraz je proměnná uvedené paměťové třídy.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.ntype=nt_component)
          and (pexpcomponent(expr^.sub)^.s.psym^.etype=et_var)
          and (pentity_var(pexpcomponent(expr^.sub)^.s.psym)^.mclass in mclass);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cv;



    ------------------------------------------------------------------------------------------------
    procedure cent (
        etype     : in tentitytype;              -- požadovený typ entity
        out_attr  : in tattractual;              -- výsledný skutečný atribut
       _out_typ   : in ttype;                    -- typ atributu
        out_class : in nodeclass)                -- třída uzlu
        return t_logical =                       -- T-vyhovuje kontrole
    -- Kontrola: výraz je entita zadaného typu PTYPE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=expr^.sub^.getsymbol<>nil and then expr^.sub^.getsymbol^.etype=etype;
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cent;

var
  el               : pexpnode;                   -- podvýraz                                    
  arglist          : pexpitem;                   -- parametry                                   
  size             : tunidata_size;              -- velikost vytvářeného typu                   
  xt               : typeview;

begin
  -- rozdělit podvýrazy 
  expr^.split(el,arglist);

  -- vyhodnotit prefix 
  x_phase_next(curr,el,nulltype,eu_none,pred ep_final,info);
  if el^.zprac<pred ep_final then
    expr^.join(el,arglist);
    return;
    end if;

  -- %%TECH přestože dynamické atributy se určují až v další fázi zpracování
  -- výrazu, je možné se na ně odkazovat funkcí X_RTA_IS_AVAILABLE díky
  -- volání X_PHASE_NEXT výše.

  -- sloučit 
  expr^.join(el,arglist);

  -- zkusit, jestli to není jazykem definovaný atribut 
  a_getlangattr(expr^.id^,expr^.atf);

  if expr^.atf=atf_none

    -- uživatelem definovaný atribut 
    then
      unimplementedx({UNIMP=}000045,expr^.pos);

    -- jazykem definovaný atribut 
    else
      -- zkontrolovat, zda má atribut smysl 
      case expr^.atf
        -- :type
        when atf_type             do check:=ct(dts_all-dts_internal,etd_incomplete,ata_type_type,tt_sub,nc_type);

        -- :ancestor
        when atf_ancestor         do check:=cent(et_module,ata_module_ancestor,tt_module_ancestor,nc_module)
                                         or ct(dts_all-dts_internal,etd_incomplete{full},ata_type_ancestor,tt_ancestor,nc_type);

        -- :root_ancestor
        when atf_root_ancestor    do check:=cent(et_module,ata_module_root_ancestor,tt_module_root_ancestor,nc_module)
                                         or ct(dts_all-dts_internal,etd_incomplete{full},ata_type_root_ancestor,tt_root_ancestor,nc_type);

        -- :size
        when atf_size             do check:=cd(rta_size,ata_expr_size,tt_size,nc_value)
                                         or ct(dts_all-dts_internal,etd_full,ata_type_size,tt_uniint,nc_value)
                                         or ctvx(ttypeviewset:[tview_partial],etd_full,ata_type_size,atc_static,tt_uniint,nc_value);

        -- :bits
        when atf_bits             do check:=ct(dts_ordinal,etd_full,ata_ord_bits    ,tt_uniint,nc_value);

        -- :position
        when atf_position         do check:=cv(etd_full,mcs_offset,ata_var_position,tt_uniint,nc_value);

        -- :first
        when atf_first            do check:=ct(dts_ordinal,etd_full,ata_ord_first   ,tt_sub   ,nc_value)
                                         or ct(dts_array,  etd_full,ata_array_first ,tt_range ,nc_value)
                                         or ct(dts_string, etd_full,ata_string_first,tt_range ,nc_value);

        -- :last
        when atf_last             do check:=cd(rta_last           ,ata_expr_last   ,tt_range ,nc_value)
                                         or ct(dts_ordinal,etd_full,ata_ord_last    ,tt_sub   ,nc_value)
                                         or ct(dts_array,  etd_full,ata_array_last  ,tt_range ,nc_value)
                                         or ct(dts_string, etd_full,ata_string_last ,tt_range ,nc_value);

        -- :range {%%TODO(RTATTRIB) :length }
        when atf_range            do check:=ct (       dts_ordinal,etd_full         ,ata_ord_range                ,tt_sub          ,nc_type)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_range ,atc_dynamic,tt_range        ,nc_composite)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_range ,atc_dynamic,tt_range        ,nc_composite)
                                         or cn (nt_imm,dts_string ,etd_full         ,ata_string_range             ,tt_range        ,nc_composite)
                                         or cn (nt_imm,dts_u_string,etd_full        ,ata_string_range             ,tt_uniint       ,nc_composite)
                                         or ct (       dts_string ,etd_full         ,ata_string_range             ,tt_range        ,nc_type)
                                         or cdt(       dts_array  ,etd_full,rta_last,ata_array_range              ,tt_range        ,nc_composite)
                                         or ct (       dts_array  ,etd_full         ,ata_array_range              ,tt_range        ,nc_type);

        -- :length {%%TODO(RTATTRIB) :length }
        when atf_length           do check:=cdt(       tdatatypeset:[dt_uarray],etd_full,rta_last,ata_array_length             ,tt_uarray_length,nc_value)
                                         or ct (       tdatatypeset:[dt_array] ,etd_full         ,ata_array_length             ,tt_uniint       ,nc_value)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_length,atc_dynamic,tt_string_length,nc_var)
                                         or cn (nt_imm,dts_string ,etd_full         ,ata_string_length            ,tt_string_length,nc_value)
                                         or cn (nt_imm,dts_u_string,etd_full        ,ata_string_length            ,tt_uniint       ,nc_value)
                                         or ct (       dts_string ,etd_full         ,ata_string_length            ,tt_uniint       ,nc_value);
            
        -- :base
        when atf_base             do check:=ct(dts_base,etd_full,ata_type_base,tt_base,nc_type);

        -- :root_base
        when atf_root_base        do check:=ct(dts_base,etd_full,ata_type_root_base,tt_root_base,nc_type);

        -- :image
        when atf_image            do check:=cn(nt_imm,dts_u_ordinal,etd_full,ata_imm_ord_image,tt_unistr,nc_value);

        -- :unchecked
        when atf_unchecked        do check:=ctv(nc_var,ttypeviewset:[tview_unchecked,tview_partial],etd_full,ata_var_unchecked,atc_dynamic,tt_unchecked,nc_var)
                                         or cc(nc_var,dts_regular,etd_full,ata_var_unchecked,atc_dynamic,tt_unchecked,nc_var);

        -- :true
        when atf_true             do check:=ct(dts_u_logical,etd_full,ata_logical_true ,tt_sub,nc_value);

        -- :false
        when atf_false            do check:=ct(dts_u_logical,etd_full,ata_logical_false,tt_sub,nc_value);

        -- :ord
        when atf_ord              do check:=cc(nc_var  ,dts_ordinal,etd_full,ata_ord_ord,atc_dynamic,tt_ord,nc_var)
                                         or cn(nt_imm  ,dts_u_ordinal,etd_full,ata_ord_ord,tt_ord,nc_value)
                                         or cc(nc_value,dts_u_ordinal,etd_full,ata_ord_ord,atc_dynamic,tt_ord,nc_value);

        -- :tag
        when atf_tag              do check:=cd  (rta_tag,ata_expr_tag,tt_tag,nc_value)
                                         or cent(et_message,ata_message_tag,tt_tag,nc_value)
                                         or ctg (dts_all-dts_internal,etd_incomplete,ata_type_tag,tt_tag,nc_value);

        -- :tagged
        when atf_tagged           do check:=cd(rta_tag,ata_expr_tagged,tt_unilogical,nc_value)
                                         or ct(dts_all-dts_internal,etd_full,ata_expr_tagged,tt_unilogical,nc_value);

        -- :full
        when atf_full             do check:=ct(dts_set,etd_full,ata_set_full,tt_sub,nc_value);

        when others               do verify({VERIFY=}000114,true);
        end case;
      if not check then
        ce^.seterror({CCERR=}000464,ce_i_attr);
        ce^.setparam(entityident_to_string(expr^.id^));
        {%%X doplnit hint pro každý atribut }
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;

      -- typ výrazu
      case out_typ
        -- převzít typ podvýrazu
        when tt_sub        do expr^.t:=expr^.sub^.t;

        -- rozsah typu podvýrazu
        when tt_range      do expr^.t:=expr^.sub^.t.getrange(curr);

        -- typ dynamického atributu :size
        when tt_size       do
            -- odvodit nový typ
            cpu^.getrtattribsize(rta_size,size);
            expr^.newtype(curr,dt_unsigned,size);

        -- báze
        when tt_base       do expr^.t:=expr^.sub^.t.getbase(curr);

        -- předek typu
        when tt_ancestor   do expr^.t:=expr^.sub^.t.getancestor(curr);

        -- kořenový předek typu
        when tt_root_ancestor do unimplementedx({UNIMP=}000185,expr^.pos);

        -- předek modulu
        when tt_module_ancestor do expr^.xsym:=expr^.sub^.getsymbol^.ancestor.getuentity;

        -- kořenový předek modulu
        when tt_module_root_ancestor do unimplementedx({UNIMP=}000186,expr^.pos);

        -- odvodit typ ordinální hodnoty
        when tt_ord        do
            -- univerzální diskrétní typ --> univerzální integer
            if el^.t.stype in dts_unitype then expr^.settype(curr,def_uniint)
            -- signed --> signed
            elsif expr^.sub^.t.stype=dt_signed then expr^.newtype(curr,dt_signed,expr^.sub^.t.getsize)
            -- ostatní --> unsigned
            else expr^.newtype(curr,dt_unsigned,expr^.sub^.t.getsize);
            {%%X Otázka: Typ :ord aplikovaného na modulární typ je zase }
            -- modulární nebo ne ? Asi by neměl.
            end if;

        -- :length neomezeného pole
        when tt_uarray_length do
            -- odvodit nový typ
            cpu^.getrtattribsize(rta_size,size);
            expr^.newtype(curr,dt_unsigned,size);

        -- řetězcový length
        when tt_string_length do
            -- odvodit nový typ
            xt:=el^.t.getrange(curr);
            expr^.newtype(curr,xt.stype,xt.getsize);

            -- nastavit meze
            expr^.t.getctype^.lval:=ui_0;
            expr^.t.getctype^.hval:=xt.gethval;

        -- :tag
        when tt_tag        do
            -- odvodit nový typ
            cpu^.getrtattribsize(rta_tag,size);
            expr^.newtype(curr,dt_tag,size);

        -- univerzální typy
        when tt_uniint     do expr^.settype(curr,def_uniint);
        when tt_unireal    do expr^.settype(curr,def_unireal);
        when tt_unilogical do expr^.settype(curr,def_unilogical);
        when tt_unistr     do expr^.settype(curr,def_unistr); --x_unistr(curr,expr,def_unichar);

        -- unchecked
        when tt_unchecked  do expr^.setunchecked(curr,expr^.sub^.t);

        when others        do verify({VERIFY=}000116,true);
        end case;
      end if;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_attrib;



----------------------------------------------------------------------------------------------------
procedure a_form_aggregate (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpaggregate;       -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Agregát.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arglist          : pexpitem;                   -- seznam složek
  x                : pexpitem;                   -- seznam složek
  xel              : pexpnode;                   -- podvýrazy složky
  xer              : pexpnode;                   -- podvýrazy složky
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     
  ncs              : nodeclassset;               -- třída povolených hodnot podvýrazů

begin
  vyhodnoceno:=true;

  -- rozdělit podvýrazy 
  expr^.split(el,arglist);

  -- formální kontrola jména typu 
  if el<>nil then
    a_form(curr,el,info);
    vyhodnoceno:=vyhodnoceno and (el^.zprac>=ep_form);
    end if;

  -- vymyslet typ výrazu 
  if el<>nil

    -- kvalifikovaný výraz 
    then
      -- levý podvýraz musí být jednoznačný
      checkresolve(curr,el,nulltype,info);

      -- kontrola třídy podvýrazu 
      checkclass(curr,el,ncs_prefix_aggregate,ce_x_name_aggrtype,info);

      -- podvýraz musí být agregátní typ 
      checksts(curr,el,dts_aggregate,ce_x_name_aggrtype,'',info);

      -- převzít typ 
      expr^.t:=el^.t;

      -- jaké třídy hodnot podvýrazů povolíme v závislosti na typu agregátu ?
      if t_is_stype(expr^.t,dt_set)

        -- má-li to být množina, tak musíme povolit i rozsahy hodnot
        then ncs:=ncs_value+ncs_range

        -- jinak povolíme jen hodnoty
        else ncs:=ncs_value
        end if;

    -- nekvalifikovaný výraz => typ je libovolný agregátní typ 
    else
      -- inicializovat jako libovolný agregátní typ
      expr^.t.initaggregate;

      -- nevíme, jestli to nebude množina, tak povolit jak jednotlivé hodnoty, tak rozsahy hodnot
      ncs:=ncs_value+ncs_range;
      end if;

  -- vyhodnotit argumenty 
  x:=arglist;
  while x<>nil loop
    verify({VERIFY=}000219,x^.ntype<>nt_item);

    -- rozdělit podvýrazy 
    x^.split(xel,xer);

    -- formální kontrola hodnoty 
    if xel<>nil then a_form(curr,xel,info); end if;

    -- sloučit podvýrazy 
    x^.join(xel,xer);

    -- podvýraz musí být hodnota 
    if (xel<>nil) and (xel^.zprac>=ep_form) then checkclass(curr,xel,ncs{ncs_value},ce_i_expr,info); end if;

    -- %%TECH Formální kontrolu výběru nemohu v této fázi provádět, protože by
    -- se mohlo jednat o identifikátor složky recordu a v tuto chvíli ještě   
    -- nezmám typ agregátu (no, někdy už ano, ale s jistotou ho dovedu určit  
    -- až v následující fázi).                                                

    -- povedla se formální kontrola podvýrazů ? 
    vyhodnoceno:=vyhodnoceno and ((xel=nil) or (xel^.zprac>=ep_form));

    -- další podvýraz 
    x:=pexpitem(x^.next);
    end loop;

  -- sloučit podvýrazy
  expr^.join(el,arglist);  

  -- povedla se formální kontrola podvýrazů ? 
  if not vyhodnoceno then return; end if;

  -- třída výrazu 
  expr^.nclass:=nc_value;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_aggregate;


{ Ondra 16.7.2003+12.9.2003 : Explicitní volání speciálních metod zakázáno.

----------------------------------------------------------------------------------------------------
procedure a_form_callspec (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcallspec;        -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Volání speciální metody.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  if expr^.sub<>nil

    -- máme podvýraz, musí to být instance třídy nebo modul
    then
      -- formální kontrola podvýrazu 
      a_form(curr,expr^.sub,info);
      if expr^.sub^.zprac<ep_form then return; end if;

      -- kontrola třídy podvýrazu 
      -- (použít CHECKCLASS nepřinese zjednodušení) 
      case expr^.sub^.nclass
        -- proměnná nebo typ 
        when nc_var,nc_type do
            -- musí to být třída
            checksts(curr,expr^.sub,dts_class,ce_x_name_instance,'',info);

        -- modul
        when nc_module  do
            -- není co kontrolovat

        -- chyba
        when others do
            {%%X zpřesnit chybové hlášení }
            ce^.seterror({CCERR=}000465,ce_x_name_instance);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
        end case;

    -- nemáme podvýraz, najít implicitní speciální metodu 
    else
      -- najít nejbližší kontejnerový objekt 
      --%%TODO(optimize) Vzhledem k vlastnostem Flexu by klidně volání SYM_GET_CONTAINER
      -- mohlo být třikrát přímo v tom IFu. Bylo by to tak přehlednější.
      psym:=sym_get_container(curr.entity);

      -- musí to být třída nebo modul 
      if psym=nil or psym^.etype not in ets_modular
      -- a ADJUST, ROLLBACK, COMMIT lze navíc volat jen v třídě 
      or (expr^.spectype in tspectypeset:[tst_adjust,tst_rollback,tst_commit] and psym^.etype<>et_class)
      then
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000466,ce_i_callspec);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;
      end if;

  -- třída výrazu: nic, nevrací hodnotu 
  expr^.nclass:=nc_none;

  -- formální kontrola úspěšně dokončena 
  expr^.zprac:=ep_form;
  end a_form_callspec;
}


----------------------------------------------------------------------------------------------------
procedure a_form_current (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcurrent;         -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- CURRENT.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;
  node             : pexpcomponent;

begin
  -- najít odpovídající entitu   
  psym:=sym_get_enclosing_or_self(curr.entity,currentityinfo[expr^.entity].etype);
  if psym=nil then
    ce^.seterror({CCERR=}000467,ce_i_current_selector);
    expr^.errpos;
    ce^.resumeerror;
    end if;

  -- založit nový uzel 
  newnode(pexpnode(node),info,nt_component);

  -- komponenta 
  node^.s.set_entity(psym);

  -- dokončit formální kontrolu 
  a_form_component_finalize(curr,node,info);

  -- předat ven 
  pexpnode(expr):=pexpnode(node);
  end a_form_current;



----------------------------------------------------------------------------------------------------
procedure a_form =
-- Formální kontrola výrazu.                                                  
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000002,expr=nil);

  -- zpracovávat jen výrazy z bezprostředně předchozí fáze
  if expr^.zprac<>pred ep_form then return; end if;

  -- pokud je uzel chybný, nezpracovávat
  if expr^.erroneous then return end if;

  -- zkontrolovat výraz 
  case expr^.ntype
    -- binární operátor 
    when nt_operator  do a_form_operator(curr,pexpoper(expr),info);

    -- unární operátor
    when nt_unary     do a_form_unary(curr,pexpunary(expr),info);

    -- komponenta
    when nt_component do a_form_component(curr,pexpcomponent(expr),info);

    -- přímá hodnota
    when nt_imm       do a_form_imm(curr,pexpimm(expr),info);

    -- seznam argumentů
    when nt_list      do a_form_list(curr,pexplist(expr),info);

    -- rozsah
    when nt_range     do a_form_range(curr,pexprange(expr),info);

    -- index pole
    when nt_index     do a_form_index(curr,pexpindex(expr),info);

    -- reference
    when nt_ref       do a_form_ref(curr,pexpref(expr),info);

    -- dereference
    when nt_deref     do a_form_deref(curr,pexpderef(expr),info);

    -- atribut
    when nt_attrib    do a_form_attrib(curr,pexpattrib(expr),info);

    -- agregát
    when nt_aggregate do a_form_aggregate(curr,pexpaggregate(expr),info);

    -- interface cast
    when nt_interface_cast do a_form_interface_cast(curr,pexpinterfacecast(expr),info);
{
    -- Ondra 16.7.2003+12.9.2003 : Explicitní volání speciálních metod zakázáno.
    -- volání speciální metody
    when nt_callspec  do a_form_callspec(curr,pexpcallspec(expr),info);
}
    -- THIS
    when nt_this      do a_form_this(curr,pexpthis(expr),info);

    -- CURRENT
    when nt_current   do a_form_current(curr,pexpcurrent(expr),info);

    -- jiné symboly tu nemají co dělat
    when others       do verify({VERIFY=}000003,true);
    end case;

catch 
  when resume_error do
      -- kontrola
      verify({VERIFY=}000872,expr^.zprac>=ep_form);

      -- nastavit příznak, že tento uzel byl chybný
      expr^.erroneous:=true;

      -- znovu vyvolat vyjímku
      if not node_catch_resume_error(catch_mode,expr^.ntype) then raise;end if;
  end a_form;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initunarytab;
  end entry;



end cx_form;
