----------------------------------------------------------------------------------------------------
module private cx_form =
-- P©eklada‡ Flexu.
-- Form ln¡ anal˜za v˜razu.
----------------------------------------------------------------------------------------------------
-- Ondra : 29.08.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_lexsym,cc_sym,
  cd_decl,cd_decl.cd_unit,
  cx_util,cx_rta;


----------------------------------------------------------------------------------------------------
procedure a_form_imm (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpimm;             -- v˜raz
    info           : in expinfo);                -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola p©¡m‚ hodnoty.
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
procedure checkeval (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- souvisej¡c¡ v˜raz
    srch           : in out tentitysearch;       -- vyhledan˜ kontrolovan˜ symbol
    id             : in pentityident;            -- identifik tor symbolu
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Kontrola vyhodnocen¡ symbolu. Nevyhodnocen˜ symbol se pokus¡ vyhodnotit
-- alespo¤ do £rovnˆ deklarace symbolu.
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

begin
  -- symbol nen¡ k dispozici
  if srch.psym=nil then
    if etc_generic not in curr.entity^.compile {info.final}

      -- ale on se mˆl nal‚zt -> je to chyba
      then
        declare var
          undef         : pentity;               -- z stupce za nedefinovanou entitu
          undef_context : tcontext;              -- kontext z stupce za nedefinovanou entitu

        begin
          -- ohl sit chybu
          ce^.seterror({CCERR=}000040,ce_undeclared);
          ce^.setparam(entityident_to_string(id^));
          expr^.errpos;

          -- zalo‘it symbol typu ET_UNDEF coby prost©edek zotaven¡ z chyby
          d_create_internal(curr,undef,undef_context,et_undef,id);
          d_end_internal(undef^,false);

          -- nastavit jako v˜sledek 
          srch.set_entity(undef);

          -- poslat chybu v˜¨
          ce^.resumeerror;
          end declare;

      -- asi nˆjak  genericita
      else
        --info.generic:=true;
        {checkeval:=false;}
        return;
        end if;
    end if;
{
  -- ne£plnˆ vyhodnocen˜ symbol vyhodnotit
  if psym^.evaluated<psym^.declared then
    {%%X Tady se zcela zbyte‡nˆ po© d vyhodnocuje pozice v˜razu, co‡ je zna‡nˆ }
    -- netrivi ln¡ v˜po‡et. Nedal by se do E_SYMBOL a podobn˜ch procedur
    -- p©ed vat nˆjak‚ symbolick‚ ur‡en¡ pozice a pozici fyzicky zji¨Ÿovat a‘
    -- p©i nalezen¡ chyby ?
    expr^.getpos(pos);
    e_symbol(psym,pos,psym^.declared,info.final);
    end if;
}
  end checkeval;



----------------------------------------------------------------------------------------------------
procedure checkclass (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- souvisej¡c¡ v˜raz
    nclass         : in nodeclassset;            -- povolen‚ t©¡dy operandu
    code           : in terrorcode;              -- k¢d chyby
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Kontrola t©¡dy podv˜razu.
----------------------------------------------------------------------------------------------------
begin
  if expr^.nclass not in nclass then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000041,code);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checkclass;



----------------------------------------------------------------------------------------------------
procedure checksts (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- souvisej¡c¡ v˜raz
    sts            : in tdatatypeset;            -- povolen‚ typy operandu
    code           : in terrorcode;              -- k¢d chyby
    hint           : in t_char32ustr;            -- hint
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Kontrola typu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
  if not t_is_sts(expr^.t,sts) then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000042,code);
    ce^.setinfo(hint);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checksts;



----------------------------------------------------------------------------------------------------
procedure checkview (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- souvisej¡c¡ v˜raz
    tview          : in ttypeviewset;            -- povolen‚ pohledy na typ operandu
    code           : in terrorcode;              -- k¢d chyby
    hint           : in t_char32ustr;            -- hint
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Kontrola pohledu na typ podv˜razu.
----------------------------------------------------------------------------------------------------
begin
  if expr^.t.tview not in tview then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000043,code);
    ce^.setinfo(hint);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end checkview;



----------------------------------------------------------------------------------------------------
procedure checkresolve (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- v˜raz
    ptyp           : in typeview;                -- po‘adovan˜ typ v˜razu
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Je-li to pot©eba, tak vyhodnot¡ nejednozna‡n˜ v˜raz.
----------------------------------------------------------------------------------------------------
with
  cx_resolve;
  
begin
  if expr^.ntype in nts_ambiguous then
    a_resolve(curr,pexpambiguous(expr),ptyp,info);
    end if;
  end checkresolve;



------------------------------------------------------------------------------------------------
procedure check_aliased (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpnode;                -- obaluj¡c¡ v˜raz
    sub            : in pexpnode) =              -- kontrolovan˜ podv˜raz
-- Kontrola, zda je povolen ALIASED p©¡stup k podv˜razu.
-- V p©¡padech, jako je p©etypov n¡, vol  rekurzivnˆ samo sebe.
------------------------------------------------------------------------------------------------
begin
  case sub^.ntype
    -- komponenta
    when nt_component do
        verify(703,sub^.getsymbol=nil or else sub^.getsymbol^.etype<>et_var);
        
        -- na promˆnnou lze z¡skat referenci jen tehdy, je-li aliased
        if not pentity_var(sub^.getsymbol)^.valiased then
          ce^.seterror({CCERR=}000000,ce_i_reference);
          expr^.errpos;
          ce^.resumeerror;
          end if;

    -- index pole nebo ©etˆzce
    when nt_index do
        -- na slo‘ku pole nebo ©etˆzce lze z¡skat referenci jen tehdy, je-li aliased
        if not sub^.sub^.t.getctype^.saliased then
          ce^.seterror({CCERR=}000000,ce_i_reference);
          expr^.errpos;
          ce^.resumeerror;
          end if;

    -- dereference
    when nt_deref do 
        -- nic nedˆlat, reference je inverze dereference

    -- p©etypov n¡ 
    when nt_typecast do 
        check_aliased(curr,expr,sub^.sub^.next^.sub);

    -- interface cast
    when nt_interface_cast do 
        -- nic nedˆlat, reference je v‘dy dovolena

    -- THIS
    when nt_this do 
        -- nic nedˆlat, reference je v‘dy dovolena

    -- atribut
    when nt_attrib do
        check_aliased(curr,expr,sub^.sub);

      { Aha, a co takov‚ vˆci jako :unchechek, ‘e?
        -- nelze z¡skat referenci na atribut, a to ani na dynamick˜, proto‘e obecnˆ
        -- m–‘e b˜t vypo‡ten˜
        ce^.seterror({CCERR=}000000,ce_i_reference);
        expr^.errpos;
        ce^.resumeerror;
      }
{
    -- vol n¡ procedury resp. jej¡ n vratov  hodnota
    when nt_call do

    --
    when nt_operator, nt_unary do
}
    -- pro ostatn¡ p©¡pady nem  reference smysl
    -- %%TECH A‘ to tady zdechne na intern¡ chybu, tak viz t‚‘ pozn mka na konci [a_form_call]
    -- ve v˜po‡tu t©¡dy uzlu.
    when others do verify(704,true);
    end case;
  end check_aliased;



----- %%TECH ---------------------------------------------------------------------------------------
-- Pravidla typov‚ kompatibility jsou pops na rozhodovac¡ funkc¡
--     t : <oper tor, datov˜ typ, datov˜ typ> -> <akce>
-- kter  pro trojici oper tor, typ lev‚ho operandu, typ prav‚ho operandu
-- zvol¡ akci, kter  se m  nad oper torem prov‚st, nebo vr t¡ chybu
-- (v takov‚m p©¡padˆ jsou operandy nekompatibiln¡).
--
-- Postup p©i p©id v n¡ nov˜ch akc¡:
--   1. do TOPERACTION p©idat identifik tor (d le odkazovan˜ jako xxx)
--   2. do procedury INITOPERTAB doplnit souvisej¡c¡ pravidla
--   3. obsluhu akce d t do A_TYPE_OPERATOR
----------------------------------------------------------------------------------------------------

type
  -- akce
  tunaryaction  = enum
      una_error;                                 -- nekompatibiln¡ operandy
      una_el;                                    -- p©evz¡t typ lev‚ho podv˜razu
      end enum;

  -- ©¡d¡c¡ tabulka typov‚ kontroly bin rn¡ch oper tor–
  tunarytab        = array expunarytype,tdatatype of tunaryaction;

var
  unarytab         : tunarytab;

----------------------------------------------------------------------------------------------------
procedure uset11 (
    tab            : in out tunarytab;           -- ©¡d¡c¡ tabulka
    op             : in expunarytype;            -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=action;
  end uset11;



----------------------------------------------------------------------------------------------------
procedure usetss (
    tab            : in out tunarytab;           -- ©¡d¡c¡ tabulka
    op             : in expunarytypeset;         -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expunarytype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=action;
          end if;
        end loop;
      end if;
    end loop;
  end usetss;



----------------------------------------------------------------------------------------------------
procedure uset1s (
    tab            : in out tunarytab;           -- ©¡d¡c¡ tabulka
    op             : in expunarytype;            -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=action;
      end if;
    end loop;
  end uset1s;



----------------------------------------------------------------------------------------------------
procedure usets1 (
    tab            : in out tunarytab;           -- ©¡d¡c¡ tabulka
    op             : in expunarytypeset;         -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    action         : in tunaryaction) =          -- akce
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expunarytype loop
    if i in op then
      tab[i,stype]:=action;
      end if;
    end loop;
  end usets1;



----------------------------------------------------------------------------------------------------
procedure initunarytab =
-- Inicializace ©¡d¡c¡ tabulky typov‚ kontroly un rn¡ch oper tor–.
----------------------------------------------------------------------------------------------------
begin
  ---- + ----
  uset1s(unarytab,un_plus          ,dts_u_numeric,una_el);

  ---- - ----
  uset11(unarytab,un_minus         ,dt_signed    ,una_el);
  uset11(unarytab,un_minus         ,dt_uniint    ,una_el);
  uset1s(unarytab,un_minus         ,dts_u_float  ,una_el);

  ---- NOT ----
  uset1s(unarytab,un_not           ,dts_u_logical,una_el);

  ---- BIT NOT ----
  uset11(unarytab,un_bitnot        ,dt_unsigned  ,una_el);
  uset11(unarytab,un_bitnot        ,dt_uniint    ,una_el);

  ---- SET NOT ----
  uset11(unarytab,un_setnot        ,dt_set       ,una_el);

  ---- ABS ----
  uset11(unarytab,un_abs           ,dt_signed    ,una_el);
  uset11(unarytab,un_abs           ,dt_uniint    ,una_el);
  uset1s(unarytab,un_abs           ,dts_u_float  ,una_el);

  ---- SUCC/PRED ----
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_integer,una_el);
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_char   ,una_el);
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_u_logical,una_el);
  usets1(unarytab,expunarytypeset:[un_succ,un_pred],dt_enum      ,una_el);
  end initunarytab;



----------------------------------------------------------------------------------------------------
procedure checkparam (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    param          : in pentity_param;           -- form ln¡ parametr
    expr           : in pexpnode;                -- skute‡n˜ parametr
    typ            : in typeview;                -- typ v˜razu
    ok             : out t_logical) =            -- T-parametry si odpov¡daj¡
-- Kontrola form ln¡ho a skute‡n‚ho parametru p©et¡‘en‚ procedury.
----------------------------------------------------------------------------------------------------
var
  argt             : typeview;                   -- typ argumentu
  oclass           : toperclass;                 -- t©¡da operace p©ed n¡ parametru

begin
  -- p©edpoklad: nedopadne to dob©e
  ok:=false;

  -- ovˆ©it t©¡du v˜razu
  case param^.pass
    -- hodnotou nebo referenc¡
    when pp_value, pp_ref do
        case param^.mode
          -- IN => hodnota
          when pm_in            do 
              -- podv˜raz mus¡ b˜t hodnota
              -- %%X nebo typ, kdy‘ je to tag!
              if expr^.nclass not in ncs_value then return; end if;

              -- p©ed n¡ oby‡en‚ho IN parametru
              oclass:=toc_param_in;

          -- [ IN ] OUT => promˆnn 
          when pm_out, pm_inout do 
              -- podv˜raz mus¡ b˜t promˆnn 
              if expr^.nclass not in ncs_var then return; end if;

              -- p©ed n¡ oby‡ejn‚ho OUT parametru
              oclass:=toc_param_out;

          when others   do verify(294,true);
          end case;

    -- referenc¡, bez typov‚ kontroly
    when pp_unchecked do 
        -- podv˜raz mus¡ b˜t promˆnn 
        if expr^.nclass not in ncs_var then return; end if;

        -- p©ed n¡ UNCHECKED parametru
        oclass:=toc_param_unchecked;

    -- referenc¡, v‡etnˆ odvozen˜ch typ–
    when pp_class     do
        -- podv˜raz mus¡ b˜t promˆnn 
        if expr^.nclass not in ncs_var then return; end if;

        -- p©ed n¡ CLASS nebo VIRTUAL parametru
        oclass:=toc_param_class;

    -- referenc¡, ©¡d¡c¡ parametr virtu ln¡ho vol n¡
    when pp_virtual   do 
        -- podv˜raz mus¡ b˜t promˆnn 
        if expr^.nclass not in ncs_var then return; end if;

        -- p©ed n¡ CLASS nebo VIRTUAL parametru
        oclass:=toc_param_class;

    when others do verify(673,true);
    end case;

  -- ovˆ©it kompatibilitu typ–
  verify(293,param^.pass=pp_unchecked);
  argt.init(curr,param^.typ.getctype);
  if t_get_compatibility_level(curr,toc_param_class{oclass},false,argt,typ)<tcl_static_identical then return; end if;

  -- OK, kompatibiln¡
  ok:=true;

catch
  when others do
      expr^.errpos;
      raise;
  end checkparam;



----------------------------------------------------------------------------------------------------
procedure a_form_operator (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpoper;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola oper toru.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  er               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  elt              : ptypeview;                  -- typy podv˜raz–
  ert              : ptypeview;                  -- typy podv˜raz–
  rest             : typeview;                   -- typ v˜sledku
  level            : tcomplevel;                 -- £rove¤ kompatibility operand–
  restype          : tresulttype;                -- typ v˜sledku
  lop              : expopertype;                -- jazykem definovan˜ oper tor
  oop              : tooperator;                 -- p©et¡‘iteln˜ oper tor
  srch             : tentitysearch;              -- hled tko
  srchparam        : tentitysearch;              -- hled tko parametr–                          
  param            : pentity_param;              -- form ln¡ parametr                           
  pdesc            : poverloaddesc;              -- pro zjednodu¨en¡: popis p©et¡‘en‚ procedury 
  pproc            : pentity_subprogram;         -- pro zjednodu¨en¡: p©et¡‘en  procedura       
  ptyp             : pentity_type;               -- pro zjednodu¨en¡: typ procedury (oper toru) 
  ok               : t_logical;                  -- T-skute‡n˜ a form ln¡ parametr si odpov¡daj¡
  ui               : tuniint;

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el,er);

  -- form ln¡ kontrola lev‚ho podv˜razu 
  a_form(curr,el,info);

  -- form ln¡ kontrola prav‚ho podv˜razu 
  a_form(curr,er,info);

  -- slou‡it 
  expr^.join(el,er);

  -- povedla se form ln¡ kontrola podv˜raz– 
  if (el^.zprac<>ep_form) or (er^.zprac<>ep_form) then return; end if;

  -- speci ln¡ p©¡pad: porovn n¡ typ– 
  if (el^.nclass=nc_type) and (er^.nclass=nc_type) then
    unimplementedx(78,el^.pos);
{
  -- speci ln¡ p©¡pad: oper tory IN a NOT IN 
  elsif expr^.oper in [op_in,op_notin] then
    unimplemented(79);
}
  -- speci ln¡ p©¡pad: V˜raz IN Konstruktor rozsahu 
  elsif (expr^.oper in expopertypeset:[op_in,op_notin]) and (er^.nclass=nc_composite) then
    unimplementedx(79,expr^.pos);

  -- speci ln¡ p©¡pad: V˜raz IN Jm‚no typu
  elsif (expr^.oper in expopertypeset:[op_in,op_notin]) and (er^.nclass=nc_type) then
    unimplementedx(80,expr^.pos);

  -- v¨echny ostatn¡ p©¡pady 
  else
    -- podv˜razy mus¡ b˜t hodnoty 
    checkclass(curr,el,ncs_value,ce_i_expr,info);
    checkclass(curr,er,ncs_value,ce_i_expr,info);

    ----- %%X Optimalizace vyhled v n¡ p©et¡‘en˜ch oper tor– -------------
    -- 1. P©i deklaraci oper toru se do typu poznamen , ‘e k nˆmu existuje
    --    p©et¡‘en˜ oper tor a vyhled vat se bude jen pro takov‚ operandy,    
    --    kter‚ maj¡ univerz ln¡ typy, nebo typy s mo‘n˜m p©et¡‘en¡m.         
    -- 2. Kromˆ ukl d n¡ do tabulky symbol– zav‚st v ka‘d‚m symbolu je¨tˆ     
    --    speci ln¡ tabulku oper tor– a odkazy na v¨echny d le viditeln‚      
    --    podobn‚ tabulky (v nad©azen˜ch symbolech nebo p©es WITH/USE).       
    ----------------------------------------------------------------------

    -- zjistit si odpov¡daj¡c¡ p©et¡‘iteln˜ oper tor 
    oop:=expoperinfo[expr^.oper].oop;

    -- iterace p©es v¨echny dvojice typ– podv˜raz– 
    for eli in 0..el^.gettypecount-1 loop
      for eri in 0..er^.gettypecount-1 loop
        -- typy 
        el^.gettype(eli,elt);
        er^.gettype(eri,ert);

        -- up©esnit oper tor 
        x_refine_binary(expr^.oper,elt^,ert^,lop);

        -- zkusit jazykem definovan˜ oper tor 
        t_typecheck(curr,expoperinfo[lop].oc,expr^.assign,elt^,ert^,level,restype);
        if level<>tcl_incompatible then
          -- typ v˜sledku 
          case restype
            -- nic 
            when trt_none       do expr^.addtype(nulltype,eli,eri,nil);

            -- typ lev‚ho operandu (T1)
            when trt_left       do expr^.addtype(elt^,eli,eri,nil);

            -- typ prav‚ho operandu (T2)
            when trt_right      do expr^.addtype(ert^,eli,eri,nil);

            -- rozhodnout mezi T1 a T2
            when trt_resolve    do
                x_resolve(elt^,ert^,false,rest);
                expr^.addtype(rest,eli,eri,nil);
          {
            -- odvodit constrained string
            when trt_string    do
                -- vypo‡¡tat el:length+er:length
                ui:=elt^.getrange(curr).gethval+ert^.getrange(curr).gethval;

                -- odvodit typ
                t_derive_string(curr,ui,elt^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);

            -- odvodit constrained string z lev‚ho operandu
            when trt_string_el1 do
                -- vypo‡¡tat el:length+1
                ui:=elt^.getrange(curr).gethval+ui_1;

                -- odvodit typ
                t_derive_string(curr,ui,elt^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);

            -- odvodit constrained string z prav‚ho operandu
            when trt_string_er1 do
                -- vypo‡¡tat er:length+1
                ui:=ert^.getrange(curr).gethval+ui_1;

                -- odvodit typ
                t_derive_string(curr,ui,ert^.getbase(curr),ptyp);
                rest.init(curr,ptyp);
                expr^.addtype(rest,eli,eri,nil);
          }
            -- univerz ln¡ real
            when trt_unireal    do
                rest.init(curr,def_unireal);
                expr^.addtype(rest,eli,eri,nil);

            -- univerz ln¡ logical
            when trt_unilogical do
                rest.init(curr,def_unilogical);
                expr^.addtype(rest,eli,eri,nil);

            when others do verify(221,true);
            end case;
          end if;

        -- hledat p©et¡‘en˜ oper tor (je-li to p©et¡‘iteln˜ oper tor... 
        if (oop<>oop_none)
        -- ... a alespo¤ jeden operand je neuniverz ln¡ho typu) 
        and not (t_is_sts(elt^,dts_unitype) and t_is_sts(ert^,dts_unitype)) then
          -- %%X Tenhle algoritmus je a‘ na drobnosti stejn˜, 
          -- jako v A_FORM_UNARY. Ne¨lo by to zobecnit ?     

          -- prohledat v¨echny p©et¡‘en‚ oper tory
          srch.find_id_first(curr,^ooperinfo[oop].txt);
          while srch.psym<>nil loop

            -- prohledat v¨echny p©et¡‘en‚ procedury 
            for i in pentity_overload(srch.psym)^.table^:range loop
              -- popis p©et¡‘en‚ procedury 
              pdesc:=^pentity_overload(srch.psym)^.table^[i];

              -- zaj¡maj¡ n s jen bin rn¡ (ne)p©i©azovac¡ oper tory 
              if pdesc^.arity=toa_binary and pdesc^.assign=expr^.assign then
                -- p©et¡‘en  procedura 
                pproc:=pentity_subprogram(pdesc^.psym.getcentity);

                -- nebyla ji‘ procedura jednou £spˆ¨nˆ zpracov na ? 
                if not expr^.checktype(pproc) then

                  -- typ procedury 
                  ptyp:=pproc^.typ.getctype;

                  -- kontrola prvn¡ho parametru 
                  srchparam.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
                  verify(290,srchparam.psym=nil);
                  checkparam(curr,pentity_param(srchparam.psym),el,elt^,ok);

                  -- prvn¡ parametr odpov¡d , OK zkusit dal¨¡ 
                  if ok then
                    -- kontrola druh‚ho parametru 
                    srchparam.find_et_next;
                    verify(291,srchparam.psym=nil);
                    checkparam(curr,pentity_param(srchparam.psym),er,ert^,ok);

                    -- druh˜ parametr t‚‘ odpov¡d , OK za©adit na seznam 
                    if ok then
                      if expr^.assign

                        -- zkr cen‚ p©i©azen¡ => v˜sledek m  typ lev‚ho op. 
                        then expr^.addtype(elt^,eli,eri,pproc)

                        -- norm ln¡ oper tor => v˜sledek podle oper toru 
                        else
                          -- sestavit pohled na v˜sledek 
                          rest.init(curr,ptyp^.result^.typ.getctype);

                          -- parametry si odpov¡daj¡, za©adit dal¨¡ mo‘n˜ typ uzlu 
                          expr^.addtype(rest,eli,eri,pproc);
                          end if;
                      end if;
                    end if;
                  end if;
                end if;
              end loop;

            -- zkusit dal¨¡ oper tor 
            srch.find_id_next;
            end loop;
          end if;
        end loop;
      end loop;

    -- nalezl se alespo¤ jeden typ ? 
    if expr^.gettypecount=0 then
      {%%X zp©esnit chybov‚ hl ¨en¡ }
      ce^.seterror({CCERR=}000044,ce_incompatible);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;}
      ce^.resumeerror;
      end if;

    -- t©¡da uzlu: hodnota 
    expr^.nclass:=nc_value;
    end if;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_operator;



----------------------------------------------------------------------------------------------------
procedure a_form_unary (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpunary;           -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola un rn¡ho oper toru.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  elt              : ptypeview;                  -- typy podv˜raz–
  rest             : typeview;                   -- typ v˜sledku
  lop              : expunarytype;               -- jazykem definovan˜ oper tor                 
  oop              : tooperator;                 -- p©et¡‘iteln˜ oper tor                       
  srch             : tentitysearch;              -- hled tko
  srchparam        : tentitysearch;              -- hled tko parametr–                          
  param            : pentity_param;              -- form ln¡ parametr                           
  pdesc            : poverloaddesc;              -- pro zjednodu¨en¡: popis p©et¡‘en‚ procedury 
  pproc            : pentity_subprogram;         -- pro zjednodu¨en¡: p©et¡‘en  procedura       
  ptyp             : pentity_type;               -- pro zjednodu¨en¡: typ procedury (oper toru) 
  ok               : t_logical;                  -- T-skute‡n˜ a form ln¡ parametr si odpov¡daj¡

begin
  -- rozdˆlit podv˜raz 
  expr^.split(el);

  -- form ln¡ kontrola podv˜razu 
  a_form(curr,el,info);

  -- slou‡it 
  expr^.join(el);

  -- povedla se form ln¡ kontrola podv˜raz– 
  if el^.zprac<>ep_form then return; end if;

  -- podv˜raz mus¡ b˜t hodnota 
  checkclass(curr,el,ncs_value,ce_i_expr,info);

  -- zjistit si odpov¡daj¡c¡ p©et¡‘iteln˜ oper tor 
  oop:=expunaryinfo[expr^.oper].oop;

  -- iterace p©es v¨echny typy podv˜razu 
  for eli in 0..el^.gettypecount-1 loop
    -- typ 
    el^.gettype(eli,elt);

    -- zkusit jazykem definovan˜ oper tor 
    if t_is_sts(elt^,dts_all-dts_special) then
      -- up©esnit oper tor 
      x_refine_unary(expr^.oper,elt^,lop);

      -- typov  kontrola 
      case unarytab[lop,elt^.stype]
        -- chyba
        when una_error  do ;

        -- zvolit typ lev‚ho podv˜razu
        when una_el     do expr^.addtype(elt^,eli,0,nil);

        when others     do verify(43,true);
        end case;
      end if;

    -- hledat p©et¡‘en˜ oper tor (je-li to p©et¡‘iteln˜ oper tor... 
    if (oop<>oop_none)
    -- ... a operand je neuniverz ln¡ho typu) 
    and not t_is_sts(elt^,dts_unitype) then
      -- %%X Tenhle algoritmus je a‘ na drobnosti stejn˜,
      -- jako v A_FORM_OPERATOR. Ne¨lo by to zobecnit ?  

      -- prohledat v¨echny p©et¡‘en‚ oper tory 
      srch.find_id_first(curr,^ooperinfo[oop].txt);
      while srch.psym<>nil loop

        -- prohledat v¨echny p©et¡‘en‚ procedury 
        for i in pentity_overload(srch.psym)^.table^:range loop
          -- popis p©et¡‘en‚ procedury 
          pdesc:=^pentity_overload(srch.psym)^.table^[i];

          -- zaj¡maj¡ n s jen bin rn¡ (ne)p©i©azovac¡ oper tory 
          if (pdesc^.arity=toa_unary) and (pdesc^.assign=expr^.assign) then
            -- p©et¡‘en  procedura 
            pproc:=pentity_subprogram(pdesc^.psym.getcentity);

            -- typ procedury 
            ptyp:=pproc^.typ.getctype;

            -- kontrola prvn¡ho parametru 
            srchparam.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
            verify(290,srchparam.psym=nil);
            checkparam(curr,pentity_param(srchparam.psym),el,elt^,ok);

            -- prvn¡ parametr odpov¡d , OK za©adit na seznam 
            if ok then
              if expr^.assign

                -- zkr cen‚ p©i©azen¡ => v˜sledek m  typ lev‚ho op. 
                then expr^.addtype(elt^,eli,0,pproc)

                -- norm ln¡ oper tor => v˜sledek podle oper toru 
                else
                  -- sestavit pohled na v˜sledek 
                  rest.init(curr,ptyp^.result^.typ.getctype);

                  -- parametry si odpov¡daj¡, za©adit dal¨¡ mo‘n˜ typ uzlu 
                  expr^.addtype(rest,eli,0,pproc);
                  end if;
              end if;
            end if;
          end loop;

        -- zkusit dal¨¡ oper tor 
        srch.find_id_next;
        end loop;
      end if;
    end loop;

  -- nalezl se alespo¤ jeden typ ? 
  if expr^.gettypecount=0 then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000045,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

{ Star  verze bez p©et¡‘en¡:

  -- podv˜raz mus¡ b˜t hodnota 
  checkclass(curr,el,ncs_value,ce_i_expr,info);

  -- a mus¡ m¡t typ 
  checksts(curr,el,dts_all-dts_special,ce_i_expr,'',info);

  -- zmˆnit operand NOT --> BIT_NOT/SET_NOT 
  if expr^.oper=un_not then
    if t_is_sts(el^.t,dts_u_integer)  then x_setbitop(expr)
    elsif t_is_sts(el^.t,dts_u_set) then x_setsetop(expr); end if;
    end if;

  -- typov  kontrola 
  case unarytab[expr^.oper,el^.t.stype]
    -- chyba
    when una_error do
        {%%X zp©esnit chybov‚ hl ¨en¡ }
        ce^.seterror({CCERR=}000046,ce_incompatible);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end;

    -- zvolit typ lev‚ho podv˜razu
    when una_el do expr^.t:=el^.t;

    when others do verify(43,true);
    end case;
}
  -- t©¡da uzlu: hodnota 
  expr^.nclass:=nc_value;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_unary;



----------------------------------------------------------------------------------------------------
procedure a_form_param (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    arg            : in out pexpitem;            -- skute‡n˜ parametr
    param          : in pentity_param;           -- form ln¡ parametr
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola skute‡n‚ho parametru procedury.                          
----------------------------------------------------------------------------------------------------
begin
  --verify(701,arg^.itype not in expitemtypeset:[ei_expr,ei_ident]);

  -- podv˜raz mus¡ m¡t jednozna‡n˜ typ 
  if param^.pass=pp_unchecked
    then checkresolve(curr,arg^.sub,nulltype,info)
    else checkresolve(curr,arg^.sub,arg^.t,info);
    end if;

  -- kontrola t©¡dy podv˜razu a kompatibility typ– v z vislosti na zp–sobu p©ed n¡ parametru
  case param^.pass
    -- hodnotou nebo referenc¡
    when pp_value, pp_ref do
        case param^.mode
          -- IN
          when pm_in do
              -- podv˜raz mus¡ b˜t hodnota
              checkclass(curr,arg^.sub,ncs_value,ce_i_expr,info);

              -- typy mus¡ b˜t kompatibiln¡
              if not t_compatible(curr,toc_param_in,false,arg^.t,arg^.sub^.t) then
                {%%X zp©esnit chybov‚ hl ¨en¡ }
                ce^.seterror({CCERR=}000047,ce_incompatible);
                arg^.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

          -- [ IN ] OUT
          when pm_out,pm_inout do
              -- podv˜raz mus¡ b˜t promˆnn 
              checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

              -- typy mus¡ b˜t kompatibiln¡
              if not t_compatible(curr,toc_param_out,false,arg^.t,arg^.sub^.t) then
                {%%X zp©esnit chybov‚ hl ¨en¡ }
                ce^.seterror({CCERR=}000048,ce_incompatible);
                arg^.errpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;
              --u_nimplemented(13);

          when others do verify(292,true);
          end case;

    -- referenc¡, bez typov‚ kontroly
    when pp_unchecked do
        -- podv˜raz mus¡ b˜t promˆnn 
        checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

        -- typy mus¡ b˜t kompatibiln¡
        if not t_compatible(curr,toc_param_unchecked,false,arg^.t,arg^.sub^.t) then
          {%%X zp©esnit chybov‚ hl ¨en¡ }
          ce^.seterror({CCERR=}000048,ce_incompatible);
          arg^.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;
{
        -- %%X Doplnit kontrolu n sobku velikostu pro unconstrained array
        -- a unconstrained string a dynamick‚ kontroly

        -- m  form ln¡ parametr typ ?
        if arg^.t.hassize

          -- m  => skute‡n˜ parametr mus¡ m¡t stejnou velikost
          then
            -- %%X u_nimplemented(14);

          -- nem  => na typu skute‡n‚ho parametru nez le‘¡
          else
            { nic nedˆlat };
            end if;
}
    -- referenc¡, v‡etnˆ odvozen˜ch typ–
    when pp_class     do
        -- podv˜raz mus¡ b˜t promˆnn 
        checkclass(curr,arg^.sub,ncs_var,ce_x_name_var,info);

        -- typy mus¡ b˜t kompatibiln¡
        if not t_compatible(curr,toc_param_class,false,arg^.t,arg^.sub^.t) then
          {%%X zp©esnit chybov‚ hl ¨en¡ }
          ce^.seterror({CCERR=}000049,ce_incompatible);
          arg^.errpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;
        --u_nimplemented(72);

    -- referenc¡, ©¡d¡c¡ parametr virtu ln¡ho vol n¡
    when pp_virtual   do unimplemented(81);

    when others do verify(59,true);
    end case;
{
  -- kontrola aliased p©¡stupu pro aliased parametry
  if param^.paliased then
    check_aliased(curr,arg,arg^.sub);
    end if;
}
  end a_form_param;



----------------------------------------------------------------------------------------------------
procedure a_form_call (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexplist;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola vol n¡ procedury.
----------------------------------------------------------------------------------------------------
var
  proc             : pentity_type;               -- typ procedury

begin
  ----- %%LANG Po©ad¡ vyhodnocov n¡ parametr– ------------------------------------------------------
  -- Pozi‡n¡ parametry se vyhodnocuj¡ zleva doprava. Kl¡‡ov‚ parametry nemaj¡ p©esn‚ po©ad¡
  -- vyhodnocov n¡ definov no - kompil tor si je m–‘e p©eskl dat tak, jak se mu budou nejl‚pe
  -- ukl dat na stack.
  --------------------------------------------------------------------------------------------------

  ----- %%TECH P©erovn n¡ skute‡n˜ch parametr– -----------------------------------------------------
  -- P©eklada‡ p©erovn v  skute‡n‚ parametry podle po©ad¡ deklarace form ln¡ch parametr–, a to
  -- v‡etnˆ kl¡‡ov˜ch parametr–. P©i generov n¡ k¢du se vol¡ smˆr zpracov n¡ parametr– (zleva
  -- doprava nebo naopak) podle volac¡ konvence.
  --------------------------------------------------------------------------------------------------

  -- typ procedury 
  proc:=expr^.sub^.t.getutype;



  ----- Zpracovat v¨echny form ln¡ parametry procedury ---------------------------------------------
  declare var
    el                : pexpnode;                -- jm‚no procedury
    org_arglist       : pexpitem;                -- p–vodn¡ seznam skute‡n˜ch parametr–
    new_arglist_first : pexpitem;                -- set©¡dˆn˜ seznam skute‡n˜ch parametr–
    new_arglist_last  : pexpitem;                -- set©¡dˆn˜ seznam skute‡n˜ch parametr–
    arg               : pexpitem;                -- jeden skute‡n˜ parametr procedury
    param             : pentity_param;           -- form ln¡ parametry procedury
    param_srch        : tentitysearch;           -- vyhled v tko 

      ----------------------------------------------------------------------------------------------
      procedure param_available return t_logical =
      -- True, je-li k dispozici nˆjak˜ form ln¡ parametr a z rove¤ to nen¡ parametr reprezentuj¡c¡
      -- n vratovou hodnotu.
      ----------------------------------------------------------------------------------------------
      begin
        result:=param_srch.psym<>nil and then param_srch.psym<>proc^.result;
        end param_available;


  
      ----------------------------------------------------------------------------------------------
      procedure get_actual_arg =
      -- Oddˆl¡ prvn¡ skute‡n˜ parametr ze seznamu skute‡n˜ch parametr– [org_arglist] do [arg].
      ----------------------------------------------------------------------------------------------
      begin
        arg:=org_arglist;
        org_arglist:=org_arglist^.next;
        arg^.next:=nil;
        end get_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure find_actual_arg (
          id       : in tentityident) =
      -- Nalezne skute‡n˜ parametr [arg] podle identifik toru mezi kl¡‡ov˜mi parametry na seznamu
      -- skute‡n˜ch parametr– [org_arglist]. Nalezen˜ parametr ze seznamu odstran¡. Pokud nic
      -- nenajde, vr t¡ v [arg] nil a seznam nemˆn¡.
      ----------------------------------------------------------------------------------------------
      var
        parg       : pexpitem;                   -- p©edchoz¡ skute‡n˜ parametr na seznamu

      begin
        -- naj¡t parametr podle identifik toru 
        parg:=nil;
        arg:=org_arglist;
        while arg<>nil loop
          verify(700,arg^.itype<>ei_ident);

          -- je to on ?
          if arg^.id^=id then break end if;

          -- zkusit dal¨¡
          parg:=arg;
          arg:=arg^.next;
          end loop;

        -- na¨lo-li se, vy©adit ze seznamu
        if arg<>nil then
          if parg<>nil
            then parg^.next:=arg^.next
            else org_arglist:=arg^.next
            end if;
          end if;
        end find_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure put_actual_arg =
      -- Um¡st¡ pr vˆ zpracov van˜ skute‡n˜ parametr [arg] do nov‚ho seznamu skute‡n˜ch parametr– 
      -- [new_arglist].
      ----------------------------------------------------------------------------------------------
      begin
        -- pokud dojde k chybˆ p©i pou‘¡v n¡ implicitn¡ hodnoty, 
        -- nemus¡ b˜t skute‡n˜ parametr v–bec zn m
        if arg=nil then return end if;

        -- za©adit na seznam
        if new_arglist_last<>nil
          then new_arglist_last^.next:=arg
          else new_arglist_first:=arg
          end if;
        new_arglist_last:=arg;
        end put_actual_arg;



      ----------------------------------------------------------------------------------------------
      procedure pair_args =
      -- Sp ruje skute‡n˜ parametr [arg] s form ln¡m parametrem [param].
      ----------------------------------------------------------------------------------------------
      begin
        -- ke skute‡n‚mu parametru p©i©adit form ln¡ parametr, aŸ se to p©¡¨tˆ l‚pe hled  
        arg^.sym:=param;

        -- po‘adovan˜ typ parametru 
        x_set_param_type(curr,param,arg);
        end pair_args;



      ----------------------------------------------------------------------------------------------
      procedure check_default_value =
      -- Zkontroluje, jestli m  form ln¡ parametr [param] implicitn¡ hodnotu.
      ----------------------------------------------------------------------------------------------
      begin
        if param^.mode<>pm_in or not param^.init.isset then
          ce^.seterror({CCERR=}000051,ce_param_no_default_value);
          ce^.setparam(entityident_to_string(param^.id^));
          if arg<>nil 
            then arg^.errpos 
            else el^.errpos
            end if;
          ce^.resumeerror;
          end if;
        end check_default_value;



      ----------------------------------------------------------------------------------------------
      procedure add_default_value =
      -- Do skute‡n‚ho parametru dopln¡ implicitn¡ hodnotu.
      ----------------------------------------------------------------------------------------------
      with 
        cx_expr.cx_imm;

      begin
        -- zalo‘it nov˜ uzel reprezentuj¡c¡ implicitn¡ hodnotu
        newnode(arg^.sub,info,nt_imm);

        -- typ uzlu
        arg^.sub^.settype(curr,param^.typ.getctype);

        -- druh p©¡m‚ hodnoty
        pexpimm(arg^.sub)^.immkind:=iek_imm;

        -- hodnota
        store_imm(pexpimm(arg^.sub)^.imm,param^.init.getimm^);

        -- form ln¡ kontrola novˆ vznikl‚ hodnoty ([a_form_param] kontrolu podv˜raz– 
        -- nevol , proto‘e to zaji¨Ÿuje nad©azen  rutina je¨tˆ nad [a_form_call])
        a_form_imm(curr,arg^.sub,info);
        
        -- form ln¡ kontrola novˆ vznikl‚ho parametru
        a_form_param(curr,arg,param,info);
        end add_default_value;

      

      ----------------------------------------------------------------------------------------------
      procedure create_default_arg =
      -- Pro aktu ln¡ form ln¡ parametr [param] sestav¡ implicitn¡ skute‡n˜ parametr [arg].
      ----------------------------------------------------------------------------------------------
      begin
        arg:=nil;

        -- form ln¡ parametr mus¡ m¡t implicitn¡ hodnotu
        check_default_value;

        -- zalo‘it nov˜ uzel reprezentuj¡c¡ implicitn¡ hodnotu
        newnode(arg,info,nt_item);

        -- typ parametru
        arg^.itype:=ei_empty;

        -- sp rovat skute‡n˜ a form ln¡ parametr
        pair_args;

        -- doplnit implicitn¡ hodnotu do skute‡n‚ho parametru
        add_default_value;

      catch
        -- p©¡padnou chybu zachytit a nepustit d l
        when resume_error do -- nic nedˆlat
        end create_default_arg;

  begin
    -- rozdˆlit podv˜razy 
    expr^.split(el,org_arglist);
 
    -- inicializovat hled n¡ parametr–
    param_srch.find_et_first(proc,rc_primary,et_param,[]);


    ----- 1. Zpracovat v¨echny pozi‡n¡ parametry ---------------------------------------------------
    while (param_available and org_arglist<>nil) and then org_arglist^.itype in expitemtypeset:[ei_expr,ei_empty] loop
      -- pro zjednodu¨en¡ form ln¡ parametr
      param:=param_srch.psym;

      -- oddˆlit jeden skute‡n˜ parametr
      get_actual_arg;

      -- sp rovat skute‡n˜ a form ln¡ parametr
      pair_args;

      -- zpracovat 
      case arg^.itype
        -- implicitn¡ parametr
        when ei_empty do
            begin
              -- form ln¡ parametr mus¡ m¡t implicitn¡ hodnotu
              check_default_value;

              -- doplnit implicitn¡ hodnotu do skute‡n‚ho parametru
              add_default_value;

            catch
              -- p©¡padnou chybu zachytit a nepustit d l
              when resume_error do -- nic nedˆlat
              end;

        -- pozi‡n¡ parametr
        when ei_expr do
            -- form ln¡ kontrola parametru
            a_form_param(curr,arg,param,info);

        when others do verify(249,true);
        end case;

      -- um¡stit pr vˆ zpracovan˜ skute‡n˜ parametr na seznam skute‡n˜ch parametr–
      put_actual_arg;

      -- dal¨¡ form ln¡ parametr
      param_srch.find_et_next;
      end loop;


    ----- 2. Zpracovat v¨echny kl¡‡ov‚ parametry ---------------------------------------------------
    while (param_available and org_arglist<>nil) and then org_arglist^.itype=ei_ident loop
      -- pro zjednodu¨en¡ form ln¡ parametr
      param:=param_srch.psym;
      
      -- dohledat parametr podle identifik toru
      find_actual_arg(param^.id^);

      -- na¨el se skute‡n˜ parameter ?
      if arg<>nil 
      
        -- ano => zkontrolovat
        then
          -- sp rovat skute‡n˜ a form ln¡ parametr
          pair_args;

          -- form ln¡ kontrola parametru
          a_form_param(curr,arg,param,info);

        -- ne => pou‘¡t implicitn¡ hodnotu
        else
          -- sestavit implicitn¡ parametr
          create_default_arg;
          end if;

      -- um¡stit pr vˆ zpracovan˜ skute‡n˜ parametr na seznam skute‡n˜ch parametr–
      put_actual_arg;

      -- dal¨¡ form ln¡ parametr
      param_srch.find_et_next;
      end loop;


    ----- 3. Do©e¨it p©ebytky ----------------------------------------------------------------------
    -- zbyly nˆjak‚ form ln¡ parametry ? => pou‘¡t implicitn¡ hodnoty
    while param_available loop
      -- pro zjednodu¨en¡ form ln¡ parametr
      param:=param_srch.psym;
      
      -- sestavit implicitn¡ parametr
      create_default_arg;

      -- um¡stit pr vˆ zpracovan˜ skute‡n˜ parametr na seznam skute‡n˜ch parametr–
      put_actual_arg;

      -- dal¨¡ form ln¡ parametr
      param_srch.find_et_next;
      end loop;

    -- zbyly nˆjak‚ skute‡n‚ parametry ? => ohl sit chyby
    while org_arglist<>nil loop
      -- oddˆlit jeden skute‡n˜ parametr
      get_actual_arg;

      -- zpracovat
      case arg^.itype
        -- implicitn¡ nebo pozi‡n¡ parametr
        when ei_expr,ei_empty do
            -- ohl sit nabyte‡n˜ parametr
            ce^.seterror({CCERR=}000000,ce_param_excessive);
            arg^.errpos;

        -- kl¡‡ov˜ parametr
        when ei_ident do
            -- existuje parametr tohoto jm‚na ? 
            param_srch.find_local_all(sym_primary_context(proc^),arg^.id^);
            if param_srch.psym<>nil

              -- ano => pak byla jeho hodnota ji‘ ur‡ena, ohl sit duplicitn¡ parametr
              then
                ce^.seterror({CCERR=}000000,ce_param_duplicate);
                ce^.setparam(entityident_to_string(arg^.id^));
                arg^.errpos;

              -- ne => ohl sit neexistuj¡c¡ parametr
              else
                ce^.seterror({CCERR=}000000,ce_param_unknown);
                ce^.setparam(entityident_to_string(arg^.id^));
                arg^.errpos;
                end if;

        -- nic jin‚ho neum¡me
        when others do verify(702,true);
        end case;     
      end loop;


    -- slou‡it podv˜razy
    expr^.join(el,new_arglist_first);
    end declare;



  ----- Zpracovat n vratovou hodnotu ---------------------------------------------------------------
  if proc^.result<>nil

    -- procedura m  n vratovou hodnotu 
    then
      -- typ v˜razu 
      expr^.settype(curr,proc^.result^.typ.getutype);

      -- t©¡da uzlu : hodnota 
      expr^.nclass:=nc_value;

      -- %%TECH Pokud se zde nˆkdy kv–li p©ed v n¡ n vratov‚ hodnoty referenc¡ zmˆn¡ t©¡da uzlu na
      -- [nc_var], tak se s t¡m mus¡ po‡¡tat v [a_form_ref]! Reference n vratov‚ hodnoty procedury
      -- pochopitelnˆ nem  smysl. Zat¡m se v takov‚m p©¡padˆ v [a_form_ref] ohl s¡ intern¡ chyba,
      -- ale je to pouze vedlej¨¡ efekt kontroly povolen¡ ALIASED p©¡stupu.

    -- procedura nem  n vratovou hodnotu 
    else
      -- t©¡da uzlu : nic 
      expr^.nclass:=nc_none;
      end if;

  -- zmˆnit typ uzlu 
  expr^.ntype:=nt_call;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_call;



----------------------------------------------------------------------------------------------------
procedure a_form_message_send (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexplist;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola odesl n¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- parametry
  arg              : pexpitem;                   -- parametr

begin
  -- %%TECH P©edpokl d  se, ‘e form ln¡ kontrola prefixu i parametr– ji‘ byla
  -- provedena a ‘e typ podv˜razu je zpr va.

  -- oddˆlit prefix a parametry 
  expr^.get(el,arglist);

  -- prefix mus¡ m¡t jednozna‡n˜ typ 
  checkresolve(curr,el,nulltype,info);

  -- prefix mus¡ b˜t typu zpr va 
  checksts(curr,el,dts_message,ce_i_prefix,hint_prefix_message,info);

  -- prefix mus¡ b˜t zpr va 
  checkclass(curr,el,ncs_prefix_send,ce_i_prefix,info);

  -- kontrola parametr– 
  arg:=arglist;
  while arg<>nil loop
    unimplementedx(100,arg^.sub^.pos);
    end loop;

  -- zmˆnit typ uzlu 
  expr^.ntype:=nt_send;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_message_send;



----------------------------------------------------------------------------------------------------
procedure a_form_message_accept (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexplist;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola p©ijet¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- parametry
  arg              : pexpitem;                   -- parametr                                    

begin
  -- %%TECH P©edpokl d  se, ‘e form ln¡ kontrola prefixu i parametr– ji‘ byla
  -- provedena a ‘e typ podv˜razu je zpr va.

  -- oddˆlit prefix a parametry 
  expr^.get(el,arglist);

  -- prefix mus¡ m¡t jednozna‡n˜ typ 
  checkresolve(curr,el,nulltype,info);

  -- prefix mus¡ b˜t typu zpr va 
  checksts(curr,el,dts_message,ce_i_prefix,hint_prefix_message,info);

  -- prefix mus¡ b˜t zpr va 
  checkclass(curr,el,ncs_prefix_accept,ce_i_prefix,info);

  -- kontrola parametr– 
  arg:=arglist;
  while arg<>nil loop
    unimplementedx(100,arg^.sub^.pos);
    end loop;

  -- zmˆnit typ uzlu 
  expr^.ntype:=nt_accept;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_message_accept;



----------------------------------------------------------------------------------------------------
procedure a_form_deref (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpderef;           -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Dereference.
----------------------------------------------------------------------------------------------------
var
  base             : typeview;                   -- b zov˜ typ
  el               : pexpnode;                   -- podv˜raz                                    

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el);

  -- form ln¡ kontrola podv˜razu 
  a_form(curr,el,info);

  -- slou‡it podv˜razy 
  expr^.join(el);

  -- povedla se form ln¡ kontrola podv˜raz– 
  if el^.zprac<>ep_form then return; end if;

  -- podv˜raz mus¡ b˜t jednozna‡n˜ 
  checkresolve(curr,el,nulltype,info);

  -- kontrola t©¡dy podv˜razu 
  checkclass(curr,el,ncs_prefix_deref,ce_i_prefix,info);

  -- kontrola typu podv˜razu 
  checksts(curr,el,dts_pointer,ce_i_prefix,'',info);

  -- typ v˜razu 
  base:=el^.t.getbase(curr);
  verify(110,(el^.t.getpbase<>pb_unchecked) and (base.tview=tview_null));
  if base.tview<>tview_null
    -- typ b ze je ur‡en (nen¡ UNCHECKED i kdy‘ PBASE=PB_UNCHECKED)
    then expr^.t:=base
    -- typ b ze nen¡ ur‡en, dosadit jako unchecked
    else expr^.setunchecked(curr,base);
    end if;

  -- t©¡da uzlu: podle podv˜razu 
  expr^.nclass:=x_get_deref_nclass(el);

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_deref;



----------------------------------------------------------------------------------------------------
procedure a_form_this (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpthis;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- THIS.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  -- z¡skat kontejner, bude se hodit
  psym:=sym_get_container(curr.entity);

  -- mus¡me b˜t nˆkde v t©¡dˆ 
  if psym^.etype<>et_class then 
    -- %%X zp©esnit chybov‚ hl ¨en¡
    ce^.seterror({CCERR=}000052,ce_i_this);
    expr^.errpos;
    ce^.resumeerror;
    end if;

  -- t©¡da v˜razu: promˆnn‚ 
  expr^.nclass:=nc_var;

  -- typ v˜razu: nalezen  t©¡da 
  expr^.settype(curr,pentity_type(psym));

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_this;



----------------------------------------------------------------------------------------------------
procedure a_form_component_finalize (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpcomponent;       -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Dokon‡en¡ form ln¡ kontroly komponenty.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure create_this =
    -- Coby EXPR^.SUB dopln¡ uzel reprezentuj¡c¡ THIS.
    ------------------------------------------------------------------------------------------------
    begin
      -- vznikl novy uzel 
      newnode(expr^.sub,info,nt_this);

      -- form ln¡ kontrola 
      a_form_this(curr,pexpthis(expr^.sub),info);
      end create_this;

var
  ptyp             : pentity_type;               -- typ promˆnn‚                                
  pproc            : pentity_subprogram;         -- procedura (pro zjednodu¨en¡)

begin
  -- zv˜¨it po‡et pou‘it¡ symbolu
  succ expr^.s.psym^.stat_usage;

  -- zjistit o symbolu r–zn‚ zaj¡mav‚ £daje 
  case expr^.s.psym^.etype
    -- nedefinovan˜ symbol (zotaven¡ z chyby)
    when et_undef do
        -- chyba ji‘ byla hl ¨ena, jen p©esko‡it tento v˜raz
        ce^.resumeerror;

    -- promˆnn 
    when et_var do
        -- typ v˜razu
        ptyp:=pentity_var(expr^.s.psym)^.typ.getutype;
        if ptyp<>nil
          -- typovan˜ v˜raz
          then expr^.settype(curr,pentity_var(expr^.s.psym)^.typ.getutype)
          -- unchecked v˜raz
          else expr^.settypeunchecked(curr,ptyp);
          end if;

        -- t©¡da uzlu
        -- slo‘ka t©¡dy
        if (expr^.sub=nil) and (pentity_var(expr^.s.psym)^.mclass=mc_class) and sym_check_container(curr.entity,et_class) then
          -- t©¡da: promˆnn‚
          expr^.nclass:=nc_var;

          -- doplnit THIS
          create_this;

        -- slo‘ka typu
        elsif (expr^.sub<>nil) and (expr^.sub^.nclass=nc_type)
        and (pentity_var(expr^.s.psym)^.mclass in mcs_offset) then
          -- t©¡da: typ
          expr^.nclass:=nc_type

        -- slo‘ka recordu
        elsif (expr^.sub=nil) and (pentity_var(expr^.s.psym)^.mclass=mc_record) then
          expr^.nclass:=nc_type;

        -- jinak je to opravdu promˆnn 
        else
          verify(465,(pentity_var(expr^.s.psym)^.mclass in mcs_offset) and (expr^.sub=nil));

          -- t©¡da: promˆnn‚
          expr^.nclass:=nc_var;
          end if;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- konstanta
    when et_const do
        -- typ v˜razu
        expr^.settype(curr,pentity_const(expr^.s.psym)^.typ.getctype);

        -- t©¡da uzlu: typ
        expr^.nclass:=nc_value;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- v˜‡tov˜ prvek
    when et_enum do
        -- typ v˜razu
        expr^.settype(curr,pentity_enum(expr^.s.psym)^.typ);

        -- t©¡da uzlu: typ
        expr^.nclass:=nc_value;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- parametr procedury
    when et_param do
        -- typ v˜razu
        ptyp:=pentity_param(expr^.s.psym)^.typ.getutype;
        if ptyp<>nil
          -- typovan˜ v˜raz
          then expr^.settype(curr,pentity_var(expr^.s.psym)^.typ.getutype)
          -- unchecked v˜raz
          else expr^.settypeunchecked(curr,ptyp)
          end if;

        -- t©¡da uzlu: typ
        expr^.nclass:=nc_type;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- typ/t©¡da
    when et_type, et_class do
        -- typ v˜razu
        expr^.settype(curr,pentity_type(expr^.s.psym));

        -- t©¡da uzlu: typ
        expr^.nclass:=nc_type;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- procedura, metoda
    when et_procedure, et_static, et_virtual do
        -- pro zjednodu¨en¡
        pproc:=pentity_procedure(expr^.s.psym);

        -- typ v˜razu
        expr^.settype(curr,pproc^.typ.getutype);

        -- t©¡da uzlu se ur‡¡ podle zp–sobu p©ed v n¡ a dostupnosti instance
        case pproc^.instance
          -- nep©ed vat => t©¡da: procedura
          when tip_none     do expr^.nclass:=nc_proc;

          -- volitelnˆ => t©¡da: procedura
          when tip_optional do
              -- t©¡da: procedura
              expr^.nclass:=nc_proc;

              -- pokud nem me explicitnˆ uvedenu instanci
              -- a je-li to v t©¡dˆ, tak doplnit THIS
              if (expr^.sub=nil) and sym_check_container(curr.entity,et_class) then
                create_this;
                end if;

          -- p©ed vat => t©¡da: procedura nebo nic podle dostupnosti instance
          when tip_pass,tip_dispatch do
              -- rozhodnout se podle podv˜razu
              -- podv˜raz nen¡, nejsme v t©¡dˆ ?
              if expr^.sub=nil then
                -- je to v t©¡dˆ ?
                if sym_check_container(curr.entity,et_class)

                  -- ano => t©¡da: procedura + doplnit THIS
                  then
                    expr^.nclass:=nc_proc;
                    create_this;

                  -- ne => t©¡da: nic
                  else
                    expr^.nclass:=nc_none;
                    end if;

              -- podv˜raz je promˆnn  => m me instanci => t©¡da: procedura
              elsif expr^.sub^.nclass in ncs_value then 
                expr^.nclass:=nc_proc

              -- podv˜raz je, ale nen¡ to promˆnn  => t©¡da: nic
              else
                expr^.nclass:=nc_proc
                end if;

          when others do verify(378,true);
          end case;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

        -- doplnit implicitn¡ vol n¡
        if (nf_name in expr^.nflags
        and (nf_top not in expr^.nflags or info.kind not in eks_proc)
        -- Ondra 18.9.2001 : Pouze pokud nechceme referenci na proceduru
        and nf_reference not in expr^.nflags)
        -- Ondra 11.10.2001 : Nebo pokud se v˜sledek bude dereferencovat }
        or nf_dereference in expr^.nflags then
          -- zv˜¨it strom
          newtree(pexpnode(expr),info,nt_call);

          -- form ln¡ kontrola vol n¡
          a_form_call(curr,pexplist(pexpnode(expr)),info);
          end if;

    -- zpr va
    when et_message     do
        -- typ v˜razu
        expr^.settype(curr,pentity_message(expr^.s.psym)^.typ.getutype);

        -- t©¡da uzlu: zpr va
        expr^.nclass:=nc_message;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

        -- m–‘e to b˜t send/accept
        if info.kind in eks_message and {%%TODO(IN) (nodeflagset:[nf_name,nf_top]<=expr^.nflags)}
        nf_name in expr^.nflags and nf_top in expr^.nflags then
          -- zv˜¨it strom
          newtree(pexpnode(expr),info,nt_list);

          -- form ln¡ kontrola
          case info.kind
            -- odesl n¡ zpr vy
            when ek_context_send   do a_form_message_send(curr,pexplist(pexpnode(expr)),info);

            -- p©ijmut¡ zpr vy
            when ek_context_accept do a_form_message_accept(curr,pexplist(pexpnode(expr)),info);

            when others do verify(305,true);
            end case;
          end if;

    -- p©et¡‘en¡

    -- speci ln¡ metoda

    -- generick˜ parametr

    -- modul
    when et_module do
        -- t©¡da uzlu: modul
        expr^.nclass:=nc_module;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- program
    when et_program     do
        -- t©¡da uzlu: nic
        expr^.nclass:=nc_none;

        -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
        expr^.zprac:=ep_form;

    -- jin‚ symboly neum¡m zpracovat
    when others do
        ce^.seterror({CCERR=}000053,ce_i_symbol);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;
  end a_form_component_finalize;



----------------------------------------------------------------------------------------------------
procedure a_form_component (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpcomponent;       -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola komponenty.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- nalezen˜ symbol

    ------------------------------------------------------------------------------------------------
    procedure find_in_class =
    -- Vyhled n¡ komponenty v t©¡dˆ.
    ------------------------------------------------------------------------------------------------
    var
      sv           : tentityvisibleset;          -- povolen‚ £rovnˆ viditelnosti

    begin
      -- povolen‚ £rovnˆ viditelnosti hledan‚ho symbolu
      sym_get_visibility(curr.entity,expr^.sub^.t.getutype,sv);

      -- nejsou povoleny ‘ dn‚ £rovnˆ viditelnosti => hled n¡ (selektor) je zak z no
      if sv=tentityvisibleset:[] then
        ce^.seterror({CCERR=}000054,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      --%%TODO(Ondra): Pokud je EXPR^.SUB^.T.GETUTYPE^ roven CURR.ENTITY, pop©¡padˆ nˆjak‚ nad©azen‚
      -- entita, tak by se spr vnˆ mˆl dohledat kontext podle kontextu CURR, proto‘e jinak nap©¡klad
      -- P.X m–‘e b˜t nˆco jin‚ho ne‘ prost‚ X.

      -- vyhledat
      srch.find_local(sym_primary_context(expr^.sub^.t.getutype^),expr^.id^,sv);
      end find_in_class;



    ------------------------------------------------------------------------------------------------
    procedure find_in_entity =
    -- Vyhled n¡ komponenty v souvisej¡c¡ entitˆ.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym.cc_advanced;

    var
      sv           : tentityvisibleset;          -- povolen‚ £rovnˆ viditelnosti

    begin
      -- podv˜raz mus¡ b˜t komponenta nebo atribut s ur‡en˜m souvisej¡c¡m symbolem
      if expr^.sub^.ntype not in nodetypeset:[nt_component,nt_attrib] or else expr^.sub^.getsymbol=nil then
        ce^.seterror({CCERR=}000055,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      -- povolen‚ £rovnˆ viditelnosti hledan‚ho symbolu
      sym_get_visibility(curr.entity,expr^.sub^.getsymbol,sv);

      -- jestli‘e nejsou povoleny ‘ dn‚ £rovnˆ viditelnosti
      if sv=tentityvisibleset:[] 
      -- a p©ekl dan˜ v˜raz bude pou‘it jako jm‚no v nˆjak‚ vazebn¡ klauzuli
      and info.kind in eks_link 
      -- a podv˜raz reprezentuje modul nebo t©¡du
      and expr^.sub^.getsymbol^.etype in ets_modular 
      -- m–‘eme to zkusit zachr nit automatick˜m USE
      then
        -- automatick‚ USE
        sym_add_with(curr,expr^.sub,expr^.sub^.getsymbol,twm_use,twl_normal);

        -- a zkusit zjistit viditelnost je¨tˆ jednou
        sym_get_visibility(curr.entity,expr^.sub^.getsymbol,sv);
        end if;

      -- nejsou povoleny ‘ dn‚ £rovnˆ viditelnosti => hled n¡ (selektor) je zak z no
      if sv=tentityvisibleset:[] then
        ce^.seterror({CCERR=}000056,ce_i_selector);
        expr^.errpos;
        ce^.resumeerror;
        end if;

      --%%TODO(Ondra): Pokud je EXPR^.SUB^.GETSYMBOL^ rovna CURR.ENTITY, pop©¡padˆ nˆjak‚ nad©azen‚
      -- entitˆ, tak by se spr vnˆ mˆl dohledat kontext podle kontextu CURR, proto‘e jinak nap©¡klad
      -- P.X m–‘e b˜t nˆco jin‚ho ne‘ prost‚ X.

      -- vyhledat
      srch.find_local(sym_primary_context(expr^.sub^.getsymbol^),expr^.id^,sv);
      end find_in_entity;

begin
  -- form ln¡ kontrola podv˜razu 
  if expr^.sub<>nil then
    -- form ln¡ kontrola podv˜razu 
    a_form(curr,expr^.sub,info);

    -- povedla se form ln¡ kontrola podv˜razu ? 
    if expr^.sub^.zprac<ep_form then return; end if;

    -- podv˜raz mus¡ m¡t jednozna‡n˜ typ 
    checkresolve(curr,expr^.sub,nulltype,info);

    -- kontrola t©¡dy podv˜razu 
    checkclass(curr,expr^.sub,ncs_prefix_component,ce_i_prefix,info);
    end if;

  -- vyhledat symbol (nen¡-li ji‘ ur‡en) 
  if expr^.s.psym=nil then
    ----- %%TECH/%%LANG ----- Vyhled n¡ symbolu ----------------------------------------------------
    -- Symbol se hled  podle kontextu viditelnosti. Pokud pod aktu ln¡m uzlem 
    -- nen¡ jin˜ uzel, hled  se vzhledem k p©ekl dan‚mu prvku. Pokud je       
    -- uveden kontext (expr^.sub<>nil), ©¡d¡ se vyhled v n¡ typem podv˜razu.  
    --   Pro generick‚ podv˜razy nezb˜v  ne‘ ukon‡it form ln¡ kontrolu v˜razu 
    -- pro tento uzel.                                                        
    ------------------------------------------------------------------------------------------------
    if expr^.sub=nil

      -- nekvalifikovany identifikator 
      then
        -- vyhledat 
	srch.find_global(curr,expr^.id^);

        -- v ur‡it‚m kontextu by to mohlo b˜t jm‚no dosud nep©elo‘en‚ho modulu 
        if srch.psym=nil and info.kind in eks_link then
          -- zkusit p©elo‘it soubor 
          p_loadmodule(curr,expr^.id^);

          -- a zkusit je¨tˆ jednou vyhledat 
          srch.find_global(curr,expr^.id^);
          end if;

      -- kvalifikovany identifikator 
      else
        case expr^.sub^.t.tview
          -- beztypov˜ v˜raz
          when tview_null do find_in_entity;

          -- Full view
          when tview_full do
              case expr^.sub^.t.stype
                -- record
                when dt_record    do srch.find_local(sym_primary_context(expr^.sub^.t.getutype^),expr^.id^,tentityvisibleset:[etv_public]);

                -- t©¡da
                when dt_class     do find_in_class;

                -- procedura
                when dt_procedure do find_in_entity;

                -- v ostatn¡ch p©¡padech nen¡ co hledat
                when others do
                    ce^.seterror({CCERR=}000057,ce_i_selector);
                    --%%TODO(LIB) ce^.setinfo(formats(hint_prefix_component,nptostr(datatypename,ord(expr^.sub^.t.stype))));
                    expr^.errpos;
                    ce^.resumeerror;
                end case;

          -- Incomplete view
          when tview_incomplete do
              if expr^.sub^.t.isclass

                -- t©¡da, to je OK
                then
                  find_in_class;

                -- pro jin‚ typy to nelze
                else
                  -- nen¡ co hledat
                  ce^.seterror({CCERR=}000058,ce_i_selector);
                  ce^.setinfo(hint_prefix_component_hidden);
                  expr^.errpos;
                  ce^.resumeerror;
                  end if;

          -- Partial view/Unchecked view
          when tview_partial, tview_unchecked do
              -- nen¡ co hledat
              ce^.seterror({CCERR=}000059,ce_i_selector);
              ce^.setinfo(hint_prefix_component_hidden);
              expr^.errpos;
              ce^.resumeerror;

          when others do verify(185,true);
          end case;
        end if;

    -- kontrola vyhodnocen¡
    checkeval(curr,expr,srch,expr^.id,info);
    end if;

  -- symbol se nenalezl, nevad¡ zkus¡me p©¡¨tˆ 
  if srch.psym=nil then
    verify(18,not info.final or not (etc_generic in curr.entity^.compile));
    return;
    end if;

  -- poznamenat symbol 
  expr^.s:=srch;

  -- dokon‡it kontrolu 
  a_form_component_finalize(curr,expr,info);
  end a_form_component;



----------------------------------------------------------------------------------------------------
procedure a_form_imm =
-- Form ln¡ kontrola p©¡m‚ hodnoty.
----------------------------------------------------------------------------------------------------
with
  cx_imm;
  
begin
  verify(225,expr^.sub<>nil);

  -- odvodit univerz ln¡ typ
  case expr^.immkind
    -- obecn  p©¡m  hodnota
    when iek_imm                 do -- nic nedˆlat, typ je ji‘ ur‡en

    -- univerz ln¡ integer
    when iek_integer_literal     do expr^.settype(curr,def_uniint);

    -- univerz ln¡ re ln‚ ‡¡slo
    when iek_real_literal        do expr^.settype(curr,def_unireal);

    -- univerz ln¡ znak
    when iek_character_literal   do expr^.settype(curr,def_unichar);

    -- univerz ln¡ NIL
    when iek_nil_literal         do expr^.settype(curr,def_uninil);

    -- znakov˜ agreg t
    when iek_character_aggregate do expr^.settype(curr,def_unistr);

    -- univerz ln¡ logical
    when iek_logical_metaliteral do expr^.settype(curr,def_unilogical);

    when others do verify(522,true);
    end case;
{
  -- odvodit univerz ln¡ typ
  case expr^.imm.ic
    -- univerz ln¡ integer
    when ic_ordinal   do expr^.settype(curr,def_uniint);

    -- univerz ln¡ re ln‚ ‡¡slo
    when ic_real      do expr^.settype(curr,def_unireal);

    -- znakov˜ agreg t (v t‚to f zi to nem–‘e b˜t nic jin‚ho)
    when ic_condensed do
        -- podle d‚lky se odhadne typ
        if expr^.imm.citems.len=1

          -- jednoprvkov˜ znakov˜ agreg t => univerz ln¡ znak
          then
            expr^.settype(curr,def_unichar);
            imm_mutestr(expr^.imm);

          -- ostatn¡ znakov‚ agreg ty => univerz ln¡ pole of UNICHAR
          else
            expr^.settype(curr,def_unistr); --x_unistr(curr,expr,def_unichar);
            end if;

{%%X mˆlo nˆjak˜ smysl nastavovat velikost typu na po‡et prvk– ?

    begin
        -- jako velikost se pou‘ije po‡et prvk–
        udload(ud,expr^.imm.pocet);

        -- string
        expr^.newtype(curr,dt_unistr,ud);

        -- of char
        {%%X a co vyhodnocen¡ ? (pspecunistr(...)^.base.e:=ete_evaluated)}
        expr^.t.typ^.base._t:=def_unichar;
        end;
}
    -- univerz ln¡ konstanta
    when ic_nil         do expr^.settype(curr,def_uninil);

    -- co jin‚ hodnoty ?
    end case;
}
  -- t©¡da uzlu: hodnota
  expr^.nclass:=nc_value;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_form;
  end a_form_imm;



----------------------------------------------------------------------------------------------------
procedure a_form_typecast (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexplist;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola p©etypov n¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  er               : pexpnode;                   -- podv˜razy
  arglist          : pexpitem;                   -- seznam argument–                            

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el,arglist);

  -- nesplet si nˆkdo p©etypov n¡ a vol n¡ procedury ? 
  if (arglist=nil) or (arglist^.next<>nil) or (arglist^.itype<>ei_expr) then
    ce^.seterror({CCERR=}000060,ce_x_name_proc);
    expr^.join(el,arglist);
    el^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- z¡skat opravdov˜ prav˜ podv˜raz 
  verify(130,arglist^.sub=nil);

  -- form ln¡ kontrola lev‚ho podv˜razu 
  a_form(curr,el,info);

  -- form ln¡ kontrola prav‚ho podv˜razu 
  a_form(curr,arglist^.sub,info);
  arglist^.zprac:=arglist^.sub^.zprac;
  er:=arglist^.sub;
  
  -- slou‡it 
  expr^.join(el,arglist);

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- podv˜razy mus¡ m¡t jednozna‡n˜ typ 
  checkresolve(curr,el,nulltype,info);
  checkresolve(curr,er,nulltype,info);

  -- kontrola t©¡dy podv˜raz– 
  checkclass(curr,el,ncs_prefix_typecast,ce_i_prefix,info);
  checkclass(curr,er,ncs_value,ce_i_expr,info);

  -- lev˜ podv˜raz mus¡ m¡t typ s Partial ‡i Full view 
  checkview(curr,el,ttypeviewset:[tview_partial,tview_full],ce_i_prefix,hint_prefix_view,info);

  -- lev˜ podv˜raz s Full view mus¡ m¡t regul rn¡ typ
  if el^.t.tview=tview_full then
    checksts(curr,el,dts_regular,ce_i_prefix,hint_prefix_regular,info);
    end if;

  -- typy mus¡ b˜t kompatibiln¡ 
  if not t_compatible(curr,toc_typecast,false,el^.t,er^.t) then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000061,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- zmˆnit typ uzlu 
  expr^.ntype:=nt_typecast;

  -- typ v˜razy 
  expr^.t:=el^.t;

  -- t©¡da v˜razu 
  {%%X Tohle je z©ejmˆ dost zjednodu¨en‚, co }
  -- dynamick‚ p©etypov n¡ na z kladˆ tagu ?  
  case er^.nclass
    -- hodnota --> hodnota 
    when nc_value do expr^.nclass:=nc_value;

    -- promˆnn  --> promˆnn  nebo hodnota
    when nc_var   do
        --%%X Tohle by mˆlo vypl˜vat z v˜sledku typov‚ kontroly v t©¡dˆ typecast

        -- jeden z podv˜raz– nem  velikost => t©¡da promˆnn 
        if not el^.t.hassize or not er^.t.hassize then expr^.nclass:=nc_var

        -- c¡lov˜ typ je unconstrained => t©¡da promˆnn 
        elsif t_is_sts(el^.t,dts_unconstrained) then expr^.nclass:=nc_var

        -- podv˜razy maj¡ stejnou velikost => t©¡da promˆnn 
        elsif el^.t.getsize=er^.t.getsize then expr^.nclass:=nc_var

        -- podv˜razy maj¡ r–znou velikost ‡i co => t©¡da hodnota
        else expr^.nclass:=nc_value;
        end if;

    when others do verify(281,true);
    end case;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_typecast;



----------------------------------------------------------------------------------------------------
procedure a_form_list (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexplist;            -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola seznamu argument–.
----------------------------------------------------------------------------------------------------
var
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty
  el               : pexpnode;                   -- podv˜raz
  arglist          : pexpitem;                   -- argumenty
  x                : pexpitem;

begin
  ----- %%TECH -------------------------------------------------------------------------------------
  -- Form ln¡ kontrolu mohu prov‚st nez visle pro prefix i pro v¨echny argumenty, tak‘e se p©¡padn‚ 
  -- nevyhodnocen¡ detekuje a‘ po zpracov n¡ v¨ech podv˜raz–.                                                         
  -- Srovnej s CX_TYPE.A_TYPE_CALL, CX_OPT.A_OPT_CALL                         
  --                                                                          
  -- %%X a p©eci - nemˆlo by se to pro ka‘d˜ typ dˆlat znova ? T©eba ve form ln¡ kontrole vol n¡ 
  -- procedury se stejnˆ v cyklu kontroluj¡ parametry.                                                               
  --------------------------------------------------------------------------------------------------

  -- rozdˆlit 
  expr^.split(el,arglist);

  -- form ln¡ kontrola ©¡d¡c¡ho v˜razu 
  a_form(curr,el,info);
  vyhodnoceno:=el^.zprac>=ep_form;

  -- vyhodnotit argumenty 
  x:=arglist;
  while x<>nil loop
    verify(105,x^.ntype<>nt_item);
    if x^.sub<>nil then
      -- form ln¡ kontrola 
      a_form(curr,x^.sub,info);
      vyhodnoceno:=vyhodnoceno and (x^.sub^.zprac>=ep_form);

      -- pro zjednodu¨en¡ p©evz¡t typ a t©¡du podv˜razu 
      x^.t:=x^.sub^.t;
      x^.nclass:=x^.sub^.nclass;
      end if;

    -- dal¨¡ podv˜raz 
    x:=pexpitem(x^.next);
    end loop;

  -- slou‡it 
  expr^.join(el,arglist);

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if not vyhodnoceno then return; end if;

  -- ©¡d¡c¡ v˜raz mus¡ m¡t jednozna‡n˜ typ 
  checkresolve(curr,el,nulltype,info);

  case el^.nclass
    -- typ -->
    when nc_type do
        if t_is_sts(el^.t,dts_message)

          -- --> cosi se zpr vou
          then
            case info.kind
              -- odesl n¡ zpr vy
              when ek_context_send   do a_form_message_send(curr,expr,info);

              -- p©ijet¡ zpr vy
              when ek_context_accept do a_form_message_accept(curr,expr,info);

              when others do verify(304,true);
              end case;

          -- --> p©etypov n¡
          else
            a_form_typecast(curr,expr,info);
            end if;

    -- adresa procedury --> vol n¡ procedury
    when nc_proc do a_form_call(curr,expr,info);

    -- adresa promˆnn‚ --> chyba
    when nc_var do
        if t_is_sts(el^.t,tdatatypeset:[dt_procedure])

          -- je to pointer na proceduru
          then a_form_call(curr,expr,info)

          -- je to nˆco jin‚ho
          else
            -- typ: procedura -- chyb¡ ^
            -- jinak chyb¡ :TYPE
            ce^.seterror({CCERR=}000062,ce_x_name_proc_type);
            el^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

    -- tag
    when nc_tag do
        -- m¡sto :TAG mˆlo b˜t :TYPE
        ce^.seterror({CCERR=}000063,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

    -- v˜raz nem  uveden typ
    when nc_none do
        ce^.seterror({CCERR=}000064,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;

    when nc_undef do verify(50,true);

    -- jin‚ t©¡dy jsou chyba a neum¡m d t ‘ dnou n povˆdu
    when others do
        ce^.seterror({CCERR=}000065,ce_x_name_proc_type);
        el^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;
  end a_form_list;



----------------------------------------------------------------------------------------------------
procedure a_form_interface_cast (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpinterfacecast;   -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola interface castu
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el,er);

  -- form ln¡ kontrola lev‚ho podv˜razu 
  a_form(curr,el,info);

  -- form ln¡ kontrola prav‚ho podv˜razu 
  a_form(curr,er,info);
  
  -- slou‡it 
  expr^.join(el,er);

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if el^.zprac<ep_form or er^.zprac<ep_form then return; end if;

  -- podv˜razy mus¡ m¡t jednozna‡n˜ typ 
  checkresolve(curr,el,nulltype,info);
  checkresolve(curr,er,nulltype,info);

  -- kontrola t©¡dy podv˜raz– 
  checkclass(curr,el,ncs_prefix_typecast,ce_i_prefix,info);
  checkclass(curr,er,ncs_var,ce_i_expr,info);

  -- lev˜ podv˜raz mus¡ m¡t typ s Incomplete ‡i Full view 
  checkview(curr,el,ttypeviewset:[tview_incomplete,tview_full],ce_i_prefix,hint_prefix_view,info);

  -- typy mus¡ b˜t kompatibiln¡ 
  if not t_compatible(curr,toc_interface_cast,false,el^.t,er^.t) then
    {%%X zp©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000000,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typ v˜razy 
  expr^.t:=el^.t;

  -- t©¡da v˜razu 
  expr^.nclass:=nc_var;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_form_range (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexprange;           -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola seznamu argument–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  er               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  elt              : ptypeview;                  -- typy podv˜raz–
  ert              : ptypeview;                  -- typy podv˜raz–
  ranget           : typeview;                   -- typ rozsahu                                 

begin
  {%%X}{%%RESOLVE}

  -- rozdˆlit podv˜razy 
  expr^.split(el,er);

  -- form ln¡ kontrola lev‚ho podv˜razu 
  a_form(curr,el,info);

  -- form ln¡ kontrola prav‚ho podv˜razu 
  a_form(curr,er,info);

  -- slou‡it podv˜razy 
  expr^.join(el,er);

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- podv˜razy mus¡ b˜t hodnoty 
  checkclass(curr,el,ncs_value,ce_i_expr,info);
  checkclass(curr,er,ncs_value,ce_i_expr,info);

  -- iterace p©es v¨echny dvojice typ– podv˜raz– 
  for eli in 0..el^.gettypecount-1 loop
    for eri in 0..er^.gettypecount-1 loop
      -- typy 
      el^.gettype(eli,elt);
      er^.gettype(eri,ert);

      -- jsou oba typy diskr‚tn¡ ? 
      if t_is_sts(elt^,dts_u_ordinal) and t_is_sts(ert^,dts_u_ordinal)
      -- a jsou kompatibiln¡ ? 
      and t_compatible(curr,toc_range,false,elt^,ert^) then
        -- odvodit typ rozsahu 
        x_resolve(elt^,ert^,false,ranget);

        -- za©adit jako v˜sledek 
        expr^.addtype(ranget,eli,eri,nil);
        end if;
      end loop;
    end loop;

{ Star  verze bez p©et¡‘en¡:

  -- typy podv˜raz– mus¡ b˜t diskr‚tn¡ 
  checksts(curr,el,dts_u_ordinal,ce_x_ord,'',info);
  checksts(curr,er,dts_u_ordinal,ce_x_ord,'',info);

  -- a mus¡ b˜t i kompatibiln¡ 
  if not t_compatible(curr,toc_range,false,el^.t,er^.t) then
    {%%X up©esnit chybov‚ hl ¨en¡ }
    ce^.seterror({CCERR=}000066,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- odvodit typ rozsahu 
  x_resolve(el^.t,er^.t,expr^.t);
}
  -- t©¡da uzlu 
  expr^.nclass:=nc_composite;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_range;



----------------------------------------------------------------------------------------------------
procedure a_form_index (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpindex;           -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Form ln¡ kontrola indexu pole.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  er               : pexpnode;                   -- lev˜ a prav˜ podv˜raz
  rtype            : typeview;                   -- typ rozsahu pole/©etˆzce

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el,er);

  -- form ln¡ kontrola lev‚ho podv˜razu 
  a_form(curr,el,info);

  -- form ln¡ kontrola prav‚ho podv˜razu 
  a_form(curr,er,info);

  -- slou‡it podv˜razy 
  expr^.join(el,er);

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if (el^.zprac<ep_form) or (er^.zprac<ep_form) then return; end if;

  -- lev˜ podv˜raz mus¡ b˜t jednozna‡n˜ 
  checkresolve(curr,el,nulltype,info);

  -- kontrola t©¡dy lev‚ho podv˜razu 
  checkclass(curr,el,ncs_prefix_index,ce_i_prefix,info);

  -- prav˜ podv˜raz mus¡ b˜t v˜bˆr 
  checkclass(curr,er,ncs_choice,ce_i_expr,info);

  -- lev˜ podv˜raz mus¡ b˜t pole nebo ©etˆzec 
  -- Ondra 6.8.2002 : Kdyby to nebylo v Pascalu, ale t©eba ve Flexu nebo
  -- v Algolu, tak m me o chybu m‚nˆ. Nelze se dotazovat na STYPE lev‚ho
  -- operandu, proto‘e to m–‘e b˜t unchecked typ. %%X Zat¡m jen zru¨en hint.
  checksts(curr,el,dts_u_index,ce_i_prefix,{%%TODO(LIB) formats(}''{hint_prefix_index}{%%TODO(LIB),nptostr(datatypename,ord(el^.t.stype)))},info);
  -- Pozn mka: Kdyby to bylo v Algolu, tak budu parametr HINT p©ed vat jako   
  -- Call-by-name, aby se to FORMATS nevyhodnocovalo poka‘d‚, ale jen kdy‘    
  -- opravdu nastane chyba.                                                   
  --   Kdyby to bylo ve Flexu, tak 1) pou‘iju textovou substituci, 2) nebo    
  -- pou‘iju #pragma smart_inline(checksts);, 3) nebo proceduru CHECKSTS      
  -- deklaraju v re‘imu #syntax algol; a kompil tor si to nˆjak p©ebere.      
  -- Z vˆr: Je¨tˆ ‘e nejsme v Algolu (viz N:\DOC\SW\JAZYKY\ALGOL).            

  -- typ rozsahu 
  rtype:=el^.t.getrange(curr);

  -- prav˜ podv˜raz mus¡ b˜t jednozna‡n˜ 
  checkresolve(curr,er,rtype,info);

  -- typ prav‚ho podv˜razu mus¡ b˜t kompatibiln¡ 
  if not t_compatible(curr,toc_transform,false,rtype,er^.t) then
    ce^.seterror({CCERR=}000067,ce_incompatible);
    er^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- ur‡it typ indexu 
  if er^.nclass in ncs_range
    then expr^.itype:=eix_slice
    else expr^.itype:=eix_component;
    end if;

  -- typ v˜razu 
  case expr^.itype
    -- jedna komponenta
    when eix_component  do expr^.t:=el^.t.getbase(curr);

    -- ©ez pole
    when eix_slice      do unimplementedx(112,expr^.pos);

    when others         do verify(329,true);
    end case;

  -- t©¡da uzlu 
  expr^.nclass:=el^.nclass;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_index;



----------------------------------------------------------------------------------------------------
procedure a_form_ref (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpref;             -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Reference.
----------------------------------------------------------------------------------------------------
with
  cx_phase;

var
  el               : pexpnode;                   -- podv˜raz

begin
   -- rozdelit podv˜razy 
  expr^.split(el);

  -- vyhodnotit prefix 
  x_phase_next(curr,el,nulltype,eu_none,ep_type,info);

  -- slou‡it 
  expr^.join(el);

  -- povedlo se vyhodnocen¡ podv˜razu?
  if el^.zprac<ep_type then return; end if;

  -- podv˜raz mus¡ b˜t jednozna‡n˜ 
  checkresolve(curr,el,nulltype,info);

  -- podv˜raz mus¡ b˜t promˆnn  nebo procedura 
  checkclass(curr,el,ncs_ref,ce_i_expr,info);

  -- kontrola typu pohledu na typ podv˜razu
  case el^.nclass
    -- promˆnn 
    when nc_var  do
        -- kontrola typu pohledu
        checkview(curr,el,ttypeviewset:[tview_full,tview_partial,tview_unchecked,tview_incomplete],ce_i_expr,'',info);

        -- mus¡ to b˜t regul rn¡ typ
        case el^.t.tview
          -- Unchecked view
          when tview_unchecked  do
              -- Regul rn¡ jistˆ bude
              -- D–kaz: Unchecked view lze zkonstruovat jen pomoc¡ :unchecked
              -- a tento atribut lze aplikovat jen na podv˜raz regul rn¡ho
              -- typu.

          -- Partial view
          when tview_partial    do
              -- Regul rn¡ jistˆ bude
              -- D–kaz: Pokud je u typu podez©en¡, ‘e na nˆj m–‘e b˜t
              -- vytvo©eno Partial view, je definitoricky prohl ¨en za
              -- regul rn¡. Dop©edn  deklarace nelze dokon‡it definic¡
              -- singul rn¡ho typu.

          -- Incomplete view => class
          when tview_incomplete do
              -- %%X Nem–‘e se st t, ‘e by typ byl singul rn¡? Snad ne, proto‘e  
              -- jinak by od nˆj neexistovala instance v podobˆ promˆnn‚, ne? 

          -- Full view => class
          when tview_full       do
              -- podv˜raz mus¡ b˜t regul rn¡ typ
              checksts(curr,el,dts_regular,ce_i_expr,'',info);

          when others do verify(227,true);
          end case;

    -- procedura
    when nc_proc do
        -- Pohled je jistˆ Full view
        -- D–kaz    : Procedura se deklarauje buƒto implicitn¡ definic¡
        -- procedur ln¡ho typu (je ihned SD_DECLARED => Full view, Partial
        -- view b˜t nem–‘e - nem  jak), nebo uveden¡m Full view nˆjak‚ho
        -- procedur ln¡ho typu.
        --   Typ procedury je singul rn¡ typ, tak‘e na nˆj nejde ani
        -- :unchecked => nem–‘e b˜t Unchecked view
        verify(228,el^.t.tview<>tview_full);

    -- zpr va
    when nc_message     do
        -- Pohled je jistˆ Full view
        -- D–kaz    : viz varianta pro proceduru
        verify(228,el^.t.tview<>tview_full);

    when others do verify(109,true);
    end case;

  -- pro referenci na objekt zkontrolovat povolen¡ reference
  if el^.nclass=nc_var then
    check_aliased(curr,expr,el);
    end if;

  -- vypo‡¡tat typ reference a t©¡du v˜razu
  x_set_ref_type(curr,expr);

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_form;
  end a_form_ref;



----------------------------------------------------------------------------------------------------
procedure a_form_attrib (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpattrib;          -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Atribut.
----------------------------------------------------------------------------------------------------
with
  cc_attr,
  cx_phase;
  
var
  base             : pentity_type;               -- b zov˜ typ
  check            : t_logical;

type
  -- v˜sledn˜ typ atributu
  ttype            = enum
      tt_sub;                                    -- typ podv˜razu
      tt_range;                                  -- rozsah typu podv˜razu
      tt_size;                                   -- typ dynamick‚ho atributu :size
      tt_ancestor;                               -- :ancestor typu
      tt_root_ancestor;                          -- :root_ancestor typu
      tt_module_ancestor;                        -- :ancestor modulu
      tt_module_root_ancestor;                   -- :root_ancestor modulu
      tt_base;                                   -- :base                                       
      tt_root_base;                              -- :root_base                                  
      tt_ord;                                    -- odvodit typ ordin ln¡ hodnoty               
      tt_uarray_length;                          -- :length neomezen‚ho pole                    
      tt_string_length;                          -- ©etˆzcov˜ :length                           
      tt_tag;                                    -- :tag                                        
      tt_uniint;                                 -- univerz ln¡ cel‚ ‡¡slo                      
      tt_unireal;                                -- univerz ln¡ re ln‚ ‡¡slo                    
      tt_unilogical;                             -- univerz ln¡ boolean                         
      tt_unistr;                                 -- univerz ln¡ ©etˆzec znak–
      tt_unchecked;                              -- :unchecked
      end enum;                                  

var
  out_typ          : ttype;

    ------------------------------------------------------------------------------------------------
    procedure ct (
        typ        : in tdatatypeset;            -- povolen‚ typy
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: <v˜raz typu TYP>:atribut --> :out_attr, atc_static.
    ------------------------------------------------------------------------------------------------
    begin
      result:=t_is_sts(expr^.sub^.t,typ) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ct;



    ------------------------------------------------------------------------------------------------
    procedure ctg (
        typ        : in tdatatypeset;            -- povolen‚ typy
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
        return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: <v˜raz tagged typu TYP>:atribut --> :out_attr, atc_static.
    ------------------------------------------------------------------------------------------------
    begin
      result:=ct(typ,level,out_attr,_out_typ,out_class) and then tf_tagged in expr^.sub^.t.getctype^.tflags;
      end ctg;



    ------------------------------------------------------------------------------------------------
    procedure cd (
        rta        : in rtattrib;                -- po‘adovan˜ run-time atribut
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Test na dynamick˜ atribut.
    ------------------------------------------------------------------------------------------------
    begin
      result:=x_rta_is_available(expr^.sub,rta);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_dynamic;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cd;



    ------------------------------------------------------------------------------------------------
    procedure cdt (
        typ        : in tdatatypeset;            -- povolen‚ typy
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        rta        : in rtattrib;                -- po‘adovan˜ run-time atribut
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Jako CT plus test na dynamick˜ atribut.
    ------------------------------------------------------------------------------------------------
    begin
      result:=ct(typ,level,out_attr,_out_typ,out_class) and x_rta_is_available(expr^.sub,rta);
      if result then
        expr^.aclass:=atc_dynamic;
        end if;
      end cdt;



    ------------------------------------------------------------------------------------------------
    procedure cn (
        ntype      : in nodetype;                -- povolen˜ typ uzlu
        typ        : in tdatatypeset;            -- povolen‚ typy
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, nav¡c v˜raz typu NTYPE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.ntype=ntype) and ct(typ,level,out_attr,_out_typ,out_class);
      end cn;



    ------------------------------------------------------------------------------------------------
    procedure cc (
        nclass     : in nodeclass;               -- povolen  t©¡da uzlu
        typ        : in tdatatypeset;            -- povolen‚ typy
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
        out_aclass : in tattrclass;              -- t©¡da atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, nav¡c v˜raz t©¡dy NCLASS.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.nclass=nclass) and ct(typ,level,out_attr,_out_typ,out_class);
      if result then
        expr^.aclass:=out_aclass;
        end if;
      end cc;



    ------------------------------------------------------------------------------------------------
    procedure ctv (
        nclass     : in nodeclass;               -- povolen  t©¡da uzlu
        tview      : in ttypeviewset;            -- povolen‚ pohledy na typ
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
        out_aclass : in tattrclass;              -- t©¡da atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CT, nav¡c v˜raz t©¡dy NCLASS.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.nclass=nclass) and (expr^.sub^.t.tview in tview) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=out_aclass;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ctv;



    ------------------------------------------------------------------------------------------------
    procedure ctvx (
        tview      : in ttypeviewset;            -- povolen‚ pohledy na typ
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
        out_aclass : in tattrclass;              -- t©¡da atributu
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: jako CTV, ale bez kontroly t©¡dy uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.t.tview in tview) and (expr^.sub^.t.evaluated>=level);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=out_aclass;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end ctvx;



    ------------------------------------------------------------------------------------------------
    procedure cv (
        level      : in tentitydeclared;         -- po‘adoven‚ vyhodnocen¡ typu
        mclass     : in memclassset;             -- povolen‚ pamˆŸov‚ t©¡dy
        out_attr   : in tattractual;             -- v˜sledn˜ skute‡n˜ atribut
       _out_typ    : in ttype;                   -- typ atributu
        out_class  : in nodeclass)               -- t©¡da uzlu
                   return t_logical =            -- T-vyhovuje kontrole
    -- Kontrola: v˜raz je promˆnn  uveden‚ pamˆŸov‚ t©¡dy.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(expr^.sub^.ntype=nt_component)
          and (pexpcomponent(expr^.sub)^.s.psym^.etype=et_var)
          and (pentity_var(pexpcomponent(expr^.sub)^.s.psym)^.mclass in mclass);
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cv;



    ------------------------------------------------------------------------------------------------
    procedure cent (
        etype     : in tentitytype;              -- po‘adoven˜ typ entity
        out_attr  : in tattractual;              -- v˜sledn˜ skute‡n˜ atribut
       _out_typ   : in ttype;                    -- typ atributu
        out_class : in nodeclass)                -- t©¡da uzlu
        return t_logical =                       -- T-vyhovuje kontrole
    -- Kontrola: v˜raz je entita zadan‚ho typu PTYPE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=expr^.sub^.getsymbol<>nil and then expr^.sub^.getsymbol^.etype=etype;
      if result then
        expr^.ata:=out_attr;
        expr^.aclass:=atc_static;
        expr^.nclass:=out_class;
        out_typ:=_out_typ;
        end if;
      end cent;

var
  el               : pexpnode;                   -- podv˜raz                                    
  arglist          : pexpitem;                   -- parametry                                   
  size             : tunidata_size;              -- velikost vytv ©en‚ho typu                   
  xt               : typeview;

begin
  -- rozdˆlit podv˜razy 
  expr^.split(el,arglist);

  -- vyhodnotit prefix 
  x_phase_next(curr,el,nulltype,eu_none,pred ep_final,info);
  if el^.zprac<pred ep_final then
    expr^.join(el,arglist);
    return;
    end if;

  -- %%TECH p©esto‘e dynamick‚ atributy se ur‡uj¡ a‘ v dal¨¡ f zi zpracov n¡
  -- v˜razu, je mo‘n‚ se na nˆ odkazovat funkc¡ X_RTA_IS_AVAILABLE d¡ky
  -- vol n¡ X_PHASE_NEXT v˜¨e.

  -- slou‡it 
  expr^.join(el,arglist);

  -- zkusit, jestli to nen¡ jazykem definovan˜ atribut 
  a_getlangattr(expr^.id^,expr^.atf);

  if expr^.atf=atf_none

    -- u‘ivatelem definovan˜ atribut 
    then
      unimplementedx(45,expr^.pos);

    -- jazykem definovan˜ atribut 
    else
      -- zkontrolovat, zda m  atribut smysl 
      case expr^.atf
        -- :type
        when atf_type             do check:=ct(dts_all-dts_internal,etd_incomplete,ata_type_type,tt_sub,nc_type);

        -- :ancestor
        when atf_ancestor         do check:=cent(et_module,ata_module_ancestor,tt_module_ancestor,nc_module)
                                         or ct(dts_all-dts_internal,etd_incomplete{full},ata_type_ancestor,tt_ancestor,nc_type);

        -- :root_ancestor
        when atf_root_ancestor    do check:=cent(et_module,ata_module_root_ancestor,tt_module_root_ancestor,nc_module)
                                         or ct(dts_all-dts_internal,etd_incomplete{full},ata_type_root_ancestor,tt_root_ancestor,nc_type);

        -- :size
        when atf_size             do check:=cd(rta_size,ata_expr_size,tt_size,nc_value)
                                         or ct(dts_all-dts_internal,etd_full,ata_type_size,tt_uniint,nc_value)
                                         or ctvx(ttypeviewset:[tview_partial],etd_full,ata_type_size,atc_static,tt_uniint,nc_value);

        -- :bits
        when atf_bits             do check:=ct(dts_ordinal,etd_full,ata_ord_bits    ,tt_uniint,nc_value);

        -- :position
        when atf_position         do check:=cv(etd_full,mcs_offset,ata_var_position,tt_uniint,nc_value);

        -- :first
        when atf_first            do check:=ct(dts_ordinal,etd_full,ata_ord_first   ,tt_sub   ,nc_value)
                                         or ct(dts_array,  etd_full,ata_array_first ,tt_range ,nc_value)
                                         or ct(dts_string, etd_full,ata_string_first,tt_range ,nc_value);

        -- :last
        when atf_last             do check:=cd(rta_last           ,ata_expr_last   ,tt_range ,nc_value)
                                         or ct(dts_ordinal,etd_full,ata_ord_last    ,tt_sub   ,nc_value)
                                         or ct(dts_array,  etd_full,ata_array_last  ,tt_range ,nc_value)
                                         or ct(dts_string, etd_full,ata_string_last ,tt_range ,nc_value);

        -- :range
        when atf_range            do check:=ct (       dts_ordinal,etd_full         ,ata_ord_range                ,tt_sub          ,nc_type)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_range ,atc_dynamic,tt_range        ,nc_composite)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_range ,atc_dynamic,tt_range        ,nc_composite)
                                         or cn (nt_imm,dts_string ,etd_full         ,ata_string_range             ,tt_range        ,nc_composite)
                                         or cn (nt_imm,dts_u_string,etd_full        ,ata_string_range             ,tt_uniint       ,nc_composite)
                                         or ct (       dts_string ,etd_full         ,ata_string_range             ,tt_range        ,nc_type)
                                         or cdt(       dts_array  ,etd_full,rta_last,ata_array_range              ,tt_range        ,nc_composite)
                                         or ct (       dts_array  ,etd_full         ,ata_array_range              ,tt_range        ,nc_type);

        -- :length
        when atf_length           do check:=cdt(       tdatatypeset:[dt_uarray],etd_full,rta_last,ata_array_length             ,tt_uarray_length,nc_value)
                                         or ct (       tdatatypeset:[dt_array] ,etd_full         ,ata_array_length             ,tt_uniint       ,nc_value)
                                         or cc (nc_var,dts_string ,etd_full         ,ata_string_length,atc_dynamic,tt_string_length,nc_var)
                                         or cn (nt_imm,dts_string ,etd_full         ,ata_string_length            ,tt_string_length,nc_value)
                                         or cn (nt_imm,dts_u_string,etd_full        ,ata_string_length            ,tt_uniint       ,nc_value)
                                         or ct (       dts_string ,etd_full         ,ata_string_length            ,tt_uniint       ,nc_value);
            
        -- :base
        when atf_base             do check:=ct(dts_base,etd_full,ata_type_base,tt_base,nc_type);

        -- :root_base
        when atf_root_base        do check:=ct(dts_base,etd_full,ata_type_root_base,tt_root_base,nc_type);

        -- :image
        when atf_image            do check:=cn(nt_imm,dts_u_ordinal,etd_full,ata_imm_ord_image,tt_unistr,nc_value);

        -- :unchecked
        when atf_unchecked        do check:=ctv(nc_var,ttypeviewset:[tview_unchecked,tview_partial],etd_full,ata_var_unchecked,atc_dynamic,tt_unchecked,nc_var)
                                         or cc(nc_var,dts_regular,etd_full,ata_var_unchecked,atc_dynamic,tt_unchecked,nc_var);

        -- :true
        when atf_true             do check:=ct(dts_u_logical,etd_full,ata_logical_true ,tt_sub,nc_value);

        -- :false
        when atf_false            do check:=ct(dts_u_logical,etd_full,ata_logical_false,tt_sub,nc_value);

        -- :ord
        when atf_ord              do check:=cc(nc_var  ,dts_ordinal,etd_full,ata_ord_ord,atc_dynamic,tt_ord,nc_var)
                                         or cn(nt_imm  ,dts_u_ordinal,etd_full,ata_ord_ord,tt_ord,nc_value)
                                         or cc(nc_value,dts_u_ordinal,etd_full,ata_ord_ord,atc_dynamic,tt_ord,nc_value);

        -- :tag
        when atf_tag              do check:=cd(rta_tag,ata_expr_tag,tt_tag,nc_value)
                                         or ctg(dts_all-dts_internal,etd_incomplete,ata_type_tag,tt_tag,nc_value);

        -- :tagged
        when atf_tagged           do check:=cd(rta_tag,ata_expr_tagged,tt_unilogical,nc_value)
                                         or ct(dts_all-dts_internal,etd_full,ata_expr_tagged,tt_unilogical,nc_value);

        -- :full
        when atf_full             do check:=ct(dts_set,etd_full,ata_set_full,tt_sub,nc_value);

        when others               do verify(114,true);
        end case;
      if not check then
        ce^.seterror({CCERR=}000068,ce_i_attr);
        ce^.setparam(entityident_to_string(expr^.id^));
        {%%X doplnit hint pro ka‘d˜ atribut }
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;

      -- typ v˜razu
      case out_typ
        -- p©evz¡t typ podv˜razu
        when tt_sub        do expr^.t:=expr^.sub^.t;

        -- rozsah typu podv˜razu
        when tt_range      do expr^.t:=expr^.sub^.t.getrange(curr);

        -- typ dynamick‚ho atributu :size
        when tt_size       do
            -- odvodit nov˜ typ
            cpu^.getrtattribsize(rta_size,size);
            expr^.newtype(curr,dt_unsigned,size);

        -- b ze
        when tt_base       do expr^.t:=expr^.sub^.t.getbase(curr);

        -- p©edek typu
        when tt_ancestor   do expr^.t:=expr^.sub^.t.getancestor(curr);

        -- ko©enov˜ p©edek typu
        when tt_root_ancestor do unimplementedx(185,expr^.pos);

        -- p©edek modulu
        when tt_module_ancestor do expr^.xsym:=expr^.sub^.getsymbol^.ancestor.getuentity;

        -- ko©enov˜ p©edek modulu
        when tt_module_root_ancestor do unimplementedx(186,expr^.pos);

        -- odvodit typ ordin ln¡ hodnoty
        when tt_ord        do
            -- univerz ln¡ diskr‚tn¡ typ --> univerz ln¡ integer
            if el^.t.stype in dts_unitype then expr^.settype(curr,def_uniint)
            -- signed --> signed
            elsif expr^.sub^.t.stype=dt_signed then expr^.newtype(curr,dt_signed,expr^.sub^.t.getsize)
            -- ostatn¡ --> unsigned
            else expr^.newtype(curr,dt_unsigned,expr^.sub^.t.getsize);
            {%%X Ot zka: Typ :ord aplikovan‚ho na modul rn¡ typ je zase }
            -- modul rn¡ nebo ne ? Asi by nemˆl.
            end if;

        -- :length neomezen‚ho pole
        when tt_uarray_length do
            -- odvodit nov˜ typ
            cpu^.getrtattribsize(rta_size,size);
            expr^.newtype(curr,dt_unsigned,size);

        -- ©etˆzcov˜ length
        when tt_string_length do
            -- odvodit nov˜ typ
            xt:=el^.t.getrange(curr);
            expr^.newtype(curr,xt.stype,xt.getsize);

            -- nastavit meze
            expr^.t.getctype^.lval:=ui_0;
            expr^.t.getctype^.hval:=xt.gethval;

        -- :tag
        when tt_tag        do
            -- odvodit nov˜ typ
            cpu^.getrtattribsize(rta_tag,size);
            expr^.newtype(curr,dt_tag,size);

        -- univerz ln¡ typy
        when tt_uniint     do expr^.settype(curr,def_uniint);
        when tt_unireal    do expr^.settype(curr,def_unireal);
        when tt_unilogical do expr^.settype(curr,def_unilogical);
        when tt_unistr     do expr^.settype(curr,def_unistr); --x_unistr(curr,expr,def_unichar);

        -- unchecked
        when tt_unchecked  do expr^.setunchecked(curr,expr^.sub^.t);

        when others        do verify(116,true);
        end case;
      end if;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_attrib;



----------------------------------------------------------------------------------------------------
procedure a_form_aggregate (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpaggregate;       -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Agreg t.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arglist          : pexpitem;                   -- seznam slo‘ek
  x                : pexpitem;                   -- seznam slo‘ek
  xel              : pexpnode;                   -- podv˜razy slo‘ky
  xer              : pexpnode;                   -- podv˜razy slo‘ky
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     
  ncs              : nodeclassset;               -- t©¡da povolen˜ch hodnot podv˜raz–

begin
  vyhodnoceno:=true;

  -- rozdˆlit podv˜razy 
  expr^.split(el,arglist);

  -- form ln¡ kontrola jm‚na typu 
  if el<>nil then
    a_form(curr,el,info);
    vyhodnoceno:=vyhodnoceno and (el^.zprac>=ep_form);
    end if;

  -- vymyslet typ v˜razu 
  if el<>nil

    -- kvalifikovan˜ v˜raz 
    then
      -- lev˜ podv˜raz mus¡ b˜t jednozna‡n˜
      checkresolve(curr,el,nulltype,info);

      -- kontrola t©¡dy podv˜razu 
      checkclass(curr,el,ncs_prefix_aggregate,ce_x_name_aggrtype,info);

      -- podv˜raz mus¡ b˜t agreg tn¡ typ 
      checksts(curr,el,dts_aggregate,ce_x_name_aggrtype,'',info);

      -- p©evz¡t typ 
      expr^.t:=el^.t;

      -- jak‚ t©¡dy hodnot podv˜raz– povol¡me v z vislosti na typu agreg tu ?
      if t_is_stype(expr^.t,dt_set)

        -- m -li to b˜t mno‘ina, tak mus¡me povolit i rozsahy hodnot
        then ncs:=ncs_value+ncs_range

        -- jinak povol¡me jen hodnoty
        else ncs:=ncs_value
        end if;

    -- nekvalifikovan˜ v˜raz => typ je libovoln˜ agreg tn¡ typ 
    else
      -- inicializovat jako libovoln˜ agreg tn¡ typ
      expr^.t.initaggregate;

      -- nev¡me, jestli to nebude mno‘ina, tak povolit jak jednotliv‚ hodnoty, tak rozsahy hodnot
      ncs:=ncs_value+ncs_range;
      end if;

  -- vyhodnotit argumenty 
  x:=arglist;
  while x<>nil loop
    verify(219,x^.ntype<>nt_item);

    -- rozdˆlit podv˜razy 
    x^.split(xel,xer);

    -- form ln¡ kontrola hodnoty 
    if xel<>nil then a_form(curr,xel,info); end if;

    -- slou‡it podv˜razy 
    x^.join(xel,xer);

    -- podv˜raz mus¡ b˜t hodnota 
    if (xel<>nil) and (xel^.zprac>=ep_form) then checkclass(curr,xel,ncs{ncs_value},ce_i_expr,info); end if;

    -- %%TECH Form ln¡ kontrolu v˜bˆru nemohu v t‚to f zi prov dˆt, proto‘e by
    -- se mohlo jednat o identifik tor slo‘ky recordu a v tuto chv¡li je¨tˆ   
    -- nezm m typ agreg tu (no, nˆkdy u‘ ano, ale s jistotou ho dovedu ur‡it  
    -- a‘ v n sleduj¡c¡ f zi).                                                

    -- povedla se form ln¡ kontrola podv˜raz– ? 
    vyhodnoceno:=vyhodnoceno and ((xel=nil) or (xel^.zprac>=ep_form));

    -- dal¨¡ podv˜raz 
    x:=pexpitem(x^.next);
    end loop;

  -- slou‡it podv˜razy
  expr^.join(el,arglist);  

  -- povedla se form ln¡ kontrola podv˜raz– ? 
  if not vyhodnoceno then return; end if;

  -- t©¡da v˜razu 
  expr^.nclass:=nc_value;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_aggregate;


{ Ondra 16.7.2003+12.9.2003 : Explicitn¡ vol n¡ speci ln¡ch metod zak z no.

----------------------------------------------------------------------------------------------------
procedure a_form_callspec (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpcallspec;        -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- Vol n¡ speci ln¡ metody.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  if expr^.sub<>nil

    -- m me podv˜raz, mus¡ to b˜t instance t©¡dy nebo modul
    then
      -- form ln¡ kontrola podv˜razu 
      a_form(curr,expr^.sub,info);
      if expr^.sub^.zprac<ep_form then return; end if;

      -- kontrola t©¡dy podv˜razu 
      -- (pou‘¡t CHECKCLASS nep©inese zjednodu¨en¡) 
      case expr^.sub^.nclass
        -- promˆnn  nebo typ 
        when nc_var,nc_type do
            -- mus¡ to b˜t t©¡da
            checksts(curr,expr^.sub,dts_class,ce_x_name_instance,'',info);

        -- modul
        when nc_module  do
            -- nen¡ co kontrolovat

        -- chyba
        when others do
            {%%X zp©esnit chybov‚ hl ¨en¡ }
            ce^.seterror({CCERR=}000069,ce_x_name_instance);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
        end case;

    -- nem me podv˜raz, naj¡t implicitn¡ speci ln¡ metodu 
    else
      -- naj¡t nejbli‘¨¡ kontejnerov˜ objekt 
      --%%TODO(optimize) Vzhledem k vlastnostem Flexu by klidnˆ vol n¡ SYM_GET_CONTAINER
      -- mohlo b˜t t©ikr t p©¡mo v tom IFu. Bylo by to tak p©ehlednˆj¨¡.
      psym:=sym_get_container(curr.entity);

      -- mus¡ to b˜t t©¡da nebo modul 
      if psym=nil or psym^.etype not in ets_modular
      -- a ADJUST, ROLLBACK, COMMIT lze nav¡c volat jen v t©¡dˆ 
      or (expr^.spectype in tspectypeset:[tst_adjust,tst_rollback,tst_commit] and psym^.etype<>et_class)
      then
        {%%X zp©esnit chybov‚ hl ¨en¡ }
        ce^.seterror({CCERR=}000070,ce_i_callspec);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;
      end if;

  -- t©¡da v˜razu: nic, nevrac¡ hodnotu 
  expr^.nclass:=nc_none;

  -- form ln¡ kontrola £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_form;
  end a_form_callspec;
}


----------------------------------------------------------------------------------------------------
procedure a_form_current (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in out pexpcurrent;         -- v˜raz
    info           : in expinfo) =               -- informace o pr–bˆhu anal˜zy
-- CURRENT.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;
  node             : pexpcomponent;

begin
  -- naj¡t odpov¡daj¡c¡ entitu   
  psym:=sym_get_enclosing_or_self(curr.entity,currentityinfo[expr^.entity].etype);
  if psym=nil then
    ce^.seterror({CCERR=}000071,ce_i_current_selector);
    expr^.errpos;
    ce^.resumeerror;
    end if;

  -- zalo‘it nov˜ uzel 
  newnode(pexpnode(node),info,nt_component);

  -- komponenta 
  node^.s.set_entity(psym);

  -- dokon‡it form ln¡ kontrolu 
  a_form_component_finalize(curr,node,info);

  -- p©edat ven 
  pexpnode(expr):=pexpnode(node);
  end a_form_current;



----------------------------------------------------------------------------------------------------
procedure a_form =
-- Form ln¡ kontrola v˜razu.                                                  
----------------------------------------------------------------------------------------------------
begin
  verify(2,expr=nil);

  -- zpracov vat jen v˜razy z bezprost©ednˆ p©edchoz¡ f ze
  if expr^.zprac<>pred ep_form then return; end if;

  -- zkontrolovat v˜raz 
  case expr^.ntype
    -- bin rn¡ oper tor 
    when nt_operator  do a_form_operator(curr,pexpoper(expr),info);

    -- un rn¡ oper tor
    when nt_unary     do a_form_unary(curr,pexpunary(expr),info);

    -- komponenta
    when nt_component do a_form_component(curr,pexpcomponent(expr),info);

    -- p©¡m  hodnota
    when nt_imm       do a_form_imm(curr,pexpimm(expr),info);

    -- seznam argument–
    when nt_list      do a_form_list(curr,pexplist(expr),info);

    -- rozsah
    when nt_range     do a_form_range(curr,pexprange(expr),info);

    -- index pole
    when nt_index     do a_form_index(curr,pexpindex(expr),info);

    -- reference
    when nt_ref       do a_form_ref(curr,pexpref(expr),info);

    -- dereference
    when nt_deref     do a_form_deref(curr,pexpderef(expr),info);

    -- atribut
    when nt_attrib    do a_form_attrib(curr,pexpattrib(expr),info);

    -- agreg t
    when nt_aggregate do a_form_aggregate(curr,pexpaggregate(expr),info);

    -- interface cast
    when nt_interface_cast do a_form_interface_cast(curr,pexpinterfacecast(expr),info);

{
    -- Ondra 16.7.2003+12.9.2003 : Explicitn¡ vol n¡ speci ln¡ch metod zak z no.
    -- vol n¡ speci ln¡ metody
    when nt_callspec  do a_form_callspec(curr,pexpcallspec(expr),info);
}
    -- THIS
    when nt_this      do a_form_this(curr,pexpthis(expr),info);

    -- CURRENT
    when nt_current   do a_form_current(curr,pexpcurrent(expr),info);

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others       do verify(3,true);
    end case;
  end a_form;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initunarytab;
  end entry;



end cx_form;