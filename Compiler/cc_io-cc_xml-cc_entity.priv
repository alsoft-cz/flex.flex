----------------------------------------------------------------------------------------------------
module private cc_entity =
-- V˜stup entit do XML
----------------------------------------------------------------------------------------------------
-- honzap : 8.12.2003 : Vytvo©il
----------------------------------------------------------------------------------------------------

with 
  standard.conversions,
  cc_def,
  cc_io.cc_xml.cc_util,
  cc_io.cc_xml.cc_expr,
  cc_base.cc_sym,
  cc_def.cc_unitype,
  cc_io.cc_xml.cc_imm;

----------------------------------------------------------------------------------------------------
procedure tentitycompileset_to_string (
    value          : in tentitycompileset)       -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [tentitycompileset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in tentitycompile loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then
      result & tentitycompile_export_id[i] & ' ';
      end if;
    end loop;
  end tentitycompileset_to_string;



----------------------------------------------------------------------------------------------------
procedure varflagset_to_string (
    value          : in varflagset)              -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [varflagset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in varflags loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then
      result & varflags_export_id[i] & ' ';
      end if;
    end loop;
  end varflagset_to_string;



----------------------------------------------------------------------------------------------------
procedure constflagset_to_string (
    value          : in constflagset)            -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [constflagset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in constflags loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then
      result & constflags_export_id[i] & ' ';
      end if;
    end loop;
  end constflagset_to_string;



----------------------------------------------------------------------------------------------------
procedure rtattribset_to_string (
    value          : in rtattribset)             -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [rtattribset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in rtattrib loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then
      result & rtattrib_export_id[i] & ' ';
      end if;
    end loop;
  end rtattribset_to_string;



----------------------------------------------------------------------------------------------------
procedure procflagset_to_string (
    value          : in procflagset)             -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [procflagset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in procflags loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then 
      result & procflags_export_id[i] & ' ';
      end if;
    end loop;
  end procflagset_to_string;



----------------------------------------------------------------------------------------------------
procedure typeflagset_to_string (
    value          : in typeflagsset)            -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [typeflagsset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in typeflags loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then 
      result & typeflags_export_id[i] & ' ';
      end if;
    end loop;
  end typeflagset_to_string;



----------------------------------------------------------------------------------------------------
procedure ptrflagsset_to_string (
    value          : in ptrflagsset)             -- p©ev dˆn  hodnota
    return t_char32str =
-- P©evod [ptrflagsset] na ©etˆzec
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat
  for i in ptrflags loop
    -- pokud je prvek v mno‘inˆ, p©idat do v˜sledku
    if i in value then 
      result & ptrflags_export_id[i] & ' ';
      end if;
    end loop;
  end ptrflagsset_to_string;



----------------------------------------------------------------------------------------------------
procedure xml_dump_spectable (
    stable         : in tspectable;              -- dumpovan  struktura
    xml            : in p_xml_dumper;            -- XML dumper
    child          : in t_char32str) =           -- jm‚no vno©en‚ho elementu
-- XML dump [tspectable]
----------------------------------------------------------------------------------------------------
begin
  -- zano©en¡
  xml^.go_in(child);

  -- zpracovat
  for i in tspectype loop
    if stable[i].getuentity<>nil then
      xml^.write_text_element(tspectype_export_id[i],sym_get_qid(stable[i].getuentity));
      end if;
    end loop;

  -- vyno©en¡
  xml^.go_out(child);
  end xml_dump_spectable;



----------------------------------------------------------------------------------------------------
procedure xml_dump_floatsparams (
    sparams        : in tfloatsparams;           -- dumpovan  struktura
    xml            : in p_xml_dumper;            -- XML dumper
    child          : in t_char32str) =           -- jm‚no vno©en‚ho elementu
-- XML dump [tfloatsparams]
----------------------------------------------------------------------------------------------------
begin
  -- zano©en¡
  xml^.go_in(child);

  -- zapsat atributy
  -- TODO low          : tunireal;                   -- nejmen¨¡ ‡¡slo
  -- TODO high         : tunireal;                   -- nejvˆt¨¡ ‡¡slo
  -- TODO small        : tunireal;                   -- nejmen¨¡ ‡¡slo vˆt¨¡ ne‘ 0
  xml^.write_text_element('emin',unsigned_to_string(uniint_to_unsigned(sparams.emin)));
  xml^.write_text_element('emax',unsigned_to_string(uniint_to_unsigned(sparams.emax)));
--  xml^.write_text_element('signed_zeros',t_logical_export_id[sparams.signed_zeros]);
  -- TODO positive_inf : tunireal;                   -- Positive Infinity
  -- TODO negative_inf : tunireal;                   -- Negative Infinity
  -- TODO positiove_zero : tunireal;                 -- Positive Zero
  -- TODO negative_zero: tunireal;                   -- Negative Zero
  -- TODO not_a_number : tunireal;                   -- Not a Number

  -- vyno©en¡
  xml^.go_out(child);
  end xml_dump_floatsparams;



----------------------------------------------------------------------------------------------------
procedure xml_dump_floatparams (
    fp             : in tfloatparams;            -- dumpovan  struktura
    xml            : in p_xml_dumper;            -- XML dumper
    child          : in t_char32str) =           -- jm‚no vno©en‚ho elementu
----------------------------------------------------------------------------------------------------
begin
  -- zano©en¡
  xml^.go_in(child);

  -- vypsat atributy
  -- TODO fdelta       : tunireal;                   -- p©esnost
  xml^.write_text_element('fdigits',unsigned_to_string(uniint_to_unsigned(fp.fdigits)));
--  xml^.write_text_element('rounding',t_logical_export_id[fp.rounding]);
--  xml^.write_text_element('oflw',t_logical_export_id[fp.oflw]);
  if fp.sparams<>nil then xml_dump_floatsparams(fp.sparams^,xml,'sparams');end if;

  -- vyno©en¡
  xml^.go_out(child);
  end xml_dump_floatparams;



----------------------------------------------------------------------------------------------------
procedure xml_dump_virtual_table (
    vtable         : in pvirtualtable;           -- tabulka, kter  m  b˜t vyps na
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
----------------------------------------------------------------------------------------------------
begin
  if vtable=nil then return end if;
  -- zano©en¡
  xml^.go_in(name);

  -- dump prvk– ©etˆzce
  for i in vtable^:range loop
    if vtable^[i]<>nil then xml^.write_text_element('code',sym_get_qid(vtable^[i]));end if;
    end loop;

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_virtual_table;



----------------------------------------------------------------------------------------------------
procedure xml_dump_class_interface =
-- provede dump struktury [intf]
----------------------------------------------------------------------------------------------------
begin
  -- pr zdn  struktura => konec
  if intf=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  if intf^.refclass.getuentity<>nil then xml^.write_text_element('refclass',sym_get_qid(intf^.refclass.getuentity));end if;
  if intf^.instance.getuentity<>nil then xml^.write_text_element('instance',sym_get_qid(intf^.instance.getuentity));end if;
  xml^.write_text_element('is_exposed',t_logical_export_id[intf^.is_exposed]);
  xml_dump_virtual_table(intf^.vtable,xml,'vtable');

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_class_interface;



----------------------------------------------------------------------------------------------------
procedure xml_dump_interface_list (
    intfs          : in p_interface_list;        -- struktura, kter  m  b˜t zaps na
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
-- provede dump struktury [intfs]
----------------------------------------------------------------------------------------------------
var
  intf             : p_class_interface;          -- prvek seznamu

begin
  -- pokud seznam nen¡ zad n, nic nedˆlat
  if intfs=nil then return end if;

  -- proj¡t senzam [intfs]
  intf:=intfs^.get_first;
  while intf<>nil loop
    -- dump prvku
    xml_dump_class_interface(intf,xml,name);

    -- dal¨¡ prvek seznamu
    intf:=intfs^.get_next(intf);
    end loop;
  end xml_dump_interface_list;



----------------------------------------------------------------------------------------------------
procedure xml_dump_type_vector (
    type_vector    : in p_type_vector;           -- vektor. kter˜ bude zaps n
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
-- dump vektoru
----------------------------------------------------------------------------------------------------
begin
  -- pokud vekor nen¡ zad n, nic nedˆlat
  if type_vector=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  -- %%TODO(TYPEVECTOR)

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_type_vector;



----------------------------------------------------------------------------------------------------
procedure xml_dump_type_vector_set (
    vector_set     : in p_type_vector_set;       -- vektor. kter˜ bude zaps n
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
-- dump vektoru
----------------------------------------------------------------------------------------------------
begin
  -- pokud mno‘ina nen¡ zad na, nic nedˆlat
  if vector_set=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  -- %%TODO(TYPEVECTOR)

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_type_vector_set;



----------------------------------------------------------------------------------------------------
procedure xml_dump_overload_desc (
    desc           : in poverloaddesc;           -- dumped structure
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
----------------------------------------------------------------------------------------------------
begin
  -- pokud [desc] nen¡ zad no, nic nedˆlat
  if desc=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  -- dump
  if desc^.psym.getuentity<>nil then xml^.write_text_element('psym',sym_get_qid(desc^.psym.getuentity));end if;
  xml^.write_text_element('assign',t_logical_export_id[desc^.assign]);
  xml^.write_text_element('arity',tooperarity_export_id[desc^.arity]);

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_overload_desc;



----------------------------------------------------------------------------------------------------
procedure xml_dump_overload_table (
    table          : in poverloadtable;          -- dumped structure
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
----------------------------------------------------------------------------------------------------
begin
  -- pokud tabulka nen¡ zad na, nic nedˆlat
  if table=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  -- zpracovat ©etˆzec
  for i in table^:range loop
    xml_dump_overload_desc(^table^[i],xml,'desc');
    end loop;

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_overload_table;



----------------------------------------------------------------------------------------------------
procedure xml_dump_id_table (
    table          : in pidnode;                 -- dumpovan  strutura
    xml            : in p_xml_dumper) =          -- XML dumper
-- dump tabulky identifik tor–
----------------------------------------------------------------------------------------------------
begin
  -- pr zdn˜ uzel - nic nedˆlat
  if table=nil then return end if;

  -- zpracovat lev˜ podstrom
  xml_dump_id_table(table^.left,xml);

  -- zano©en¡
  xml^.go_in('idnode');

  -- dump
  xml^.write_attribute('vaha',signed_to_string(table^.vaha));
  if table^.id<>nil then xml^.write_text_element('id',entityident_to_string(table^.id^));end if;
  if table^.entity<>nil then xml^.write_text_element('entity',sym_get_qid(table^.entity));end if;

  -- vyno©en¡
  xml^.go_out('idnode');

  -- zpracovat prav˜ podstrom
  xml_dump_id_table(table^.left,xml);
  end xml_dump_id_table;



----------------------------------------------------------------------------------------------------
procedure xml_dump_with_table (
    table          : in twithtable;              -- dumpovan  strutura
    xml            : in p_xml_dumper;            -- XML dumper
    name           : in t_char32ustr) =          -- jm‚no obalov‚ho elementu
-- dump with-tabulky
----------------------------------------------------------------------------------------------------
begin
  if table=nil then return end if;

  -- zano©en¡
  xml^.go_in(name);

  -- zpracovat prvky ©etˆzce
  for i in table^:range loop
    -- zano©en¡
    xml^.go_in('item');

    -- dump
    xml^.write_attribute('mode',t_with_mode_export_id[table^[i].mode]);
    if table^[i].entity.getuentity<>nil then xml^.write_text_element('entity',sym_get_qid(table^[i].entity.getuentity));end if;
    xml^.write_text_element('stat_usage',unsigned_to_string(table^[i].stat_usage));
    xml_dump_lex_pos_block(xml,'lexpos',table^[i].lexpos);
    xml^.write_text_element('level',t_with_level_export_id[table^[i].level]);
    xml^.write_text_element('automatic',t_logical_export_id[table^[i].automatic]);

    -- vyno©en¡
    xml^.go_in('item');
    end loop;

  -- vyno©en¡
  xml^.go_out(name);
  end xml_dump_with_table;



----------------------------------------------------------------------------------------------------
class private c_entity_dumper =
-- T©¡da pro v˜stup entity do XML
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override enter_node =
    -- Ud lost spu¨tˆn  p©i vstupu do uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- vstup do elementu
      xml^.go_in(tentitytype_export_id[node^.etype]);
      end enter_node;



    ------------------------------------------------------------------------------------------------
    override leave_node =
    -- Ud lost spu¨tˆn  p©i v˜stupu z uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- v˜stup z elementu
      xml^.go_out(tentitytype_export_id[node^.etype]);
      end leave_node;



    ------------------------------------------------------------------------------------------------
    override enter_region =
    -- ud lost
    ------------------------------------------------------------------------------------------------
    begin
      -- vstup do elementu
      xml^.go_in('region');
      end enter_region;



    ------------------------------------------------------------------------------------------------
    override leave_region =
    -- ud lost
    ------------------------------------------------------------------------------------------------
    begin
      -- v˜stup z elementu
      xml^.go_out('region');
      end leave_region;



    ------------------------------------------------------------------------------------------------
    override enter_sub_region =
    -- Ud lost spu¨tˆn  p©i vstupu do regionu.
    ------------------------------------------------------------------------------------------------
    begin
      -- vstup do elementu
      xml^.go_in('region');
      end enter_sub_region;



    ------------------------------------------------------------------------------------------------
    override leave_sub_region =
    -- Ud lost spu¨tˆn  p©i v˜stupu z regionu.
    ------------------------------------------------------------------------------------------------
    begin
      -- v˜stup z elementu
      xml^.go_out('region');
      end leave_sub_region;


    
    ------------------------------------------------------------------------------------------------
    override before_sub_regions =
    -- ud lost
    ------------------------------------------------------------------------------------------------
    begin
      -- vstup do elementu
      xml^.go_in('regions');
      end before_sub_regions;



    ------------------------------------------------------------------------------------------------
    override after_sub_regions =
    -- ud lost
    ------------------------------------------------------------------------------------------------
    begin
      -- v˜stup z elementu
      xml^.go_out('regions');
      end after_sub_regions;



    ------------------------------------------------------------------------------------------------
    override process_region =
    -- zpracov n¡ regionu
    ------------------------------------------------------------------------------------------------
    begin
      -- dump
      xml^.write_text_element('rtype',tregiontype_export_id[region^.rtype]);
      xml^.write_text_element('vsect',tentityvisible_export_id[region^.vsect]);

      -- dump region^.idtable
      xml^.go_in('idtable');
      xml_dump_id_table(region^.idtable,xml);
      xml^.go_out('idtable');

      -- region^.withtable
      xml_dump_with_table(region^.withtable,xml,'withtable');
      end process_region;



    ------------------------------------------------------------------------------------------------
    override process_entity_base =
    -- ud lost
    ------------------------------------------------------------------------------------------------
    begin
      -- dump b zov‚ t©¡dy
      xml^.write_attribute('visible',tentityvisible_export_id[node^.visible]);
      xml^.write_attribute('full',tentityvisible_export_id[node^.full]);
      xml^.write_attribute('declared', tentitydeclared_export_id[node^.declared]);
      xml^.write_attribute('evaluated', tentitydeclared_export_id[node^.evaluated]);
      xml^.write_attribute('compiling', tentitydeclared_export_id[node^.compiling]);
      xml^.write_attribute('eval', tentityeval_export_id[node^.eval]);
      if node^.id<>nil then xml^.write_text_element('id',entityident_to_string(node^.id^));end if;
      xml^.write_text_element('compile',tentitycompileset_to_string(node^.compile));
      -- TODO node^.compv:tcompvar -- parametry prekladu
      xml^.write_text_element('is_abstract',t_logical_export_id[node^.is_abstract]);
      xml^.write_text_element('analyzed',analyzestatus_export_id[node^.analyzed]);
      xml^.write_text_element('linked',linkstatus_export_id[node^.linked]);
      xml^.write_text_element('debugstat',analyzestatus_export_id[node^.debugstat]);
      xml^.write_text_element('stat_usage',unsigned_to_string(node^.stat_usage));
      end process_entity_base;



    ------------------------------------------------------------------------------------------------
    override process_entity_code =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- dump
      -- TODO bl : cc_ref.refblock;
      xml^.write_text_element('nesting',unsigned_to_string(node^.nesting));
      end process_entity_code;



    ------------------------------------------------------------------------------------------------
    override process_entity_compile =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- dump - atributy mus¡ j¡t prvn¡
      xml^.write_attribute('compitype',tcompilationtype_export_id[node^.compitype]);

      -- zpracovat p©edka
      process_entity_code(node);
      end process_entity_compile;



    ------------------------------------------------------------------------------------------------
    override process_entity_program =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_code(node);
      end process_entity_program;



    ------------------------------------------------------------------------------------------------
    override process_entity_module =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- TODO lib_info     : p_flex_record
      end process_entity_module;



    ------------------------------------------------------------------------------------------------
    override process_entity_init =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- dump
      if node^.init.getuimm<>nil then xml_dump_imm_value(xml,'imm',node^.init.getuimm^);end if;
      end process_entity_init;



    ------------------------------------------------------------------------------------------------
    override process_entity_value =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_init(node);

      -- dump
      if node^.typ.getutype<>nil then xml^.write_text_element('typ',sym_get_qid(node^.typ.getutype));end if;
      dump_rtattribs(xml,'rtattribs',node^.rta_avail,node^.rta_used);
      xml^.write_text_element('rta_fixed',t_logical_export_id[node^.rta_fixed]);
      end process_entity_value;



    ------------------------------------------------------------------------------------------------
    override process_entity_param =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_value(node);

      -- dump
      xml^.write_text_element('mode',parammode_export_id[node^.mode]);
      xml^.write_text_element('pass',parampass_export_id[node^.pass]);
      xml^.write_text_element('paliased',t_logical_export_id[t_logical(node^.paliased)]);
      -- TODO xml^.write_text_element('size',unsigned_to_string(node^.size));
      xml^.write_text_element('num',unsigned_to_string(node^.num));
      end process_entity_param;



    ------------------------------------------------------------------------------------------------
    override process_entity_var =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_value(node);

      -- dump
      xml^.write_text_element('mclass',memclasstxt[node^.mclass]);
      xml^.write_text_element('vflags',varflagset_to_string(node^.vflags));
      xml^.write_text_element('vmode',varmode_export_id[node^.vmode]);
      xml^.write_text_element('vaccess',varaccess_export_id[node^.vaccess]);
      xml^.write_text_element('valiased',t_logical_export_id[node^.valiased]);
      xml^.write_text_element('vimplements',varimplements_export_id[node^.vimplements]);
      if node^.imp_param<>nil then xml^.write_text_element('imp_param',sym_get_qid(node^.imp_param));end if;
--      xml^.write_text_element('addr',unsigned_to_string(node^.addr));
      -- TODO attr_position: cc_ref.refexpr;             -- pozice slo‘ky recordu
      -- TODO export_info  : p_flex_record;              -- informace pro export
      end process_entity_var;



    ------------------------------------------------------------------------------------------------
    override process_entity_const =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_value(node);

      -- dump
      xml^.write_text_element('cflags',constflagset_to_string(node^.cflags));
      end process_entity_const;



    ------------------------------------------------------------------------------------------------
    override process_entity_enum =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- dump
      if node^.typ<>nil then xml^.write_text_element('typ',sym_get_qid(node^.typ));end if;
      xml^.write_text_element('order',unsigned_to_string(node^.order));
      xml^.write_text_element('order',unsigned_to_string(uniint_to_unsigned(node^.ordinal)));
      -- TODO attr_ord     : cc_ref.refexpr
      end process_entity_enum;



    ------------------------------------------------------------------------------------------------
    override process_entity_type =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- dump - atributy mus¡ j¡t prvn¡
      xml^.write_attribute('tkind',typekind_export_id[node^.tkind]);

      -- zpracovat p©edka
      process_entity_init(node);

      -- dump
      xml^.write_text_element('stype',tdatatypetxt[node^.stype]);
      xml^.write_text_element('eval',tentityeval_export_id[node^.seval]);
      xml^.write_text_element('derive',typederive_export_id[node^.derive]);
      xml^.write_text_element('defview',ttypeviewtxt[node^.defview]);
      -- TODO xml^.write_text_element('extofs',unsigned_to_string(node^.extofs));
      xml^.write_text_element('tflags',typeflagset_to_string(node^.tflags));
      xml^.write_text_element('compat',typecompat_export_id[node^.compat]);
      -- TODO expr         : cc_ref.refexpr
--      xml^.write_text_element('align',unsigned_to_string(node^.align));
      xml^.write_text_element('tinit',typeinit_export_id[node^.tinit]);
      xml_dump_spectable(node^.stable,xml,'stable');
      xml^.write_text_element('cclass',tcontainsclass_export_id[node^.cclass]);
      if node^.base.getutype<>nil then xml^.write_text_element('base',sym_get_qid(node^.base.getutype));end if;
      xml^.write_text_element('lval',unsigned_to_string(uniint_to_unsigned(node^.lval)));
      xml^.write_text_element('hval',unsigned_to_string(uniint_to_unsigned(node^.hval)));
--      xml^.write_text_element('bits',unsigned_to_string(node^.bits));
      xml^.write_text_element('intaritm',tintaritm_export_id[node^.intaritm]);
      xml_dump_floatparams(node^.fp,xml,'fp');
      if node^.srange.getutype<>nil then xml^.write_text_element('srange',sym_get_qid(node^.srange.getutype));end if;
      xml^.write_text_element('saliased',t_logical_export_id[t_logical(node^.saliased)]);
--      xml^.write_text_element('lsize',unsigned_to_string(node^.lsize));
      xml^.write_text_element('pflags',ptrflagsset_to_string(node^.pflags));
      xml^.write_text_element('pclass',ptrclass_export_id[node^.pclass]);
      xml^.write_text_element('pbase',ptrbase_export_id[node^.pbase]);
      xml^.write_text_element('pattrib',rtattribset_to_string(node^.pattrib));
      xml^.write_text_element('paccess',varaccess_export_id[node^.paccess]);
      xml^.write_text_element('rflags',procflagset_to_string(node^.rflags));
      if node^.result<>nil then xml^.write_text_element('result',sym_get_qid(node^.result));end if;
--      xml^.write_text_element('insize',unsigned_to_string(node^.insize));
      xml^.write_text_element('parcount',unsigned_to_string(node^.parcount));
      -- TODO call_conv    : p_flex_record
      xml_dump_interface_list(node^.interfaces,xml,'interfaces');
      -- TODO attr_align   : cc_ref.refexpr
      -- TODO attr_size    : cc_ref.refexpr
      -- TODO attr_mptr    : cc_ref.refexpr
      end process_entity_type;



    ------------------------------------------------------------------------------------------------
    override process_entity_subprogram =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_code(node);

      -- dump
      xml^.write_text_element('instance',tinstancepass_export_id[node^.instance]);
      if node^.typ.getutype<>nil then xml^.write_text_element('typ',sym_get_qid(node^.typ.getutype));end if;
      end process_entity_subprogram;



    ------------------------------------------------------------------------------------------------
    override process_entity_static_subprogram =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_subprogram(node);

      -- dump
      xml^.write_text_element('no_return',t_logical_export_id[node^.no_return]);
      end process_entity_static_subprogram;


    
    ------------------------------------------------------------------------------------------------
    override process_entity_procedure =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_static_subprogram(node);

      -- dump
      -- TODO import_info  : p_flex_record
      -- TODO export_info  : p_flex_record
      end process_entity_procedure;



    ------------------------------------------------------------------------------------------------
    override process_entity_static =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_static_subprogram(node);
      end process_entity_static;



    ------------------------------------------------------------------------------------------------
    override process_entity_virtual =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_subprogram(node);

      -- dump
      xml^.write_text_element('vcall',tvcalltype_export_id[node^.vcall]);
      xml^.write_text_element('vindex',unsigned_to_string(node^.vindex));
      xml_dump_type_vector_set(node^.vector_set,xml,'vector_set');
      xml_dump_type_vector(node^.root_vector,xml,'root_vector');
      end process_entity_virtual;



    ------------------------------------------------------------------------------------------------
    override process_entity_override =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_code(node);

      -- dump
      if node^.virt.getuentity<>nil then xml^.write_text_element('virt',sym_get_qid(node^.virt.getuentity));end if;
      xml_dump_class_interface(node^.interface,xml,'interface');
      xml_dump_type_vector(node^.type_vector,xml,'type_vector');
      end process_entity_override;



    ------------------------------------------------------------------------------------------------
    override process_entity_task =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_subprogram(node);
      end process_entity_task;



    ------------------------------------------------------------------------------------------------
    override process_entity_special =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_subprogram(node);

      -- dump
      xml^.write_text_element('spectype',tspectype_export_id[node^.spectype]);
      xml^.write_text_element('specobj',tspecobject_export_id[node^.specobj]);
      end process_entity_special;


    
    ------------------------------------------------------------------------------------------------
    override process_entity_macro =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_subprogram(node);
      end process_entity_macro;



    ------------------------------------------------------------------------------------------------
    override process_entity_overload0 =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity(node);

      -- dump
      xml_dump_overload_table(node^.table,xml,'table');
      end process_entity_overload0;



    ------------------------------------------------------------------------------------------------
    override process_entity_overload =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_overload0(node);
      end process_entity_overload;



    ------------------------------------------------------------------------------------------------
    override process_entity_operator =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_overload0(node);

      -- dump
      xml^.write_text_element('oop',tooperator_export_id[node^.oop]);
      end process_entity_operator;



    ------------------------------------------------------------------------------------------------
    override process_entity_attribute =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_value(node);
      end process_entity_attribute;



    ------------------------------------------------------------------------------------------------
    override process_entity_message =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- dump
      if node^.typ.getutype<>nil then xml^.write_text_element('typ',sym_get_qid(node^.typ.getutype));end if;
      end process_entity_message;



    ------------------------------------------------------------------------------------------------
    override process_entity_label =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);

      -- dump
      xml^.write_text_element('num',unsigned_to_string(node^.num));
      xml^.write_text_element('reachable',t_logical_export_id[node^.reachable]);
      xml^.write_text_element('placed',t_logical_export_id[node^.placed]);
      xml^.write_text_element('level',unsigned_to_string(node^.level));
      end process_entity_label;



    ------------------------------------------------------------------------------------------------
    override process_entity_template =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);
      end process_entity_template;



    ------------------------------------------------------------------------------------------------
    override process_entity_tparam =
    -- zpracov n¡ uzlu - dump
    ------------------------------------------------------------------------------------------------
    begin
      -- zpracovat p©edka
      process_entity_base(node);
      end process_entity_tparam;



    ------------------------------------------------------------------------------------------------
    static init =
    -- inicializace
    ------------------------------------------------------------------------------------------------
    begin
      this.xml:=xml;
      end init;

    end c_entity_dumper;



----------------------------------------------------------------------------------------------------
procedure dump_entity_to_file =
-- Provede dump entity do XML souboru
----------------------------------------------------------------------------------------------------
var
  xml              : p_file_xml_dumper;          -- souborov˜ xml dumper

begin
  -- vyvo©it instanci
  new xml;

  -- inicializovat
  xml^.init(file);

  -- vlastn¡ dump
  dump_entity_to_xml(entity,xml);
leave
  discard xml;
  end dump_entity_to_file;



----------------------------------------------------------------------------------------------------
procedure dump_entity_to_xml =
-- Provede dump entity do XML dumperu
----------------------------------------------------------------------------------------------------
var
  dumper           : p_entity_dumper;            -- dumper

begin
  -- vyvo©it instanci
  new dumper;

  -- inicializivat
  dumper^.init(xml);

  -- vlastn¡ dump
  dumper^.traverse_entity(entity);

leave
  -- uvolnit pamˆt
  discard dumper;
  end dump_entity_to_xml;

end cc_entity;
