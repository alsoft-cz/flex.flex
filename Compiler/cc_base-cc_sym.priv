----------------------------------------------------------------------------------------------------
module private cc_sym =
-- Překladač Flexu.
-- Manipulace s tabulkou symbolů.
----------------------------------------------------------------------------------------------------
-- Ondra : 18.06.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_gc,
  cc_def.cc_var,
  cc_def.cc_codes;


----------------------------------------------------------------------------------------------------
class private tentitysearch =
-- Hledátko.
----------------------------------------------------------------------------------------------------

    var
      flags        : tesearchflagset;
      level        : t_unsigned;

      -- pouze pro hledání podle typu entity
      etype        : tentitytype;                -- typ prvku
      req_etype    : ^tentitytype;                -- pozadovany typ entity (NIL=netestuje)

    ------------------------------------------------------------------------------------------------
    static find_ident (
        idtable    : in pidnode;                 -- tabulka identifikatoru
        id         : in tentityident;            -- identifikator
        vis        : in tentityvisibleset;       -- požadovaná viditelnost
        node       : out pidnode) =              -- nalezeny uzel nebo NIL
    -- Vyhledá identifikátor v tabulce identifikátorů.
    ------------------------------------------------------------------------------------------------
    var
      pid          : pidnode;                    -- pro vyhledani uzlu

    begin
      pid:=idtable;
      while pid<>nil loop
        -- hledat v prave vetvi
        if id>pid^.id^ then 
          pid:=pid^.right

        -- hledat v leve vetvi
        elsif id<pid^.id^ then
          pid:=pid^.left;

        -- nalezeno
        else
          node:=pid;
          break;
          end if;
        end loop;

      -- zkorigovat výsledek podle viditelnosti
      if node<>nil and then node^.entity^.visible not in vis then
        node:=nil;
        end if;
      end find_ident;



    ------------------------------------------------------------------------------------------------
    static find_link (
        _ancestor  : in pentity;                 -- symbol obsahujici tab. id.
        id         : in tentityident;            -- identifikator
        _vis       : in tentityvisibleset;       -- požadovaná viditelnost
        node       : out pidnode) =              -- nalezeny uzel
    -- Najde entitu podle identifikatoru v prilinkovane tabulce entit.
    ------------------------------------------------------------------------------------------------
    var
      ancestor     : pentity;                    -- předek
      vis          : tentityvisibleset;

    begin
      ancestor:=_ancestor;
      vis:=_vis*tentityvisibleset:[etv_public,etv_protected,etv_supervised];
      while ancestor<>nil loop
        ---- hledani na lokalni urovni ----
        find_ident(ancestor^.regions[rc_primary]^.idtable,id,vis,node);
        if node<>nil then return end if;

        ---- hledat v předkovi ----
        ancestor:=ancestor^.ancestor.getuentity;
        end loop;
      end find_link;



    ------------------------------------------------------------------------------------------------
    static find_with (
        withtab    : in twithtable;              -- tabulka použitých modulů
        id         : in tentityident;            -- identifikator
        node       : out pidnode) =              -- nalezeny uzel nebo NIL
    -- Najde symbol podle identifikátoru ve WITH modulech
    ------------------------------------------------------------------------------------------------
    begin
      if withtab<>nil then
        for i in withtab^:range loop
          if withtab^[i].mode=twm_with then
            find_link(withtab^[i].entity.getcentity,id,with_level_to_visibility[withtab^[i].level]{tentityvisibleset:[etv_public]},node);
            if node<>nil then
              if (req_etype=nil or node^.entity^.etype=req_etype^) and node^.entity^.etype<>et_module {not in ets_modular} then 
                succ withtab^[i].stat_usage;
                end if;		
              break;
              end if;
            end if;
          end loop;
        end if;
      end find_with;



    ------------------------------------------------------------------------------------------------
    static find_global =
    -- Nalezne entitu podle identifikátoru.
    -- Tabulku entit prohledává podle pravidel viditelnosti.
    ------------------------------------------------------------------------------------------------
    var
      node             : pidnode;                    -- (ne)nalezeny uzel
      xcontext         : tcontext;                   -- prohledavany kontext (v hieararchii)

    begin
      -- kazdopadne predem vynulovat
      this.level:=0;
      this.psym:=nil;
      node:=nil;

      -- prohledat
      xcontext:=context;
      loop
        -- je s aktuální entitou asociovaný nějaký deklarativní region ?
        if xcontext.region<>nil 
        
          -- entita s deklarativním regionem => prohledat
          then 
            -- prohledat tuto úroveň
            find_ident(xcontext.region^.idtable,id,tentityvisibleset:full,node);
            if node<>nil then break end if;
   
            -- prohledat předka
            if sym_is_top_region(xcontext) then
              find_link(xcontext.entity^.ancestor.getuentity,id,tentityvisibleset:[etv_public,etv_protected],node);
              if node<>nil then break end if;
              end if;
      
            -- prohledat with/use tabulku
            find_with(xcontext.region^.withtable,id,node);
            if node<>nil then break end if;

            -- na vyšší úroveň
            if sym_is_top_region(xcontext)
              then xcontext:=xcontext.entity^.context;
              else xcontext:=xcontext.region^.context;
              end if;

          -- entita bez deklarativního regionu => na vyšší úroveň
          else
            xcontext:=xcontext.entity^.context;
            end if;

        -- zkusit vyšší úroveň
        until xcontext.entity=nil;

      -- vratit (ne)nalezeny symbol
      if node=nil
        then this.psym:=nil;
        else this.psym:=node^.entity;
        end if;

      end find_global;

     

    ------------------------------------------------------------------------------------------------
    static find_global_ex =
    -- Find_global doplnena o test typu entity
    -- Pouziva se pri testovani template - neinkrementuje pouziti modulu ve WITH tabulce
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud je req_etype<>nil, testuje ve find_with() typ ve WITH tabulce hledane entity
      req_etype:=^etype;
      find_global(context,id);
      req_etype:=nil;
      end find_global_ex;


    
    ------------------------------------------------------------------------------------------------
    static find_global_by_qid =
    -- Nalezne entitu podle kvalifikovaneho identifikátoru.
    -- Tabulku entit prohledává podle pravidel viditelnosti.
    ------------------------------------------------------------------------------------------------
    with
      standard.strings;

    var
      strstring    : p_char32str_string;
      srch_qid     : t_char32str;

    begin
      -- kazdopadne predem vynulovat
      this.level:=0;
      this.psym:=nil;

      -- je co hledat?
      if qid:length=0 then return; end if;

      -- odstranit tecku na zacatku
      srch_qid:=str_trim(qualified_entity_ident_to_string(qid),".",[se_left]);

      -- nastavit počáteční kontext pro prohledávání
      psym:=^compi;

      -- pokud se po nás chce dohledat přímo kompilační jednotku, jsme hotovi
      if srch_qid={%%TODO(QID)}entityident_to_string(id_compilation) then return end if;

      -- rozloz qid
      str_separate(srch_qid,".",strstring);

      -- prohledej jednotlive sub-id dodaneho qid
      for i in strstring^:range loop
        declare var
          eid      : pentityident;
          
        begin
          -- najdi sub-id
          eid:=string_to_entityident(strstring^[i]);
         
          -- speciální varianta: atribut :type
          if eid^=':type' then
            case psym^.etype
              when et_var       do psym:=pentity_var(psym)^.typ.getutype;
              when et_const     do psym:=pentity_const(psym)^.typ.getutype;
              when et_procedure do psym:=pentity_procedure(psym)^.typ.getutype;
              when et_static    do psym:=pentity_static(psym)^.typ.getutype;
              when et_virtual   do psym:=pentity_virtual(psym)^.typ.getutype;
              when et_task      do psym:=pentity_task(psym)^.typ.getutype;
              when et_special   do psym:=pentity_special(psym)^.typ.getutype;
              when et_message   do psym:=pentity_message(psym)^.typ.getutype;
              when others       do psym:=nil;
              end case;
          
          -- speciální varianta: atribut :base
          elsif eid^=':base' then
            if psym^.etype=et_type
              then psym:=pentity_type(psym)^.base.getutype;
              else psym:=nil;
              end if;
          
          -- speciální varianta: atribut :range
          elsif eid^=':range' then
            if psym^.etype=et_type
              then psym:=pentity_type(psym)^.srange.getutype;
              else psym:=nil;
              end if;
          
          -- obyčejný identifikátor
          else
            find_local_all(sym_primary_context(psym^),eid^);
            end if;
          
        leave
          discard eid;
          end declare;

        -- exituj, pokud se nenaslo
        if psym=nil then break; end if;
        end loop;

    leave
      discard strstring;
      end find_global_by_qid;

    
    
    ------------------------------------------------------------------------------------------------
    static find_local =
    -- Nalezne entitu podle idenfifikátoru.
    -- Hledá na lokální úrovni a v předkovi. Viditelnost symbolu musí být v množině požadované
    -- viditelnosti.
    ------------------------------------------------------------------------------------------------
    var
      node             : pidnode;                    -- (ne)nalezeny uzel
      xcontext         : tcontext;                   -- prohledavany kontext (v hieararchii)

    begin
      -- kazdopadne predem vynulovat
      this.level:=0;
      this.psym:=nil;
      node:=nil;

      -- prohledat
      if context.region<>nil then
        xcontext:=context;
        loop
          -- prohledat tuto úroveň
          find_ident(xcontext.region^.idtable,id,visibility,node);
          if node<>nil then break end if;
   
          -- nejsme už v top-level regionu ?
          if sym_is_top_region(xcontext) then
            -- ještě zkusit prohledat předka
            find_link(context.entity^.ancestor.getuentity,id,visibility,node);

            -- a končíme
            break;
            end if;

          -- o úroveň výš
          xcontext:=xcontext.region^.context;
          end loop;
        end if;
                            
      -- vratit (ne)nalezeny symbol
      if node=nil
        then this.psym:=nil;
        else this.psym:=node^.entity;
        end if;
      end find_local;



    ------------------------------------------------------------------------------------------------
    static find_local_all =
    -- Nalezne entitu podle idenfifikátoru.
    -- Hledá pouze na lokální úrovni. Viditelnost symbolu nebere v úvahu.
    ------------------------------------------------------------------------------------------------
    var
      node             : pidnode;                    -- (ne)nalezeny uzel
      xcontext         : tcontext;                   -- prohledavany kontext (v hieararchii)

    begin
      -- kazdopadne predem vynulovat
      this.level:=0;     -- %%TECH Tyto dva řádky jsou jen pro jistotu, jestli to není v překladači třeba, lze je smazat
      this.psym:=nil;
      node:=nil;

      -- hledat na lokalni urovni
      xcontext:=context;
      while xcontext.region<>nil loop
        -- prohledat tuto úroveň
        find_ident(xcontext.region^.idtable,id,tentityvisibleset:full,node);
        if node<>nil then break end if;
   
        -- o úroveň výš
        xcontext:=xcontext.region^.context;
        end loop;
      
      -- vratit (ne)nalezeny symbol
      if node=nil
        then this.psym:=nil;
        else this.psym:=node^.entity;
        end if;
      end find_local_all;



    var
      -- pouze pro hledání podle typu entity
      rcategory    : tregioncategory;            -- kategorie prohledávaného regionu

    ------------------------------------------------------------------------------------------------
    static search_et (
        zdroj      : in tcontext;                -- zdroj entit
        next       : in out t_logical) =         -- T-hledat následující
    -- Najde první/následující prvek daného typu.
    ------------------------------------------------------------------------------------------------
    var
      last_found   : class pentity;              -- entita nalezená při předchozím hledání

    begin
      -- zvolit pořadí prohledávání
      if esf_reverse in flags

        -- opačné pořadí
        then psym:=zdroj.region^.entities.last

        -- přímé pořadí
        else
          -- nemáme napřed zkusit předka ?
          if esf_ancestor in flags and then zdroj.entity^.ancestor.isset then
            search_et(sym_build_context_from_category(zdroj.entity^.ancestor.getcentity,rcategory),next);
            if psym<>nil then return; end if;
            end if;

          -- teď prohledat sebe
          psym:=zdroj.region^.entities.first;
          end if;

      -- prohledat
      while psym<>nil loop	

        -- nalezeno
        if psym^.etype=this.etype or else this.etype=et_undef then
          -- %%TECH, %%X Tato metoda pamatování si předchozího symbolu
          -- nebude fungovat v paralelním překladači.
          if next

            -- tenhle již byl jednou nalezen
            then
              next:=last_found<>psym;

            -- nově nalezen
            else
              last_found:=psym;
              return;
              end if;
          end if;
      {   
        -- o úroveň níž
        elsif psym^.etype=et_with {(psym^.ptype=et_link) and (pdeflink(psym)^.ltype=lt_full)} {%%X and (pdeflink(psym)^.sym<>psym^.owner)} then
          -- generický nebo nevyhodnocený odkaz, dále nic nezkoumat
          -- %%X nemělo by se volat E_SYMBOL ? 
          if pdefwith(psym)^.typ.e<>ete_evaluated then return; end if;
          --if pdeflink(psym)^.sym.e<>se_evaluated then exit; end if;

          -- zkusit vyhledat
          --search_et(pvnoreny,pdeflink(psym)^.sym.getcentity,ptype,reverse,adr,next);
          search_et(pvnoreny,pdefwith(psym)^.typ.getctype,ptype,flags{reverse},adr,next);
          if pvnoreny<>nil then
            --udadd(adr,pdeflink(psym)^.ofs);
            udadd(adr,pdefwith(psym)^.ofs);
            psym:=pvnoreny;
            return;
            end if;
          end;
      }
        
        -- další symbol
        if esf_reverse in flags
          then psym:=psym^.prev;
          else psym:=psym^.next;
          end if;
        end loop;

      -- stále nenalezeno => při opačném pořadí by šlo zkusit předka
      if psym=nil and then esf_reverse in flags and then esf_ancestor in flags and then zdroj.entity^.ancestor.isset then
        search_et(sym_build_context_from_category(zdroj.entity^.ancestor.getcentity,rcategory),next);
        if psym<>nil then return; end if;
        end if;
      end search_et;



    var
      -- pouze pro hledání podle typu entity
      zdroj        : tcontext;                   -- zdroj prvků

    ------------------------------------------------------------------------------------------------
    static find_et_first =
    -- Nalezne první entitu zadaného typu. Je-li ETYPE=ET_UNDEF, najde libovolný.
    -- Normálně se hledá v přímém pořadí, s flagem ESF_REVERSE v opačném.
    ------------------------------------------------------------------------------------------------
    var
      next             : t_logical;

    begin
      this.flags:=flags;
      this.level:=0;
      this.zdroj:=sym_build_context_from_category(zdroj,rcategory);
      this.rcategory:=rcategory;
      this.etype:=etype;
      next:=false;
      search_et(this.zdroj,next);
      end find_et_first;



    ------------------------------------------------------------------------------------------------
    static find_et_first_in_context =
    -- Nalezne první entitu zadaného typu v uvedeném kontextu. 
    -- Nesmí být uveden příznak ESF_ANCESTOR. 
    -- V ostatních ohledech se chová stejně jako FIND_ET_FIRST.
    ------------------------------------------------------------------------------------------------
    var
      next             : t_logical;

    begin
      verify({VERIFY=}000626,esf_ancestor in flags);
      this.flags:=flags;
      this.level:=0;
      this.zdroj:=context;
      this.etype:=etype;
      next:=false;
      search_et(this.zdroj,next);
      end find_et_first_in_context;



    ------------------------------------------------------------------------------------------------
    static find_et_next =
    -- Nalezne další prvek zadaného typu.
    ------------------------------------------------------------------------------------------------
    var
      next             : t_logical;

    begin
      this.level:=0;
      next:=true;
      search_et(this.zdroj,next);
      end find_et_next;



    ------------------------------------------------------------------------------------------------
    static count_et =
    -- Vrátít počet entit vyhovujících zadaným parametrům.
    ------------------------------------------------------------------------------------------------
    begin
      find_et_first(zdroj,rcategory,etype,flags);
      while psym<>nil loop
        succ result;
        find_et_next;
        end loop;
      end count_et;



    var
      -- pouze pro hledání více entit se stejným identifikátorem
      xcontext     : tcontext;
      ycontext     : tcontext;
      windex       : twithtable^:range;
      sv           : tentityvisibleset;
      status       : enum
          search_this;
          search_local;
          search_with;
          search_context;
          end enum;      
      next         : status:type;
      id           : pentityident;

    ------------------------------------------------------------------------------------------------
    static find_id_first =
    -- Nalezne první entitu podle identifikátoru.
    ------------------------------------------------------------------------------------------------
    begin
      -- kazdopadne predem vynulovat
      this.level:=0;
      this.psym:=nil;

      -- počáteční stav automatu
      this.status:=search_this;
      this.xcontext:=context{where};
      this.id:=id;

      -- hledat
      find_id_next;
      end find_id_first;



    ------------------------------------------------------------------------------------------------
    static find_id_next =
    -- Nalezne další entitu podle identifikátoru.
    ------------------------------------------------------------------------------------------------
    var
      node         : pidnode;                    -- (ne)nalezeny uzel
      xcontext     : tcontext;                   -- symbol prohledávaný v ose x
      ycontext     : tcontext;                   -- symbol prohledávaný v ose y
      windex       : twithtable^:range;          -- index do with-tabulky
      sv           : tentityvisibleset;          -- maska viditelnosti

    begin
      -- naplnit pracovní proměnné
      xcontext:=this.xcontext;
      ycontext:=this.ycontext;
      windex:=this.windex;
      sv:=this.sv;

      -- hledat
      node:=nil;
      while node=nil and xcontext.entity<>nil loop
        case this.status
          -- hledání na lokální úrovni a v předkovi
          when search_this  do
              -- zavolat podprogram
              ycontext:=xcontext;
              this.status:=search_local;
              sv:=tentityvisibleset:full;

              -- příště se bude prohledávat with-tabulka
              windex:=windex:first;
              this.next:=search_with;

          -- hledání v ose y
          when search_local do
              -- prohledat lokální tabulku symbolů
              find_ident(ycontext.region^.idtable,this.id^,sv,node);

              -- další region
              if sym_is_top_region(ycontext)

                -- podívat se k předkovi
                then
                  -- předek
                  if ycontext.entity^.ancestor.getuentity=nil

                    -- neexistuje => další krok
                    then 
                      this.status:=this.next
 
                    -- existuje => omezit masku viditelnosti a prohledat
                    else 
                      -- ještě doplnit primární region
                      ycontext:=sym_primary_context(ycontext.entity^.ancestor.getuentity^);

                      -- omezit masku viditelnosti
                      sv*tentityvisibleset:[etv_public,etv_protected]
                      end if;

                -- o region výše
                else
                  -- context nadřazeného regionu
                  ycontext:=ycontext.region^.context;

                  -- %%TECH Pokud bychom povolili WITH/USE i v DECLARE bloku, tak by se zde
                  -- muselo doplnit prohledání lokální WITH tabulky.
                  end if;

          -- hledání ve with-tabulce
          when search_with  do
              -- nalézt první přípustnou položku
              if xcontext.region^.withtable<>nil then 
                while windex<=xcontext.region^.withtable^:length and xcontext.region^.withtable^[windex].mode<>twm_with loop 
                  succ windex; 
                  end loop;
                end if;

              if xcontext.region^.withtable=nil or else windex>xcontext.region^.withtable^:length

                -- prohledat nadřazený kontext
                then 
                  this.status:=search_context

                -- prohledat with tabulku
                else
                  -- zavolat podprogram
                  ycontext:=sym_primary_context(xcontext.region^.withtable^[windex].entity.getcentity^);
                  this.status:=search_local;
                  sv:=with_level_to_visibility[xcontext.region^.withtable^[windex].level];

                  -- příště se bude prohledávat další položka ve with-tabulce
                  this.next:=search_with;
                  succ windex;
                  end if;

          -- hledání v nadřazeném kontextu
          when search_context do
              xcontext:=xcontext.entity^.context;
              this.status:=search_this;

          when others do verify({VERIFY=}000289,true);
          end case;
        end loop;

      -- vratit (ne)nalezeny symbol
      if node=nil
        then this.psym:=nil;
        else this.psym:=node^.entity;
        end if;

      -- uložit pracovní proměnné
      this.xcontext:=xcontext;
      this.ycontext:=ycontext;
      this.windex:=windex;
      this.sv:=sv;
      end find_id_next;



    ------------------------------------------------------------------------------------------------
    static set_entity =
    -- Uměle naplní výsledek hledání.
    ------------------------------------------------------------------------------------------------
    begin
      this.psym:=psym;
      end set_entity;

    end tentitysearch;



----------------------------------------------------------------------------------------------------
procedure sym_primary_context =
-- Sestaví primární kontext entity.                                                                
----------------------------------------------------------------------------------------------------
begin
  result.entity:=^curr;
  result.region:=curr.regions[rc_primary];
  end sym_primary_context;



----------------------------------------------------------------------------------------------------
procedure sym_build_context =
-- Ze zadané entity a regionu sestaví kontext.
----------------------------------------------------------------------------------------------------
begin
  result.entity:=entity;
  result.region:=region;
  end sym_build_context;



----------------------------------------------------------------------------------------------------
procedure sym_build_context_from_category =
-- Ze zadané entity a kategorie regionu sestaví kontext.
----------------------------------------------------------------------------------------------------
begin
  result.entity:=entity;
  result.region:=entity^.regions[rcategory];
  end sym_build_context_from_category;



----------------------------------------------------------------------------------------------------
procedure sym_relative_context =
-- Sestaví (primární) kontext zadané entity s ohledem na aktuální kontext. Pokud je ENTITY shodná
-- nebo nadřazená k CURR.ENTITY, pak vrátí kontext, ke kterému lze dotrasovat přes CURR, jinak
-- vrátí prostý primární kontext.
----------------------------------------------------------------------------------------------------
begin
  -- zkusit dohledat relativní kontext od CURR
  result:=curr;
  while result.entity<>nil and then result.entity<>entity loop
    result:=result.entity^.context;
    end loop;

  -- nenalezlo-li se, tak sestavit primární kontext
  if result.entity=nil then
    result:=sym_primary_context(entity^);
    end if;
  end sym_relative_context;



----------------------------------------------------------------------------------------------------
procedure sym_get_enclosing_context_restricted =
-- Nalezne nadřazený kontext, jehož entita nepatří mezi zakázané typy entit.
----------------------------------------------------------------------------------------------------
begin
  result:=curr^.context;
  while result.entity<>nil and then result.entity^.etype in ets_disabled loop
    result:=result.entity^.context;
    end loop;
  end sym_get_enclosing_context_restricted;



----------------------------------------------------------------------------------------------------
procedure sym_is_top_region =
-- True, je-li region uvedený v kontextu top-level regionem entity uvedené v kontextu.
----------------------------------------------------------------------------------------------------
begin
  result:=curr.region^.context.region=nil;
  end sym_is_top_region;



----------------------------------------------------------------------------------------------------
procedure sym_get_qid =
-- Sestaví kvalifikovaný identifikátor entity a vrátí ho jako řetězec.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  psym:=_psym;

  -- není to rovnou kompilační jednotka
  if psym<>nil and then psym^.etype=et_compile

    -- ano => vrátit přímo identifikátor
    then result:=entityident_to_string(psym^.id^)

    -- ne => sestavit kvalifikovaný identifikátor
    else
      -- zpracovat postupně všechny entity v hierarchii
      while psym<>nil and then psym^.etype<>et_compile loop
        --  typ bez identifikátoru => dosadit atribut
        if psym^.id=nil and then psym^.etype in tentitytypeset:[et_type,et_class] then 
          -- volba atributu závisí na typu nadřazené entity
          case psym^.context.entity^.etype
            -- proměnná, konstanta => :type
            when et_var,et_const do 
                result:=':type' & result;

            -- jiný typ => :range nebo :base
            when et_type do
                -- je to typ rozsahu => :range
                if pentity_type(psym^.context.entity)^.srange.getutype=psym then
                  result:=':range' & result;

                -- je to typ báze => :base
                elsif pentity_type(psym^.context.entity)^.base.getutype=psym then
                  result:=':base' & result;

                -- nic jiného tu nemá co dělat
                else
                  verify({VERIFY=}001289);
                  end if;

            -- podprogram => :type
            when et_procedure,et_static,et_virtual,et_task,et_special do
                result:=':type' & result;

            -- zpráva => :type
            when et_message do
                result:=':type' & result;
            
            -- nic jiného tu nemá co dělat
            when others do verify({VERIFY=}001290);
            end case;    

          -- !!! záplata na [str_separate]
          result:="." & result;
          
        -- speciální metoda
        elsif psym^.etype=et_special then 
          result:="." & entityident_to_string(psym^.id^) & result;

        -- entita s identifikátorem
        elsif psym^.id<>nil then 
          result:="." & entityident_to_string(psym^.id^) & result;

        -- nějaká entita bez identifikátoru
        else
          verify({VERIFY=}001291);
          end if;

        -- nadřazená entita
        psym:=psym^.context.entity;
        end loop;
      end if; 
  end sym_get_qid;



----------------------------------------------------------------------------------------------------
#template sym_get_id_body_template (
    counter,                                     -- čítač entit s daným prefixem
    prefix);                                     -- prefix identifikátoru
-- Šablona těla procedury pro sestavení interního identifikátoru entity.
----------------------------------------------------------------------------------------------------
  with
    standard.conversions,
    cc_var;

  var
    s                : t_char32str;

  begin
    -- zvýšit čítač
    succ counter;

    -- převést na řetězec
    s:=unsigned_to_string(counter);

    -- nabrat paměť
    new result range prefix:length+s:length;

    -- zaregistruj do gc
    c_garbage_collector.get_instance^.register_memblock(result);

    -- základ všech interních pracovních identifikátorů je stejný
    result^:=prefix;

    -- přidat čítač na konec identifikátoru
    for i in s:range loop
      result^ & tidentchar(s[i]);
      end loop;
  #end sym_get_id_body_template;



----------------------------------------------------------------------------------------------------
procedure sym_get_temp_id =
-- Vygeneruje interní pracovní identifikátor entity.
----------------------------------------------------------------------------------------------------
  sym_get_id_body_template(temp_counter,id_int_temp);
  end sym_get_temp_id;

  

----------------------------------------------------------------------------------------------------
procedure sym_get_override_id =
-- Vygeneruje interní identifikátor overridu pojmenovaného kompilátorem.
----------------------------------------------------------------------------------------------------
  sym_get_id_body_template(override_counter,id_int_override);
  end sym_get_override_id;



----------------------------------------------------------------------------------------------------
procedure sym_get_uniarray_id =
-- Vygeneruje interní identifikátor typu univerzální pole.
----------------------------------------------------------------------------------------------------
  sym_get_id_body_template(uniarray_counter,id_int_uniarray);
  end sym_get_uniarray_id;



----------------------------------------------------------------------------------------------------
procedure sym_get_interface_id =
-- Vygeneruje interní identifikátor instance interfacu.
----------------------------------------------------------------------------------------------------
  sym_get_id_body_template(interface_counter,id_int_interface);
  end sym_get_interface_id;



----------------------------------------------------------------------------------------------------
procedure sym_get_label_id =
-- Vygeneruje interní identifikátor návěští.
----------------------------------------------------------------------------------------------------
  sym_get_id_body_template(label_counter,id_int_label);
  end sym_get_label_id;



----------------------------------------------------------------------------------------------------
procedure sym_is_fully_visible =
-- True, je-li ve WHERE viditelná úplná deklarace WHAT.
----------------------------------------------------------------------------------------------------
var
  ancestor         : pentity;                    -- předek
  where            : tcontext;

begin
  where:=_where;

  -- ani nemá úplnou deklaraci
  if what^.declared<>etd_full then
    result:=false;
    return;
    end if;

  -- Úplná deklarace symbolu je vidět pokud platí alespoň jedna z podmínek:
  --   1) WHAT je deklarováno ve WHERE
  --   2) WHAT je deklarováno v některém symbolu nadřazeném WHERE
  --   3) WHAT je deklarováno v předkovi WHERE
  --   4) WHAT je deklarováno v předkovi symbolu nadřazeném WHERE
  -- Přičemž podmínky 3) a 4) mají smysl pouze pokud je úplná deklarace WHAT
  -- v části PROTECTED
  while where.entity<>nil and then where.entity<>what^.context.entity loop
    -- test předků
    if what^.full=etv_protected then
      ancestor:=where.entity^.ancestor.getuentity;
      while ancestor<>nil and then ancestor<>what^.context.entity loop
        ancestor:=ancestor^.ancestor.getuentity;
        end loop;
      if ancestor<>nil then
        break;
        end if;
      end if;

    -- nadřazený prvek
    where:=where.entity^.context;
    end loop;
  result:=where.entity<>nil;
  end sym_is_fully_visible;


     
----------------------------------------------------------------------------------------------------
procedure sym_is_included =
-- True, je-li symbol WHAT v tabulce symbolů symbolu WHERE (přímo i nepřímo). 
----------------------------------------------------------------------------------------------------
var
  what             : pentity;

begin
  what:=_what;
  while what<>nil and then what<>where loop
    what:=what^.context.entity{owner};
    end loop;
  result:=what<>nil;
  end sym_is_included;



----------------------------------------------------------------------------------------------------
procedure sym_is_included_or_ancestor =
-- True, je-li symbol WHAT v tabulce symbolů symbolu WHERE (přímo i nepřímo), nebo v některém 
-- z předků nadřazených symbolů WHERE.
----------------------------------------------------------------------------------------------------
var
  what             : pentity;

begin
  what:=_what;
  loop
    -- není where=what nebo where předek what ?
    if sym_is_ancestor(where,what) then
      result:=true;
      return;
      end if;

    -- zkusit nadřazený symbol
    what:=what^.context.entity;
    until what=nil;
  end sym_is_included_or_ancestor;


                
----------------------------------------------------------------------------------------------------
procedure sym_is_used =
-- True, je-li symbol WHAT withnut/usenut (v závislosti na MODE/TYPE) v symbolu WHERE.                                                           
----------------------------------------------------------------------------------------------------
begin
  result:=twl_none;
  -- Ondra 5.4.2002 : Hledání nemá být rekurzivní vzhledem k nadřazeným entitám.
{
  while where<>nil loop
}

    if where.region^.withtable<>nil then
      for i in where.region^.withtable^:range loop
        {%%X Ondra 21.6.2001 : Proč jsem ten typ vazby vlastně zaváděl? }
        -- Nefungovalo to s tím, tak jsem to zakomentoval
        if where.region^.withtable^[i].mode in _mode {and then (where^.withtab^[i].typ in _typ)} 
        and then where.region^.withtable^[i].entity.getcentity=what then
          where.region^.withtable^[i].stat_usage+1000;
          --result:=true;
          result:=where.region^.withtable^[i].level;
          return;
          end if;
        end loop;
      end if;
  {
    where:=where^.context;
    end loop;
  }
  end sym_is_used;



----------------------------------------------------------------------------------------------------
procedure sym_is_descendant =
-- True, je-li E1 potomek E2.
----------------------------------------------------------------------------------------------------
var
  e1               : pentity;

begin
  -- Poznámka: Stejná procedura je i v CC_TYPE, ale pro typy (T_DESCENDANT) 
  e1:=_e1;
  while e1<>nil and then e1<>e2 loop e1:=e1^.ancestor.getuentity; end loop;
  result:=e1=e2;
  end sym_is_descendant;



----------------------------------------------------------------------------------------------------
procedure sym_is_ancestor =
-- True, je-li E1 předek E2.
----------------------------------------------------------------------------------------------------
var
  e2               : pentity;

begin
  -- Poznámka: Stejná procedura je i v CC_TYPE, ale pro typy (T_ANCESTOR) 
  e2:=_e2;
  while e2<>nil and then e1<>e2 loop e2:=e2^.ancestor.getuentity; end loop;
  result:=e1=e2;
  end sym_is_ancestor;



----------------------------------------------------------------------------------------------------
procedure sym_get_container =
-- Nejbližší nadřazený nebo stejný kontejner typu modul/třída/program/kompilační jednotka.
----------------------------------------------------------------------------------------------------
begin
  result:=curr;
  while result<>nil and then result^.etype not in ets_container loop 
    result:=result^.context.entity;
    end loop;
  end sym_get_container;



----------------------------------------------------------------------------------------------------
procedure sym_check_container =
-- True, je-li nejbližší kontejnerová entita typu ETYPE.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000619,etype not in ets_container);

  -- souhlasí ?
  result:=sym_get_container(curr)^.etype=etype;
  end sym_check_container;



----------------------------------------------------------------------------------------------------
procedure sym_get_enclosing_or_self =
-- Najbližší nadřazená nebo stejná entita typu ETYPE.
----------------------------------------------------------------------------------------------------
begin
  result:=curr;
  while result<>nil and then result^.etype<>etype loop 
    result:=result^.context.entity;
    end loop;
  end sym_get_enclosing_or_self;



----------------------------------------------------------------------------------------------------
procedure sym_get_enclosing_or_self_ex =
-- Najbližší nadřazená nebo stejná entita typu ETYPE.
----------------------------------------------------------------------------------------------------
begin
  result:=curr;
  while result<>nil and then result^.etype not in etype loop 
    result:=result^.context.entity;
    end loop;
  end sym_get_enclosing_or_self_ex;



----------------------------------------------------------------------------------------------------
procedure sym_check_enclosing_or_self =
-- True, existuje-li nadřazená nebo stejná entita typu ETYPE.
----------------------------------------------------------------------------------------------------
begin
  -- existuje ?
  result:=sym_get_enclosing_or_self(curr,etype)<>nil;
  end sym_check_enclosing_or_self;



----------------------------------------------------------------------------------------------------
procedure sym_get_nearest_abstract_or_self =
-- Nejbližší abstraktní předek-or-self.
----------------------------------------------------------------------------------------------------
begin
  result:=curr;
  while result<>nil and then not result^.is_abstract loop 
    result:=result^.ancestor.getuentity;
    end loop;
  end sym_get_nearest_abstract_or_self;



----------------------------------------------------------------------------------------------------
procedure sym_get_first_abstract_or_self =
-- Nejvzdálenější abstraktní předek-or-self.
----------------------------------------------------------------------------------------------------
var
  p                : pentity;

begin
  p:=curr;
  while p<>nil loop
    if p^.is_abstract then
      result:=p;
      end if;
    p:=p^.ancestor.getuentity;
    end loop;
  end sym_get_first_abstract_or_self;



----------------------------------------------------------------------------------------------------
procedure sym_check_special =
-- True, pokud entita obsahuje zadanou speciální metodu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;

begin
  srch.find_et_first(context.entity,rc_primary,et_special,tesearchflagset:[]);
  while srch.psym<>nil and then pentity_special(srch.psym)^.spectype<>spec loop
    srch.find_et_next;
    end loop;
  result:=srch.psym<>nil;
  end sym_check_special;



----------------------------------------------------------------------------------------------------
procedure sym_get_visibility =
-- Viditelnost symbolů vnořených v symbolu SEARCH s ohledem na aktuální kontext CONTEXT.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
 
  -- CONTEXT je obsažen v SEARCH => je vidět vše
  if sym_is_included(context,search) then
    visibility:=tentityvisibleset:full;
    return;
    end if;

  -- co je prohledávaný symbol zač ?
  if search^.etype in ets_modular

    -- prohledávaný symbol je modul/třída
    then
      -- mohl by to být předek některého z modulů/tříd nadřazených CONTEXT
      psym:=context;
      while psym<>nil loop
        -- nalezen potomek => je vidět vše public a protected
        if psym^.etype=search^.etype and sym_is_descendant(psym,search) then
          visibility:=tentityvisibleset:[etv_public,etv_protected];
          return;
          end if;
        psym:=psym^.context.entity;
        end loop;

      -- mohl by být WITH/USE v CONTEXT nebo některém nadřazeném symbolu
      psym:=context;
      while psym<>nil loop
        declare var
          level    : t_with_level;               -- úroveň vazby

        begin
          -- nalezen uživatel => je vidět vše public
          level:=sym_is_used(search,sym_primary_context(psym^),[twm_use,twm_with]);
          if level<>twl_none then
            visibility:=with_level_to_visibility[level];
            return;
            end if;
          end declare;

        psym:=psym^.context.entity;
        end loop;

      if search^.etype=et_class
      
        -- z třídy jsou vždy vidět aspoň public věci
        -- %%X Nemělo by tohle být trochu složitější ?? Co třeba případ: 
        --  class c =
        --    var i : integer;
        --    end c;
        --  module m =
        --    ... c.i:=0;     -- je zde I vidět ? neměl bych dělat WITH ?
        --    end m;
        then visibility:=tentityvisibleset:[etv_public]

        -- Ondra 27.6.2001 : Z modulu je něco vidět pouze pokud je vnořen v
        -- modulu/třídě/programu/kompilační jednotce nejvnitřeji obalující
        -- context.
        else
          if sym_is_included(search,sym_get_container(context))
            then visibility:=tentityvisibleset:[etv_public];
            else visibility:=tentityvisibleset:[];
            end if;
          end if;
      {
        -- z modulu není vidět nic
        else visibility:=[];
      }

    -- z ostatních symbolů jsou vidět jen public symboly
    else 
      visibility:=tentityvisibleset:[etv_public];
      end if;
  end sym_get_visibility;


  
----------------------------------------------------------------------------------------------------
procedure sym_set_warning =
-- Nastaví stav warningu pro danou entitu.
----------------------------------------------------------------------------------------------------
with
  advanced.low_level.bit_operations;

var
  zac              : cc_warning_desc:range;
  kon              : cc_warning_desc:range;
  stred            : t_unsigned;

begin
  -- není to nastavení pro všechna varování ?
  if id=cc_warning_id_all

    -- ano => nastavit všechny
    then
      if value
        then context.entity^.compv.warns:=twarningcodeset:full;
        else context.entity^.compv.warns:=[];
        end if;

    -- ne => vyhledat konkrétní varování
    else
      -- vyhledat
      zac:=cc_warning_desc:first;
      kon:=cc_warning_desc:last;
      loop
        stred:=(zac+kon) div 2;
        if id>cc_warning_desc[stred].id
          then zac:=stred+1;
          else kon:=stred;
          end if;
        until zac>=kon;

      if id<>cc_warning_desc[zac].id then
        ce^.setwarning(context,{CCERR=}000056,cw_unknown_option);
        ce^.setparam(entityident_to_string(id));
        ce^.loadpos;
        return;
        end if;

      -- nastavit
      if value
        then bit_set(context.entity^.compv.warns,t_bit_index(cc_warning_desc[zac].warn:ord));
        else bit_reset(context.entity^.compv.warns,t_bit_index(cc_warning_desc[zac].warn:ord));
        end if;
      end if;
  end sym_set_warning;



----------------------------------------------------------------------------------------------------
procedure sym_set_hint =
-- Nastaví stav hintu pro danou entitu.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

var
  zac              : cc_hint_desc:range;
  kon              : cc_hint_desc:range;
  stred            : t_unsigned;

begin
  -- není to nastavení pro všechny hinty ?
  if id=cc_hint_id_all

    -- ano => nastavit všechny
    then
      if value
        then context.entity^.compv.hints:=thintcodeset:full;
        else context.entity^.compv.hints:=[];
        end if;

    -- ne => vyhledat konkrétní hint
    else
      -- vyhledat
      zac:=cc_hint_desc:first;
      kon:=cc_hint_desc:last;
      loop
        stred:=(zac+kon) div 2;
        if id>cc_hint_desc[stred].id
          then zac:=stred+1;
          else kon:=stred;
          end if;
        until zac>=kon;
      if id<>cc_hint_desc[zac].id then
        ce^.setwarning(context,{CCERR=}000057,cw_unknown_option);
        ce^.setparam(entityident_to_string(id));
        ce^.loadpos;
        return;
        end if;

      -- nastavit
      if value
        then bit_set(context.entity^.compv.hints,t_bit_index(cc_hint_desc[zac].hint:ord));
        else bit_reset(context.entity^.compv.hints,t_bit_index(cc_hint_desc[zac].hint:ord));
        end if;
      end if;
  end sym_set_hint;



----------------------------------------------------------------------------------------------------
procedure sym_set_diag =
-- Nastaví stav diagnostického hlášení pro danou entitu.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

var
  zac              : cc_diag_desc:range;
  kon              : cc_diag_desc:range;
  stred            : t_unsigned;

begin
  -- není to nastavení pro všechna diagnostická hlášení?
  if id=cc_diag_id_all

    -- ano => nastavit všechny
    then
      if value
        then context.entity^.compv.diags:=tdiagcodeset:full;
        else context.entity^.compv.diags:=[];
        end if;

    -- ne => vyhledat konkrétní diagnostické hlášení
    else
      -- vyhledat
      zac:=cc_diag_desc:first;
      kon:=cc_diag_desc:last;
      loop
        stred:=(zac+kon) div 2;
        if id>cc_diag_desc[stred].id
          then zac:=stred+1;
          else kon:=stred;
          end if;
        until zac>=kon;
      if id<>cc_diag_desc[zac].id then
        ce^.setwarning(context,{CCERR=}000058,cw_unknown_option);
        ce^.setparam(entityident_to_string(id));
        ce^.loadpos;
        return;
        end if;

      -- nastavit
      if value
        then bit_set(context.entity^.compv.diags,t_bit_index(cc_diag_desc[zac].diag:ord));
        else bit_reset(context.entity^.compv.diags,t_bit_index(cc_diag_desc[zac].diag:ord));
        end if;
      end if;
  end sym_set_diag;


                          
----------------------------------------------------------------------------------------------------
#separate private cc_advanced;
-- Další pokročilé funkce pro manipulaci s entitami, regiony, contexty, stromem entit a regionů.
----------------------------------------------------------------------------------------------------
#separate private cc_partition;
-- Podpora pro práci s více partitionami.
----------------------------------------------------------------------------------------------------

end cc_sym;
