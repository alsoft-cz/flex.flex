----------------------------------------------------------------------------------------------------
module private cd_unit =
-- Překladač Flexu.
-- Překlad kompilační jednotky.
----------------------------------------------------------------------------------------------------
-- Ondra : 28.04.2000 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_gc,
  cc_def.cc_var,
  cc_def.cc_files,
  cc_base.cc_options,
  cb_block,
  cb_block.cb_def,
  cb_block.cb_compile,
  cd_decl.cd_create,
  cd_decl.cd_eval,
  cd_decl.cd_type,
  cd_decl.cd_attr,
  cd_decl.cd_util,
  cx_expr,
  cx_expr.cx_def,
  cx_expr.cx_compile,
  advanced.low_level.bit_operations;

----------------------------------------------------------------------------------------------------
procedure p_body (
    curr           : in tcontext;                -- překládaný prvek
    part_extend    : in t_logical := false;      -- T-extend
    part_expose    : in t_logical := false;      -- T-expose
    part_with      : in t_logical := false;      -- T-with/use
    part_spec      : in t_logical := false;      -- T-speciální metody
    part_stmt      : in t_logical := false);     -- T-příkazy
-- Překlad deklarační a příkazové části symbolu.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure p_type (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace typů.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  ptyp             : pentity_type;               -- typ
  ptyp_context     : tcontext;                   -- kontext deklarace
  compat           : typecompat;                 -- determinace kompatibility
  pos              : lexposblock;                -- pozice symbolu
  expr             : pexpnode;                   -- počáteční hodnota
  newdecl          : t_logical;                  -- T-je to úplná deklarace nového typu

begin
  loop
    begin
      -- zatím nevíme, co je deklarace zač
      newdecl:=false;

      -- začátek deklarace
      d_create(curr,pentity(ptyp),ptyp_context,et_type,pos);

      if ptyp^.declared=etd_incomplete

        -- Type declaration completion/Private extension declaration
        then
          if followlex(ptyp_context,lex_eq) then
            ce^.seterror({CCERR=}000260,ce_x_eq);
            ce^.setinfo(hint_x_completion);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

        -- Incomplete type declaration/Full type declaration
        else
          -- další symbol
          getlex(ptyp_context,lex);
          case lex

            -- Incomplete type declaration
            when lex_scol do d_end(ptyp^,pos);

            -- Full type declaration
            when lex_eq   do
                -- přejít do další fáze překladu
                d_next(ptyp^,pos);

                -- poznamenat si, že je to úplná deklarace nového typu
                newdecl:=true;

            -- cokoliv jiného je chyba
            when others do
                ce^.seterror({CCERR=}000261,ce_x_eq_scol);
                ce^.setinfo(hint_def_or_forward);
                ce^.loadpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
            end case;
          end if;

      -- přeložit definici
      if ptyp^.compiling=etd_full then

        -- není to náhodou Private extension Declaration ?
        if ptyp^.derive=td_private_extension

          -- ano => definice extenze
          then
            p_private_extension(curr,ptyp^,ptyp_context);

          -- ne => normální deklarace typu/dokončení deklarace
          else
            -- další symbol
            getlex(ptyp_context,lex);

            -- mohla by to být determinace kompatibility
            case lex
              -- determinace "protected"
              when lex_protected do compat:=tc_protected;

              -- determinace "private"
              when lex_private   do compat:=tc_private;

              when others do
                 compat:=tc_norm;
                 ungetlex;
              end case;

            -- definice typu
            p_typeedef(curr,ptyp^,ptyp_context,compat);

            -- atributy
            p_attribute(ptyp_context);
            end if;

        -- := Počáteční hodnota
        if checklex(ptyp_context,lex_assign) then
          -- výraz
          x_vyraz(ptyp_context,expr,es_expr);
          ptyp^.init.setexpr(expr);
          end if;

        -- musí následovat středník
        if followlex(ptyp_context,lex_scol) then
          ce^.seterror({CCERR=}000262,ce_x_scol);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          end if;

        -- pokud je to private extension, tak se vrátit k Incomplete declaration
        if newdecl and (ptyp^.derive=td_private_extension) then d_rollback(ptyp^); end if;

        -- konec deklarace
        d_end(ptyp^,pos);
        end if;

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
      end;

    -- podívat se na další symbol
    looklex(curr,lex);
    until lex<>lex_id;
  end p_type;



----------------------------------------------------------------------------------------------------
procedure p_const (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace konstant.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pconst           : pentity_const;              -- konstanta
  pconst_context   : tcontext;                   -- primární kontext konstanty
  pos              : lexposblock;                -- pozice
  expr             : pexpnode;                   -- výraz

begin
  loop
    begin
      -- začátek deklarace
      d_create(curr,pentity(pconst),pconst_context,et_const,pos);

      if pconst^.compiling=etd_none

        -- Incomplete constant declaration/Full constant declaration
        then
          -- další symbol
          getlex(pconst_context,lex);

          -- : Typ
          if lex=lex_col then
            -- konstanta má explicitně uvedený typ
            pconst^.cflags+constflagset:[cf_typed];

            -- přečíst typ konstanty
            p_typeidef(curr,pconst_context,pconst^.typ);

            -- další symbol
            getlex(pconst_context,lex);
            end if;

          case lex

            -- Full constant declaration
            when lex_eq  do d_next(pconst^,pos);

            -- Incomplete constant declaration
            when lex_scol do
                -- konstanta musí mít uveden typ
                if not (cf_typed in pconst^.cflags) then
                  ce^.seterror({CCERR=}000263,ce_x_eq_col);
                  ce^.setinfo(hint_def_or_type);
                  ce^.loadpos;
                  {%%RESUME ce^.raiseerror;}
                  ce^.resumeerror;
                  end if;

                -- konec delarace
                d_end(pconst^,pos);


            -- cokoliv jiného je chyba
            when others do
                if cf_typed in pconst^.cflags
                  then
                    ce^.seterror({CCERR=}000264,ce_x_eq_scol);
                    ce^.setinfo(hint_def_or_forward);
                  else
                    ce^.seterror({CCERR=}000265,ce_x_eq_col);
                    ce^.setinfo(hint_def_or_type);
                    end if;
                ce^.loadpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
            end case;

        -- Full constant declaration
        else

          -- další symbol
          getlex(pconst_context,lex);
          case lex
            -- rovnítko
            when lex_eq do { v pořádku };

            -- dvojtečka
            when lex_col do
                ce^.seterror({CCERR=}000266,ce_x_eq);
                ce^.setinfo(hint_already_forward);
                ce^.loadpos;
                {%%RESUME ce^.raiseerror;}
                resumelex(pconst_context,lex,lex_eq,rl_skip,lex_scol,rt_resume);


            -- cokoliv jiného
            when others do
                ce^.seterror({CCERR=}000267,ce_x_eq);
                ce^.setinfo(hint_x_completion);
                ce^.loadpos;
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
            end case;
          end if;

      -- přeložit definici
      if pconst^.compiling=etd_full then
        -- konstantní výraz
        x_vyraz(pconst_context,expr,es_expr);
        pconst^.init.setexpr(expr);

        -- musí následovat středník
        if followlex(pconst_context,lex_scol) then
          ce^.seterror({CCERR=}000268,ce_x_scol);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          end if;

        -- konec deklarace
        d_end(pconst^,pos);
        end if;

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
      end;

    -- podívat se na další symbol
    looklex(curr,lex);
    until lex<>lex_id;
  end p_const;



----------------------------------------------------------------------------------------------------
procedure p_var (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace proměnných.
----------------------------------------------------------------------------------------------------
label 
  R1;

var
  lex              : lexsym;                     -- lexikální symbol
  pvar             : pentity_var;                -- proměnná
  pvar_context     : tcontext;                   -- kontext proměnné
  expr             : pexpnode;                   -- počáteční hodnota
  pos              : lexposblock;                -- pozice

begin
  loop
    begin
      -- začátek deklarace
      d_create(curr,pentity(pvar),pvar_context,et_var,pos);

      -- zvolit implicitní paměťovou třídu podle typu nadřazeného prvku
      case curr.entity^.etype
        when et_compile   do pvar^.mclass:=mc_static;
        when et_program   do 
            -- paměťová třída v top-level regionu je static, ve vnořených automatic
            if sym_is_top_region(curr)
              then pvar^.mclass:=mc_static;
              else pvar^.mclass:=mc_auto;
              end if;
        when et_module    do pvar^.mclass:=mc_static;
        when et_class     do pvar^.mclass:=mc_class;
        when et_special   do pvar^.mclass:=mc_auto;
        when et_procedure do pvar^.mclass:=mc_auto;
        when et_static    do pvar^.mclass:=mc_auto;
        when et_virtual   do pvar^.mclass:=mc_auto;
        when et_task      do pvar^.mclass:=mc_auto;
        when et_override  do pvar^.mclass:=mc_auto;
        when et_macro     do pvar^.mclass:=mc_auto;
        when others do verify({VERIFY=}000320,true);
        end case;

      -- dvojtečka
      if followlex(pvar_context,lex_col) then
        ce^.seterror({CCERR=}000269,ce_x_col);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- paměťová třída
      getlex(pvar_context,lex);
      case lex
        -- STATIC
        when lex_static do
            -- dovoleno všude kromě makra
            if etc_macro in curr.entity^.compile then
              ce^.seterror({CCERR=}000270,ce_i_memclass);
              ce^.setinfo(hint_static_in_macro);
              ce^.loadpos;
              {%%RESUME ce^.raiseerror;}
              goto R1;
              end if;

            -- poznamenat
            pvar^.mclass:=mc_static;

        -- CLASS
        when lex_class  do
            -- dovoleno všude kromě makra
            -- (co kdyby bylo makro v třídě, že)
            if etc_macro in curr.entity^.compile then
              ce^.seterror({CCERR=}000271,ce_i_memclass);
              ce^.setinfo(hint_class_in_macro);
              ce^.loadpos;
              {%%RESUME ce^.raiseerror;}
              goto R1;
              end if;
          
            -- proměnná musí být v třídě
            if not sym_check_container(curr.entity,et_class) then
              ce^.seterror({CCERR=}000272,ce_i_memclass);
              ce^.setinfo(hint_class_in_class);
              ce^.loadpos;
              {%%RESUME ce^.raiseerror;}
              goto R1;
              end if;

            -- poznamenat
            pvar^.mclass:=mc_class;

        -- TASK
        when lex_task   do
            -- dovoleno všude kromě makra
            if etc_macro in curr.entity^.compile then
              ce^.seterror({CCERR=}000273,ce_i_memclass);
              ce^.setinfo(hint_task_in_macro);
              ce^.loadpos;
              {%%RESUME ce^.raiseerror;}
              goto R1;
              end if;

            -- poznamenat
            pvar^.mclass:=mc_task;

        -- neuvedeno, zvolit default
        when others do
            -- vrátit poslední prvek do vstupu
            ungetlex;
        end case;

    R1:
      -- determinace přístupu
      p_varaccess(pvar_context,pvar^.vaccess);

      -- ALIASED
      p_aliased_access(pvar_context,pvar^.valiased);

      -- typ
      p_typeidef(curr,pvar_context,pvar^.typ);

      -- implicitní hodnota ?
      if checklex(pvar_context,lex_assign) then
        x_vyraz(pvar_context,expr,es_expr);
        pvar^.init.setexpr(expr);
        end if;

      -- středník
      if followlex(pvar_context,lex_scol) then
        ce^.seterror({CCERR=}000274,ce_x_scol);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- pozice
      getlexpos(pos.e,ll_curr,true);

      -- konec deklarace
      d_end(pvar^,pos);

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
      end;

    -- podívat se na další symbol
    looklex(curr,lex);
    until lex<>lex_id;
  end p_var;



------------------------------------------------------------------------------------------------------
--procedure p_alias (
--    curr           : in tcontext) =              -- překládaný prvek
---- Deklarace aliasů.
------------------------------------------------------------------------------------------------------
--var
--  lex,lex2         : lexsym;                     -- lexikální symbol
--  srch             : tentitysearch;              -- vyhledávání v tabulce symbolů
--  palias           : pentity_alias;              -- proměnná
--  expr             : pexpnode;                   -- výraz
--  pos              : lexposblock;                -- pozice
--
--begin
--  loop
--    begin
--      -- začátek deklarace
--      d_create(curr,pentity(palias),et_alias,pos);
--
--      -- dvojtečka
--      if followlex(lex_col) then
--        ce^.seterror({CCERR=}000275,ce_x_col);
--        ce^.loadpos;
--        {%%RESUME ce^.raiseerror;}
--        end if;
--
--      -- typ
--      p_typename(curr,palias^,palias^.typ);
--
--      -- musí následovat IN nebo OUT
--      getlex(lex);
--      if lex not in lexsymset:[lex_in,lex_out] then
--        ce^.seterror({CCERR=}000276,ce_x_in_out);
--        ce^.loadpos;
--        {%%RESUME ce^.raiseerror;}
--        ce^.resumeerror;
--        end if;
--
--      -- IN [ OUT ]
--      if lex=lex_in then
--        -- třeba je to IN OUT
--        getlex(lex2);
--        if lex2<>lex_out then ungetlex; end if;
--
--        -- výraz
--        x_vyraz(curr,expr,es_name);
--        palias^.write.setexpr(expr);
--        if lex2=lex_out then palias^.read.setexpr(expr); end if;
--
--        -- může následovat OUT
--        if lex2<>lex_out then
--          getlex(lex);
--          if lex<>lex_out then ungetlex; end if;
--          end if;
--        end if;
--
--      -- OUT
--      if lex=lex_out then
--        -- výraz
--        x_vyraz(curr,expr,es_name);
--        palias^.read.setexpr(expr);
--        end if;
--
--      -- středník
--      if followlex(lex_scol) then
--        ce^.seterror({CCERR=}000277,ce_x_scol);
--        ce^.loadpos;
--        {%%RESUME ce^.raiseerror;}
--        end if;
--
--      -- konec deklarace
--      d_end(palias^,pos);
--
--    catch
--      when resume_error do resumelex(lex,lex_scol,rl_skip,lex_scol,rt_skip);
--      end;
--
--    -- podívat se na další symbol
--    looklex(lex);
--    until lex<>lex_id;
--  end p_alias;



----------------------------------------------------------------------------------------------------
procedure p_label (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace návěští.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  plabel           : pentity_label;              -- návěští
  plabel_context   : tcontext;                   -- context návěští
  pos              : lexposblock;                -- pozice

begin
  -- návěští nelze deklarovat v modulu a v třídě
  if curr.entity^.etype in ets_modular then
    ce^.seterror({CCERR=}000278,ce_baddecl);
    ce^.setinfo(hint_decl_label);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  loop
    -- začátek deklarace
    d_create(curr,pentity(plabel),plabel_context,et_label,pos);

    -- středník
    if followlex(plabel_context,lex_scol) then
      ce^.seterror({CCERR=}000279,ce_x_scol);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- konec deklarace
    d_end(plabel^,pos);

    -- podívat se na další symbol
    looklex(curr,lex);
    until lex<>lex_id;
  end p_label;



----------------------------------------------------------------------------------------------------
procedure p_with_module (
    curr           : in tcontext;                -- překládaný prvek
    mode           : in t_with_mode) =           -- WITH/USE
-- Překlad WITH/USE.
----------------------------------------------------------------------------------------------------
use
  cc_base.cc_sym.cc_advanced;

label 
  R1;
 
var
  ek_context       : static const array t_with_mode of expkind := [
      for twm_use      use ek_context_use,
      for twm_with     use ek_context_with];
  ce_i             : static const array t_with_mode of terrorcode := [
      for twm_use      use ce_i_use,
      for twm_with     use ce_i_with];

begin
  -- WITH/USE
  if (mode=twm_with and not checklex(curr,lex_with))
  or (mode=twm_use and not checklex(curr,lex_use)) then 
    return; 
    end if;

  loop
    declare 
      var
        expr       : pexpnode;                   -- výraz
        psym       : pentity;                    -- symbol (modul/třída)
        eval       : tentityeval;
        level      : t_with_level;               -- úroveň vazby

    begin
      -- úroveň vazby
      if checklex(curr,lex_supervised)
        then level:=twl_supervised;
        else level:=twl_normal;
        end if;
      
      -- výraz
      x_vyraz(curr,expr,es_name);
      x_evaluate(curr,expr,ek_context[mode],nil,eu_formal,true,eval);
      if expr^.erroneous then goto R1 end if;
      verify({VERIFY=}000141,eval<>ete_evaluated);

      -- symbol
      x_get_symbol(expr,psym);

      -- nelze udělat WITH na nadřazený symbol
      if sym_is_included(curr.entity,psym) then
        ce^.seterror({CCERR=}000280,ce_i[mode]);
        ce^.setinfo(hint_with_super);
        expr^.errpos;
        goto R1;
        end if;

      -- nelze udělat WITH na vnořený symbol
      -- Poznámka: Tato situace může opravdu nastat: ve WITH v private body
      -- by mohlo být jméno modulu deklarovaného v public body
      if sym_is_included(psym,curr.entity) then
        ce^.seterror({CCERR=}000281,ce_i[mode]);
        ce^.setinfo(hint_with_sub);
        expr^.errpos;
        goto R1;
        end if;

      -- nelze udělat WITH na svého předka
      if sym_is_ancestor(psym,curr.entity) then
        ce^.seterror({CCERR=}000282,ce_i[mode]);
        ce^.setinfo(hint_with_ancestor);
        expr^.errpos;
        goto R1;
        end if;

      -- nelze udělat WITH na svého potomka
      if sym_is_descendant(psym,curr.entity) then
        ce^.seterror({CCERR=}000283,ce_i[mode]);
        ce^.setinfo(hint_with_descendant);
        expr^.errpos;
        goto R1;
        end if;

      -- musí být známa alespoň specifikace
      {e_symbol(psym,psym^.pos[etp_spec],sd_specified,true);}

      -- doplnit do WITH tabulky
      cc_base.cc_sym.cc_advanced.sym_add_with(curr,expr,psym,mode,level,false);
      end declare;

  R1:

    -- další symbol
    until not checklex(curr,lex_comma);

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000284,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

catch
  when resume_error do 
      declare var
        lex      : lexsym;                     -- lexikální symbol
      begin
        resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
        end declare;
  end p_with_module;



----------------------------------------------------------------------------------------------------
procedure p_extend (
    curr           : in tcontext) =              -- překládaný prvek
-- Překlad EXTEND.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;
  expr             : pexpnode;                   -- výraz
  psym             : pentity;                    -- symbol (modul/třída)
  eval             : tentityeval;

begin
  -- EXTEND
  if not checklex(curr,lex_extend) then return; end if;

  begin
    -- výraz
    x_vyraz(curr,expr,es_name);
    x_evaluate(curr,expr,ek_context_extend,nil,eu_formal,true,eval);
    if expr^.erroneous then return end if;
    verify({VERIFY=}000784,eval<>ete_evaluated);

    -- symbol
    x_get_symbol(expr,psym);

    -- nelze dělat EXTEND na svého potomka
    if sym_is_descendant(psym,curr.entity) then
      ce^.seterror({CCERR=}000285,ce_i_extend);
      ce^.setinfo(hint_extend_descendant);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;};
      ce^.resumeerror;
      end if;

    -- nelze dělat EXTEND na nadřazený modul
    if sym_is_included(curr.entity,psym) then
      ce^.seterror({CCERR=}000286,ce_i_extend);
      ce^.setinfo(hint_extend_enclosing);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;};
      ce^.resumeerror;
      end if;

    -- nelze dělat EXTEND na WITH/USEnutý modul
    if sym_is_used(psym,curr,t_with_mode_set:full)<>twl_none then
      ce^.seterror({CCERR=}000287,ce_i_extend);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;};
      ce^.resumeerror;
      end if;

    -- musí být známa alespoň specifikace
    --%%X !!
    {e_symbol(psym,psym^.pos[etp_spec],sd_specified,true);}

    -- zařadit jako předka
    curr.entity^.ancestor.setexpr(expr);
    curr.entity^.ancestor.setentity(psym);

    -- středník
    if followlex(curr,lex_scol) then
      ce^.seterror({CCERR=}000288,ce_x_scol);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- vyhodnotit
    e_after_extend(curr.entity);

  catch
    when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
    end;
  end p_extend;



----------------------------------------------------------------------------------------------------
procedure p_expose (
    curr           : in tcontext) =              -- překládaný prvek
-- Překlad EXPOSE.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;
  expr             : pexpnode;                   -- výraz
  psym             : pentity;                    -- symbol (modul/třída)
  eval             : tentityeval;

begin
  -- EXPOSE
  if not checklex(curr,lex_expose) then return; end if;
  
  begin
    loop
      -- výraz
      x_vyraz(curr,expr,es_name);
      x_evaluate(curr,expr,ek_context_expose,nil,eu_formal,true,eval);
      if not expr^.erroneous then
        verify({VERIFY=}000785,eval<>ete_evaluated);

        -- symbol
        x_get_symbol(expr,psym);

        -- nelze dělat EXPOSE na svého potomka
        if sym_is_descendant(psym,curr.entity) then
          ce^.seterror({CCERR=}000289,ce_i_expose);
          ce^.setinfo(hint_expose_descendant);
          expr^.errpos;
          ce^.resumeerror;
          end if;

        -- nelze dělat EXPOSE na svého předka
        if sym_is_ancestor(psym,curr.entity) then
          ce^.seterror({CCERR=}000290,ce_i_expose);
          ce^.setinfo(hint_expose_ancestor);
          expr^.errpos;
          ce^.resumeerror;
          end if;

        -- nelze dělat EXPOSE na nadřazenou třídu
        if sym_is_included(curr.entity,psym) then
          ce^.seterror({CCERR=}000291,ce_i_expose);
          ce^.setinfo(hint_expose_enclosing);
          expr^.errpos;
          ce^.resumeerror;
          end if;

        -- nelze dělat EXPOSE na WITH/USEnutou třídu
        if sym_is_used(psym,curr,t_with_mode_set:full)<>twl_none then
          ce^.seterror({CCERR=}000292,ce_i_expose);
          expr^.errpos;
          ce^.resumeerror;
          end if;

        -- zařadit jako exposovaný interface
        pentity_type(curr.entity)^.interfaces^.add_interface(expr,psym);
        end if;
      until not checklex(curr,lex_comma);

    -- středník
    if followlex(curr,lex_scol) then
      ce^.seterror({CCERR=}000293,ce_x_scol);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- vyhodnotit
    e_after_expose(curr.entity);

  catch
    when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
    end;
  end p_expose;



----------------------------------------------------------------------------------------------------
procedure p_special (
    curr           : in tcontext) =              -- překládaný prvek
-- Překlad speciálních metod.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  declared         : set of tuserspectype;       -- již deklarované speciální metody

    ------------------------------------------------------------------------------------------------
    procedure deklarace (
        spectype   : in tuserspectype) =         -- typ speciální metody
    -- Deklarace speciální metody.
    ------------------------------------------------------------------------------------------------
    var
      ce_dup       : const array tuserspectype of terrorcode := [
          for tst_entry    use ce_dupentry,
          for tst_exit     use ce_dupexit,
          for tst_adjust   use ce_dupadjust,
          for tst_rollback use ce_duprollback,
          for tst_commit   use ce_dupcommit];

      ce_x_end     : const array tuserspectype of terrorcode := [
          for tst_entry    use ce_x_end_entry,
          for tst_exit     use ce_x_end_exit,
          for tst_adjust   use ce_x_end_adjust,
          for tst_rollback use ce_x_end_rollback,
          for tst_commit   use ce_x_end_commit];

    var
      pspec        : pentity_special;            -- speciální metoda
      pspec_context: tcontext;                   -- kontext speciální metody
      pos          : lexposblock;                -- pozice

    begin
      -- nebyla již metoda deklarována ?
      if spectype in declared then
        ce^.seterror({CCERR=}000294,ce_dup[spectype]);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- začátek deklarace
      d_create_without_name(curr,pentity(pspec),pspec_context,et_special,tspectypeid[spectype],pos);

      -- trik: speciální metoda musí být nejlépe public, aby se správně vyexportovala do metadat, 
      -- i když je de-facto v private části třídy
      -- %%X No, zrovna čistá praktika to není... Nešlo by to nějak jinak?
      pspec^.visible:=etv_public;
      pspec^.full   :=etv_public;
      sym_set_globaly_visible(pspec,for force use true);

      -- uložit typ speciální metody
      pspec^.spectype:=spectype;

      -- určit typ objektu, ke kterému se metoda vztahuje
      case curr.entity^.etype
        when et_class   do pspec^.specobj:=tso_class;
        when et_module  do pspec^.specobj:=tso_module;
        when others     do verify({VERIFY=}000573,true);
        end case;

      -- bude se předávat instance ?
      case curr.entity^.etype
        when et_class   do pspec^.instance:=tip_pass;
        when et_module  do pspec^.instance:=tip_none;
        when others     do verify({VERIFY=}000409,true);
        end case;

      -- zařadit do tabulky speciálních metod
      if curr.entity^.etype=et_class then
        pentity_type(curr.entity)^.stable[spectype].setentity(pspec);
        end if;

      -- rovnítko
      if followlex(pspec_context,lex_eq) then
        ce^.seterror({CCERR=}000295,ce_x_eq);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- dokončit vyhodnocení specifikace podprogramu před překladem definice
      e_before_subprogram_body(pspec);

      -- překládá se rovnou část PRIVATE
      pspec_context.region^.vsect:=etv_private;

      -- přeložit deklarace
      p_body(pspec_context,--false,true,false,true);
             for part_with   use true,
             for part_stmt   use true);

      -- END kw
      if followendkw(pspec_context,lex) then
        ce^.seterror({CCERR=}000296,ce_x_end[spectype]);
        ce^.loadpos2;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- středník
      if followlex(pspec_context,lex_scol) then
        ce^.seterror({CCERR=}000297,ce_x_scol);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- konec deklarace
      d_end(pspec^,pos);

      -- poznačit, že tato metoda byla deklarována
      --declared:=declared+tuserspectypeset:[spectype];
      bit_set(declared,t_bit_index(spectype:ord) - t_bit_index(spectype:first:ord));  --%%TODO(SET)
      end deklarace;

begin
  declared:=[];
  loop
    -- další symbol
    getlex(curr,lex);

    case lex
      -- ENTRY
      when lex_entry do deklarace(tst_entry);

      -- EXIT
      when lex_exit  do deklarace(tst_exit);

      -- ADJUST
      when lex_adjust do
          -- ADJUST smí být pouze v třídě
          if curr.entity^.etype<>et_class then
            ce^.seterror({CCERR=}000298,ce_i_adjust);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- přeložit deklaraci
          deklarace(tst_adjust);

      -- ROLLBACK
      when lex_rollback do
          -- ROLLBACK smí být pouze v třídě
          if curr.entity^.etype<>et_class then
            ce^.seterror({CCERR=}000299,ce_i_rollback);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- přeložit deklaraci
          deklarace(tst_rollback);

      -- COMMIT
      when lex_commit do
          -- COMMIT smí být pouze v třídě
          if curr.entity^.etype<>et_class then
            ce^.seterror({CCERR=}000300,ce_i_commit);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- přeložit deklaraci
          deklarace(tst_commit);

      -- jiné symboly nás nezajímají
      when others do
          ungetlex;
          return;
      end case;
    end loop;
  end p_special;



----------------------------------------------------------------------------------------------------
procedure p_body =
-- Překlad deklarační a příkazové části symbolu.
----------------------------------------------------------------------------------------------------
var
  bl               : pblnode;

begin
  -- klauzule WITH/USE
  if part_with then
    -- klauzule WITH
    p_with_module(curr,twm_with);

    -- klauzule USE
    p_with_module(curr,twm_use);
    end if;

  -- zresetovat uziti USE modulu ve WITH tabulce, nastavenych uvnitr p_with_module()
  if curr.region^.withtable<>nil then
    for i in curr.region^.withtable^:range loop
        curr.region^.withtable^[i].stat_usage:=0
      end loop;
    end if;

  -- klauzule EXTEND
  if part_extend then
    p_extend(curr);
    end if;

  -- klauzule EXPOSE
  if part_expose then
    p_expose(curr);
    end if;

  -- deklarace
  p_declare(curr);

  -- speciální metody
  if part_spec then
    p_special(curr);
    end if;

  -- příkazy
  if part_stmt then
    -- BEGIN
    if followlex(curr,lex_begin) then
      ce^.seterror({CCERR=}000301,ce_x_begin);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- příkazová část
    b_block(curr,bl);
    pentity_code(curr.entity)^.bl.setblock(bl);
    end if;
  end p_body;



----------------------------------------------------------------------------------------------------
procedure p_end_ident (
    curr           : in tcontext) =              -- překládaný prvek
-- Přeloží END <identifikátor>;
----------------------------------------------------------------------------------------------------
begin
  -- END <identifikátor>
  if followendid(curr,curr.entity^.id^) then
    ce^.seterror({CCERR=}000302,ce_x_end_body);
    ce^.setparam(entityident_to_string(curr.entity^.id^));
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- musí následovat středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000303,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end p_end_ident;



----------------------------------------------------------------------------------------------------
procedure p_subprogram (
    curr           : in tcontext;                -- překládaný prvek
    _etype         : in tentitytype) =           -- typ podprogramu
-- Deklarace podprogramu.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pproc            : pentity_subprogram;         -- podprogram
  pproc_context    : tcontext;                   -- kontext podprogramu
  pos              : lexposblock;                -- pozice

begin
  declare var
    etype          : tentitytype;                -- pracovní kopie parametru _ETYPE
  begin
    etype:=_etype;

    -- STATIC smí být jen v třídě
    if etype=et_static and curr.entity^.etype<>et_class then
      ce^.seterror({CCERR=}000304,ce_baddecl);
      ce^.setinfo(hint_static_class);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      etype:=et_procedure;

    -- VIRTUAL smí být jen v třídě, modulu, programu, kompilační jednotce
    elsif etype=et_virtual and curr.entity^.etype not in ets_container then
      ce^.seterror({CCERR=}000305,ce_baddecl);
      ce^.setinfo(hint_virtual_container);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      etype:=et_procedure;
      end if;

    -- začátek deklarace
    d_create(curr,pentity(pproc),pproc_context,etype,pos);
    end declare;

  if pproc^.declared=etd_incomplete

    -- Declaration completion
    then
      -- další symbol
      getlex(pproc_context,lex);

      case lex
        -- rovnítko
        when lex_eq     do ;

        -- dvojtečka nebo levá závorka nebo RETURN
        when lex_lpar, lex_return, lex_col do
            ce^.seterror({CCERR=}000306,ce_x_eq);
            ce^.setinfo(hint_pars_defined);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;

        -- něco jiného
        when others do
            ce^.seterror({CCERR=}000307,ce_x_eq);
            ce^.setinfo(hint_x_completion);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
        end case;

    -- Incomplete declaration/Full declaration
    else
      -- předávání instance
      -- v třídě
      if curr.entity^.etype=et_class then
        if pproc^.etype=et_virtual and curr.region^.vsect<>etv_private then pproc^.instance:=tip_dispatch
        elsif pproc^.etype=et_procedure then pproc^.instance:=tip_optional
        else pproc^.instance:=tip_pass;
        end if;
      -- v modulu/programu/kompilační jednotku
      elsif curr.entity^.etype in tentitytypeset:[et_module,et_program,et_compile] then pproc^.instance:=tip_none
      -- v overridu
      elsif curr.entity^.etype=et_override then pproc^.instance:=tip_pass
      -- v proceduře
      elsif curr.entity^.etype in ets_subprogram then begin
        -- nezapomenout konvertovat tip_dispatch na tip_pass
        if pentity_subprogram(curr.entity)^.instance=tip_dispatch
          then pproc^.instance:=tip_pass
          else pproc^.instance:=pentity_subprogram(curr.entity)^.instance
          end if;
        end
      else
        verify({VERIFY=}000238,true)
        end if;

      if checklex(pproc_context,lex_col)

        -- : Typ
        then p_typename(curr,pproc_context,pproc^.typ)

        -- ( ... ) RETURN Typ
        else
          declare var
            ptyp         : pentity_type;         -- typ podprogramu
            ptyp_context : tcontext;             -- kontext typu podprogramu
            tpos         : lexposblock;          -- pozice implicitní deklarace typu

          begin
            -- začátek deklarace
            d_create_without_name(pproc_context,pentity(ptyp),ptyp_context,et_type,nil,tpos);
            pproc^.typ.settype(ptyp);
            d_next(ptyp^,tpos);

            -- přeložit definici
            p_def_procedure(pproc_context,ptyp^,ptyp_context);

            -- konec deklarace
            d_end(ptyp^,tpos);
            end declare;
          end if;

      -- další symbol
      getlex(pproc_context,lex);
      case lex

        -- rovnítko => Full declaration
        when lex_eq   do 
            -- abstraktní deklarace nesmí obsahovat definici
            if pproc^.is_abstract then
              ce^.seterror({CCERR=}000308,ce_no_abstract_definition);
              ce^.loadpos;
              ce^.resumeerror;
              end if;
            
            -- další část deklarace
            d_next(pproc^,pos);

        -- středník => Incomplete declaration
        when lex_scol do d_end(pproc^,pos);

        -- cokoliv jiného je chyba
        when others do
            ce^.seterror({CCERR=}000309,ce_x_eq_scol);
            ce^.setinfo(hint_def_or_forward);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
        end case;
      end if;

  -- přeložit definici
  if pproc^.compiling=etd_full and not pproc^.is_abstract then
    -- dokončit vyhodnocení specifikace podprogramu před překladem definice
    e_before_subprogram_body(pproc);

    -- překládá se rovnou část PRIVATE
    pproc_context.region^.vsect:=etv_private;

    -- vygenerovat lokální proměnné podle parametrů
    p_genlocvar(pproc^);

    -- přeložit deklarace
    p_body(pproc_context,--false,true,false,true);
           for part_with   use true,
           for part_stmt   use true);
    p_end_ident(pproc_context);

    -- konec deklarace
    d_end(pproc^,pos);
    end if;
  end p_subprogram;



----------------------------------------------------------------------------------------------------
procedure p_override (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace přetížení virtuální metody.
----------------------------------------------------------------------------------------------------
var
  poverride        : pentity_override;           -- přetížení virtuální metody
  poverride_context: tcontext;                   -- context přetížení virtuální metody
  pos              : lexposblock;                -- pozice
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;

begin
  -- OVERRIDE smí být jen v třídě, modulu, programu, kompilační jednotce
  if curr.entity^.etype not in ets_container then
    ce^.seterror({CCERR=}000310,ce_baddecl);
    ce^.setinfo(hint_override_container);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- začátek deklarace
  d_create_without_name(curr,pentity(poverride),poverride_context,et_override,sym_get_override_id,pos);
  
  -- jméno virtuální metody
  x_vyraz(curr,expr,es_name);
  x_evaluate(curr,expr,ek_sym_virtual,nil,eu_formal,true,eval);
  verify({VERIFY=}000239,eval<>ete_evaluated);
  poverride^.virt.setexpr(expr);

  -- specifikace typů řídících parametrů
  if checklex(poverride_context,lex_with) then
    unimplemented({UNIMP=}000158);
    end if;

  -- =
  if followlex(poverride_context,lex_eq) then
    ce^.seterror({CCERR=}000311,ce_x_eq);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- je to vždy Full declaration
  d_next(poverride^,pos);

  -- dokončit vyhodnocení specifikace podprogramu před překladem definice
  e_before_subprogram_body(poverride);

  -- trik: override musí mít stejnou nebo lepší úroveň viditelnosti jako související virtuální
  -- metoda, aby se správně vyexportoval do metadat, i když je v private části třídy
  -- %%X No, zrovna čistá praktika to není... Nešlo by to nějak jinak?
  poverride^.visible:=poverride^.virt.getcentity^.visible;
  poverride^.full:=poverride^.virt.getcentity^.visible;
  sym_set_globaly_visible(poverride,for force use true);

  -- překládá se rovnou část PRIVATE
  poverride_context.region^.vsect:=etv_private;

  -- vygenerovat lokální proměnné podle parametrů
  p_genlocvar_override(poverride^);

  -- přeložit deklarace
  p_body(poverride_context,--false,true,false,true);
         for part_with   use true,
         for part_stmt   use true);

  -- %%TECH Zde nelze použít procedure P_END_IDENT, protože override je          
  -- nepojmenovaný objekt a uvádí se identifikátor související virtuální metody

  -- END <identifikátor>
  if followendid(poverride_context,poverride^.virt.getcentity^.id^) then
    ce^.seterror({CCERR=}000312,ce_x_end_body);
    ce^.setparam(entityident_to_string(poverride^.virt.getcentity^.id^));
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- musí následovat středník
  if followlex(poverride_context,lex_scol) then
    ce^.seterror({CCERR=}000313,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- konec deklarace
  d_end(poverride^,pos);
  end p_override;



----------------------------------------------------------------------------------------------------
procedure p_overload (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace přetížení.
----------------------------------------------------------------------------------------------------
type
  p_machine_pointer= ^unchecked for machine_pointer use true;

const
  overloadinit     = 4;
  overloaddelta    = 4;

label 
  R1;

var
  lex              : lexsym;                     -- lexikální symbol
  poverload        : pentity_overload0;          -- přetížení
  poverload_context: tcontext;                   -- kontext přetížení
  pos              : lexposblock;                -- pozice
  expr             : pexpnode;                   -- výraz
  psym             : pentity;                    -- symbol
  oop              : tooperator;                 -- přetížitelný operátor
  eval             : tentityeval;
  _table           : poverloadtable;
  _overload        : ^toverloaddesc;

begin
  begin
    -- další symbol
    getlex(curr,lex);

    -- deklarace přetížení
    if lex=lex_id then
      -- vrátit zpět do vstupu
      ungetlex;

      -- začátek deklarace
      d_create(curr,pentity(poverload),poverload_context,et_overload,pos);

    -- deklarace operátoru
    elsif lex in lex_operator then
      -- vyhledat odpovídající přetížitelný operátor
      oop:=oop:first;
      while (oop<=oop:last) and (ooperinfo[oop].lex<>lex) loop succ oop; end loop;
      verify({VERIFY=}000276,oop>oop:last);

      -- %%X Tohle je něco jako záplata, ale nevěděl jsem, jak to vyřešit líp 

      -- změnit lexikální element na identifikátor
      setlex(lex_id);
      setlexid(^ooperinfo[oop].txt);
      ungetlex;

      -- začátek deklarace
      d_create(curr,pentity(poverload),poverload_context,et_operator,pos);

      -- doplnit operátor
      pentity_operator(poverload)^.oop:=oop;

    -- cokoliv jiného je chyba
    else
      ce^.seterror({CCERR=}000314,ce_x_id_operator);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      ce^.resumeerror;
      end if;

    -- dvojtečka
    if followlex(poverload_context,lex_col) then
      ce^.seterror({CCERR=}000315,ce_x_col);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- seznam jmen procedur
    loop
      -- jméno procedury
      x_vyraz(curr,expr,es_name);
      x_evaluate(curr,expr,ek_sym_proc,nil,eu_formal,true,eval);

      -- pokud se proceduru nepodaří vyhodnotit, skočit na další iteraci
      if expr^.erroneous then goto R1 end if;
      verify({VERIFY=}000273,eval<>ete_evaluated);

      -- symbol
      x_get_symbol(expr,psym);

      -- relokovat paměť
      if poverload^.table=nil then
        new poverload^.table range overloadinit;
      elsif poverload^.table^:length=poverload^.table^:last then
        --%%TODO(ADJUST)
        new _table range poverload^.table^:last+overloaddelta;
        _table^:=poverload^.table^;
        discard poverload^.table;
        poverload^.table:=_table;
        end if;

      -- zařadit do tabulky %%TODO(AGGREGATE), %%TODO(STRING_ADJUST)
      new _overload;
      _overload^.psym.setexpr(expr);
      _overload^.psym.setentity(psym);
      poverload^.table^ & _overload^;
      discard p_machine_pointer(_overload);

    R1:
      until not checklex(poverload_context,lex_comma);
    
    -- registruj do globalniho gc
    c_garbage_collector.get_instance^.register_memblock(poverload^.table);

    -- středník
    if followlex(poverload_context,lex_scol) then
      ce^.seterror({CCERR=}000316,ce_x_scol);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- konec deklarace
    d_end(poverload^,pos);

  catch
    when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
    end;
  end p_overload;



----------------------------------------------------------------------------------------------------
procedure p_module (
    curr           : in tcontext;                -- překládaný prvek
    etype          : in tentitytype) =           -- modul/třída
-- Deklarace modulu/třídy.
-- %%X dodělat RESUME                                                          
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  psym             : pentity;                    -- modul
  psym_context     : tcontext;                   -- kontext modulu
  pos              : lexposblock;                -- pozice

begin
  -- začátek deklarace
  d_create(curr,psym,psym_context,etype,pos);

  -- Incomplete declaration/Full declaration
  if psym^.compiling=etd_none then
    -- = nebo ;
    getlex(psym_context,lex);
    case lex

      -- Full declaration
      when lex_eq do
          -- další část deklarace
          d_next(psym^,pos);

          -- Full body
          p_body(psym_context,--true,true,true,false);
                 for part_extend use true,
                 for part_expose use etype=et_class,
                 for part_with   use true,
                 for part_spec   use true);
          p_end_ident(psym_context);

          -- konec deklarace
          d_end(psym^,pos);

      -- Incomplete declaration
      when lex_scol do d_end(psym^,pos);

      -- cokoliv jiného je chyba
      when others do
          ce^.seterror({CCERR=}000317,ce_x_eq_scol);
          ce^.setinfo(hint_def_or_forward);
          ce^.loadpos;
          {%%RESUME ce^.seterror;}
          ce^.resumeerror;
      end case;

  -- Full body declaration
  elsif psym^.compiling=etd_full and psym^.declared=etd_incomplete then
    -- rovnítko
    if followlex(psym_context,lex_eq) then
      ce^.seterror({CCERR=}000318,ce_x_eq);
      ce^.loadpos;
      end if;

    -- Full body
    p_body(psym_context,--true,true,true,false);
           for part_extend use true,
           for part_expose use etype=et_class,
           for part_with   use true,
           for part_spec   use true);
    p_end_ident(psym_context);

    -- konec deklarace
    d_end(psym^,pos);

  -- Public body declaration
  elsif psym^.compiling=etd_public then
    -- rovnítko
    if followlex(psym_context,lex_eq) then
      ce^.seterror({CCERR=}000319,ce_x_eq);
      ce^.loadpos;
      end if;

    -- Public body
    p_body(psym_context,--true,true,false,false);
           for part_extend use true,
           for part_expose use etype=et_class,
           for part_with   use true);
    p_end_ident(psym_context);

    -- konec deklarace
    d_end(psym^,pos);

  -- Private body declaration
  elsif (psym^.declared=etd_public) and (psym^.compiling=etd_full)then
    -- rovnítko
    if followlex(psym_context,lex_eq) then
      ce^.seterror({CCERR=}000320,ce_x_eq);
      ce^.loadpos;
      end if;

    -- Private body
    p_body(psym_context,--false,true,true,false);
           for part_with   use true,
           for part_spec   use true);
    p_end_ident(psym_context);

    -- konec deklarace
    d_end(psym^,pos);

  else
    verify({VERIFY=}000155,true)
    end if;

  -- zařadit do fronty na provádění ENTRY/EXIT
  if psym^.etype=et_module and psym^.declared=etd_full then
    entrylist.add(psym);
    end if;
  end p_module;



----------------------------------------------------------------------------------------------------
procedure p_message (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace zprávy.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pmsg             : pentity_message;            -- zpráva
  pmsg_context     : tcontext;                   -- kontext zprávy
  pos              : lexposblock;                -- pozice
  tpos             : lexposblock;                -- pozice implicitní deklarace typu
  expr             : pexpnode;                   -- výraz
  psym             : pentity;                    -- předek
  mtyp             : pentity_type;               -- typ zprávy
  mtyp_context     : tcontext;                   -- kontext typu zprávy
  eval             : tentityeval;

label
  R1;

begin
  loop
    begin
      -- začátek deklarace
      d_create(curr,pentity(pmsg),pmsg_context,et_message,pos);

      -- další symbol
      getlex(pmsg_context,lex);
      case lex
        -- : Typ
        when lex_col do
            p_typename(curr,pmsg_context,pmsg^.typ);

        -- EXTEND Zpráva
        when lex_extend do
            -- výraz
            x_vyraz(pmsg_context,expr,es_name);
            x_evaluate(pmsg_context,expr,ek_context_message,nil,eu_formal,true,eval);
            if expr^.erroneous then goto R1 end if;
            verify({VERIFY=}000786,eval<>ete_evaluated);

            -- symbol
            x_get_symbol(expr,psym);

            -- Jistě to není potomek této zprávy
            -- Důkaz: Nelze udělat dopřednou deklaraci zprávy => tato zpráva
            -- nebyla vidět v předchozích deklaracích. Následující deklarace
            -- ještě nejsou vidět
            verify({VERIFY=}000234,sym_is_descendant(psym,pmsg));

            -- zařadit jako předka
            pmsg^.ancestor.setexpr(expr);
            pmsg^.ancestor.setentity(psym);

        -- implicitní deklarace typu
        when others do
            -- symbol vrátit zpět
            ungetlex;

            -- začátek deklarace
            d_create_without_name(pmsg_context,pentity(mtyp),mtyp_context,et_type,nil,tpos);
            pmsg^.typ.settype(mtyp);
            d_next(mtyp^,tpos);

            -- přeložit definici
            p_def_message(curr,mtyp^,mtyp_context);

            -- konec deklarace
            d_end(mtyp^,tpos);
        end case;

      -- středník
      if followlex(pmsg_context,lex_scol) then
        ce^.seterror({CCERR=}000321,ce_x_scol);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- konec deklarace
      d_end(pmsg^,pos);

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
      end;

  R1:
    -- podívat se na další symbol
    looklex(curr,lex);
    until lex<>lex_id;
  end p_message;



----------------------------------------------------------------------------------------------------
procedure p_program (
    curr           : in tcontext) =              -- překládaný prvek
-- Deklarace programu
-- %%X dodělat RESUME                                                         
----------------------------------------------------------------------------------------------------
var
  pprog            : pentity_program;            -- program
  pprog_context    : tcontext;                   -- kontext programu
  pos              : lexposblock;                -- pozice

begin
  -- začátek deklarace
  d_create(curr,pentity(pprog),pprog_context,et_program,pos);

  -- rovnítko
  if followlex(pprog_context,lex_eq) then
    ce^.seterror({CCERR=}000322,ce_x_eq);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- překládá se rovnou část PRIVATE
  pprog_context.region^.vsect:=etv_private;

  -- přeložit deklaraci
  p_body(pprog_context,--false,true,false,true);
         for part_with   use true,
         for part_stmt   use true);
  p_end_ident(pprog_context);

  -- konec deklarace
  d_end(pprog^,pos);
  end p_program;



----------------------------------------------------------------------------------------------------
procedure p_private (
    curr           : in tcontext) =              -- překládaný prvek
-- Část PRIVATE
----------------------------------------------------------------------------------------------------
begin
  -- část PRIVATE smí být jen v modulu a třídě
  if curr.entity^.etype not in ets_modular then
    ce^.seterror({CCERR=}000323,ce_bad_private);
    ce^.setinfo(hint_part_no_private);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;};
    return;
    end if;

  -- PRIVATE musí následovat po PUBLIC/PROTECTED/SUPERVISED
  if not (curr.region^.vsect<etv_private) then
    ce^.seterror({CCERR=}000324,ce_bad_private);
    ce^.setinfo(hint_part_bad_private);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    return;
    end if;

  -- PRIVATE smí být jen ve Full body
  if curr.entity^.compiling<>etd_full then
    ce^.seterror({CCERR=}000325,ce_bad_private);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    return;
    end if;

  -- nástavit část PRIVATE
  curr.region^.vsect:=etv_private;
  end p_private;



----------------------------------------------------------------------------------------------------
procedure p_supervised (
    curr           : in tcontext) =              -- překládaný prvek
-- Část SUPERVISED
----------------------------------------------------------------------------------------------------
begin
  -- část SUPERVISED smí být jen v modulu a třídě
  if curr.entity^.etype not in ets_modular then
    ce^.seterror({CCERR=}000326,ce_bad_supervised);
    ce^.setinfo(hint_part_no_supervised);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;};
    return;
    end if;

  -- supervised musí následovat po PUBLIC/PROTECTED
  if not (curr.region^.vsect<etv_supervised) then
    ce^.seterror({CCERR=}000327,ce_bad_supervised);
    ce^.setinfo(hint_part_bad_supervised);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    return;
    end if;

  -- nástavit část SUPERVISED
  curr.region^.vsect:=etv_supervised;
  end p_supervised;



----------------------------------------------------------------------------------------------------
procedure p_protected (
    curr           : in tcontext) =              -- překládaný prvek
-- Část PROTECTED
----------------------------------------------------------------------------------------------------
begin
  -- část PROTECTED smí být jen v modulu a třídě
  if curr.entity^.etype not in ets_modular then
    ce^.seterror({CCERR=}000328,ce_bad_protected);
    ce^.setinfo(hint_part_no_protected);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;};
    return;
    end if;

  -- protected musí následovat po PUBLIC
  if not (curr.region^.vsect<etv_protected)then
    ce^.seterror({CCERR=}000329,ce_bad_protected);
    ce^.setinfo(hint_part_bad_protected);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    return;
    end if;

  -- nástavit část protected
  curr.region^.vsect:=etv_protected;
  end p_protected;



----------------------------------------------------------------------------------------------------
procedure p_declare =
-- Deklarace.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  loop
    begin
      -- přečíst ze vstupu lexikální symbol
      getlex(curr,lex);

      -- zpracovat
      case lex
        -- deklarace
        --- POZOR: při doplnění dalšího klíčového slova promítnout ---
        --- i do obsluhy RESUME_ERROR za tímto CASE                ---
        when lex_type       do p_type(curr);
        when lex_const      do p_const(curr);
        when lex_var        do p_var(curr);
      --when lex_define     do u_nimplemented(40);
        when lex_procedure  do p_subprogram(curr,et_procedure);
        when lex_static     do p_subprogram(curr,et_static);
        when lex_virtual    do p_subprogram(curr,et_virtual);
        when lex_task       do p_subprogram(curr,et_task);
        when lex_override   do p_override(curr);
        when lex_macro      do unimplemented({UNIMP=}000040);
        when lex_class      do p_module(curr,et_class);
      --when lex_interface  do u_nimplemented(40);
        when lex_message    do p_message(curr);
      --when lex_alias      do p_alias(curr);
        when lex_label      do p_label(curr);
        when lex_overload   do p_overload(curr);
        when lex_module     do p_module(curr,et_module);

        -- viditelnost
        when lex_private    do p_private(curr);
        when lex_protected  do p_protected(curr);
        when lex_supervised do p_supervised(curr);

        -- konec bloku deklarací
        when lex_eof,lex_entry,lex_exit,lex_adjust,lex_rollback,lex_commit,lex_program,lex_begin,lex_end do
            -- naposledy přečtený symbol vrátit do vstupu
            ungetlex;
            return;

        -- nějaký blábol
        when others do
            ce^.seterror({CCERR=}000330,ce_x_decl);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror; }
            ce^.resumeerror;
        end case;

    catch
      when resume_error do
          begin
            loop
              getlex(curr,lex);
              if lex in lexsymset:[lex_eof,lex_program,lex_begin,lex_end] then return{goto k1}; end if;
              until lex in lexsymset:[lex_type,lex_const,lex_var,{lex_define,}lex_procedure,
                lex_static,lex_virtual,lex_macro,lex_class,{lex_interface,}
                lex_private,lex_protected,lex_message,{lex_alias,}lex_label,
                lex_overload,lex_module,{lex_entry,lex_exit,lex_adjust,}lex_task];
              ungetlex;
          catch
            when resume_error, compiler_error do { co s výjimkou ? };
            end;
      end;
    end loop;
{ -- To se udělá samo
  -- zkontrolovat, zda nezůstaly nějaké neúplné deklarace
  e_all(curr,e);
}
  end p_declare;



----------------------------------------------------------------------------------------------------
procedure p_compfile (
    curr           : in tcontext;                -- překládaný prvek
    name           : in t_char32str;             -- jméno souboru
    part           : in t_part;                  -- část jména souboru
    nalez          : in out t_logical) =         -- T-soubor nalezen
-- Přeloží soubor. Příznak NALEZ se nenuluje, jen nastavuje.
----------------------------------------------------------------------------------------------------
with
  cc_text;

var
  lex              : lexsym;                     -- lexikální symbol
  fname            : t_char32str;                -- jméno souboru

begin
  -- sestavit jméno souboru
  fname:=cfg_files^.get_source_file_name(name,part);
  if fname='' then return; end if;

  -- teď je již jisté, že soubor existuje, jinak bychom nezískali jeho jméno
  nalez:=true;

  -- otevřít soubor
  text_open(fname,false);

  begin
    -- přeložit deklarace
    p_declare(curr);

    -- konec textu
    getlex(curr,lex);
    if lex<>lex_eof then
      ce^.seterror({CCERR=}000331,ce_x_eof);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

  leave
    -- zavřít soubor
    text_close;
    end;
  end p_compfile;



----------------------------------------------------------------------------------------------------
procedure p_loadmodule =
-- Načte modul ze souboru.
----------------------------------------------------------------------------------------------------
var
  compi            : tcontext;                   -- kompilační jednotka
  found            : t_logical;                  -- T-soubor nalezen

begin
  found:=false;

  -- najít kompilační jednotku
  compi:=sym_primary_context(sym_get_enclosing_or_self(curr.entity,et_compile)^);
  verify({VERIFY=}000086,{%%TODO(OPT) compi=nil => Internal error 131}compi.entity=nil);

  -- přeložit soubor *.SRC
  p_compfile(compi,entityident_to_string(id),part_all,found);

  -- přeložit soubor *.PUB
  p_compfile(compi,entityident_to_string(id),part_public,found);

  -- přeložit soubor *.PRIV
  p_compfile(compi,entityident_to_string(id),part_private,found);

  -- přeložilo se aspoň něco ?
  if not found then
    ce^.seterror({CCERR=}000332,ce_f_notfound);
    ce^.setparam(entityident_to_string(id));
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end p_loadmodule;



----------------------------------------------------------------------------------------------------
procedure p_create_internal_entities (
    compi          : in tcontext) =              -- kompilační jednotka
-- Doplní implicitní deklarace do kompilační jednotky.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure newunitype (
        dtype      : in tdatatype;               -- datový typ
        size       : in tunidata_size;           -- velikost
        ptyp       : out pentity_type;           -- vzniklý typ
        id         : in pentityident) =          -- identifikátor
    -- Nový univerzální typ.
    ------------------------------------------------------------------------------------------------
    var
      ptyp_context : tcontext;                   -- kontext typu

    begin
      d_create_internal(compi,pentity(ptyp),ptyp_context,et_type,id);
      ptyp^.stype:=dtype;
      ptyp^.size:=size;
      ptyp^.compile+tentitycompileset:[etc_no_cmt_export];
      d_end_internal(ptyp^,false);
      end newunitype;



    ------------------------------------------------------------------------------------------------
    procedure newdefaultord (
        dtype      : in tdatatype;               -- datový typ
        ptyp       : out pentity_type;           -- vzniklý typ
        id         : in pentityident) =          -- identifikátor
    -- Nový ordinální typ.
    ------------------------------------------------------------------------------------------------
    var
      ptyp_context : tcontext;                   -- kontext typu

    begin
      d_create_internal(compi,pentity(ptyp),ptyp_context,et_type,id);
      ptyp^.stype:=dtype;
      cpu^.getdefaultord(dtype,ptyp^.bits,ptyp^.size,ptyp^.lval,ptyp^.hval);
      ptyp^.compile+tentitycompileset:[etc_no_cmt_export];
      d_end_internal(ptyp^,false);
      end newdefaultord;



    ------------------------------------------------------------------------------------------------
    procedure newdefaulttag (
        ptyp       : out pentity_type;           -- vzniklý typ
        id         : in pentityident) =          -- identifikátor
    -- Nový typ :tag.
    ------------------------------------------------------------------------------------------------
    var
      ptyp_context : tcontext;                   -- kontext typu

    begin
      d_create_internal(compi,pentity(ptyp),ptyp_context,et_type,id);
      ptyp^.stype:=dt_tag;
      cpu^.getrtattribsize(rta_tag,ptyp^.size);
      ptyp^.compile+tentitycompileset:[etc_no_cmt_export];
      d_end_internal(ptyp^,false);
      end newdefaulttag;



    ------------------------------------------------------------------------------------------------
    procedure newdefaultptr (
        base       : in pentity_type;            -- bázový typ
        pflags     : in ptrflagsset;             -- parametry pointeru
        pclass     : in ptrclass;                -- třída báze
        pbase      : in ptrbase;                 -- kompatibilita báze
        pattrib    : in rtattribset;             -- dynamické atributy
        ptyp       : out pentity_type;           -- vzniklý typ
        id         : in pentityident) =          -- identifikátor
    -- Nový typ pointer.
    ------------------------------------------------------------------------------------------------
    var
      ptyp_context : tcontext;                   -- kontext typu

    begin
      d_create_internal(compi,pentity(ptyp),ptyp_context,et_type,id);
      ptyp^.stype:=dt_pointer;
      ptyp^.base.settype(base);
      ptyp^.pflags:=pflags;
      ptyp^.pclass:=pclass;
      ptyp^.pbase:=pbase;
      ptyp^.pattrib:=pattrib;
      cpu^.getptrsize(ptyp^.pattrib,ptyp^.size);
      ptyp^.compile+tentitycompileset:[etc_no_cmt_export];
      d_end_internal(ptyp^,false);
      end newdefaultptr;

begin
  ---- univerzální typ UNIINT ----
  newunitype(dt_uniint,unsigned_to_unidata_size(tuniint:size),def_uniint,^id_int_uniint);

  ---- univerzální typ UNIREAL ----
  newunitype(dt_unireal,unsigned_to_unidata_size(tunireal:size),def_unireal,^id_int_unireal);

  ---- univerzální typ UNICHAR ----
  newunitype(dt_unichar,unsigned_to_unidata_size(tunichar:size),def_unichar,^id_int_unichar);

  ---- univerzální typ UNILOGICAL ----
  newunitype(dt_unilogical,unsigned_to_unidata_size(tunilogical:size),def_unilogical,^id_int_unilogical);

  ---- univerzální typ UNISTR (univerzální pole of UNICHAR) ----
  newunitype(dt_uniarray,uds_0,def_unistr,sym_get_uniarray_id);
  def_unistr^.base.settype(def_unichar);

  ---- univerzální NIL ----
  newunitype(dt_uninil,uds_0,def_uninil,^id_int_uninil);

  ---- typ interní složky třídy @TAG ----
  newdefaulttag(inttype_tag,^id_int_t_tag);

  ---- typ interní složky třídy @STATUS ----
  newdefaultord(dt_unsigned,inttype_status,^id_int_t_status);

  ---- interní typ pro atributy :size a :last ----
  newdefaultord(dt_unsigned,inttype_size,^id_int_t_size);

  ---- strojový pointer ----
  newdefaultptr(nil,ptrflagsset:[pf_machine],pc_data,pb_unchecked,[],inttype_machine_pointer,^id_int_t_mptr);
  end p_create_internal_entities;



----------------------------------------------------------------------------------------------------
procedure p_setup_compilation_environment =
-- Připraví prostředí pro kompilaci v zadané kompilační jednotce.
-- WITHne existující globální partition, podle potřeby deklaruje univerzální typy a přeloží run-time
-- podporu (modul Flex).
-- Pozor: Standardně se volá v rámci [p_create_compilation_unit]. Samostatně určeno pouze pro
-- vytváření kompilačních jednotek z metadat a podobně.
----------------------------------------------------------------------------------------------------
with
  supervised cc_base.cc_sym.cc_partition;

var
  compi_context    : tcontext;                   -- kontext kompilační jednotky

begin
  -- pro jednoduchost si připravit kontext, bude se hodit
  compi_context:=sym_primary_context(compi^);

  -- %%TECH V předchozí verzi překladače bylo COMPI^.OWNER=COMPI.
  -- Zde jsem to zrušil, protože je to k ničemu.

  -- WITHnout všechny dosud přeložené globální partition
  part_with_partitions(compi_context);

  -- inicializovat built-in prostředí
  if compi^.part_type in parts_contains_runtime then
    -- doplnit implicitní deklarace
    p_create_internal_entities(compi_context);
    end if;

  -- přeložit run-time podporu (modul FLEX)
  if compi^.part_type in parts_compile_runtime and not cfg_no_runtime then 
    p_loadmodule(compi_context,id_flex); 
    end if;

{
  -- zapnout varování a hinty
  -- (až po překladu FLEX, ať to neopruzuje)
  compi^.compv.warns:=compi^.compv.warns:full;
  compi^.compv.hints:=compi^.compv.hints:full;
}
  end p_setup_compilation_environment;
  
  
  
----------------------------------------------------------------------------------------------------
procedure p_create_compilation_unit =
-- Vytvoří kompilační jednotku a zajistí překlad run-time knihovny.
----------------------------------------------------------------------------------------------------
use
  cc_base.cc_sym.cc_advanced;

var
  compi_context    : tcontext;                   -- kontext kompilační jednotky

begin
  -- zapamatovat si typ překládané partition
  curr_partition_type:=part_type;

  -- vytvořit entitu a primární region
  cc_base.cc_sym.cc_advanced.sym_new_entity(et_compile,pentity(compi));
  cc_base.cc_sym.cc_advanced.sym_new_region(rt_primary,compi^.regions[rc_primary]);
  compi_context:=sym_primary_context(compi^);

  -- nastavit počáteční bezpečnostní úroveň této partition
  compi^.sec_level:=sec_level;
  compi^.sec_required:=sec_required;
  o_set_option_param_uniint(opt_required_security,compi^,unsigned_to_uniint(t_unsigned(sec_required)));
  o_set_option_param_uniint(opt_security_level,compi^,unsigned_to_uniint(t_unsigned(sec_level)));

  -- zapamatovat si typ, výsledný tvar, externí identifikátor a uživatele partition
  compi^.part_type  :=part_type;
  compi^.part_result:=part_result;
  compi^.part_extid :=part_extid;
  compi^.part_userid:=part_userid;

  -- partition je vždy globálně viditelná
  compi^.compile+tentitycompileset:[etc_globaly_visible];

  -- přiřadit identifikátor (je to výjimka jen pro kompilační jednotku, ta jsem to udělal přímo 
  -- takhle místo jako proceduru do [cc_base.cc_sym])
  new compi^.id range id_compilation:length;
  c_garbage_collector.get_instance^.register_memblock(compi^.id);  
  compi^.id^:=id_compilation;

  -- připravit prostředí pro kompilaci
  p_setup_compilation_environment(compi);
  end p_create_compilation_unit;



----------------------------------------------------------------------------------------------------
procedure p_compile_compilation_unit =
-- Přeloží jednu část kompilační jednotky.
----------------------------------------------------------------------------------------------------
var
  compi_context    : tcontext;                   -- kontext kompilační jednotky

begin
  -- run-time partition nemá žádnou uživatelskou část
  -- if compi^.part_type=part_runtime then return end if;
  
  -- sestavit kontext deklarace
  compi_context:=sym_primary_context(compi^);

  -- globální deklarace
  p_declare(compi_context);

  -- deklarace programu nebo knihovny
  if compi^.part_type in parts_contains_program and then checklex(compi_context,lex_program)
    
    -- přeložit program
    then 
      -- přeložit program
      p_program(compi_context);

      -- nebyl-li dosud zvolen tvar přeložené partition, vybrat variantu "program"
      if compi^.part_result=tpr_auto_select then
        compi^.part_result:=tpr_program;
        end if;

    -- knihovna uz zkompilovana (viz p_declare)
    else 
      -- nebyl-li dosud zvolen tvar přeložené partition, vybrat variantu "knihovna"
      if compi^.part_result=tpr_auto_select then
        compi^.part_result:=tpr_library;
        end if;
      end if;

  -- konec textu
  if not checklex(compi_context,lex_eof) then
    ce^.seterror({CCERR=}000333,ce_x_eof);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end p_compile_compilation_unit;



----------------------------------------------------------------------------------------------------
procedure p_finalize_compilation_unit =
-- Finalizuje kompilační jednotku.
----------------------------------------------------------------------------------------------------
with
  supervised cc_base.cc_sym.cc_partition,
  cc_binding;

begin
  -- označit deklaraci jako ukončenou
  compi^.declared:=etd_full;

  -- vyhodnotit deklaraci
  e_symbol(compi,nil,etd_full,true);

  -- vyexportovat partition, aby bylo možné se na ní staticky linkovat
  if compi^.part_type<>part_standalone and compi^.part_result=tpr_library then
    -- vyexportovat kompilační jednotku
    export_entity(compi,for traverse use false);
    
    -- vyexportovat program, je-li k dispozici
    declare var
      srch         : tentitysearch;  
      
    begin
      srch.find_et_first(compi,rc_primary,et_program,[]);
      if srch.psym<>nil then
        export_entity(srch.psym,for external_name use entityident_to_external_entity_ident(id_program)^,for traverse use false);
        end if;
      end declare;  
    end if;
  
  -- registrovat partition
  part_register_partition(compi);
  end p_finalize_compilation_unit;



end cd_unit;