----------------------------------------------------------------------------------------------------
module private cx_util =
-- Překladač Flexu.
-- Procedury na manipulaci se stromem.
----------------------------------------------------------------------------------------------------
-- Ondra : 31.07.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_lexsym,cc_sym,
  cx_expr.cx_imm,
  cx_expr.cx_rta;

----------------------------------------------------------------------------------------------------
procedure x_refine_binary =
-- Podle typů operandů upřesní volbu jazykem definovaného bin. operátoru.
----------------------------------------------------------------------------------------------------
begin
  -- ? AND --> BIT_AND 
  if t_is_sts(t1,dts_u_integer) or t_is_sts(t2,dts_u_integer) then
    case oper
      when op_and do lop:=op_bitand;
      when op_or  do lop:=op_bitor;
      when op_xor do lop:=op_bitxor;
      -- jinak beze změny
      when others do lop:=oper;
      end case;

  -- ? * --> INTERSECT
  elsif t_is_sts(t1,dts_u_set) or t_is_sts(t2,dts_u_set) then
    case oper
      when op_add do lop:=op_union;
      when op_sub do lop:=op_diff;
      when op_mul do lop:=op_isect;
      -- jinak beze změny
      when others do lop:=oper;
      end case;

  -- ostatní případy beze změny 
  else
    lop:=oper;
    end if;
  end x_refine_binary;



----------------------------------------------------------------------------------------------------
procedure x_refine_unary =
-- Podle typu operandu upřesní volbu jazykem definovaného un. operátoru.      
----------------------------------------------------------------------------------------------------
begin
  -- ? NOT --> BIT_NOT 
  if t_is_sts(t1,dts_u_integer) then
    case oper
      when un_not do lop:=un_bitnot;
      -- jinak beze změny
      when others do lop:=oper;
      end case;

  -- ? NOT --> SET_NOT
  elsif t_is_sts(t1,dts_u_set) then
    case oper
      when un_not do lop:=un_setnot;
      -- jinak beze změny
      when others do lop:=oper;
      end case;

  -- ostatní případy beze změny
  else
    lop:=oper;
    end if;
  end x_refine_unary;



----------------------------------------------------------------------------------------------------
procedure x_resolve =
-- Podle dvou ordinálních typů (netestuje se) operandů odvodí typ výsledku.   
-- Typy musí být kompatibilní (netestuje se).                                 
----------------------------------------------------------------------------------------------------
var
  t1               : typeview;
  t2               : typeview;
  p                : pentity_type;

begin
  -- není třeba něco dělat s Partial view ?
  if usefullview and _t1.tview=tview_partial and _t2.tview=tview_partial

    -- z Partial view udělat Full view
    then
      t1.initfull(_t1.getutype);
      t2.initfull(_t2.getutype);

    -- ponechat
    else
      t1:=_t1;
      t2:=_t2;
      end if;

  -- signed -- signed 
  if (t1.stype=dt_signed and t2.stype=dt_signed)
  -- unsigned -- unsigned 
  or (t1.stype=dt_unsigned and t2.stype=dt_unsigned)
  -- logical -- logical 
  or (t1.stype=dt_logical and t2.stype=dt_logical)
  -- character -- character 
  or (t1.stype=dt_char and t2.stype=dt_char)
  -- enum -- enum
  or (t1.stype=dt_enum and t2.stype=dt_enum)
  then
  {
    if t1.getbits<>t2.getbits then
      write('rozdilne bitove delky typu ');
      write(tdatatypetxt[t1.stype]); write(' '); write(unsigned_to_string(unidata_bitsize_to_unsigned(t1.getbits))); write(' -- ');
      write(tdatatypetxt[t2.stype]); write(' '); write(unsigned_to_string(unidata_bitsize_to_unsigned(t2.getbits))); write_line('');
      end if;
  }  
    -- vybrat přesnější typ (přednost má typ levého podvýrazu)
    if t1.getbits<t2.getbits
      then result:=t2
      else result:=t1;
      end if;

  -- pointer -- pointer
  elsif t1.stype=dt_pointer and t2.stype=dt_pointer then
    -- vybrat pointer s typovou informací
    -- (přednost má typ levého podvýrazu)
    if t1.getpbase<>pb_class and t2.getpbase=pb_class
      then result:=t2
      else result:=t1;
      end if;

  -- string -- string
  elsif t1.stype in dts_string and t2.stype in dts_string then
    result:=t1;

  -- array -- array
  elsif t1.stype in dts_array and t2.stype in dts_array then
    result:=t1;

  -- možina -- množina
  elsif t1.stype in dts_set and t2.stype in dts_set then
    result:=t1;

  -- record -- record
  elsif t1.stype=dt_record and t2.stype=dt_record then
    result:=t1;

  -- tag -- tag
  elsif t1.stype=dt_tag and t2.stype=dt_tag then
    result:=t1;

  -- univerzální -- univerzální
  -- Sem už by měly dorazit kompatibilní typy, takže není třeba testovat, zda
  -- se jedná o _kompatibilní_ univerzální typy a stačí vrátit jeden z nich.
  elsif t1.stype in dts_unitype and t2.stype in dts_unitype then
    result:=t1;

  -- univerzální -- cosi
  elsif t1.stype in dts_unitype then
    result:=t2;

  -- cosi -- univerzální
  elsif t2.stype in dts_unitype then
    result:=t1;

  else
    verify({VERIFY=}000064,true);
    end if;
  end x_resolve;



----------------------------------------------------------------------------------------------------
procedure x_resolve_by_result =
-- Na základě požadovaného typu výsledku (T1) a typu podvýrazu z typové       
-- kontroly 1 (T2) zvolí typ podvýrazu typové kontroly 2.                     
-- Typy musí být kompatibilní (netestuje se).                                 
----------------------------------------------------------------------------------------------------
begin
  -- požadovaný typ výsledku není Full view => zvolit typ podvýrazu 
  if t1.tview<>tview_full then result:=t2

  -- typ podvýrazu je Null view => zvolit požadovaný typ 
  elsif t2.tview=tview_null then result:=t1

  -- typ podvýrazu není Full view => zvolit ten, typ výsledku nesmí mít vliv 
  elsif t2.tview<>tview_full then result:=t2
{
  -- jeden z typů není k dispozici
  if t1.tview=tview_null then result:=t2
  elsif t2.tview=tview_null then result:=t1
}
  -- dále už jsou oba typy zcela jistě Full view

  -- stejné typy, není co řešit
  elsif t_equal(t1,t2) then result:=t1

  -- ordinální - ordinální
  elsif (t1.stype in dts_ordinal) and (t2.stype in dts_ordinal) then
    -- T2 je přesnější
    if t1.getbits<t2.getbits then result:=t2

    -- stejně přesné, ale různé znaménko
    elsif (((t1.stype=dt_signed) and (t2.stype=dt_unsigned))
    or ((t1.stype=dt_unsigned) and (t2.stype=dt_signed)))
    and t1.getbits=t2.getbits then result:=t2

    -- celočíselné a T1 je přesnější
    elsif (t1.stype in tdatatypeset:[dt_signed,dt_unsigned])
    and (t2.stype in tdatatypeset:[dt_signed,dt_unsigned])
    and t2.getbits<t1.getbits then
      result:=t1{newtmp(curr,result,t2.stype,t1.size)};

    -- ostatní případy
    else
      result:=t1;
      end if;

  -- ve všech ostatních případech zvolit T1
  {%%X Určitě ??? }
  else
    result:=t1;
    end if;
  end x_resolve_by_result;



----------------------------------------------------------------------------------------------------
procedure x_resolve_opdtype =
-- Typ operandů upravený vzhledem k operátoru.
-- (Například výsledek porovnání je vždy univerzální logical, ale typ         
-- operandů je třeba pole.)                                                   
----------------------------------------------------------------------------------------------------
var
  res              : typeview;

begin
  if expoperinfo[expr^.oper].tdiff

    -- typ znova vypočítat
    then
      if expr^.oper in expopertypeset:[op_in,op_notin]

        -- pro IN a NOT IN je to typ pravého operandu
        then
          -- není třeba něco dělat s Partial view ?
          if usefullview and (expr^.sub^.next^.t.tview=tview_partial)

            -- z Partial view udělat Full view
            then
              res.initfull(expr^.sub^.next^.t.getutype);
              result:=res.stype;

            -- ponechat
            else
              result:=expr^.sub^.next^.t.stype
              end if;

        -- pro ostatní operandy zvolit přesnější typ
        else
          x_resolve(expr^.sub^.t,expr^.sub^.next^.t,usefullview,res);
          result:=res.stype;
          end if;

    -- typ převzít
    else
      if usefullview and (expr^.t.tview=tview_partial)
        then
          res.initfull(expr^.t.getutype);
          result:=res.stype;
        else 
          result:=expr^.t.stype;
          end if;
      end if;
  end x_resolve_opdtype;




----------------------------------------------------------------------------------------------------
procedure x_addunary =
-- Doplní unární operátor. Typ a třídu uzlu převezme z původního výrazu.      
----------------------------------------------------------------------------------------------------
begin
  -- vznikl nový uzel 
  derivenode(pexpnode(newexpr),oldexpr,info,nt_unary);

  -- převzít typ a třídu 
  newexpr^.nclass:=oldexpr^.nclass;

  -- operátor (včetně příznaku přiřazení) 
  pexpunary(newexpr)^.oper:=oper;
  pexpunary(newexpr)^.assign:=assignable and oldexpr^.assign;

  -- operand 
  pexpunary(newexpr)^.join(sub);
  end x_addunary;



----------------------------------------------------------------------------------------------------
procedure x_addui =
-- Doplní univerzální integer. Typ uzlu převezme z původního výrazu.          
-- Třídu nastaví na NC_VALUE.                                                 
----------------------------------------------------------------------------------------------------
begin
  -- vznikl nový uzel 
  derivenode(pexpnode(newexpr),oldexpr,info,nt_imm,is_const);

  -- třída uzlu 
  newexpr^.nclass:=nc_value;

  -- uložit konstantu 
  store_ordinal(pexpimm(newexpr)^.imm,ui);
  end x_addui;



----------------------------------------------------------------------------------------------------
procedure x_addul =
-- Doplní univerzální logical. Typ uzlu převezme z původního výrazu.          
-- Třídu nastaví na NC_VALUE.                                                 
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;

begin
  ui:=unilogical_to_uniint(ul);
  x_addui(newexpr,oldexpr,ui,info,is_const);
  end x_addul;



----------------------------------------------------------------------------------------------------
procedure x_add_imm =
-- Doplní konstantu. Typ uzlu převezme z původního výrazu.                    
-- Třídu nastaví na NC_VALUE.                                                 
----------------------------------------------------------------------------------------------------
begin
  -- vznikl nový uzel 
  derivenode(pexpnode(newexpr),oldexpr,info,nt_imm,is_const);

  -- třída uzlu 
  newexpr^.nclass:=nc_value;
  end x_add_imm;



----------------------------------------------------------------------------------------------------
procedure x_addop =
-- Doplní binární operátor EL op UI.                                          
----------------------------------------------------------------------------------------------------
begin
  -- vznikl nový uzel 
  derivenode(pexpnode(newexpr),expr,info,nt_operator);

  -- operátor (včetně příznaku přiřazení) 
  newexpr^.oper:=op;
  newexpr^.assign:=assignable and expr^.assign;

  -- třída uzlu 
  newexpr^.nclass:=nc_value;

  -- levý podvýraz 
  newexpr^.sub:=el;

  -- pravý podvýraz 
  x_addui(pexpimm(newexpr^.sub^.next),newexpr,ui,info);
  end x_addop;



----------------------------------------------------------------------------------------------------
procedure x_addsysstr =
-- Doplní univerzální řetězec. Třídu nastaví na NC_VALUE.                     
----------------------------------------------------------------------------------------------------
begin
  -- vznikl nový uzel 
  derivenode(pexpnode(newexpr),oldexpr,info,nt_imm);

  -- třída uzlu 
  newexpr^.nclass:=nc_value;

  -- uložit konstantu 
  store_sysstr(pexpimm(newexpr)^.imm,s);
  end x_addsysstr;



----------------------------------------------------------------------------------------------------
procedure x_changeop =
-- X expr^.oper ER --> X newop UI                                             
----------------------------------------------------------------------------------------------------
begin
  -- změnit operátor 
  expr^.oper:=newop;

  -- vznikl nový uzel 
  derivenode(pexpnode(er),er,info,nt_imm);

  -- převzal se typ původního pravého operandu, ale my chceme jiný
  er^.settype(curr,def_uniint);

  -- třída uzlu 
  er^.nclass:=nc_value;

  -- konstanta 
  store_ordinal(pexpimm(er)^.imm,ui);
  end x_changeop;



----------------------------------------------------------------------------------------------------
procedure x_rangetotype =
-- Z konstantního rozsahu udělá typ.
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

var
  a                : tuniint;                    -- meze
  b                : tuniint;                    -- meze
  el               : pexpimm;                    -- podvýrazy
  er               : pexpimm;                    -- podvýrazy

    ------------------------------------------------------------------------------------------------
    procedure new_ordinal_type (
        stype      : in tdatatype) =
    -- Vytvoří nový ordinální typ podle konstantního rozsahu
    ------------------------------------------------------------------------------------------------
    var
      ptyp_context : tcontext;                   -- kontext vzniklého typu
      ptyp_pos     : lexposblock;                -- virtuální pozice typu

    begin
      -- zjistit virtuální pozici typu
      expr^.getpos(ptyp_pos);

      -- vytvořit a zařadit typ
      d_create_implicit_type(curr,ptyp,ptyp_context,stype,ptyp_pos);

      -- doplnit meze typu
      ptyp^.lval:=a;
      ptyp^.hval:=b;

      -- a dopočítat zbývající parametry
      cpu^.getordparams2(ptyp^.stype,ptyp^.bits,ptyp^.size,ptyp^.lval,ptyp^.hval,native);

      -- dokončení deklarace
      d_end_implicit_type(ptyp^,ptyp_pos,false);
      end new_ordinal_type;

var
  ptyp_context     : tcontext;                   -- kontext vzniklého typu
  ptyp_pos         : lexposblock;                -- virtuální pozice typu

begin
  verify({VERIFY=}000067,not ((expr^.ntype=nt_range) and (expr^.sub^.ntype=nt_imm) and (expr^.sub^.next^.ntype=nt_imm)));

  -- podvýrazy 
  expr^.get(pexpnode(el),pexpnode(er));

  -- meze
  load_uniint(el^.imm,a);
  load_uniint(er^.imm,b);

  case expr^.t.stype
    -- univerzální celé číslo 
    when dt_uniint     do 
        if uniint_sign(a) or uniint_sign(b)
          then new_ordinal_type(dt_signed);
          else new_ordinal_type(dt_unsigned);
          end if;
      
    -- univerzální znak
    when dt_unichar    do new_ordinal_type(dt_char);

    -- univerzální logical
    when dt_unilogical do new_ordinal_type(dt_logical);
      
    -- diskrétní typ
    when dt_signed,dt_unsigned,dt_char,dt_logical,dt_enum do
        --unimplemented({UNIMP=}000234);

        -- vytvořit a zařadit typ
        d_create_implicit_type(curr,ptyp,ptyp_context,expr^.t.stype,ptyp_pos);

        -- specifikace
        ptyp^.size:=expr^.t.getsize;
        ptyp^.bits:=expr^.t.getbits;
        ptyp^.lval:=a;
        ptyp^.hval:=b;
        ptyp^.ancestor.setentity(expr^.t.getctype);

        -- dokončení deklarace
        d_end_implicit_type(ptyp^,ptyp_pos,false);

{ Poznámka: Tato procedura nesmí z konstantního rozsahu regulárního ordinálního typu odvodit
  nějakého potomka tohoto typu s range constraintem. To se řeší jinak, jinde a jindy.

    -- regulární ordinální typ
    when dt_signed,dt_unsigned,dt_char,dt_logical,dt_enum do
        unimplemented({UNIMP=}000235);
}
    when others do verify({VERIFY=}000066,true);
    end case;
  end x_rangetotype;



----------------------------------------------------------------------------------------------------
procedure x_uniarray =
-- Nastaví typ výrazu jako univerzální pole of BASE.
----------------------------------------------------------------------------------------------------
begin
  -- string
  expr^.newtype(curr,dt_uniarray,uds_0);

  -- of BASE
  {%%X a co vyhodnocení ? (pspecunistr(...)^.base.e:=ete_evaluated)}
  expr^.t.getutype^.base.settype(base);
  end x_uniarray;



----------------------------------------------------------------------------------------------------
procedure x_getconcatkind =
-- Způsob, jakým se zřetězuje zadaný výraz vzhledem k dodanému typu.          
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000370,not t_is_sts(typ,dts_u_index));

  if expr^.t.tview<>tview_full

    -- není k dispozici úplný pohled na typ => musí to být komponenta
    then concatkind:=nck_component

    -- je k dispozici pohled na typ => rozhodnout se podle datového typu
    else
      case expr^.t.stype
        -- řetězce
        when dt_string   do
            -- mají stejné báze ?
            if t_equal(typ.getbase(curr),expr^.t.getbase(curr))
              -- ano => pak je to podřetězce
              then concatkind:=nck_substring
              -- ne => musí to být komponenta
              else concatkind:=nck_component;
              end if;

        -- neomezený řetězec => musí to být podřetězce
        when dt_ustring  do concatkind:=nck_substring;

        -- pole
        when dt_array    do
            -- mají stejné báze ?
            if t_equal(typ.getbase(curr),expr^.t.getbase(curr))
              -- ano => pak je to podpole
              then concatkind:=nck_subarray
              -- ne => musí to být komponenta
              else concatkind:=nck_component;
              end if;

        -- neomezené pole => musí to být podpole
        when dt_uarray   do concatkind:=nck_subarray;

        -- univerzální pole
        when dt_uniarray do
            -- univerzální pole se přizpůsobuje typu výsledku
            -- (komponenta to být nemůže)
            if t_is_sts(typ,dts_string)
              -- pro string je to tedy podřetězec
              then concatkind:=nck_substring
              -- a pro pole je to podpole
              else concatkind:=nck_subarray;
              end if;

        -- ostatní typy => musí to být komponenta
        when others      do concatkind:=nck_component;
        end case;
      end if;
  end x_getconcatkind;



----------------------------------------------------------------------------------------------------
procedure x_classinstance =
-- Nalezne podvýraz určující instanci třídy.
----------------------------------------------------------------------------------------------------
var
  expr             : pexpnode;

begin
  expr:=_expr;
  while expr<>nil and expr^.nclass not in nodeclassset:[nc_var,nc_value,nc_type] loop expr:=expr^.sub; end loop;
  instance:=expr;
  end x_classinstance;



----------------------------------------------------------------------------------------------------
procedure x_get_deref_nclass =
-- Pro zadaný uzel zjistí třídu uzlu po dereferenci.
----------------------------------------------------------------------------------------------------
begin
  case expr^.nclass
    when nc_value do result:=nc_var;
    when nc_var   do result:=nc_var;
    when nc_type  do result:=nc_type;
    when others   do verify({VERIFY=}000111,true);
    end case;
  end x_get_deref_nclass;



----------------------------------------------------------------------------------------------------
procedure x_is_nil =
-- True, je-li zadaný výraz přímá hodnota NIL.
----------------------------------------------------------------------------------------------------
begin
  result:=(expr^.ntype=nt_imm) and imm_isnil(pexpimm(expr)^.imm);
  end x_is_nil;



----------------------------------------------------------------------------------------------------
procedure x_is_constant =
-- True, je-li zadaný výraz konstantní.                                       
----------------------------------------------------------------------------------------------------
begin
  result:=expr^.ntype=nt_imm;
  end x_is_constant;



----------------------------------------------------------------------------------------------------
procedure x_has_static_size =
-- True, má-li zadaný výraz statickou velikost.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(TAG) a co [rta_tag]? }
  result:=rtattribset:[rta_size,rta_last]*expr^.rta_used=rtattribset:[];
  verify({VERIFY=}000519,result and not expr^.t.hassize);
  end x_has_static_size;



----------------------------------------------------------------------------------------------------
procedure x_has_dynamic_size =
-- True, má-li zadaný výraz dynamickou velikost.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(TAG) a co [rta_tag]? }
  result:=rtattribset:[rta_size,rta_last]*expr^.rta_used<>rtattribset:[];
  end x_has_dynamic_size;



----------------------------------------------------------------------------------------------------
procedure x_swap =
-- Prohodí operandy.
----------------------------------------------------------------------------------------------------
var
  ex               : pexpnode;

begin
  ex:=el;
  el:=er;
  er:=ex;
  end x_swap;



----------------------------------------------------------------------------------------------------
procedure x_set_param_type =
-- Určí typ skutečného parametru podle formálního parametru.
----------------------------------------------------------------------------------------------------
begin
  case param^.pass
    when pp_unchecked do arg^.settypeunchecked(curr,param^.typ.getutype);
    when pp_class     do arg^.settype(curr,param^.typ.getctype);--unimplemented({UNIMP=}000236);
    when pp_virtual   do unimplemented({UNIMP=}000237);
    when others       do arg^.settype(curr,param^.typ.getctype);
    end case;
  end x_set_param_type;



----------------------------------------------------------------------------------------------------
procedure x_set_ref_type =
-- Vypočítá typ a třídu uzlu typu reference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  pclass           : ptrclass;                   -- třída pointeru
  pbase            : ptrbase;                    -- kompatibilita báze                          
  paccess          : varaccess;                  -- determinace přístupu

begin
  -- referencovaný podvýraz pro zjednodušení
  expr^.get(el);

  -- určit parametry typu
  case el^.nclass
    -- proměnná
    when nc_var  do
        -- určit kompatibilitu báze
        case el^.t.tview
          -- Unchecked view => unchecked
          when tview_unchecked  do
              pbase:=pb_unchecked;

          -- Partial view, Incomplete view, Full view => class nebo strict podle (ne)přítomnosti dynamického atributu :tag
          when tview_partial, tview_incomplete, tview_full do  
              if x_rta_is_available(el,rta_tag)
                then pbase:=pb_class
                else pbase:=pb_strict;
                end if;

          when others do verify({VERIFY=}000693,true);
          end case;

        -- třída pointeru
        pclass:=pc_data;

        -- vypočítat determinaci přístupu
        paccess:=va_norm;
      { Tohle zatím nefunguje.
        --%%X Na tohle udělat funkci ! 
        -- %%X Takhle jednoduché to snad nemůže být, ne ? Musí se to prohledávat do hloubky. 
        case el^.ntype
          when nt_component do
              verify({VERIFY=}000545,(pexpcomponent(el)^.s.psym=nil) or (pexpcomponent(el)^.s.psym^.ptype<>et_var));
              case pentity_var(pexpcomponent(el)^.s.psym)^.vaccess
                when va_norm      do paccess:=va_norm;
                when va_protected do unimplementedx({UNIMP=}000188,el^.pos);
                when va_const     do paccess:=va_const;
                when others do verify({VERIFY=}000544,true);
                end case;

          when nt_attrib do paccess:=va_norm;
          when nt_index  do {%%X !! prohledat do hloubky}paccess:=va_norm; end loop;
          when nt_deref  do paccess:=el^.sub^.t.getpaccess;
          when others do verify({VERIFY=}000546,true);
          end case;
      }

    -- procedura
    when nc_proc do
        -- kompatibilita báze
        pbase:=pb_strict;
        {if el^.t.tagged
          then pbase:=pb_class
          else pbase:=pb_strict;
          end if;}

        -- třída pointeru
        pclass:=pc_subprogram;

        -- determinace přístupu: vždy normální
        paccess:=va_norm;

    -- zpráva
    when nc_message     do
        -- kompatibilita báze
        pbase:=pb_strict;
        {if el^.t.tagged
          then pbase:=pb_class
          else pbase:=pb_strict;
          end if;}

        -- třída pointeru
        pclass:=pc_message;

        -- determinace přístupu: vždy normální
        paccess:=va_norm;

    when others do verify({VERIFY=}000692,true);
    end case;

  -- odvodit typ reference
  declare var
    ptyp           : pentity_type;               -- typ pointer                                 
    size           : tunidata_size;              -- velikost pointeru
    pattrib        : rtattribset{ptrattribset};  -- volitelné atributy pointeru    

  begin
    -- vypočítat dynamické atributy uložené v pointeru
    t_get_pointer_rtattrib(pbase,pclass,el^.t.getutype,pattrib);

    -- vypočítat velikost pointeru
    cpu^.getptrsize({pclass,pbase,false,}pattrib,size);

    -- založit nový typ
    expr^.newtype(curr,dt_pointer,size);
    ptyp:=expr^.t.getutype;
 
    -- nastavit základní parametry
    ptyp^.pclass:=pclass;
    ptyp^.pbase:=pbase;
    ptyp^.pattrib:=pattrib;
    ptyp^.paccess:=paccess;
    ptyp^.base.settype(el^.t.getutype);
    end declare;

  -- třída uzlu: hodnota
  expr^.nclass:=nc_value;
  end x_set_ref_type;



----------------------------------------------------------------------------------------------------
procedure x_negate_logical =
-- Neguje výraz.
----------------------------------------------------------------------------------------------------
with
  cx_expr.cx_compile;

var
  e                : tentityeval;                -- vyhodnocení podmínky (pro formu)
  info             : expinfo;                    -- informace o průběhu analýzy

begin
  -- POZN: takhle to není zrovna nejčistší... :-(
  -- negovat výraz
  if expr^.ntype=nt_unary and pexpunary(expr)^.oper=un_not
    then
      newexpr:=expr^.sub;
    else
      -- sestavit info (potřebuju pouze fázi analýzy)
      info.phase:=pred ep_opt;
      info.kind:=nil;
      info.typ:=nil;

      -- negovat
      x_addunary(newexpr,expr,un_not,false,expr,info);

      -- reoptimalizovat
      x_evaluate(curr,newexpr,ek_any,nil,eu_none,false,e);
      end if;
  end x_negate_logical;



end cx_util;
