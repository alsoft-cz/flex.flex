----------------------------------------------------------------------------------------------------
module public cc_entity =
-- Překladač Flexu.
-- Definice tabulky symbolů.
----------------------------------------------------------------------------------------------------
-- Ondra : 27.04.2000 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  standard.classes,
  standard.classes.lists,
  cc_def.cc_unitype;

use
  cc_def.cc_lexsym;

----------------------------------------------------------------------------------------------------
-- Dopředné deklarace
----------------------------------------------------------------------------------------------------

-- entity
type
  tentity;                   pentity                   = ^class tentity;
  tentity_code;              pentity_code              = ^class tentity_code;
  tentity_compile;           pentity_compile           = ^class tentity_compile;
  tentity_program;           pentity_program           = ^class tentity_program;
  tentity_module;            pentity_module            = ^class tentity_module;
  tentity_init;              pentity_init              = ^class tentity_init;
  tentity_value;             pentity_value             = ^class tentity_value;
  tentity_param;             pentity_param             = ^class tentity_param;
  tentity_var;               pentity_var               = ^class tentity_var;
  tentity_const;             pentity_const             = ^class tentity_const;
  tentity_enum;              pentity_enum              = ^class tentity_enum;
  tentity_type;              pentity_type              = ^class tentity_type;
  tentity_subprogram;        pentity_subprogram        = ^class tentity_subprogram;
  tentity_static_subprogram; pentity_static_subprogram = ^class tentity_static_subprogram;
  tentity_procedure;         pentity_procedure         = ^class tentity_procedure;
  tentity_static;            pentity_static            = ^class tentity_static;
  tentity_virtual;           pentity_virtual           = ^class tentity_virtual;
  tentity_override;          pentity_override          = ^class tentity_override;
  tentity_task;              pentity_task              = ^class tentity_task;
  tentity_special;           pentity_special           = ^class tentity_special;
  tentity_macro;             pentity_macro             = ^class tentity_macro;
  tentity_overload0;         pentity_overload0         = ^class tentity_overload0;
  tentity_overload;          pentity_overload          = ^class tentity_overload;
  tentity_operator;          pentity_operator          = ^class tentity_operator;
  tentity_attribute;         pentity_attribute         = ^class tentity_attribute;
  tentity_message;           pentity_message           = ^class tentity_message;
  tentity_label;             pentity_label             = ^class tentity_label;
--tentity_alias;             pentity_alias             = ^class tentity_alias;
  tentity_template;          pentity_template          = ^class tentity_template;
  tentity_tparam;            pentity_tparam            = ^class tentity_tparam;

-- deklarativní region
type
  tregion;                   pregion                   = ^tregion;

-- interfacy tříd
class c_class_interface; type p_class_interface = ^class c_class_interface;
class c_interface_list;  type p_interface_list  = ^class c_interface_list;

-- vektory typů
class c_type_vector;     type p_type_vector     = ^class c_type_vector;
class c_type_vector_set; type p_type_vector_set = ^class c_type_vector_set;



----------------------------------------------------------------------------------------------------
-- Interní tvar přímé hodnoty
----------------------------------------------------------------------------------------------------
type
  -- třída konstanty (přímé hodnoty)
  timmclass        = enum
      ic_undef;                                  -- nedefinováno
      ic_ordinal;                                -- ordinální hodnota (diskrétní typ)
      ic_real;                                   -- reálné číslo
      ic_nil;                                    -- nil
      ic_condensed;                              -- řetězec
      ic_array;                                  -- agregát pole
      ic_record;                                 -- agregát recordu
      ic_set;                                    -- agregát množiny
   -- ic_bin;                                    -- binární data
   -- ic_relo;                                   -- relokabilní symbol
      end enum;
  timmclassset     = set of timmclass;

var
{%OFF}
  -- třída konstanty (přímé hodnoty)
  timmclass_export_id : const array timmclass of t_char32str := [
      for ic_undef     use 'undef',
      for ic_ordinal   use 'ordinal',
      for ic_real      use 'real',
      for ic_nil       use 'nil',
      for ic_condensed use 'condensed',
      for ic_array     use 'array',
      for ic_record    use 'record',
      for ic_set       use 'set'];
{%ON}

type
  -- druh přímé hodnoty podle způsobu zadání
  timmentrykind     = enum
      iek_none;                                  -- syntetická hodnota, zadáno nepřímo
      iek_imm;                                   -- obecná přímá hodnota, typicky získaná kopií jiné přímé hodnoty
      iek_integer_literal;                       -- celočíselný literál
      iek_real_literal;                          -- reálný literál
      iek_character_literal;                     -- znakový literál
      iek_nil_literal;                           -- NIL
      iek_character_aggregate;                   -- znakový agregát
      iek_logical_metaliteral;                   -- logický metaliterál
      end enum;

var
{%OFF}
  -- popis [timmentrykind]
  timmentrykind_export_id : const array timmentrykind of t_char32str := [
      for iek_none                use 'none',
      for iek_imm                 use 'imm',
      for iek_integer_literal     use 'integer_literal',
      for iek_real_literal        use 'real_literal',
      for iek_character_literal   use 'character_literal',
      for iek_nil_literal         use 'nil_literal',
      for iek_character_aggregate use 'character_aggregate',
      for iek_logical_metaliteral use 'logical_metaliteral'];
{%ON}

#if #declared debug; #and then; debug then;{%OFF}
var
  timmclasstxt     : const array timmclass of t_char32str := [
      for ic_undef     use 'undef',
      for ic_ordinal   use 'ordinal',
      for ic_real      use 'real',
      for ic_nil       use 'NIL',
      for ic_condensed use 'condensed',
      for ic_array     use 'array',
      for ic_record    use 'record',
      for ic_set       use 'set'];
   -- for ic_bin       use 'bin',
   -- for ic_relo      use 'relo');
#end if;{%ON}

type
  -- dopředné deklarace;
  timm_array;      pimm_array       = ^timm_array;
  timm_record;     pimm_record      = ^timm_record;
  timm_set;        pimm_set         = ^timm_set;

  -- kondenzovaný tvar řetězce
  timm_condensed   = record
      len          : t_unsigned;                 -- počet prvků
      isize        : t_unsigned;                 -- velikost jednoho prvku
      items        : p_unsigned8array;           -- prvky
      end record;
  pimm_condensed   = ^timm_condensed;

  -- celá přímá hodnota
  timm_value       = record
      ic           : timmclass;                  -- třída konstanty
      ui           : tuniint;                    -- ordinální hodnota (diskrétní typ)
      ur           : tunireal;                   -- reálné číslo
      citems       : aliased timm_condensed;     -- složky kondenzovaného agregátu
      {%%X Proč CITEMS není pointer, když ostatní jsou ? }
      aitems       : pimm_array;                 -- složky pole
      ritems       : pimm_record;                -- složky recordu
      sitems       : pimm_set;                   -- složky množiny
      codegen      : p_flex_record;              -- data generátoru kódu
      end record;
  pimm_value       = ^timm_value;

  -- složky pole
  timm_array_item  = record
      lval         : tuniint;                    -- dolní mez
      hval         : tuniint;                    -- horní mez
      val          : aliased timm_value;         -- hodnota
      end record;
  timm_array_items = string of timm_array_item;
  timm_array       = record
      list         : ^timm_array_items;          -- hodnoty složek
      othersval    : aliased timm_value;         -- hodnota OTHERS
      end record;

  -- složky recordu
  timm_record_item = record
      item         : pentity_var;                -- související složka
      val          : aliased timm_value;         -- hodnota
      end record;
  timm_record_items= string of timm_record_item;
  timm_record      = record
      list         : ^timm_record_items;         -- hodnoty složek
      othersval    : aliased timm_value;         -- hodnota OTHERS
      end record;

  -- složky množiny
  timm_set_item    = record
      lval         : tuniint;                    -- dolní mez
      hval         : tuniint;                    -- horní mez
      end record;
  timm_set_items   = string of timm_set_item;
  timm_set         = record
      list         : ^timm_set_items;            -- hodnoty složek
      end record;

type
  -- operátory porovnání dvou přímých hodnot
  tcmpoper         = enum
      cmp_none;                                  -- nic
      cmp_eq;                                    -- =
      cmp_ne;                                    -- <>
      cmp_lt;                                    -- <
      cmp_le;                                    -- <=
      cmp_gt;                                    -- >
      cmp_ge;                                    -- >=
      end enum;
  tcmpoperset      = set of tcmpoper;


----------------------------------------------------------------------------------------------------
-- Přetížitelné operátory
----------------------------------------------------------------------------------------------------
type
  -- přetížítelný operátor
  tooperator       = enum
      oop_none;                                  -- nic
      oop_assign;                                -- :=
      oop_add;                                   -- + (binární i unární)
      oop_sub;                                   -- - (binární i unární)
      oop_mul;                                   -- *
      oop_div;                                   -- /
      oop_concat;                                -- &
      oop_idiv;                                  -- DIV
      oop_imod;                                  -- MOD
      oop_shl;                                   -- SHL
      oop_shr;                                   -- SHR
      oop_lt;                                    -- <
      oop_gt;                                    -- >
      oop_le;                                    -- <=
      oop_ge;                                    -- >=
      oop_eq;                                    -- =
      oop_ne;                                    -- <>
      oop_and;                                   -- AND
      oop_or;                                    -- OR
      oop_xor;                                   -- XOR
      oop_not;                                   -- NOT
      oop_succ;                                  -- SUCC
      oop_pred;                                  -- PRED
      oop_abs;                                   -- ABS
      oop_op1;                                   -- ::
      end enum;

var
{%OFF}
  -- přetížítelný operátor
  tooperator_export_id : const array tooperator of t_char32str := [
      for oop_none   use 'none',
      for oop_assign use 'assign',
      for oop_add    use 'add',
      for oop_sub    use 'sub',
      for oop_mul    use 'mul',
      for oop_div    use 'div',
      for oop_concat use 'concat',
      for oop_idiv   use 'idiv',
      for oop_imod   use 'imod',
      for oop_shl    use 'shl',
      for oop_shr    use 'shr',
      for oop_lt     use 'lt',
      for oop_gt     use 'gt',
      for oop_le     use 'le',
      for oop_ge     use 'ge',
      for oop_eq     use 'eq',
      for oop_ne     use 'ne',
      for oop_and    use 'and',
      for oop_or     use 'or',
      for oop_xor    use 'xor',
      for oop_not    use 'not',
      for oop_succ   use 'succ',
      for oop_pred   use 'pred',
      for oop_abs    use 'abs',
      for oop_op1    use 'op1'];
{%ON}

type
  -- arita přetížitelného operátoru
  tooperarity      = enum
      toa_unary;                                 -- unární
      toa_binary;                                -- binární
      end enum;
  tooperarityset = set of tooperarity;

var
{%OFF}
  -- arita přetížitelného operátoru
  tooperarity_export_id : const array tooperarity of t_char32str := [
      for toa_unary  use 'unary',
      for toa_binary use 'binary'];
{%ON}

type
  -- informace o operátoru
  tooperinfo       = record
      lex          : cc_lexsym.lexsym;           -- odpovídající lexikální symbol
      txt          : aliased tshortident;        -- textová reprezentace
      arity        : tooperarityset;             -- povolená arita operátoru
      end record;

var
  ooperinfo        : const array tooperator of tooperinfo := [
      -- %%TECH Textový tvar operátoru daného klíčovým slovem je záměrně
      -- malými písmeny - aby bylo v browseru na první pohled vidět, že to je
      -- operátor a ne identifikátor nějaké jiné entity.
      for oop_none     use [for lex use cc_lexsym.lex_nul   , for txt use ''    , for arity use tooperarityset:[                    ]],
      for oop_assign   use [for lex use cc_lexsym.lex_assign, for txt use ':='  , for arity use tooperarityset:[          toa_binary]],
      for oop_add      use [for lex use cc_lexsym.lex_add   , for txt use '+'   , for arity use tooperarityset:[toa_unary,toa_binary]],
      for oop_sub      use [for lex use cc_lexsym.lex_sub   , for txt use '-'   , for arity use tooperarityset:[toa_unary,toa_binary]],
      for oop_mul      use [for lex use cc_lexsym.lex_mul   , for txt use '*'   , for arity use tooperarityset:[          toa_binary]],
      for oop_div      use [for lex use cc_lexsym.lex_div   , for txt use '/'   , for arity use tooperarityset:[          toa_binary]],
      for oop_concat   use [for lex use cc_lexsym.lex_concat, for txt use '&'   , for arity use tooperarityset:[          toa_binary]],
      for oop_idiv     use [for lex use cc_lexsym.lex_idiv  , for txt use 'div' , for arity use tooperarityset:[          toa_binary]],
      for oop_imod     use [for lex use cc_lexsym.lex_imod  , for txt use 'mod' , for arity use tooperarityset:[          toa_binary]],
      for oop_shl      use [for lex use cc_lexsym.lex_shl   , for txt use 'shl' , for arity use tooperarityset:[          toa_binary]],
      for oop_shr      use [for lex use cc_lexsym.lex_shr   , for txt use 'shr' , for arity use tooperarityset:[          toa_binary]],
      for oop_lt       use [for lex use cc_lexsym.lex_lt    , for txt use '<'   , for arity use tooperarityset:[          toa_binary]],
      for oop_gt       use [for lex use cc_lexsym.lex_gt    , for txt use '>'   , for arity use tooperarityset:[          toa_binary]],
      for oop_le       use [for lex use cc_lexsym.lex_le    , for txt use '<='  , for arity use tooperarityset:[          toa_binary]],
      for oop_ge       use [for lex use cc_lexsym.lex_ge    , for txt use '>='  , for arity use tooperarityset:[          toa_binary]],
      for oop_eq       use [for lex use cc_lexsym.lex_eq    , for txt use '='   , for arity use tooperarityset:[          toa_binary]],
      for oop_ne       use [for lex use cc_lexsym.lex_ne    , for txt use '<>'  , for arity use tooperarityset:[          toa_binary]],
      for oop_and      use [for lex use cc_lexsym.lex_and   , for txt use 'and' , for arity use tooperarityset:[          toa_binary]],
      for oop_or       use [for lex use cc_lexsym.lex_or    , for txt use 'or'  , for arity use tooperarityset:[          toa_binary]],
      for oop_xor      use [for lex use cc_lexsym.lex_xor   , for txt use 'xor' , for arity use tooperarityset:[          toa_binary]],
      for oop_not      use [for lex use cc_lexsym.lex_not   , for txt use 'not' , for arity use tooperarityset:[toa_unary           ]],
      for oop_succ     use [for lex use cc_lexsym.lex_succ  , for txt use 'succ', for arity use tooperarityset:[toa_unary           ]],
      for oop_pred     use [for lex use cc_lexsym.lex_pred  , for txt use 'pred', for arity use tooperarityset:[toa_unary           ]],
      for oop_abs      use [for lex use cc_lexsym.lex_abs   , for txt use 'abs' , for arity use tooperarityset:[toa_unary           ]],
      for oop_op1      use [for lex use cc_lexsym.lex_op1   , for txt use '::'  , for arity use tooperarityset:[          toa_binary]]];


----------------------------------------------------------------------------------------------------
-- Identifikátory předdefinovaných a interních entity
----------------------------------------------------------------------------------------------------
var
  -- identifikátory předdefinovaných objektů 
  id_flex          : const aliased tshortident := 'FLEX';        -- jazykem definovaná run-time knihovna        
  id_result        : const aliased tshortident := 'RESULT';      -- identifikátor návratové hodnoty funkce      

  -- interní identifikátory 
  id_int_tag       : const aliased tshortident := '@TAG';        -- identifikátor interní složky třídy @TAG     
  id_int_status    : const aliased tshortident := '@STATUS';     -- identifikátor interní složky třídy @STATUS  
  id_compilation   : const aliased tshortident := '@COMPILATION';-- identifikátor kompilační jednotky       
  id_init          : const aliased tshortident := '@INIT';
  id_entry         : const aliased tshortident := '@ENTRY';
  id_exit          : const aliased tshortident := '@EXIT';
  id_adjust        : const aliased tshortident := '@ADJUST';
  id_rollback      : const aliased tshortident := '@ROLLBACK';
  id_commit        : const aliased tshortident := '@COMMIT';
  id_int_temp      : const aliased tshortident := '^TEMP_';      -- prefix identifikátoru kompilátrem gen. sym.
  id_int_param     : const aliased tshortident := '@PARAM';      -- parametr interní metody typu (viz CA_TYPE)
  id_int_low       : const aliased tshortident := '@LOW';        -- dolní mez
  id_int_high      : const aliased tshortident := '@HIGH';       -- horní mez
  id_int_forvar    : const aliased tshortident := '@I';          -- řídící proměnná cyklu

const
  id_init_lex      = '@INIT';                    -- identifikátor metody init
  id_entry_lex     = 'ENTRY';                    -- identifikátor metody entry bez @            
  id_exit_lex      = 'EXIT';                     -- identifikátor metody exit bez @             
  id_adjust_lex    = 'ADJUST';                   -- identifikátor metody adjust bez @           
  id_rollback_lex  = 'ROLLBACK';                 -- identifikátor metody rollback bez @
  id_commit_lex    = 'COMMIT';                   -- identifikátor metody commit bez @



----------------------------------------------------------------------------------------------------
-- Společné vlastnosti entit
----------------------------------------------------------------------------------------------------
type
  -- viditelnost symbolu
  tentityvisible   = enum
      etv_public;                                -- viditelný obecně
      etv_protected;                             -- viditelný pouze potomkům
      etv_supervised;                            -- viditelný pouze supervisorům
      etv_private;                               -- viditelný pouze uvnitř deklarace
      end enum;
  tentityvisibleset= set of tentityvisible;

var
  -- viditelnost symbolu
{%OFF}
  tentityvisible_export_id : const array tentityvisible of t_char32str := [
      for etv_public     use 'public',
      for etv_protected  use 'protected',
      for etv_supervised use 'supervised',
      for etv_private    use 'private'];
{%ON}

const
  -- všechny úrovně
  etvs_all         = tentityvisibleset:full;

type
  -- průběh překladu deklarace
  tentitydeclared  = enum
      etd_none;                                  -- dosud nepřeložena žádná část deklarace
      etd_incomplete;                            -- Incomplete declaration
      etd_public;                                -- Public body declaration
      etd_full;                                  -- Full declaration
      end enum;

var
  -- průběh překladu deklarace
{%OFF}
  tentitydeclared_export_id : const array tentitydeclared of t_char32str := [
      for etd_none       use 'none',
      for etd_incomplete use 'incomplete',
      for etd_public     use 'public',
      for etd_full       use 'full'];
{%ON}

type
  -- vyhodnocení symbolu
  tentityeval      = enum
      ete_none;                                  -- dosud netestováno
   -- ete_generic;                               -- symbol je genericky závislý
      ete_evaluated;                             -- symbol je plně vyhodnocen
      ete_unevaluated;                           -- symbol se nepovedlo vyhodnotit a nemá cenu
                                                 -- to zkoušet znova
      end enum;
  tentityevalset   = set of tentityeval;

var
  -- vyhodnocení symbolu
{%OFF}
  tentityeval_export_id : const array tentityeval of t_char32str := [
      for ete_none        use 'none',
      for ete_evaluated   use 'evaluated',
      for ete_unevaluated use 'unevaluated'];
{%ON}

type
  -- režim překladu symbolu
  tentitycompile   = enum
   -- etc_internal;                              -- interní symbol vyplývající ze sémantiky
      etc_generated;                             -- symbol generovaný kompilátorem
      -- dočasné modifikátory
      etc_compiling;                             -- symbol je překládán
      etc_evaluating;                            -- symbol je vyhodnocován
      -- permanentní modifikátory
   -- etc_generic;                               -- generická deklarace (tato nebo nadřazená)
      etc_macro;                                 -- makro deklarace (tato nebo nadřazená)
      end enum;
  tentitycompileset= set of tentitycompile;

var
  -- režim překladu symbolu
{%OFF}
  tentitycompile_export_id : const array tentitycompile of t_char32str := [
      for etc_generated  use 'generated',
      for etc_compiling  use 'compiling',
      for etc_evaluating use 'evaluating',
      for etc_macro      use 'macro'];
{%ON}


const
  -- maska permanentních modifikátorů
  etcs_modemask    = tentitycompileset:[{etc_generic,}etc_macro];

type
  -- pozice entity
  tentityposition  = enum
      etp_header;                                -- hlavička (dopředná deklarace)
      etp_spec;                                  -- specifikace
      etp_def;                                   -- definice
      end enum;
  tentitypositions = array tentityposition of cc_def.cc_lexsym.lexposblock;

type
  -- paměťová třída proměnné
  memclass         = enum
      mc_static;                                 -- statická proměnná na datasegmentu
      mc_auto;                                   -- automatická proměnná na stacku
      mc_task;                                   -- statická proměnná tasku
      mc_class;                                  -- složka třídy
      mc_record;                                 -- složka recordu
      end enum;
  memclassset      = set of memclass;

var
  memclasstxt      : const array memclass of t_char32str := [
      for mc_static    use 'static',
      for mc_auto      use 'automatic',
      for mc_task      use 'task',
      for mc_class     use 'class',
      for mc_record    use 'record'];

const
  -- "lokální" proměnné
  mcs_local        = memclassset:[mc_auto];
  -- "statické" proměnné
  mcs_static       = memclassset:[mc_static,mc_task];
  -- "class" proměnné
  mcs_class        = memclassset:[mc_class];
  -- "globální" proměnné
  mcs_global       = mcs_static+mcs_class;
  -- složky strukturovaných objektů
  mcs_offset       = memclassset:[mc_class,mc_record];

type
  -- příznak, zda je možné získat adresu proměnné (ALIASED)
  t_mem_aliased    = protected t_logical;

type
  -- typ speciální metody
  tspectype        = enum
      -- %%TECH neměnit pořadí těchto složek, kompilátor podle nich generuje
      -- virtuální tabulky.
      tst_init     for ord use 0;                -- statická inicializace
      tst_entry    for ord use 1;                -- entry (konstruktor)
      tst_exit     for ord use 2;                -- return (destruktor)
      tst_adjust   for ord use 3;                -- adjust (kopírování)
      tst_rollback for ord use 4;                -- rollback (zrušení transakce)
      tst_commit   for ord use 5;                -- commit (potvrzení transakce)
      end enum;
  tspectypeset     = set of tspectype;

var
  -- konverze [tspectype] na řetězec
{%OFF}
  tspectype_export_id : const array tspectype of t_char32str := [
      for tst_init     use 'init',
      for tst_entry    use 'entry',
      for tst_exit     use 'exit',
      for tst_adjust   use 'adjust',
      for tst_rollback use 'rollback',
      for tst_commit   use 'commit'];
{%ON}

type
  -- stav sestavení symbolu
  linkstatus       = enum
      ls_undef;                                  -- dosud není známo
      ls_used;                                   -- symbol byl použit
    --ls_resolved;                               -- jsou vyhodnoceny relokabilní odkazy
      ls_linked;                                 -- je sestaveno
      end enum;

var
  -- stav sestavení symbolu
{%OFF}
  linkstatus_export_id : const array linkstatus of t_char32str := [
      for ls_undef  use 'undef',
      for ls_used   use 'used',
      for ls_linked use 'linked'];
{%ON}

type
  -- stav globální analýzy 
  analyzestatus    = enum
      as_none;                                   -- nic                                         
      as_analyzing;                              -- právě probíhá                               
      as_analyzed;                               -- analyzováno                                 
      end enum;

var
  -- stav globální analýzy 
{%OFF}
  analyzestatus_export_id : const array analyzestatus of t_char32str := [
      for as_none      use 'none',
      for as_analyzing use 'analyzing',
      for as_analyzed  use 'analyzed'];
{%ON}

----------------------------------------------------------------------------------------------------
procedure __get_type_expr (ptyp : in pentity_type) return p_flex_construct;
-- Pomocná metoda pro [cc_ref.reftype.settype] pro kontrolu konzistence. Nepoužívat.
----------------------------------------------------------------------------------------------------
#separate public cc_ref;
#separate private cc_ref;
-- Odkazy na entity a další elementy
----------------------------------------------------------------------------------------------------
#separate public cc_list;
#separate private cc_list;
-- Seznamy entit a přímých hodnot.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
-- Deklarativní regiony
----------------------------------------------------------------------------------------------------
type
  -- typ regionu
  tregiontype      = enum
      rt_primary;                                -- primární region
      rt_component;                              -- komponentový region
      rt_enumeration;                            -- výčtový region
      rt_attribute;                              -- atributový region
      rt_meta;                                   -- metaregion (#template)
      end enum;

var
  -- typ regionu
{%OFF}
  tregiontype_export_id : const array tregiontype of t_char32str := [
      for rt_primary use 'primary',
      for rt_component use 'component',
      for rt_enumeration use 'enumeration',
      for rt_attribute use 'attribute',
      for rt_meta use 'meta'];
{%ON}

type
  -- kategorie regionu
  tregioncategory  = enum
      rc_primary;
      rc_attribute;
      rc_meta;
      end enum;

  -- primární regiony
  tprimaryregiontype = tregiontype range rt_primary..rt_enumeration;

  -- seznam deklarativních regionů
  tregionlist      = t_flex_record with record
      first        : pregion;                    -- první region
      last         : pregion;                    -- poslední region
      end record;

  -- seznam entit
  tentitylist      = t_flex_record with record
      first        : pentity;                    -- první entita
      last         : pentity;                    -- poslední entita
      end record;

  -- tabulka identifikátorů
  tidnode;
  pidnode          = ^tidnode;
  tidnode          = t_flex_record with record
      left         : pidnode;                    -- levý podstrom (left^.id <= id)
      right        : pidnode;                    -- pravý podstrom (right^.id > id)
      id           : pentityident;               -- identifikátor entity
      entity       : pentity;                    -- související entita
      -- interní údaje
      vaha         : t_signed;                   -- vyváženost (výška(levý)-výška(pravý))
    --hash         : t_unsigned32;               -- hash kód
      end record;

  -- kontext deklarace
  tcontext         = record                      -- kontext deklarace
      entity       : pentity;                    -- entita, ve které je tato entita deklarována
      region       : pregion;                    -- deklarativní region, ve kterém je entita deklarována
      end record;

type
  ---- tabulka použitých modulů ---
 
  -- režim vazby
  t_with_mode      = enum
      twm_use;                                   -- USE
      twm_with;                                  -- WITH
      end enum;
  t_with_mode_set  = set of t_with_mode;

var
  -- režim vazby
  t_with_mode_export_id : const array t_with_mode of t_char32str := [
      for twm_use use 'use',
      for twm_with use 'with'];

type
  -- úroveň vazby
  t_with_level     = enum
      twl_none;                                  -- vazba není definována, pouze pro [sym_is_used]
      twl_normal;                                -- normální, zpřístupňuje public složky
      twl_supervised;                            -- supervizor, zpřístupňuje public, protected a supervised složky
      end enum;
var
  -- úroveň vazby
  t_with_level_export_id : const array t_with_level of t_char32str := [
      for twl_none use 'none',
      for twl_normal use 'normal',
      for twl_supervised use 'supervised'];

type
  -- tabulka použitých modulů
  twithtable       = ^string of record
      mode         : t_with_mode;                -- režim vazby
      entity       : cc_ref.refentity;           -- symbol
      stat_usage   : t_unsigned;                 -- pocet uziti
      lexpos       : cc_def.cc_lexsym.lexposblock;-- pozice ve zdrojaku
      level        : t_with_level;               -- úroveň vazby
      automatic    : t_logical;                  -- automaticky WITH/USE?
      end record;

var
  -- tabulka pro konverzi úrovně vazby na viditelnost
  with_level_to_visibility : const array t_with_level of tentityvisibleset := [
      for twl_normal     use [etv_public],
      for twl_supervised use [etv_public,etv_protected,etv_supervised]];

type
  -- deklarativní region
  tregion          = t_flex_record with record
      rtype        : tregiontype;                -- typ deklarativního regionu
      regions      : tregionlist;                -- seznam podřízených (vnořených) deklarativních regionů
      entities     : tentitylist;                -- seznam entit deklarovaných v tomto regionu
      idtable      : pidnode;                    -- tabulka identifikátorů
      withtable    : twithtable;                 -- tabulka použitých modulů                    
      vsect        : tentityvisible;             -- implicitní viditelnost vnořených prvků
      context      : tcontext;                   -- kontext: entita a region, do kterých patří tento region
      prev         : pregion;                    -- předchozí region
      next         : pregion;                    -- následující region
      end record;

  -- top-level deklarativní regiony
  ttoplevelregions = array tregioncategory of pregion;



----------------------------------------------------------------------------------------------------
-- Typy entit
----------------------------------------------------------------------------------------------------
type
  -- typ prvku
  tentitytype      = enum
      et_undef;        -- není definováno
      et_compile;      -- kompilační jednotka
      et_program;      -- program
      et_module;       -- modul
      et_special;      -- speciální metoda
      et_procedure;    -- procedura
      et_static;       -- statická metoda
      et_virtual;      -- virtuální metoda
      et_task;         -- task
      et_override;     -- přetížení virtuální procedury
      et_macro;        -- makro
      et_overload;     -- přetížení
      et_operator;     -- operátor
      et_var;          -- proměnná
      et_type;         -- typ
      et_class;        -- třída
      et_const;        -- konstanta
      et_enum;         -- prvek výčtového typu
      et_param;        -- formální parametr
      et_message;      -- zpráva
      et_label;        -- návěští
      et_template;     -- #template;
      et_tparam;       -- parametr #template
      et_attribute;    -- atribut
      end enum;
  tentitytypeset   = set of tentitytype;

var
  -- typ prvku
{%OFF}
  tentitytype_export_id : const array tentitytype of t_char32str := [
      for et_undef     use 'undef',
      for et_compile   use 'compile',
      for et_program   use 'program',
      for et_module    use 'module',
      for et_special   use 'special',
      for et_procedure use 'procedure',
      for et_static    use 'static',
      for et_virtual   use 'virtual',
      for et_task      use 'task',
      for et_override  use 'override',
      for et_macro     use 'macro',
      for et_overload  use 'overload',
      for et_operator  use 'operator',
      for et_var       use 'var',
      for et_type      use 'type',
      for et_class     use 'class',
      for et_const     use 'const',
      for et_enum      use 'enum',
      for et_param     use 'param',
      for et_message   use 'message',
      for et_label     use 'label',
      for et_template  use 'template',
      for et_tparam    use 'tparam',
      for et_attribute use 'attribute'];
{%ON}

const
  -- prvky obsahující prvky obsahující kód
  ets_enclosed     = tentitytypeset:[et_program,et_module,et_class,et_special,et_procedure,
                     et_static,et_virtual,et_task,et_override];
  -- podprogramy
  ets_subprogram   = tentitytypeset:[et_special,et_procedure,et_static,et_virtual,et_task,
                     et_override];
  -- statické podprogramy
  ets_static_subprogram = tentitytypeset:[et_procedure,et_static];
  -- podprogramy volatelné standardním způdobem
  ets_callable     = tentitytypeset:[et_special,et_procedure,et_static,et_virtual];
  -- typy
  ets_type         = tentitytypeset:[et_type,et_class];
  -- prvky obsahující příkazovou část
  ets_body         = ets_subprogram + tentitytypeset:[et_program];
  -- prvky obsahující kod
  ets_code         = ets_body + tentitytypeset:[et_compile];
  -- modulární entity
  ets_modular      = tentitytypeset:[et_module,et_class];
  -- prvky definující vlastnosti vnořených deklarací
  ets_container    = tentitytypeset:[et_module,et_program,et_compile,et_class];
  -- prvky obalující deklarace
  ets_enclosing    = ets_container + ets_subprogram;
  -- prvky s run-time atributy (jen odvozené od TENTITY_VALUE)
  ets_rtattrib     = tentitytypeset:[et_var];

type
  -- popis typu entity
  tentitydesc      = record
      name         : t_char32str;                -- popisné jméno typi entity
      id           : t_char32str;                -- identifikátor typu entity
      region       : tprimaryregiontype;         -- typ primárního regionu
      end record;

var
  entitydesc       : const array tentitytype of tentitydesc := [
      for et_undef     use [for name use '<?>',                for id use '*undef'   , for region use rt_primary    ],
      for et_compile   use [for name use 'Compilation unit',   for id use 'compile'  , for region use rt_primary    ],
      for et_program   use [for name use 'Program',            for id use 'program'  , for region use rt_primary    ],
      for et_module    use [for name use 'Module',             for id use 'module'   , for region use rt_primary    ],
      for et_special   use [for name use 'Special method',     for id use 'special'  , for region use rt_primary    ],
      for et_procedure use [for name use 'Procedure',          for id use 'procedure', for region use rt_primary    ],
      for et_static    use [for name use 'Static method',      for id use 'static'   , for region use rt_primary    ],
      for et_virtual   use [for name use 'Virtual method',     for id use 'virtual'  , for region use rt_primary    ],
      for et_task      use [for name use 'Task',               for id use 'task'     , for region use rt_primary    ],
      for et_override  use [for name use 'Override',           for id use 'override' , for region use rt_primary    ],
      for et_macro     use [for name use 'Macro',              for id use 'macro'    , for region use rt_primary    ],
      for et_overload  use [for name use 'Overload',           for id use 'overload' , for region use rt_primary    ],
      for et_operator  use [for name use 'Operator',           for id use 'operator' , for region use rt_primary    ],
      for et_var       use [for name use 'Variable',           for id use 'var'      , for region use rt_primary    ],
      for et_type      use [for name use 'Type',               for id use 'type'     , for region use rt_component  ],
      for et_class     use [for name use 'Class',              for id use 'class'    , for region use rt_primary    ],
      for et_const     use [for name use 'Constant',           for id use 'const'    , for region use rt_primary    ],
      for et_enum      use [for name use 'Enumeration item',   for id use 'enum'     , for region use rt_enumeration],
      for et_param     use [for name use 'Parameter',          for id use 'param'    , for region use rt_primary    ],
      for et_message   use [for name use 'Message',            for id use 'message'  , for region use rt_component  ],
      for et_label     use [for name use 'Label',              for id use 'label'    , for region use rt_primary    ],
      for et_template  use [for name use 'Template',           for id use '#template', for region use rt_component  ],
      for et_tparam    use [for name use 'Template parameter', for id use 'tparam'   , for region use rt_primary    ],
      for et_attribute use [for name use 'Attribute',          for id use 'attribute', for region use rt_primary    ]];
{%ON}



----------------------------------------------------------------------------------------------------
-- Datové typy
----------------------------------------------------------------------------------------------------
type
  -- datové typy
  tdatatype        = enum
      -- pseudotypy
      dt_undef;        -- neznámý typ
      -- univerzální typy
      dt_uniint;       -- univerzální celé číslo
      dt_unireal;      -- univerzální reálné číslo
      dt_unilogical;   -- univerzální logical
      dt_unichar;      -- univerzální znak
      dt_uniarray;     -- univerzální pole
      dt_uninil;       -- univerzální NIL
      -- regulární typy
      dt_ordinal;      -- generický ordinální typ
      dt_signed;       -- typ celé číslo se znaménkem
      dt_unsigned;     -- typ celé číslo bez znaménka
      dt_float;        -- typ floating-point číslo
      dt_fixed;        -- typ fixed-point číslo
      dt_char;         -- typ znak
      dt_logical;      -- typ logical
      dt_enum;         -- typ výčet
      dt_string;       -- typ řetězec
      dt_ustring;      -- typ neomezený řetězec
      dt_array;        -- typ pole
      dt_uarray;       -- typ neomezené pole
      dt_record;       -- typ záznam
      dt_class;        -- typ třída
      dt_set;          -- typ množina
      dt_pointer;      -- typ pointer
      dt_tag;          -- typ tag
      -- singulární typy
      dt_message;      -- typ zpráva
      dt_procedure;    -- typ podprogram
      dt_task;         -- typ task
      end enum;
  tdatatypeset     = set of tdatatype;

const
  -- všechny typy
  dts_all            = tdatatypeset:full;
  -- speciální hodnoty
  dts_special        = tdatatypeset:[dt_undef];
  -- univerzální typy
  dts_unitype        = tdatatypeset:[dt_uniint,dt_unireal,dt_unilogical,dt_unichar,dt_uniarray,dt_uninil];
  -- interní typy
  dts_internal       = dts_special + dts_unitype;
  -- singulární typy
  dts_singular       = tdatatypeset:[dt_message,dt_procedure,dt_task];
  -- regulární typy
  dts_regular        = dts_all-dts_internal-dts_singular;
  -- unconstrained typy
  dts_unconstrained  = tdatatypeset:[dt_ustring,dt_uarray];
  -- constrained typy
  dts_constrained    = dts_regular - dts_unconstrained;
  -- ordinální typy
  dts_ordinal        = tdatatypeset:[dt_ordinal,dt_signed,dt_unsigned,dt_logical,dt_char,dt_enum];
  dts_u_ordinal      = dts_ordinal + tdatatypeset:[dt_uniint,dt_unilogical,dt_unichar];
  -- znakové typy
  dts_char           = tdatatypeset:[dt_char];
  dts_u_char         = dts_char + tdatatypeset:[dt_unichar];
  -- celočíselné typy
  dts_integer        = tdatatypeset:[dt_signed,dt_unsigned];
  dts_u_integer      = dts_integer + tdatatypeset:[dt_uniint];
  -- logické typy
  dts_logical        = tdatatypeset:[dt_logical];
  dts_u_logical      = dts_logical + tdatatypeset:[dt_unilogical];
  -- výčtové typy
  dts_enum           = tdatatypeset:[dt_enum];
  dts_u_enum         = dts_enum;
  -- floating-point typy
  dts_float          = tdatatypeset:[dt_float];
  dts_u_float        = dts_float + tdatatypeset:[dt_unireal];
  -- fixed-point typy
  dts_fixed          = tdatatypeset:[dt_fixed];
  dts_u_fixed        = dts_fixed + tdatatypeset:[dt_unireal];
  -- číselné typy
  dts_numeric        = dts_integer + dts_float;
  dts_u_numeric      = dts_u_integer + dts_u_float;
  -- typy s bázovým typem
  dts_base           = tdatatypeset:[dt_string,dt_ustring,dt_array,dt_uarray,dt_pointer,dt_set];
  dts_u_base         = dts_base + tdatatypeset:[dt_uniarray];
  -- množinové typy
  dts_set            = tdatatypeset:[dt_set];
  dts_u_set          = dts_set;
  -- řetězcové typy
  dts_string         = tdatatypeset:[dt_string,dt_ustring];
  dts_u_string       = dts_string + tdatatypeset:[dt_uniarray];
  -- pole
  dts_array          = tdatatypeset:[dt_array,dt_uarray];
  dts_u_array        = dts_array + tdatatypeset:[dt_uniarray];
  -- typy s indexovanými komponentami
  dts_index          = dts_string + dts_array;
  dts_u_index        = dts_u_string + dts_u_array;
  -- neindexované regulární typy
  dts_unindexed      = dts_regular-dts_index;
  dts_u_unindexed    = dts_unindexed + dts_unitype - tdatatypeset:[dt_uniarray];
  -- agregátní
  dts_aggregate      = dts_array + dts_string + tdatatypeset:[dt_record,dt_set];
  -- třídy
  dts_class          = tdatatypeset:[dt_class];
  -- kompozitní typy
  dts_composite      = dts_aggregate + dts_class;
  -- strukturované typy
  dts_structured     = dts_class + tdatatypeset:[dt_record];
  -- typy s komponentami
  dts_component      = dts_array + dts_string + dts_structured;
  -- pointery
  dts_pointer        = tdatatypeset:[dt_pointer];
  dts_u_pointer      = dts_pointer;
  -- zprávy
  dts_message        = tdatatypeset:[dt_message];
  dts_u_message      = dts_message;
  -- tagy
  dts_tag            = tdatatypeset:[dt_tag];
  dts_u_tag          = dts_tag;

var
  -- datove typy
  tdatatypename    : const array tdatatype of t_char32str := [
      for dt_undef      use '<neznámý>',
      for dt_uniint     use 'Universal integer',     
      for dt_unireal    use 'Universal real',
      for dt_unilogical use 'Universal logical',
      for dt_unichar    use 'Universal character',
      for dt_uniarray   use 'Universal array',
      for dt_uninil     use 'Universal NIL',
      for dt_ordinal    use 'Integer',   
      for dt_signed     use 'Signed integer',
      for dt_unsigned   use 'Unsigned integer',
      for dt_float      use 'Float',
      for dt_fixed      use 'Fixed',
      for dt_char       use 'Character',
      for dt_logical    use 'Logical',
      for dt_string     use 'String',
      for dt_ustring    use 'Unconstrained string',
      for dt_array      use 'Array',
      for dt_uarray     use 'Unconstrained array',
      for dt_record     use 'Record',
      for dt_class      use 'Class',
      for dt_enum       use 'Enumeration',
      for dt_set        use 'Set',
      for dt_pointer    use 'Pointer',
      for dt_tag        use 'Tag',
      for dt_message    use 'Message',
      for dt_procedure  use 'Subprogram',
      for dt_task       use 'Task'];

{%OFF}
var
  -- datove typy
  tdatatypetxt     : const array tdatatype of t_char32str := [
      for dt_undef      use '*undef',
      for dt_uniint     use 'uniint',
      for dt_unireal    use 'unireal',
      for dt_unilogical use 'unilogical',
      for dt_unichar    use 'unichar',
      for dt_uniarray   use 'uniarray',
      for dt_uninil     use 'uninil',
      for dt_ordinal    use 'ordinal',
      for dt_signed     use 'signed',
      for dt_unsigned   use 'unsigned',
      for dt_float      use 'float',
      for dt_fixed      use 'fixed',
      for dt_char       use 'char',
      for dt_logical    use 'logical',
      for dt_string     use 'string',
      for dt_ustring    use 'ustring',
      for dt_array      use 'array',
      for dt_uarray     use 'uarray',
      for dt_record     use 'record',
      for dt_class      use 'class',
      for dt_enum       use 'enum',
      for dt_set        use 'set',
      for dt_pointer    use 'pointer',
      for dt_tag        use 'tag',
      for dt_message    use 'message',
      for dt_procedure  use 'procedure',
      for dt_task       use 'task'];
{%ON}



----------------------------------------------------------------------------------------------------
-- Entita
----------------------------------------------------------------------------------------------------
type
  -- cache příznaku volání speciálních metod pro nějaké proměnné určité paměťové třídy
  t_var_cache      = array tspectype of memclassset;

  -- entita
  tentity          = {%%TODO(ABSTRACT)} t_flex_record with record
      ---- základní vlastnosti entity ----
      etype        : tentitytype;                -- typ entity
      id           : pentityident;               -- identifikátor entity
      ---- kontext -----
      prev         : pentity;                    -- předchozí entita
      next         : pentity;                    -- následující entita
      regions      : ttoplevelregions;           -- seznam regionů
      context      : tcontext;                   -- kontext: entita a region, do kterých patří tato entita
      ancestor     : cc_ref.refentity;           -- předek
      ---- příznaky entity a stavové proměnné ----
      visible      : tentityvisible;             -- viditelnost prvku
      full         : tentityvisible;             -- viditelnost úplné deklarace
      declared     : tentitydeclared;            -- průběh překladu deklarace
      evaluated    : tentitydeclared;            -- vyhodnocené části deklarace
      compiling    : tentitydeclared;            -- překládaná část deklarace
      eval         : tentityeval{set};           -- vyhodnocení symbolu
      compile      : tentitycompileset;          -- režim překladu
      pos          : tentitypositions;           -- pozice symbolu
      compv        : tcompvar;                   -- parametry překladu
      is_abstract  : t_logical;                  -- entita je abstraktní (má smysl jen pro některé typy entit)
      ---- informace přidané globální analýzou ----
      analyzed     : analyzestatus;              -- stav globální analýzy
      loc_var_cache: t_var_cache;                -- lokální příznak volání spec. metod pro proměnné
      tra_var_cache: t_var_cache;                -- tranzitivní příznak volání spec. metod pro prom.
      ---- generování kódu ----
      codegen      : p_flex_record;              -- přídavné informace pro generátor kódu
      -- debug informace ---
      debuginfo    : p_flex_record;              -- pointer na debug informace pro tento symbol
      ---- linkování ----
      linked       : linkstatus;                 -- stav slinkování entity
      debugstat    : analyzestatus;              -- stav generování debug informace
      ---- statistiky ---- 
      stat_usage   : t_unsigned;                 -- počet použití
      end record;

----------------------------------------------------------------------------------------------------
procedure entity_set_position (
    entity         : in out class tentity;       -- entita
    level          : in tentityposition;         -- pro jakou pozici až nastavovat
    pos            : in cc_def.cc_lexsym.lexposblock); -- pozice ve zdrojáku
-- Nastaví všechny dosud nenastavené pozice zadané entity až do pozice LEVEL včetně na uvedenou
-- pozici POS.
----------------------------------------------------------------------------------------------------
procedure entity_set_position_all (
    entity         : in out class tentity;       -- entita
    pos            : in cc_def.cc_lexsym.lexposblock); -- pozice ve zdrojáku
-- Nastaví všechny pozice zadané entity na uvedenou pozici POS.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
-- Entita obsahující kód
----------------------------------------------------------------------------------------------------
type
  tentity_code     = {%%TODO(ABSTRACT)} tentity with record
      bl           : cc_ref.refblock;            -- blok příkazů
      nesting      : t_unsigned;                 -- úroveň vnoření podprogramu
      end record;



----------------------------------------------------------------------------------------------------
-- Kompilační jednotka
----------------------------------------------------------------------------------------------------

type
  tcompilationtype = enum
    ct_unknown;
    ct_program;
    ct_library;
    end enum;

var
  -- popis [tcompilationtype] pro účely exportu
{%OFF}
  tcompilationtype_export_id : const aliased array tcompilationtype of t_char32str := [
      for ct_unknown use 'unknown',
      for ct_program use 'program',
      for ct_library use 'library'];
{%ON}

type
  tentity_compile  = tentity_code with record
      compitype    : tcompilationtype;           -- program, knihovna, ...?
      end record;



----------------------------------------------------------------------------------------------------
-- Program
----------------------------------------------------------------------------------------------------
type
  tentity_program  = tentity_code with record
      end record;



----------------------------------------------------------------------------------------------------
-- Modul
----------------------------------------------------------------------------------------------------
type
  tentity_module   = tentity with record
      lib_info     : p_flex_record;              -- informace knihovnika
      end record;



----------------------------------------------------------------------------------------------------
-- Objekt s iniciální hodnotou
----------------------------------------------------------------------------------------------------
type
  tentity_init     = {%%TODO(ABSTRACT)} tentity with record
      init         : cc_ref.refimm;              -- inicializační výraz
      end record;



----------------------------------------------------------------------------------------------------
-- Prvek s proměnnou hodnotou
----------------------------------------------------------------------------------------------------
type
  ----- %%TECH Run-time atributy -------------------------------------------------------------------
  -- Run-time atributy jsou uloženy v paměti v pořadí definovaném deklarací
  -- datového typu RTATTRIB (=> neměnit), tedy:
  --
  --                +-----------+
  --                | :last     |  +n
  --                +-----------+
  --                | :size     |
  --                +-----------+
  --                | :tag      |
  --                +-----------+
  --                | ^instance |  +0
  --                +-----------+
  --
  --------------------------------------------------------------------------------------------------

  -- run-time atributy (POZOR: neměnit pořadí)
  rtattrib         = enum
      rta_instance for ord use 0;                -- ^instance
      rta_tag      for ord use 1;                -- atribut :tag
      rta_size     for ord use 2;                -- atribut :size
      rta_last     for ord use 3;                -- atribut :last
      rta_length   for ord use 4;                -- atribut :length
      end enum;
  rtattribset      = set of rtattrib;

var
  -- popis [rtattrib]
{%OFF}
  rtattrib_export_id : const array rtattrib of t_char32str := [
      for rta_instance use 'instance',
      for rta_tag      use 'tag',
      for rta_size     use 'size',
      for rta_last     use 'last',
      for rta_length   use 'length'];
{%ON}

const
  -- dynamické atributy třídy
  rtas_class       = rtattribset:[rta_tag,rta_size];

type
  -- způsob zjištění run-time atributu
  t_rtattrib_mode  = enum
      rtm_static;                                -- staticky určit podle datového typu operandu
      rtm_stored_in_value;                       -- uložen v hodnotě, kterou operand reprezentuje
      rtm_stored_in_address;                     -- uložen v adrese resp. pointeru
      rtm_stored_in_tag;                         -- uložen v tagu dynamického typu hodnoty
      rtm_computed_from_size;                    -- vypočten z dynamického atributu :size
      rtm_computed_from_last;                    -- vypočten z dynamického atributu :last
      rtm_invalid;                               -- atribut nelze zjistit
      end enum;

  -- způsoby zjištění jednotlivých run-time atributů
  t_rtattrib_modes = array rtattrib of t_rtattrib_mode;

type
  tentity_value    = {%%TODO(ABSTRACT)} tentity_init with record
      typ          : cc_ref.reftype;             -- typ promenne
      rta_avail    : rtattribset;                -- teoreticky poskytované dynamické atributy
      rta_used     : rtattribset;                -- fakticky použité dynamické atributy
      rta_fixed    : t_logical;                  -- T-množina použitých dynamických atributů je
                                                 -- fixovaná a nelze ji již měnit
      end record;


----------------------------------------------------------------------------------------------------
-- Formální parametr
----------------------------------------------------------------------------------------------------
type
  -- mód parametru
  parammode        = enum
      pm_in;                                     -- IN
      pm_out;                                    -- OUT
      pm_inout;                                  -- IN OUT
      end enum;
  parammodeset     = set of parammode;

var
  -- mód parametru
{%OFF}
  parammode_export_id : const array parammode of t_char32str := [
      for pm_in    use 'in',
      for pm_out   use 'out',
      for pm_inout use 'inout'];
{%ON}

type
  -- předávání parametru
  parampass        = enum
      pp_default;                                -- implicitní
      pp_value;                                  -- hodnotou
      pp_ref;                                    -- odkazem
      pp_unchecked;                              -- odkazem, bez typové kontroly
      pp_class;                                  -- odkazem, včetně odvozených typů
      pp_virtual;                                -- odkazem, řídící parametr virtuálního volání
      end enum;
  parampassset     = set of parampass;

var
  -- předávání parametru
{%OFF}
  parampass_export_id : const array parampass of t_char32str := [
      for pp_default   use 'default',
      for pp_value     use 'value',
      for pp_ref       use 'ref',
      for pp_unchecked use 'unchecked',
      for pp_class     use 'class',
      for pp_virtual   use 'virtual'];
{%ON}

const
  -- předání hodnotou
  pps_value        = parampassset:[pp_value];
  -- předání odkazem
  pps_ref          = parampassset:[pp_ref,pp_unchecked,pp_class,pp_virtual];
  -- tagged předání
  pps_tagged       = parampassset:[pp_class,pp_virtual];

type
  -- definice formálního parametru
  tentity_param    = tentity_value with record
      mode         : parammode;                  -- mód parametru
      pass         : parampass;                  -- způsob předání parametru
      paliased     : t_mem_aliased;              -- povolení aliased přístupu
      size         : tunidata_size;              -- velikost (s přihlédnutím k způsobu předání)
      num          : t_unsigned;                 -- pořadí parametru
      end record;



----------------------------------------------------------------------------------------------------
-- Proměnná
----------------------------------------------------------------------------------------------------
type
  ----- %%TECH -------------------------------------------------------------------------------------
  -- Pojem paměťová třída z hlediska jazyka a překladače je rozdílný.
  -- Paměťová třída definovaná jazykem určuje vlastnosti proměnné, paměťová
  -- třída definovaná překladačem určuje oblast paměti, v níž je proměnná
  -- uložena. Další vlastnosti definované paměťovou třídou jazyka jsou
  -- reprezentovány dalšími příznaky proměnné.
  --------------------------------------------------------------------------------------------------

  -- příznaky proměnné
  varflags         = enum
    --vf_persistent;                             -- persistentní proměnná
    --vf_secure;                                 -- zabezpečená proměnná
      vf_;
      end enum;
  varflagset       = set of varflags;

var
  -- příznaky proměnné
{%OFF}
  varflags_export_id : const array varflags of t_char32str := [
      for vf_ use ''];
{%ON}

type
  -- mód přístupu k proměnné
  varmode          = enum
      vm_direct;                                 -- přímo
      vm_ref;                                    -- přes referenci
      vm_index;                                  -- pres index (napriklad taskove promenne)
      end enum;
  varmodeset       = set of varmode;

var
  -- mód přístupu k proměnné
{%OFF}
  varmode_export_id : const array varmode of t_char32str := [
      for vm_direct use 'direct',
      for vm_ref    use 'ref',
      for vm_index  use 'index'];
{%ON}

type
  -- determinace přístupu
  varaccess        = enum
      va_norm;                                   -- bez omezení
      va_protected;                              -- částečně read-only
      va_const;                                  -- read-only
      end enum;
  varaccessset     = set of varaccess;

var
  -- determinace přístupu
{%OFF}
  varaccess_export_id : const array varaccess of t_char32str := [
      for va_norm      use 'norm',
      for va_protected use 'protected',
      for va_const     use 'const'];
{%ON}

type
  -- jakou "higher-order" konstrukci proměnná implementuje
  varimplements    = enum
      vi_none;                                   -- proměnná je samostatná, žádná skrytá logika
      vi_parameter;                              -- proměnná implementuje formální parametr
      vi_interface;                              -- proměnná implementuje interface třídy
      end enum;
  varimplementsset = set of varimplements;

var
  -- konverze [varimplements] na řetězec pro export
{%OFF}
  varimplements_export_id : const array varimplements of t_char32str := [
      for vi_none      use 'none',
      for vi_parameter use 'parameter',
      for vi_interface use 'interface'];
{%ON}

const
  -- druhy proměnných, které snesou Imcomplete view třídy
  vis_incomplete_class = varimplementsset:[vi_parameter,vi_interface];
  -- druhy proměnných, které snesou abstraktní typ
  vis_abstract         = varimplementsset:[vi_parameter,vi_interface];

type
  -- definice promenne
  tentity_var      = tentity_value with record
      mclass       : memclass;                   -- třída proměnné
      vflags       : varflagset;                 -- další příznaky
      vmode        : varmode;                    -- mód přístupu k proměnné
      vaccess      : varaccess;                  -- determinace přístupu
      valiased     : t_mem_aliased;              -- příznak, zda je možné získat adresu proměnné (ALIASED)
      vimplements  : varimplements;              -- jakou "higher-order" konstrukci proměnná implementuje
      imp_param    : pentity_param;              -- související parametr
      addr         : tunidata_addr;              -- adresa promenne
      -- programátorem předefinovatelné atributy
      attr_position: cc_ref.refexpr;             -- pozice složky recordu

      -- exportni informace
      export_info  : p_flex_record;              -- informace pro export
      end record;



----------------------------------------------------------------------------------------------------
-- Konstanta.
----------------------------------------------------------------------------------------------------
type
  -- modifikátory konstanty
  constflags       = enum
      cf_typed;                                  -- explicitně uvedený typ konstanty
      end enum;
  constflagset     = set of constflags;

var
  -- popis typu [constflags]
{%OFF}
  constflags_export_id : const array constflags of t_char32str := [
      for cf_typed use 'typed'];
{%ON}

type
  -- konstanta
  tentity_const    = tentity_value with record
      cflags       : constflagset;               -- modifikátory
      end record;



----------------------------------------------------------------------------------------------------
-- Podprogram
----------------------------------------------------------------------------------------------------

  ----- %%TECH Adresní třídy a volací konvence podprogramů -----------------------------------------
  -- Způsob volání podprogramu je určen adresní třídou a volací konvencí.
  -- Adresní třída vychází z typu podprogramu, volací konvence je záležitostí
  -- procesoru/operačního systému a není určena jakyzem. Adresní třída říká,
  -- jak má být podprogram spuštěn - přímým voláním, interním voláním
  -- hostitelského systému, paralelně, volací tabulkou - a jaké skryté
  -- parametry (to se netýká atributů skutečných parametrů, ale jen čistě
  -- provozních informací) se mu předávají - instance třídy. Volací konvence
  -- upřesňuje způsob předání parametrů - na stacku, v registrech, jejich
  -- pořadí - a způsob předání návratové hodnoty.
  --------------------------------------------------------------------------------------------------

  ----- %%TECH Vnořené podprogramy -----------------------------------------------------------------
  -- Pokud podprogram obsahuje vnořené podprogramy, pak je o tom při globální
  -- analýze sestavena informace, která je k dispozici generátoru kódu. Je
  -- vypočítána úroveň vnoření podprogramu, přičemž 1 znamená top-level, 2 je
  -- první vnořený podprogram atd. Hodnota 0 je rezervována a znamená, že
  -- podprogram je samostatný a ani neobsahuje žádné další vnořené
  -- podprogramy.
  --   Tento mechanismus identifikace jsem zvolil jednak kvůli snadnosti
  -- implementace a navíc to přímo odpovídá sémantice instrukce ENTER jako je
  -- implementována na IA-32 procesorech, což sice zavání jistou orientací na
  -- konkrétní platformu, ale moc rozumných způsobů, jak to dělat jinak, mě
  -- nenapadá.
  --   Poznámka: Proměnná NESTING, která obsahuje tento údaj, je deklarována
  -- již v TENTITY_CODE, protože například přetížení virtuální metody je normální
  -- podprogram, ale nemá vlastnosti jako TENTITY_SUBPROGRAM a tudíž od něj není
  -- odvozen.
  --------------------------------------------------------------------------------------------------

type
  -- předávání instance
  tinstancepass    = enum
      tip_none;                                  -- nepředávat
      tip_optional;                              -- předávat; není-li, tak NIL
      tip_pass;                                  -- předávat
      tip_dispatch;                              -- předávat, řídící parametr virtuálního volání
      end enum;

var
  -- předávání instance
{%OFF}
  tinstancepass_export_id : const array tinstancepass of t_char32str := [
      for tip_none     use 'none',
      for tip_optional use 'optional',
      for tip_pass     use 'pass',
      for tip_dispatch use 'dispatch'];
{%ON}

type
  -- podprogram
  tentity_subprogram = {%%TODO(ABSTRACT)} tentity_code with record
      instance     : tinstancepass;              -- předávání instance
      typ          : cc_ref.reftype;             -- typ podprogramu
      end record;

  -- statický podprogram
  tentity_static_subprogram = {%%TODO(ABSTRACT)} tentity_subprogram with record
      -- hinty (%%TODO(?) předělat na množinu ?)
      no_return    : t_logical;                  -- T-z tohoto podprogramu se to již nevrátí
      end record;

----------------------------------------------------------------------------------------------------
-- Procedura
----------------------------------------------------------------------------------------------------
type
  tentity_procedure = tentity_static_subprogram with record
      import_info  : p_flex_record;              -- informace pro import
      export_info  : p_flex_record;              -- informace pro export
      end record;



----------------------------------------------------------------------------------------------------
-- Statická metoda
----------------------------------------------------------------------------------------------------
type
  tentity_static   = tentity_static_subprogram with record
      end record;



----------------------------------------------------------------------------------------------------
-- Virtuální metoda
----------------------------------------------------------------------------------------------------
type
  -- typ virtuálního volání 
  tvcalltype       = enum
      tvct_simple_index;                         -- jednoduché volání indexem do CLD            
      tvct_complex;                              -- komplexní volání podle typů parametrů       
      end enum;

var
  -- typ virtuálního volání 
{%OFF}
  tvcalltype_export_id : const array tvcalltype of t_char32str := [
      for tvct_simple_index use 'simple_index',
      for tvct_complex      use 'complex'];
{%ON}

type
  -- virtuální tabulka
  tvirtualtable    = string of pentity_code;
  pvirtualtable    = ^tvirtualtable;

  -- index virtuální metoda
  tvirtualindex    = tvirtualtable:range;

  -- virtuální metda
  tentity_virtual  = tentity_subprogram with record
      vcall        : tvcalltype;                 -- typ virtuálního volání                      
      vindex       : tvirtualindex;              -- index virtuální metody                      
      vector_set   : p_type_vector_set;          -- množina vektorů typů všech overridů
      root_vector  : p_type_vector;              -- root vektor odpovídající této virtuální metodě
      end record;



----------------------------------------------------------------------------------------------------
-- Přetížení virtuální metody
----------------------------------------------------------------------------------------------------
type
  tentity_override = tentity_code with record
      virt         : cc_ref.refentity;           -- související virtuální metoda                
      interface    : p_class_interface;          -- související interface
      type_vector  : p_type_vector;              -- vektor typů odpovídající tomuto overridu
      end record;



----------------------------------------------------------------------------------------------------
-- Speciální metoda
----------------------------------------------------------------------------------------------------
var
  -- jména speciálních metod
  tspectypetxt     : const array tspectype of tshortident := [
      for tst_init     use id_init_lex,
      for tst_entry    use id_entry_lex,
      for tst_exit     use id_exit_lex,
      for tst_adjust   use id_adjust_lex,
      for tst_rollback use id_rollback_lex,
      for tst_commit   use id_commit_lex];

  -- virtuální identifikátory speciálních metod 
  tspectypeid      : protected array tspectype of pentityident {%%TODO(INIT)};

type
  -- programátorem specifikovatelné speciální metody
  tuserspectype    = tspectype range tst_entry..tspectype:last;

  -- objekt, ke kterému se speciální metoda vztahuje
  tspecobject      = enum
      tso_class;                                 -- k instanci třídy
      tso_module;                                -- k modulu
      tso_type;                                  -- k instanci typu jiného než třídy
      end enum;

var
  -- popis typu [tspecobject]
{%OFF}
  tspecobject_export_id : const array tspecobject of t_char32str := [
      for tso_class  use 'class',
      for tso_module use 'module',
      for tso_type   use 'type'];
{%ON}

type
  -- tabulka speciálních metod
  tspectable       = array tspectype of cc_ref.refentity;

type
  -- definice speciální metody
  tentity_special  = tentity_subprogram with record
      spectype     : tspectype;                  -- typ speciální metody
      specobj      : tspecobject;                -- objekt, ke kterému se spec. metoda vztahuje
      end record;



----------------------------------------------------------------------------------------------------
-- Task
----------------------------------------------------------------------------------------------------
type
  tentity_task     = tentity_subprogram with record
      end record;



----------------------------------------------------------------------------------------------------
-- Makro
----------------------------------------------------------------------------------------------------
type
  tentity_macro    = tentity_subprogram with record
      end record;



----------------------------------------------------------------------------------------------------
-- Společný základ přetížení a operátoru
----------------------------------------------------------------------------------------------------
type
  -- %%TECH Pro jednoduchost se používá stejný seznam procedur pro přetížení
  -- i pro operátory, i když ve variantě pro přetížení obsahuje irelevantní
  -- údaje.
  
  -- popis jednoho přetížení
  toverloaddesc    = record
      psym         : cc_ref.refentity;           -- symbol
      arity        : tooperarity;                -- arita operátoru
      assign       : t_logical;                  -- T-operátor pro zkrácené přiřazení
      end record;               
  poverloaddesc    = ^toverloaddesc;

  -- tabulka přetížení
  toverloadtable   = string of aliased toverloaddesc;
  poverloadtable   = ^toverloadtable;

  -- přetížení nebo operátor
  tentity_overload0 = {%%TODO(ABSTRACT)} tentity with record
      table        : poverloadtable;             -- tabulka přetížených procedur
      end record;



----------------------------------------------------------------------------------------------------
-- Přetížení
----------------------------------------------------------------------------------------------------
type
  tentity_overload = tentity_overload0 with record
      end record;



----------------------------------------------------------------------------------------------------
-- Operátor
----------------------------------------------------------------------------------------------------
type
  tentity_operator = tentity_overload0 with record
      oop          : tooperator;                 -- přetížitelný operátor
      end record;



----------------------------------------------------------------------------------------------------
-- Prvek výčtového typu.
----------------------------------------------------------------------------------------------------
type
  ---- definice prvku výčtového typu ----
  tentity_enum     = tentity with record
      typ          : pentity_type;               -- související výčtový typ
      order        : t_unsigned;                 -- pořadí deklarace
      ordinal      : tuniint;                    -- ordinální hodnota
      -- programátorem předefinovatelné atributy
      attr_ord     : cc_ref.refexpr;             -- :ord
      end record;



----------------------------------------------------------------------------------------------------
-- Typ
----------------------------------------------------------------------------------------------------
type
  -- druh typu
  typekind         = enum
      tk_unknown;                                -- dosud neznámý
      tk_regular;                                -- regulární
      tk_singular;                               -- singulární
      end enum;

var
  -- druh typu
{%OFF}
  typekind_export_id : const array typekind of t_char32str := [
      for tk_unknown  use 'unknown',
      for tk_regular  use 'regular',
      for tk_singular use 'singular'];
{%ON}

type
  -- pohledy na typ
  ttypeview        = enum
      tview_null;                                -- prázdný pohled, typ není k dispozici
      tview_aggregate;                           -- libovolný agregátní typ
      tview_incomplete;                          -- Incomplete view
      tview_partial;                             -- Partial view
      tview_full;                                -- Full view
      tview_unchecked;                           -- Unchecked view
      end enum;
  ttypeviewset     = set of ttypeview;

{%OFF}
var
  ttypeviewtxt    : const array ttypeview of t_char32str := [
      for tview_null            use 'null',
      for tview_aggregate       use 'aggregate',
      for tview_incomplete      use 'incomplete',
      for tview_partial         use 'partial',
      for tview_full            use 'full',
      for tview_unchecked       use 'unchecked'];
{%ON}

type
  -- determinace kompatibility
  typecompat       = enum
      tc_norm;                                   -- bez omezení
      tc_protected;                              -- protected
      tc_private;                                -- private
      end enum;

var
  -- determinace kompatibility
{%OFF}
  typecompat_export_id : const array typecompat of t_char32str := [
      for tc_norm      use 'norm',
      for tc_protected use 'protected',
      for tc_private   use 'private'];
{%ON}

type
  -- typ derivace
  typederive       = enum
      td_root;                                   -- root typ
      td_unconstrained;                          -- triviální derivace
      td_constrained;                            -- type constraint
      td_extension;                              -- type extension
      td_private_extension;                      -- private extension
      end enum;

var
  -- typ derivace
{%OFF}
  typederive_export_id : const array typederive of t_char32str := [
      for td_root              use 'root',
      for td_unconstrained     use 'unconstrained',
      for td_constrained       use 'constrained',
      for td_extension         use 'extension',
      for td_private_extension use 'private_extension'];
{%ON}

type
{
  -- typová informace
  typetaginfo      = enum
      tag_static;                                -- statická
      tag_dynamic;                               -- dynamická
      end enum;
}
  -- příznaky typu
  typeflags        = enum
      ----- %%TECH Používání příznaků [tf_tagged] a [tg_temp] --------------------------------------
      -- Přestože v níže deklarované množině se zdají být příznaky [tf_tagged] a [tf_temp] 
      -- nezávislé, zpravidla tomu tak není. U každého typu je nastaven nejvýše (možná právě) jeden 
      -- z nich. Původně byly implicitně deklarované typy untagged, takže neměly příznak 
      -- [tf_tagged]. Nově (viz [cd_decl.cd_eval.e_type] text Ondra 12.11.2003) jsou tagged 
      -- i implicitně deklarované typy. Je samozřejmě stále možné zkonstruovat typ, který nebude mít 
      -- ani jeden z těchto příznaků, opačný extrém je však zakázaný.
      ----------------------------------------------------------------------------------------------
      tf_tagged;                                 -- typ je tagged
      tf_temp;                                   -- typ je dočasný
      end enum;
  typeflagsset     = set of typeflags;

var
  -- konverzní pole
{%OFF}
  typeflags_export_id : const array typeflags of t_char32str := [
      for tf_tagged use 'tagged',
      for tf_temp   use 'temp'];
{%ON}

type
  -- způsob inicializace instance typu
  typeinit         = enum
      ti_normal;                                 -- standardní inicializace
      ti_complex;                                -- kompexní inicializace voláním metody INIT
      end enum;

var
  -- popis [typeinit]
{%OFF}
  typeinit_export_id : const array typeinit of t_char32str := [
      for ti_normal  use 'normal',
      for ti_complex use 'complex'];
{%ON}

type
  -- typ celočíselné aritmetiky
  tintaritm        = enum
      tia_overflow;                              -- overflow aritmetika
      tia_modular;                               -- modulární aritmetika
      end enum;

var
  -- typ celočíselné aritmetiky
{%OFF}
  tintaritm_export_id : const array tintaritm of t_char32str := [
      for tia_overflow use 'overflow',
      for tia_modular  use 'modular'];
{%ON}

type
{ Ondra 3.4.2003 : Zrušeno, float se nově definuje počtem bitů.
  -- typ definice reálného čísla
  tfloatdeftype    = enum
      fdt_delta;
      fdt_digits;
      end enum;
}
  -- statické parametry reálného čísla (nezměnitelné uživatelem)
  tfloatsparams    = record
      low          : tunireal;                   -- nejmenší číslo
      high         : tunireal;                   -- největší číslo
      small        : tunireal;                   -- nejmenší číslo větší než 0
    { Totéž co DELTA:
      epsilon      : tunireal;                   -- nejmenší kladné číslo takové, že 1+eps>1
    }
   -- radix        : tuniint;                    -- základ exponentu
   -- mantissa     : tuniint;                    -- počet míst mantisy (?)
      emin         : tuniint;                    -- nejmenší exponent
      emax         : tuniint;                    -- největší exponent
      signed_zeros : tunilogical;                -- T-rozlišuje se +/- 0
      positive_inf : tunireal;                   -- Positive Infinity
      negative_inf : tunireal;                   -- Negative Infinity
      positiove_zero : tunireal;                 -- Positive Zero
      negative_zero: tunireal;                   -- Negative Zero
      not_a_number : tunireal;                   -- Not a Number
      end record;
  pfloatsparams    = ^tfloatsparams;

  -- parametry reálného čísla (definované nebo změnitelné uživatelem)
  tfloatparams     = record
      fdelta       : tunireal;                   -- přesnost
      fdigits      : tuniint;                    -- počet míst
      rounding     : tunilogical;                -- T-zaokrouhlování
      -- %%X Zaokrouhlení mohou být čtyři:
      --  - k nejbližšímu číslu (normální)
      --  - k nule (oříznutí)
      --  - k +inf (nahoru)
      --  - k -inf (dolů)
      oflw         : tunilogical;                -- T-přetečení způsobí CONSTRAINT_ERROR
      sparams      : pfloatsparams;              -- statické parametry
      end record;

  ----- %%LANG Pointery ve Flexu -------------------------------------------------------------------
  -- Ve Flexu jsou čtyři typy pointerů:
  --   -- na data,
  --   -- na podprogram (proceduru nebo metodu),
  --   -- na task,
  --   -- na zprávu.
  -- Základ pointeru je závislý na jeho typu -- obsahuje buď pointer na data,
  -- pointer na podprogram, ID tasku nebo číslo zprávy. Dále může obsahovat
  -- různé volitelné parametry:
  --   -- atribut :tag, byl-li deklarován s modifikátorem CLASS,
  --   -- atribut :size, je-li CLASS nebo UNCHECKED nebo je-li to pointer
  --      na neomezený typ,
  --   -- pointer na instanci, je-li to pointer na podprogram.
  --------------------------------------------------------------------------------------------------

  -- třída pointeru
  ptrclass         = enum
      pc_data;                                   -- přístup k datům
      pc_subprogram;                             -- přístup k podprogramu
      pc_task;                                   -- přístup k tasku
      pc_message;                                -- přístup ke zprávě
      end enum;
  ptrclassset      = set of ptrclass;

var
  -- třída pointeru
{%OFF}
  ptrclass_export_id : const array ptrclass of t_char32str := [
      for pc_data       use 'data',
      for pc_subprogram use 'subprogram',
      for pc_task       use 'task',
      for pc_message    use 'message'];
{%ON}

type
  -- kompatibilita báze
  ptrbase          = enum
      pb_strict;                                 -- pouze identické báze
      pb_class;                                  -- pouze odvozené báze
      pb_unchecked;                              -- libovolné báze
      end enum;
  ptrbaseset       = set of ptrbase;

var
  -- kompatibilita báze
{%OFF}
  ptrbase_export_id : const array ptrbase of t_char32str := [
      for pb_strict    use 'strict',
      for pb_class     use 'class',
      for pb_unchecked use 'unchecked'];
{%ON}

type
{
  -- nepovinné atributy pointeru
  ptrattrib        = enum
      pa_tag;                                    -- :tag
      pa_size;                                   -- :size
      pa_instance;                               -- ^instance
      end enum;
  ptrattribset     = set of ptrattrib;
}
  -- modifikátory pointeru
  ptrflags         = enum
    --pf_type;                                   -- pointer obsahuje typovou identifikaci
    --pf_unchecked;                              -- pointer je univerzálně kompatibilní
    --pf_const;                                  -- pointer odkazuje na konstantní objekt
      pf_machine;                                -- machine pointer
      end enum;
  ptrflagsset      = set of ptrflags;

var
  -- konverzní pole
{%OFF}
  ptrflags_export_id : const array ptrflags of t_char32str := [
      for pf_machine use 'machine'];
{%ON}

type
  -- parametry typu procedura
  procflags        = enum
      rf_virtual;                                -- obsahuje řídící parametry virtuálního volání
      end enum;
  procflagset      = set of procflags;

var
  -- konverzní pole
{%OFF}
  procflags_export_id : const array procflags of t_char32str := [
      for rf_virtual use 'virtual'];
{%ON}

type
  -- příznak, zda typ obsahuje instanci třídy
  tcontainsclass = enum
      tcc_unknown;                               -- dosud nezjištěno
      tcc_yes;                                   -- ano
      tcc_no;                                    -- ne
      end enum;

var
  -- konverzní pole
{%OFF}
  tcontainsclass_export_id : const array tcontainsclass of t_char32str := [
      for tcc_unknown use 'unknown',
      for tcc_yes     use 'yes',
      for tcc_no      use 'no'];
{%ON}

type
  -- pole @STATUS dekomponované na množinu příznaků (POZOR: neměnit pořadí!)
  t_class_status_flags = enum
     csf_initialized for ord use 0;              -- instance byla inicializována
     csf_interface   for ord use 1;              -- instance reprezentuje interface
     end enum;
  t_class_status_field = set of t_class_status_flags for size use 4;

var
  -- konverzní pole
{%OFF}
  t_class_status_flags_export_id : const array t_class_status_flags of t_char32str := [
     for csf_initialized use 'initialized',
     for csf_interface   use 'interface'];
{%ON}

type
  -- typ
  tentity_type     = tentity_init with record
      ----- %%TECH Upozornění ----------------------------------------------------------------------
      -- Při přidávání nové složky nezapomeň doplnit její kopírování nebo
      -- jinou příslušnou akci do CD_EVAL.E_TYPE_DERIVED.
      ----------------------------------------------------------------------------------------------
      -- specifikace obecného typu
      tkind        : typekind;                   -- druh typu
      stype        : tdatatype;                  -- o jaký typ se jedná
      -- %%X má smysl udržovat oddělené EVAL a SEVAL ?
      seval        : tentityeval{set};           -- vyhodnocení specifikace
      size         : tunidata_size;              -- velikost typu
      derive       : typederive;                 -- typ derivace
      defview      : ttypeview;                  -- default view typu
      extofs       : tunidata_addr{%%X(OFS)};    -- posunutí extension
      tflags       : typeflagsset;               -- flagy typu
      compat       : typecompat;                 -- determinace kompatibility
      expr         : cc_ref.refexpr;             -- související výraz
      align        : tunidata_size;              -- zarovnání složek typu
      native_align : t_logical;                  -- nativní zarovnání složek menších než [align]
      tinit        : typeinit;                   -- způsob inicializace typu
      stable       : tspectable;                 -- tabulka speciálních metoda
      -- %%TECH CCLASS slouží jako cache na výsledek výpočtu procedury         
      -- CC_TYPE.T_CONTAINS_CLASS
      cclass       : tcontainsclass;-- příznak, zda typ obsahuje instanci třídy
      -- specifikace typu s bázovým typem
      base         : cc_ref.reftype;             -- bázový typ
      -- specifikace ordinálního typu
      lval         : tuniint;                    -- ordinalni hodnota dolni meze
      hval         : tuniint;                    -- ordinalni hodnota horni meze
      bits         : tunidata_bitsize;           -- velikost v bitech
      -- specifikace celočíselného typu
      intaritm     : tintaritm;                  -- typ celočíselné aritmetiky
      -- specifikace typu reálné číslo
    { Ondra 3.4.2003 : Zrušeno, float se nově definuje počtem bitů.
      dtype        : tfloatdeftype;              -- typ definice reálného čísla
    }
      fp           : tfloatparams;               -- parametry reálného čísla
      -- specifikace typu s rozsahem
      srange       : cc_ref.reftype;             -- rozsah
      saliased     : t_mem_aliased;              -- příznak, zda je možné získat adresu složky (ALIASED)
      -- specifikace typu string
    --lsize        : tunidata_size;              -- velikost délky řetězce
      -- specifikace typu pointer
      pflags       : ptrflagsset;                -- modifikátory
      pclass       : ptrclass;                   -- cílový objekt
      pbase        : ptrbase;                    -- kompatibilita báze
      pattrib      : rtattribset{ptrattribset};  -- atributy pointeru
      paccess      : varaccess;                  -- přístup k objektu
      -- specifikace typu procedura nebo zprava
      rflags       : procflagset;                -- další parametry
      result       : pentity_param;              -- návratová hodnota funkce
      insize       : tunidata_size;              -- celkova velikost vstupnich parametru
      parcount     : t_unsigned;                 -- počet parametrů
      call_conv    : p_flex_record;              -- volaci konvence
      -- specifikace třídy
      interfaces   : p_interface_list;           -- seznam všech interfaců třídy
    { Ondra 28.8.2003 : Zobecněno na jeden seznam interfaců. Třída je sama sobě interfacem.
      vtable       : pvirtualtable;              -- virtuální tabulka
      exposed      : cc_list.trefentitystring;   -- exposeované interfacy
    }
      -- run-time informace
    --rta_tag      : tunitag;                    -- tag (typova informace)
      -- programátorem předefinovatelné atributy
      attr_align   : cc_ref.refexpr;             -- :alignment
      attr_native_align : cc_ref.refexpr;        -- :native_alignment
      attr_size    : cc_ref.refexpr;             -- :size
      attr_mptr    : cc_ref.refexpr;             -- :machine_pointer
      end record;

----------------------------------------------------------------------------------------------------
#separate public c_class_interface;
-- Interface třídy.
----------------------------------------------------------------------------------------------------
#separate public c_interface_list;
-- Seznam interfaců třídy.
----------------------------------------------------------------------------------------------------
#separate public c_type_vector;
-- Vektor typů.
----------------------------------------------------------------------------------------------------
#separate public c_type_vector_set;
-- Množina vektorů typů.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
-- Atribut
----------------------------------------------------------------------------------------------------
type
  tentity_attribute = tentity_value with record
      end record;




----------------------------------------------------------------------------------------------------
-- Zpráva
----------------------------------------------------------------------------------------------------
type
  tentity_message  = tentity with record
      typ          : cc_ref.reftype;             -- typ zprávy
    --num          : tunimsg;                    -- číslo zprávy
      end record;



----------------------------------------------------------------------------------------------------
-- Návěští
----------------------------------------------------------------------------------------------------
type
  tentity_label    = tentity with record
      num          : t_unsigned;                 -- cislo navesti
    --addr         : tuniprg;                    -- adresa navesti
      reachable    : t_logical;                  -- přístupné jako cíl skoku
      placed       : t_logical;                  -- návěští bylo umístěno
      level        : t_unsigned;                 -- úroveň umístění návěští
      end record;



----------------------------------------------------------------------------------------------------
-- Alias
----------------------------------------------------------------------------------------------------
--type
--  tentity_alias    = tentity with record
--      typ          : cc_ref.reftype;             -- typ                                         
--      read         : cc_ref.refentity;           -- metoda pro čtení (OUT)                      
--      write        : cc_ref.refentity;           -- metoda pro zápis (IN)                       
--      end record;


----------------------------------------------------------------------------------------------------
-- Parametr šablony
----------------------------------------------------------------------------------------------------
  ---- definice parametru textové substituce ----
  tentity_tparam   = tentity with record
      end record;



----------------------------------------------------------------------------------------------------
-- Šablona
----------------------------------------------------------------------------------------------------
type
  -- reprezentace lexikálního elementu přečteného ze vstupu
  tlexnode;
  plexnode         = ^class tlexnode;
  tlexnode         = record
      prev         : plexnode;                   -- předchozí lexikální symbol
      next         : plexnode;                   -- následující lexikální symbol
      _tag         : enum _tag_param; _tag_lex; end enum; -- %%TODO(TAG)
      end record;

  -- lexikální element určující formální parametr
  tlexnode_param   = tlexnode with record
      pparam       : pentity_tparam;             -- související parametr
      end record;
  plexnode_param   = ^class tlexnode_param;

  -- lexikální element sám o sobě
  tlexnode_lex     = tlexnode with record
      xlex         : cc_lexsym.lexsym;           -- lexikální element
      xval         : cc_lexsym.lexval;           -- hodnota elementu
      xpos         : cc_lexsym.lexpos;           -- pozice elementu
      end record;
  plexnode_lex     = ^class tlexnode_lex;

  -- #template 
  tentity_template = tentity with record
      plex         : plexnode;                   -- obsah metasymbolu
      end record;

----------------------------------------------------------------------------------------------------
#separate public c_entity_iterator;
-- Iterátor
----------------------------------------------------------------------------------------------------

end cc_entity;
