----------------------------------------------------------------------------------------------------
module private ca_block =
-- Překladač Flexu.
-- Analýza bloku příkazů.
----------------------------------------------------------------------------------------------------
-- Ondra : 28.02.2002 : Vytvořil.
----------------------------------------------------------------------------------------------------

with
  cc_base,cc_base.cc_type,cc_base.cc_sym,cc_attr,cc_def.cc_var,
  cc_def.cc_unitype,cb_block,cb_block.cb_def,cb_block.cb_make,
  cx_expr,cx_expr.cx_def,cx_expr.cx_make,
  ca_util,ca_temp,ca_type;

type
  -- kontext analyzovaného uzlu
  tblcontext       = record
      blevel       : t_unsigned;                 -- úroveň vnoření vzhledem k begin..end blokům
      loop_level   : t_unsigned;                 -- úroveň vnoření cyklu
      end record;



----------------------------------------------------------------------------------------------------
procedure prepare_loop_context (
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    newcontext     : out tblcontext) =           -- kontext vnitřku cyklu
-- Připraví kontext pro analýzu vnitřku cyklu.
----------------------------------------------------------------------------------------------------
begin
  -- většinu údajů převzít
  newcontext:=blcontext;

  -- zapamatovat si úroveň vnoření tohoto cyklu
  newcontext.loop_level:=newcontext.blevel;
  end prepare_loop_context;



----------------------------------------------------------------------------------------------------
procedure a_block_sequence (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bltop          : in pblnode;                 -- odpovídající nadřazený uzel
    list           : in bllist);                 -- sekvence příkazů
-- Formální kontrola posloupnosti příkazů.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_block_cmd (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblcmd) =                -- analyzovavý příkaz
-- přiřazovací příkaz
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_cmd;



----------------------------------------------------------------------------------------------------
procedure a_block_break (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblbreak) =              -- analyzovavý příkaz
-- příkaz BREAK
----------------------------------------------------------------------------------------------------
begin
  -- není to skok mimo aktuální blok ?
  bl^.loc_outer:=bl^.blevel<>blcontext.loop_level;
  end a_block_break;



----------------------------------------------------------------------------------------------------
procedure a_block_return (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblreturn) =             -- analyzovavý příkaz
-- příkaz RETURN
----------------------------------------------------------------------------------------------------
begin
  -- toto je určitě skok mimo aktuální blok
  bl^.loc_outer:=true;
  end a_block_return;



----------------------------------------------------------------------------------------------------
procedure a_block_raise (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblraise) =              -- analyzovavý příkaz
-- příkaz RAISE
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_raise;



----------------------------------------------------------------------------------------------------
procedure a_block_send (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblsend) =               -- analyzovavý příkaz
-- příkaz SEND
----------------------------------------------------------------------------------------------------
begin
  -- blok DO 
  a_block_sequence(curr,blcontext,bl,bl^.xdo);

  -- blok WHEN ACCEPT DO
  a_block_sequence(curr,blcontext,bl,bl^.xaccept);

  -- blok WHEN DELAY DO
  a_block_sequence(curr,blcontext,bl,bl^.xdelay);
  end a_block_send;



----------------------------------------------------------------------------------------------------
procedure a_block_goto (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblgoto) =               -- analyzovavý příkaz
-- příkaz GOTO
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_goto;



----------------------------------------------------------------------------------------------------
procedure a_block_new (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblnew) =                -- analyzovavý příkaz
-- příkaz NEW
----------------------------------------------------------------------------------------------------
use
  ca_analyzer.ca_analyze;

var
  base             : typeview;                   -- bázový typ pointeru

begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);

  -- analyzovat bázový typ
  if base.getutype<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base.getctype)
      else a_type(base.getctype^);
      end if;
    end if;

  -- bázový typ je třída ?
  if base.isclass then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      porgvar      : pexpnode;                   -- původní proměnná
      ptempvar     : pentity_var;                -- pracovní proměnná
      hidden_fields: c_class_hidden_field_helper;-- manipulátor se skrytými složkami
  
    begin
      -- inicializovat manipulátor se skrytými složkami
      hidden_fields.set_context(sym_primary_context(base.getctype^));

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      if bl^.xtag<>nil then
        -- má-li explicitně specifikovaný tag, tak se :size musí brát z něj,
        -- takže pracovní proměnná musí být machine_pointer a range musí
        -- specifikovat její skutečnou velikost.
        unimplementedx({UNIMP=}000196,bl^.pos[bp_begin]);
        end if;

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- změnit příkaz NEW na alokaci pracovní proměnné
      porgvar:=bl^.xvar;
      bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

      -- Instance^.@TAG := TAG
      if bl^.xtag<>nil

        -- explicitně specifikovaný
        then
          hidden_fields.a_make_set_tag(curr,bl^.bepilog,binfo,xinfo,
              -- instance
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              -- tag
              bl^.xtag
              );

        -- podle typu třídy (Instance^:tag)
        else
          hidden_fields.a_make_set_tag(curr,bl^.bepilog,binfo,xinfo,
              -- instance
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              -- tag
              x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag{ata_expr_tag},inttype_tag,
                x_make_deref(curr,xinfo,
                  x_make_component_var(curr,xinfo,ptempvar)
                  )
                )
              );
          end if;

      -- Instance^.ENTRY
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_call_spec(curr,xinfo,tst_entry,nil,
            x_make_deref(curr,xinfo,
              x_make_component_var(curr,xinfo,ptempvar)
              ),
            nil
            )
          )
        );

      -- Instance^.@STATUS := STATUS_INITED
      hidden_fields.a_make_set_status(curr,bl^.bepilog,binfo,xinfo,
          -- instance
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            ),
          -- příznaky
          [csf_initialized]
          );

      -- Proměnná := Instance
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            porgvar,
            x_make_component_var(curr,xinfo,ptempvar))
          )
        );
      end declare;

  -- v NEW je explicitně specifikován TAG => může mít metody INIT nebo ENTRY
  elsif bl^.xtag<>nil then
    unimplementedx({UNIMP=}000195,bl^.pos[bp_begin]);

  -- %%X Není náhodou nutné zajistit, aby BASE bylo již analyzováno? Bez toho si přeci
  -- nemohu být jist, že už jsou pro něj vygenerovány metody INIT a ENTRY, které zde
  -- tak vehementně testuju na existenci.

  -- obsahuje třídu nebo má speciální metodu INIT ?
  -- Ondra 1.7.2003 : Příznak komplexní inicializace se nově nenastavuje v případě, kdy není
  -- k dispozici @INIT ale jen @ENTRY, takže se musí potřeba volání @ENTRY testovat zvlášť
  elsif base.getutype<>nil and then (base.getctype^.tinit=ti_complex
  or (t_contains_class(base.getctype^) and base.getctype^.stable[tst_entry].isset))
--  elsif base.getutype<>nil and then base.getctype^.tinit=ti_complex
--  and then (t_contains_class(base.getctype^) or base.getctype^.stable[tst_init].isset)
  -- => potom je alokace o něco složitější
  then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      porgvar      : pexpnode;                   -- původní proměnná
      ptempvar     : pentity_var;                -- pracovní proměnná
      crange       : texecuterange;              -- rozsah provádění
      typ          : pentity_type;               -- popis bázového typu pointeru 
      prangehighvar : pentity_var;               -- pracovní proměnná pro rozsah
      prangelowvar : pentity_var;                -- pracovní proměnná pro rozsah

    begin
      verify({VERIFY=}000589,not base.getctype^.stable[tst_init].isset and not base.getctype^.stable[tst_entry].isset);

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- změnit příkaz NEW na alokaci pracovní proměnné
      porgvar:=bl^.xvar;
      bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

      -- zkráceny pointer na popis bázového typu
      typ:=base.getutype;

      -- pro pole a string musíme zajistit rozsah inicializace
      if (typ^.stype in dts_index) then
        -- unconstrained type - inicializace dána rozsahem
        if bl^.xrange<>nil and typ^.stype in dts_unconstrained then
          -- založit pracovní proměnnou
          a_create_temp_var(curr,prangehighvar,bl^.xrange^.t.getctype);

          -- vypočítat velikost
          a_list_append(bl^.bprolog,
            b_make_cmd(curr,binfo,
              x_make_op_assign(curr,xinfo,
                x_make_component_var(curr,xinfo,prangehighvar),
                bl^.xrange
                )
              )
            );

          -- update rozsahu
          bl^.xrange:=x_make_component_var(curr,xinfo,prangehighvar);

          -- unconstrained pole - velikost inicializace dána rozsahem 0..RANGE-1
          if typ^.stype=dt_uarray then 
            -- dolní mez zpracovávaného rozsahu
            crange.low:=x_make_imm_uniint(curr,xinfo,ui_0);

            -- horní mez zpracovávaného rozsahu
            crange.high:=x_make_op_unary(curr,xinfo,un_pred,
              x_make_component_var(curr,xinfo,prangehighvar)
              );

          -- unconstrained string - velikost inicializace dána rozsahem 1..RANGE
          elsif typ^.stype=dt_ustring then
            -- dolní mez zpracovávaného rozsahu
            crange.low:=x_make_imm_uniint(curr,xinfo,ui_1);

            -- horní mez zpracovávaného rozsahu
            crange.high:=x_make_component_var(curr,xinfo,prangehighvar);
            end if;

        -- string a array - velikost inicializace dána rozsahem lval..hval
        elsif bl^.xrange=nil and (typ^.stype=dt_array or typ^.stype=dt_string) then  
          -- dolní mez zpracovávaného rozsahu
          crange.low:=x_make_imm_uniint(curr,xinfo,typ^.lval);

          -- horní mez zpracovávaného rozsahu
          crange.high:=x_make_imm_uniint(curr,xinfo,typ^.hval);
          end if;
        end if;

    -- zavolat metodu INIT
    if base.getctype^.stable[tst_init].isset then
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_init,base.getctype^,crange,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );
        end if;

    if base.getctype^.stable[tst_entry].isset then
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_entry,base.getctype^,crange,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );
        end if;

      -- Proměnná := Instance
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            porgvar,
            x_make_component_var(curr,xinfo,ptempvar))
          )
        );
      end declare;
    end if;
  end a_block_new;



----------------------------------------------------------------------------------------------------
procedure a_block_discard (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldiscard) =            -- analyzovavý příkaz
-- příkaz DISCARD
----------------------------------------------------------------------------------------------------
use
  ca_analyzer.ca_analyze;

var
  --%%TODO(I556)
  nulllist         : const bllist;

var
  base             : typeview;                   -- bázový typ pointeru

begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);

  -- analyzovat bázový typ
  if base.getutype<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base.getctype)
      else a_type(base.getctype^);
      end if;
    end if;

  -- bude se dealokovat třída ?
  if base.isclass then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      ptempvar     : pentity_var;                -- pracovní proměnná
      hidden_fields: c_class_hidden_field_helper;-- manipulátor se skrytými složkami

    begin  
      -- inicializovat manipulátor se skrytými složkami
      hidden_fields.set_context(sym_primary_context(base.getctype^));

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- Instance := Proměnná
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar),
            bl^.xvar)
          )
        );

      -- if Instance <> NIL and then Instance^.@STATUS = STATUS_INITED then
      --   Instance^.EXIT;
      --   end if;
      hidden_fields.a_make_test_status(curr,bl^.bprolog,binfo,xinfo,
        -- precondition
        x_make_op_ne(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar),
          x_make_imm_nil(curr,xinfo,ptempvar^.typ.getctype)
          ),
        -- instance
        x_make_deref(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar)
          ),
        -- testovaný příznak
        csf_initialized,
        -- sekvence příkazů
        b_make_list(
          b_make_cmd(curr,binfo,
            x_make_call_spec(curr,xinfo,tst_exit,nil,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              nil
              )
            ),
          nulllist
          )
        );
      end declare;
    end if;
  end a_block_discard;



----------------------------------------------------------------------------------------------------
procedure a_block_adjust (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbladjust) =             -- analyzovavý příkaz
-- příkaz ADJUST
----------------------------------------------------------------------------------------------------
with
  ca_analyzer.ca_analyze;

var
  binfo            : blinfo;                     -- kontext
  xinfo            : expinfo;                    -- kontext
  base             : typeview;                   -- bázový typ pointeru
  ptempvar         : pentity_var;                -- pracovní proměnná
  typ              : pentity_type;               -- popis bázového typu pointeru 
  porgvar          : pexpnode;                   -- původní proměnná
  crange_exit      : texecuterange;              -- rozsah provádění pro metodu exit
  crange_entry     : texecuterange;              -- rozsah provádění pro metodu entry

    ------------------------------------------------------------------------------------------------
    procedure compute_variable_size (
        _variable  : in pentity_var;             -- proměnná
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual) =           -- skutečný atribut
    -- Z attributů proměnné ptempvar zjistí velikost.
    ------------------------------------------------------------------------------------------------
    begin
      -- vypočítat velikost
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,_variable),
            x_make_attribute(curr,xinfo,atc_dynamic,_atf,_ata,inttype_tag,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                )
              )
            )
          )
        );
      end compute_variable_size;



    ------------------------------------------------------------------------------------------------
    procedure compute_range_size (
        _variable  : in pentity_var) =           -- proměnná
    -- Z attributů proměnné ptempvar zjistí velikost.
    ------------------------------------------------------------------------------------------------
    begin
      -- vypočítat velikost
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,_variable),
            bl^.xrange
            )
          )
        );
      end compute_range_size;



    ------------------------------------------------------------------------------------------------
    procedure create_exit_range (
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual) =           -- skutečný atribut
    -- Z attributů proměnné ptempvar zjistí velikost a vygeneruje rozsah deinicializace.
    ------------------------------------------------------------------------------------------------
    var
      pexithighvar : pentity_var;                -- pracovní proměnná pro rozsah
      pexitlowvar  : pentity_var;                -- pracovní proměnná pro rozsah

    begin
      -- založit pracovní proměnnou pro spodní deinicializační mez
      a_create_temp_var(curr,pexitlowvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_range_size(pexitlowvar);

      -- spodní deinicializační mez zpracovávaného rozsahu
      crange_exit.low:=x_make_op_unary(curr,xinfo,un_succ,
        x_make_component_var(curr,xinfo,pexitlowvar)
        );

      -- založit pracovní proměnnou pro horní deinicializační mez
      a_create_temp_var(curr,pexithighvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_variable_size(pexithighvar,_atf,_ata);

      -- spodní deinicializační mez zpracovávaného rozsahu
      crange_exit.high:=x_make_component_var(curr,xinfo,pexithighvar);
      end create_exit_range;



    ------------------------------------------------------------------------------------------------
    procedure create_entry_range (
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual) =           -- skutečný atribut
    -- Z attributů proměnné ptempvar zjistí velikost a vygeneruje rozsah deinicializace.
    ------------------------------------------------------------------------------------------------
    var
      pentryhighvar : pentity_var;               -- pracovní proměnná pro rozsah
      pentrylowvar  : pentity_var;               -- pracovní proměnná pro rozsah

    begin
      -- založit pracovní proměnnou pro horní inicializační mez
      a_create_temp_var(curr,pentryhighvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_range_size(pentryhighvar);

      -- horní inicializační mez zpracovávaného rozsahu
      crange_entry.high:=x_make_component_var(curr,xinfo,pentryhighvar);

      -- založit pracovní proměnnou pro dolní inicializační mez
      a_create_temp_var(curr,pentrylowvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_variable_size(pentrylowvar,_atf,_ata);

      -- spodní inicializační mez zpracovávaného rozsahu
      crange_entry.low:=x_make_op_unary(curr,xinfo,un_succ,
        x_make_component_var(curr,xinfo,pentrylowvar)
        );
      end create_entry_range;


begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);

  -- analyzovat bázový typ
  if base.getutype<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base.getctype)
      else a_type(base.getctype^);
      end if;
    end if;

  -- bázový typ pointeru
  typ:=base.getutype;

  -- umíme tento typ adjustovat?
  if typ<>nil and typ^.stype in dts_unconstrained then
    -- analyzovat bázový typ
    a_type(typ^);

    -- připravit kontexty
    a_prepare_info(binfo,xinfo);

    -- založit pracovní proměnnou
    a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

    -- změnit příkaz ADJUST na realokaci pracovní proměnné
    porgvar:=bl^.xvar;
    bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

    -- unconstrainted string
    -- if range<length then @exit range+1..length
    if typ^.stype=dt_ustring then
      -- deinicializace
      create_exit_range(atf_length,ata_string_length);

    -- unconstrainted array
    -- if range<size then @exit range+1..size
    -- if range>size then @entry size+1..range
    elsif typ^.stype=dt_uarray then 
      -- deinicializace
      create_exit_range(atf_size,ata_array_length);

      -- inicializace
      create_entry_range(atf_size,ata_array_length);
      end if;

    -- pro pole i string zavolat metodu EXIT
    a_list_append(bl^.bprolog,
      a_type_make_call(curr,binfo,xinfo,tst_exit,base.getctype^,crange_exit,
        x_make_deref(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar)
          )
        )
      );

    -- pro pole zavoláme inicializaci nových prvku
    if typ^.stype=dt_uarray then
      -- zavolat metodu INIT
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_init,base.getctype^,crange_entry,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );

      -- zavolat metodu ENTRY
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_entry,base.getctype^,crange_entry,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );
      end if;

    -- Proměnná := Instance
    a_list_append(bl^.bepilog,
      b_make_cmd(curr,binfo,
        x_make_op_assign(curr,xinfo,
          porgvar,
          x_make_component_var(curr,xinfo,ptempvar))
        )
      );

  -- tohle by se stávat nemělo
  else
    verify({VERIFY=}000730,true);
    end if;
  end a_block_adjust;



----------------------------------------------------------------------------------------------------
procedure a_block_delay (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldelay) =              -- analyzovavý příkaz
-- příkaz DELAY
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_delay;



----------------------------------------------------------------------------------------------------
procedure a_block_if (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblif) =                 -- analyzovavý příkaz
-- příkaz IF
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_if;



----------------------------------------------------------------------------------------------------
procedure a_block_loop (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblloop) =               -- analyzovavý příkaz
-- příkaz LOOP
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
#if #declared ondra; #and then; ondra then;
  -- metrika
  if bl^.cond<>nil then
    succ bl_loop_until;
    end if;
#end if;

  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_loop;



----------------------------------------------------------------------------------------------------
procedure a_block_for (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblfor) =                -- analyzovavý příkaz
-- příkaz FOR
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(sym_build_context(curr.entity,bl^.for_region){curr},newcontext,bl,bl^.sub);
  end a_block_for;



----------------------------------------------------------------------------------------------------
procedure a_block_while (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhile) =              -- analyzovavý příkaz
-- příkaz WHILE
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_while;



----------------------------------------------------------------------------------------------------
procedure a_block_case (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblcase) =               -- analyzovavý příkaz
-- příkaz CASE
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_case;



----------------------------------------------------------------------------------------------------
procedure a_block_accept (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblaccept) =             -- analyzovavý příkaz
-- příkaz ACCEPT
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_accept;



----------------------------------------------------------------------------------------------------
procedure a_block_block (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- blok příkazu
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;             -- nový kontext pro vnořené příkazy

begin
  -- připravit nový kontext pro vnořené příkazy
  newcontext:=blcontext;
  succ newcontext.blevel;

  -- kompilátorem generovaná část <INIT>
  a_block_sequence(curr,newcontext,bl,bl^.binit);

  -- kompilátorem generovaná část <ENTRY>
  a_block_sequence(curr,newcontext,bl,bl^.bentry);

  -- vlastní blok
  a_block_sequence(curr,newcontext,bl,bl^.sub);

  -- část CATCH
  a_block_sequence(curr,newcontext,bl,bl^.bcatch);

  -- část ROLLBACK
  a_block_sequence(curr,newcontext,bl,bl^.brollback);

  -- část COMMIT
  a_block_sequence(curr,newcontext,bl,bl^.bcommit);

  -- část LEAVE
  a_block_sequence(curr,newcontext,bl,bl^.bleave);

  -- kompilátorem generovaná část <EXIT>
  a_block_sequence(curr,newcontext,bl,bl^.bexit);
  end a_block_block;



----------------------------------------------------------------------------------------------------
procedure a_block_sequential (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- sekvenční blok příkazu
----------------------------------------------------------------------------------------------------
begin
  -- analyzovat blok příkazů
  a_block_block(curr,blcontext,bl); 
  end a_block_sequential;



----------------------------------------------------------------------------------------------------
procedure a_block_protected (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- protected blok příkazu
----------------------------------------------------------------------------------------------------
begin
  -- analyzovat blok příkazů
  a_block_block(curr,blcontext,bl); 
  end a_block_protected;



----------------------------------------------------------------------------------------------------
procedure a_block_declare (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldeclare) =            -- analyzovavý příkaz
-- blok příkazu s lokálními deklaracemi
----------------------------------------------------------------------------------------------------
var
  declare_context  : tcontext;                   -- kontext DECLARE bloku

begin
  -- připravit si kontext
  declare_context:=sym_build_context(curr.entity,bl^.declare_region);

  -- vygenerovat inicializaci a finalizaci proměnných
  a_block_process_vars(declare_context,bl,mc_auto,false,false);

  -- analyzovat blok příkazů
  a_block_block(declare_context,blcontext,bl);
  end a_block_declare;



----------------------------------------------------------------------------------------------------
procedure a_block_asm (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblasm) =                -- analyzovavý příkaz
-- kod v assembleru
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_asm;



----------------------------------------------------------------------------------------------------
procedure a_block_label (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbllabel) =              -- analyzovavý příkaz
-- návěští
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_label;



----------------------------------------------------------------------------------------------------
procedure a_block_when_m (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhen_m) =             -- analyzovavý příkaz
-- větev obsluhy zprávy
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_when_m;



----------------------------------------------------------------------------------------------------
procedure a_block_when_c (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhen_c) =             -- analyzovavý příkaz
-- větev CASE
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_when_c;



----------------------------------------------------------------------------------------------------
procedure a_block_if_cond (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblif_cond) =            -- analyzovavý příkaz
-- větev IF
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_if_cond;



----------------------------------------------------------------------------------------------------
procedure a_block_loop1 (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblloop1) =              -- analyzovavý příkaz
-- jednoprůchodový cyklus
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_loop1;



----------------------------------------------------------------------------------------------------
procedure a_block_sequence =
-- Formální kontrola posloupnosti příkazů.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

var
  p                : pblnode;

begin
  -- analýza všech příkazů
  p:=list.first;
  while p<>nil loop
    -- do příkazu dosadit aktuální úroveň vnoření vzhledem k begin..end blokům
    p^.blevel:=blcontext.blevel;

    -- typ příkazu zahrnout do množiny lokálně vnořených příkazů
    --%%TODO(UNION) bltop^.loc_cmd+blocktypeset:[p^.btype];
    bit_set(bltop^.loc_cmd,t_bit_index(p^.btype:ord));

  #if #declared ondra; #and then; ondra then;
    -- metrika
    succ bl_metrics[p^.btype];
  #end if;

    -- formální kontrola příkazu
    case p^.btype
      -- jednoduché příkazy
      when bt_cmd         do a_block_cmd(curr,blcontext,pblcmd(p));
      when bt_break       do a_block_break(curr,blcontext,pblbreak(p));
      when bt_return      do a_block_return(curr,blcontext,pblreturn(p));
      when bt_raise       do a_block_raise(curr,blcontext,pblraise(p));
      when bt_send        do a_block_send(curr,blcontext,pblsend(p));
      when bt_goto        do a_block_goto(curr,blcontext,pblgoto(p));
      when bt_new         do a_block_new(curr,blcontext,pblnew(p));
      when bt_discard     do a_block_discard(curr,blcontext,pbldiscard(p));
      when bt_adjust      do a_block_adjust(curr,blcontext,pbladjust(p));
      when bt_delay       do a_block_delay(curr,blcontext,pbldelay(p));
      -- složené příkazy
      when bt_if          do a_block_if(curr,blcontext,pblif(p));
      when bt_loop        do a_block_loop(curr,blcontext,pblloop(p));
      when bt_for         do a_block_for(curr,blcontext,pblfor(p));
      when bt_while       do a_block_while(curr,blcontext,pblwhile(p));
      when bt_case        do a_block_case(curr,blcontext,pblcase(p));
      when bt_accept      do a_block_accept(curr,blcontext,pblaccept(p));
      when bt_block       do a_block_block(curr,blcontext,pblblock(p));
      when bt_protected   do a_block_protected(curr,blcontext,pblblock(p));
      when bt_sequential  do a_block_sequential(curr,blcontext,pblblock(p));
      when bt_declare     do a_block_declare(curr,blcontext,pbldeclare(p));
      when bt_asm         do a_block_asm(curr,blcontext,pblasm(p));
      -- pomocné uzly
      when bt_label       do a_block_label(curr,blcontext,pbllabel(p));
      when bt_when_m      do a_block_when_m(curr,blcontext,pblwhen_m(p));
      when bt_when_c      do a_block_when_c(curr,blcontext,pblwhen_c(p));
      when bt_if_cond     do a_block_if_cond(curr,blcontext,pblif_cond(p));
      -- uzly použité poprvé při optimalizaci
      when bt_loop1       do a_block_loop1(curr,blcontext,pblloop1(p));
      when others do verify({VERIFY=}000603,true);
      end case;

    -- aktualizovat množinu globálně vnořených příkazů
    bltop^.tra_cmd+p^.tra_cmd;

    -- aktualizovat příznak globálně vnořených vnějších skoků
    bltop^.tra_outer or p^.tra_outer;
    --%%X A co declare???
    if p^.btype<>bt_block 
      then bltop^.loc_outer or p^.loc_outer;
      else bltop^.tra_outer or p^.loc_outer;
      end if;

    -- další příkaz
    p:=p^.next;
    end loop;

  -- do množiny globálně vnořených příkazů započítat
  -- množinu lokálně vnořených příkazů
  bltop^.tra_cmd+bltop^.loc_cmd;

  -- do příznaku globálně vnořených vnějších skoků
  -- započítat příznak lokálně vnořených vnějších skoků
  {bltop^.tra_outer:=bltop^.tra_outer or bltop^.loc_outer;}
  end a_block_sequence;



----------------------------------------------------------------------------------------------------
procedure a_block =
-- Analýza bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  blcontext        : tblcontext;             -- kontext analyzovaného uzlu

begin
  verify({VERIFY=}000477,bl=nil);

  -- připravit kontext analýzy uzlu
  blcontext.blevel:=0;

  -- do top-level bloku dosadit počáteční úroveň vnoření
  bl^.blevel:=blcontext.blevel;

  -- analyzovat blok
  a_block_block(sym_primary_context(curr),blcontext,bl);
  end a_block;



----------------------------------------------------------------------------------------------------
procedure a_block_process_vars =
-- Zpracuje proměnné v uvedeném kontextu a vygeneruje inicializační/finalizační kód (volá postupně
-- [a_var_init], [a_var_entry] a [a_var_exit] do zadaného bloku.
----------------------------------------------------------------------------------------------------
with
  ca_analyzer.ca_var;

var
  binfo            : blinfo;                     -- kontext
  xinfo            : expinfo;                    -- kontext

begin
  -- připravit kontexty
  a_prepare_info(binfo,xinfo);

  -- inicializace statických lokálních proměnných (jen tříd)
  a_var_init(curr,bl^.binit,binfo,xinfo,mclass,recursive,classonly);

  -- zavolat entry statických lokálních proměnných
  a_var_entry(curr,bl^.bentry,binfo,xinfo,mclass,recursive);

  -- zavolat exit statických lokálních proměnných
  a_var_exit(curr,bl^.bexit,binfo,xinfo,mclass,recursive);

  -- zavolat rollback statických lokálních proměnných
  a_var_rollback(curr,bl^.brollback{???},binfo,xinfo,mclass,recursive);

  -- zavolat commit statických lokálních proměnných
  a_var_commit(curr,bl^.bcommit{???},binfo,xinfo,mclass,recursive);
  end a_block_process_vars;



end ca_block;
