----------------------------------------------------------------------------------------------------
module private ca_block =
-- Překladač Flexu.
-- Analýza bloku příkazů.
----------------------------------------------------------------------------------------------------
-- Ondra : 28.02.2002 : Vytvořil.
----------------------------------------------------------------------------------------------------

with
  cc_base,cc_base.cc_type,cc_base.cc_sym,cc_attr,cc_def.cc_var,
  cc_def.cc_unitype,cb_block,cb_block.cb_def,cb_block.cb_make,
  cx_expr,cx_expr.cx_def,cx_expr.cx_make,
  ca_util,ca_temp,ca_type;

type
  -- kontext analyzovaného uzlu
  tblcontext       = record
      blevel       : t_unsigned;                 -- úroveň vnoření vzhledem k begin..end blokům
      loop_level   : t_unsigned;                 -- úroveň vnoření cyklu
      end record;



----------------------------------------------------------------------------------------------------
procedure prepare_loop_context (
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    newcontext     : out tblcontext) =           -- kontext vnitřku cyklu
-- Připraví kontext pro analýzu vnitřku cyklu.
----------------------------------------------------------------------------------------------------
begin
  -- většinu údajů převzít
  newcontext:=blcontext;

  -- zapamatovat si úroveň vnoření tohoto cyklu
  newcontext.loop_level:=newcontext.blevel;
  end prepare_loop_context;



----------------------------------------------------------------------------------------------------
procedure a_block_sequence (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bltop          : in pblnode;                 -- odpovídající nadřazený uzel
    list           : in bllist);                 -- sekvence příkazů
-- Formální kontrola posloupnosti příkazů.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_block_cmd (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblcmd) =                -- analyzovavý příkaz
-- přiřazovací příkaz
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_cmd;



----------------------------------------------------------------------------------------------------
procedure a_block_break (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblbreak) =              -- analyzovavý příkaz
-- příkaz BREAK
----------------------------------------------------------------------------------------------------
begin
  -- není to skok mimo aktuální blok ?
  bl^.loc_outer:=bl^.blevel<>blcontext.loop_level;
  end a_block_break;



----------------------------------------------------------------------------------------------------
procedure a_block_return (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblreturn) =             -- analyzovavý příkaz
-- příkaz RETURN
----------------------------------------------------------------------------------------------------
begin
  -- toto je určitě skok mimo aktuální blok
  bl^.loc_outer:=true;
  end a_block_return;



----------------------------------------------------------------------------------------------------
procedure a_block_raise (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblraise) =              -- analyzovavý příkaz
-- příkaz RAISE
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_raise;



----------------------------------------------------------------------------------------------------
procedure a_block_send (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblsend) =               -- analyzovavý příkaz
-- příkaz SEND
----------------------------------------------------------------------------------------------------
begin
  -- blok DO 
  a_block_sequence(curr,blcontext,bl,bl^.xdo);

  -- blok WHEN ACCEPT DO
  a_block_sequence(curr,blcontext,bl,bl^.xaccept);

  -- blok WHEN DELAY DO
  a_block_sequence(curr,blcontext,bl,bl^.xdelay);
  end a_block_send;



----------------------------------------------------------------------------------------------------
procedure a_block_goto (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblgoto) =               -- analyzovavý příkaz
-- příkaz GOTO
----------------------------------------------------------------------------------------------------
begin
  ----- %%TECH Způsob rozlišení skoku mimo aktuání blok --------------------------------------------
  -- Pro generování kódu příkazu skoku je rozhodující, zda se jedná o skok uvnitř aktuálního bloku
  -- nebo skok mimo, do nadřazeného bloku, což s sebou nese potřebu provést případné po cestě
  -- ležící finalizace a další operace.
  --
  -- V rámci globální analýzy se provádí i číslování úrovní vnoření jednotlivých uzlů. Tento
  -- mechanismus lze ovšem pro rozlišení ne/lokálního skoku použít pouze z části. Pro plné využití
  -- by bylo nutné předsunout číslování do některé z předcházejících fází zpracování příkazů.
  -- V situaci, kdy před globální analýzou předchází optimalizace příkazů, by to znamenalo přidat
  -- další, obecně zbytečný průchod zpracování.
  --
  -- Z tohoto pohledu je v dané situaci výhodnější použít komplikovanější způsob rozlišení. Nižší
  -- efektivita je vzhledem k nefrekventovanosti GOTO v reálných aplikacích nezajímavá.
  --
  -- Vlastní rozlišení probíhá takto:
  --   1. jestliže je v cílovém návěští vyplněna úroveň vnoření (tj. <> 0), rozhodne se podle ní
  --      stejně jako ve zpracování BREAK,
  --   2. je-li úroveň vnoření nulová a návěští je umístěno ve stejné sekvenci příkazů jako GOTO,
  --      což lze zatím zjistit jen ručním trasováním sekvence, je skok lokální,
  --   3. v ostatních případech se jedná o nelokální skok.
  --------------------------------------------------------------------------------------------------
  
  -- je už u návěští známa úroveň vnoření?
  if bl^.plabel^.level<>0

    -- ano => určit ne/lokálnost skoku je jednoduché 
    then 
      bl^.loc_outer:=bl^.blevel<>bl^.plabel^.level;

    -- ne => musí se to vypočítat složitěji
    else
      declare var
        p          : pblnode;

      begin
        -- zjistit, jestli návěští patří do stejné sekvence příkazů
        p:=bl^.next;
        while p<>nil and then p<>bl^.plabel^.bl.getcblock loop
          p:=p^.next;
          end loop;

        -- našlo-li se, je to lokální skok, jinak určitě nelokální
        bl^.loc_outer:=p=nil;
        end declare;
      end if;
  end a_block_goto;



----------------------------------------------------------------------------------------------------
procedure prefix_deref : tprefixproc =
-- Generátor prefixu dereference výrazu.
----------------------------------------------------------------------------------------------------
begin
  result:=x_make_deref(curr,xinfo,pexpnode(_data));
  end prefix_deref;



----------------------------------------------------------------------------------------------------
procedure a_block_new (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblnew) =                -- analyzovavý příkaz
-- příkaz NEW
----------------------------------------------------------------------------------------------------
with
  cx_expr.cx_util;

use
  ca_analyzer.ca_analyze,
  supervised ca_analyzer.ca_type;

var
  base             : typeview;                   -- bázový typ pointeru

    ------------------------------------------------------------------------------------------------
    procedure make_temp_copy (
        xinfo      : in expinfo;                 -- kontext sestavování výrazu
        x_bl       : in out pexpnode;            -- výraz uložený v příkazu
        x_org      : out pexpnode;               -- původní výraz uložený v příkazu
        x_temp     : out pexpnode) =             -- výraz reprezentující pracovní proměnnou
    -- Alokuje pracovní proměnnou stejného typu jako původní výraz [x_bl], sestaví z ní výraz 
    -- [x_temp] a nahradí jím výraz uložený v příkazu [x_bl]. Původní výraz [x_bl] zachová v [x_org].
    ------------------------------------------------------------------------------------------------
    var
      temp_var     : pentity_var;                -- pracovní proměnná

    begin
      -- schovat si původní výraz uložený v příkazu
      x_org:=x_bl;
      
      -- založit pracovní proměnnou
      a_create_temp_var(curr,temp_var,x_bl^.t.getctype);

      -- sestavit výraz reprezentující pracovní proměnnou
      x_temp:=x_make_component_var(curr,xinfo,temp_var);

      -- změnit výraz uložený v příkazu na výraz reprezentující pracovní proměnnou
      x_bl:=x_temp;
      end make_temp_copy;



    ------------------------------------------------------------------------------------------------
    procedure add_assign (
        binfo      : in blinfo;                  -- kontext
        xinfo      : in expinfo;                 -- kontext sestavování výrazu
        bl         : in out bllist;              -- seznam příkazů
        x_to       : in pexpnode;                -- cílová proměnná
        x_from     : in pexpnode) =              -- přiřazovaný výraz
    -- Vygeneruje přiřazení [x_from] do [x_to]. Pokud [x_to] je NIL, nic se nestane.
    ------------------------------------------------------------------------------------------------
    begin
      if x_to<>nil then
        a_list_append(bl,
          b_make_cmd(curr,binfo,
            x_make_op_assign(curr,xinfo,
              x_to,
              x_from    
              )
            )
          );
        end if;
      end add_assign;



    ------------------------------------------------------------------------------------------------
    procedure choose_temp_or_org (
        xinfo      : in expinfo;                 -- kontext sestavování výrazu
        x_org_var  : out pexpnode;               -- výraz reprezentující původní proměnnou
        x_temp_var : out pexpnode) =             -- výraz reprezentující pracovní proměnnou
    -- Rozhodne, jestli je možné pracovat s původní proměnnou přímo nebo jestli je nutné (resp.
    -- výhodné) použít pracovní proměnnou. Přímo dovolí pracovat pouze s jednoduchou proměnnou.
    -- Současně do výrazu [bl^.xvar] dosadí výraz reprezentující pracovní proměnnou.
    ------------------------------------------------------------------------------------------------
    begin 
      if x_is_simple_variable(bl^.xvar) 

        -- ano => alokovat přímo
        then
          -- zamapatovat si alias na cílovou proměnnou
          x_temp_var:=bl^.xvar;

        -- ne => alokovat do pracovní a na závěr přiřadit do cílové
        else
         -- alokovat pracovní proměnnou a vyměnit výraz v příkazu
          make_temp_copy(xinfo,bl^.xvar,x_org_var,x_temp_var);
          end if;
      end choose_temp_or_org;



    ------------------------------------------------------------------------------------------------
    procedure prepare_tag_and_range (
        binfo      : in blinfo;                  -- kontext
        xinfo      : in expinfo;                 -- kontext sestavování výrazu
        x_tag      : out pexpnode) =             -- výraz reprezentující tag
    -- Normalizuje informaci o tagu a velikosti alokované paměti.
    ------------------------------------------------------------------------------------------------
    begin
      if bl^.xtag<>nil

        -- explicitně specifikovaný
        then 
          -- je uvedený tag jednoduše zjistitelný ?
          if x_is_simple_tag(bl^.xtag)

            -- ano => použít přímo
            then x_tag:=bl^.xtag;

            -- ne => prohnat přes pracovní proměnnou
            else
              declare var
                x_org_tag : pexpnode; 

              begin
                -- alokovat pracovní proměnnou a vyměnit výraz v příkazu
                make_temp_copy(xinfo,bl^.xtag,x_org_tag,x_tag);

                -- vypočítat tag a uložit ho do pracovní proměnné
                add_assign(binfo,xinfo,bl^.bprolog,x_tag,x_org_tag);
                end declare;
              end if;

        -- použít bázový typ pointeru
        else
          -- sestavit výraz reprezentující tag bázového typu pointeru
          x_tag:=x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag,inttype_tag,
                   x_make_component_type(curr,xinfo,base.getctype)
                   );
          end if;

      -- podle tagu nastavit velikost alokované paměti
      if bl^.xrange=nil and x_tag<>nil then
        declare var
          real_base : pentity_type;              -- skutečný bázový typ pointeru

        begin
          -- z výrazu reprezentujícího tag zjistit typ, ke kterému se vztahuje (jestliže je to možné)
          x_get_static_tag(x_tag,real_base);

          -- podařilo se ? a je známa úplná deklarace typu ?
          if real_base<>nil and then real_base^.declared=etd_full

            -- ano => velikost lze určit konstantně
            then
              bl^.xrange:=x_make_imm_uniint(curr,xinfo,unidata_size_to_uniint(real_base^.size));

            -- ne => velikost zjistit dynamicky z tagu
            else
              bl^.xrange:=x_make_attribute(curr,xinfo,atc_dynamic,atf_size,ata_designated_size,inttype_size,
                            x_make_attribute(curr,xinfo,atc_dynamic,atf_designated,ata_tag_designated,nil,
                              x_tag
                              )
                            );
              end if;
          end declare;
        end if;
      end prepare_tag_and_range;

begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);

  -- analyzovat bázový typ
  if base.getutype<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base.getctype)
      else a_type(base.getctype);
      end if;
    end if;

  -- ... Normalizovat interface na generátor kódu tak, že vždy jsou uvedeny range i tag, zjednoduší
  -- se tak generování kódu ...

  -- bázový typ je třída ?
  if base.isclass then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      x_org_var    : pexpnode;                   -- výraz reprezentující původní proměnnou
      x_temp_var   : pexpnode;                   -- výraz reprezentující pracovní proměnná
      x_tag        : pexpnode;                   -- výraz reprezentující tag

    begin
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      ----- (1) Rozhodnout, jestli není potřeba pracovní proměnná -----
      choose_temp_or_org(xinfo,for x_org_var use x_org_var,for x_temp_var use x_temp_var);

      ----- (2) Vypočítat a zkontrolovat tag, upravit RANGE -----
      prepare_tag_and_range(binfo,xinfo,x_tag);

      ----- (3) Inicializovat instanci třídy -----
      ca_analyzer.ca_type.a_type_class_entry_internal(curr,^prefix_deref,x_temp_var,base.getctype,bl^.bepilog,binfo,xinfo,x_tag);

      ----- (4) Pracovní proměnnou přiřadit do cílové -----
      add_assign(binfo,xinfo,bl^.bepilog,for x_to use x_org_var,for x_from use x_temp_var);
      end declare;



{
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      porgvar      : pexpnode;                   -- původní proměnná
      ptempvar     : pentity_var;                -- pracovní proměnná
      hidden_fields: c_class_hidden_field_helper;-- manipulátor se skrytými složkami
  
    begin
      -- inicializovat manipulátor se skrytými složkami
      hidden_fields.set_context(sym_primary_context(base.getctype^));

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      if bl^.xtag<>nil then
        -- má-li explicitně specifikovaný tag, tak se :size musí brát z něj,
        -- takže pracovní proměnná musí být machine_pointer a range musí
        -- specifikovat její skutečnou velikost.
        unimplementedx({UNIMP=}000196,bl^.pos[bp_begin]);
        end if;

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- změnit příkaz NEW na alokaci pracovní proměnné
      porgvar:=bl^.xvar;
      bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

      -- Instance^.@TAG := TAG
      if bl^.xtag<>nil

        -- explicitně specifikovaný
        then
          hidden_fields.a_make_set_tag(curr,bl^.bepilog,binfo,xinfo,
              -- instance
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              -- tag
              bl^.xtag
              );

        -- podle typu třídy (Instance^:tag)
        else
          hidden_fields.a_make_set_tag(curr,bl^.bepilog,binfo,xinfo,
              -- instance
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              -- tag
              x_make_attribute(curr,xinfo,atc_static,atf_tag,ata_type_tag{ata_expr_tag},inttype_tag,
                x_make_deref(curr,xinfo,
                  x_make_component_var(curr,xinfo,ptempvar)
                  )
                )
              );
          end if;

      -- Instance^.ENTRY
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_call_spec(curr,xinfo,tst_entry,nil,
            x_make_deref(curr,xinfo,
              x_make_component_var(curr,xinfo,ptempvar)
              ),
            nil
            )
          )
        );

      -- Instance^.@STATUS := STATUS_INITED
      hidden_fields.a_make_set_status(curr,bl^.bepilog,binfo,xinfo,
          -- instance
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            ),
          -- příznaky
          [csf_initialized]
          );

      -- Proměnná := Instance
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            porgvar,
            x_make_component_var(curr,xinfo,ptempvar))
          )
        );
      end declare;
}

  -- v NEW je explicitně specifikován TAG => může mít metody INIT nebo ENTRY
  elsif bl^.xtag<>nil then
    --unimplementedx({UNIMP=}000195,bl^.pos[bp_begin]);
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      x_org_var    : pexpnode;                   -- výraz reprezentující původní proměnnou
      x_temp_var   : pexpnode;                   -- výraz reprezentující pracovní proměnná
      x_tag        : pexpnode;                   -- výraz reprezentující tag

    begin
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      ----- (1) Rozhodnout, jestli není potřeba pracovní proměnná -----
      choose_temp_or_org(xinfo,for x_org_var use x_org_var,for x_temp_var use x_temp_var);

      ----- (2) Vypočítat a zkontrolovat tag, upravit RANGE -----
      prepare_tag_and_range(binfo,xinfo,x_tag);

      ----- (3) Inicializovat instanci -----
      ca_analyzer.ca_type.a_type_nonclass_entry_internal(curr,^prefix_deref,x_temp_var,base.getctype,bl^.bepilog,binfo,xinfo,bl^.xrange,x_tag,x_temp_var);

      ----- (4) Pracovní proměnnou přiřadit do cílové -----
      add_assign(binfo,xinfo,bl^.bepilog,for x_to use x_org_var,for x_from use x_temp_var);
      end declare;

  -- obsahuje třídu nebo má speciální metodu INIT ?
  -- Ondra 1.7.2003 : Příznak komplexní inicializace se nově nenastavuje v případě, kdy není
  -- k dispozici @INIT ale jen @ENTRY, takže se musí potřeba volání @ENTRY testovat zvlášť
  elsif base.getutype<>nil and then (base.getctype^.tinit=ti_complex
  or a_find_special_method(base.getctype^,tst_entry)<>nil)
--  elsif base.getutype<>nil and then base.getctype^.tinit=ti_complex
--  and then (t_contains_class(base.getctype^) or base.getctype^.stable[tst_init].isset)
  -- => potom je alokace o něco složitější
  then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      porgvar      : pexpnode;                   -- původní proměnná
      ptempvar     : pentity_var;                -- pracovní proměnná
      crange       : texecuterange;              -- rozsah provádění
      srange       : pentity_type;               -- typ rozsahu bázového typu
      typ          : pentity_type;               -- popis bázového typu pointeru 
      prangehighvar : pentity_var;               -- pracovní proměnná pro rozsah
      prangelowvar : pentity_var;                -- pracovní proměnná pro rozsah

    begin
      verify({VERIFY=}000589,a_find_special_method(base.getctype^,tst_init)=nil and a_find_special_method(base.getctype^,tst_entry)=nil);

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- změnit příkaz NEW na alokaci pracovní proměnné
      porgvar:=bl^.xvar;
      bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

      -- zkrácený pointer na popis bázového typu
      typ:=base.getutype;

      -- pro string se inicializační metody NEVOLAJÍ, protože string vznikne prázdný
      if typ^.stype not in dts_string then
        -- pro pole musíme zajistit rozsah inicializace
        if typ^.stype in dts_index then
          -- unconstrained type - inicializace dána rozsahem
          if bl^.xrange<>nil and typ^.stype in dts_unconstrained then
            -- založit pracovní proměnnou
            a_create_temp_var(curr,prangehighvar,bl^.xrange^.t.getctype);

            -- vypočítat velikost
            a_list_append(bl^.bprolog,
              b_make_cmd(curr,binfo,
                x_make_op_assign(curr,xinfo,
                  x_make_component_var(curr,xinfo,prangehighvar),
                  bl^.xrange
                  )
                )
              );

            -- update rozsahu
            bl^.xrange:=x_make_component_var(curr,xinfo,prangehighvar);

            -- unconstrained pole - velikost inicializace dána rozsahem 0..RANGE-1
            if typ^.stype=dt_uarray then 
              -- dolní mez zpracovávaného rozsahu
              crange.low:=x_make_imm_uniint(curr,xinfo,ui_0);

              -- horní mez zpracovávaného rozsahu
              crange.high:=x_make_op_unary(curr,xinfo,un_pred,
                x_make_component_var(curr,xinfo,prangehighvar)
                );

            -- unconstrained string - velikost inicializace dána rozsahem 1..RANGE
            elsif typ^.stype=dt_ustring then
              -- dolní mez zpracovávaného rozsahu
              crange.low:=x_make_imm_uniint(curr,xinfo,ui_1);

              -- horní mez zpracovávaného rozsahu
              crange.high:=x_make_component_var(curr,xinfo,prangehighvar);
              end if;

          -- string a array - velikost inicializace dána rozsahem lval..hval
          elsif bl^.xrange=nil and (typ^.stype=dt_array or typ^.stype=dt_string) then  
            -- zjistit rozsah bázového typu
            srange:=typ^.srange.getctype;

            -- dolní mez zpracovávaného rozsahu
            crange.low:=x_make_imm_uniint(curr,xinfo,srange^.lval);

            -- horní mez zpracovávaného rozsahu
            crange.high:=x_make_imm_uniint(curr,xinfo,srange^.hval);
            end if;
          end if;

        -- zavolat metodu INIT
        if a_find_special_method(base.getctype^,tst_init)<>nil then
          a_list_append(bl^.bepilog,
            a_type_make_call(curr,binfo,xinfo,tst_init,base.getctype^,crange,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                )
              )
            );
            end if;

        -- zavolat metodu ENTRY
        if a_find_special_method(base.getctype^,tst_entry)<>nil then
          a_list_append(bl^.bepilog,
            a_type_make_call(curr,binfo,xinfo,tst_entry,base.getctype^,crange,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                )
              )
            );
          end if;
        end if;

      -- Proměnná := Instance
      a_list_append(bl^.bepilog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            porgvar,
            x_make_component_var(curr,xinfo,ptempvar))
          )
        );
      end declare;
    end if;
  end a_block_new;



----------------------------------------------------------------------------------------------------
procedure a_block_discard (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldiscard) =            -- analyzovavý příkaz
-- příkaz DISCARD
----------------------------------------------------------------------------------------------------
use
  ca_analyzer.ca_analyze;

var
  --%%TODO(I556)
  nulllist         : const bllist;

var
  base             : typeview;                   -- bázový typ pointeru
  base_type        : pentity_type;               -- a jeho entita

begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);
  base_type:=base.getutype;

  -- analyzovat bázový typ
  if base_type<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base_type)
      else a_type(base_type);
      end if;
    end if;

  -- bude se dealokovat třída ?
  if base.isclass then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      ptempvar     : pentity_var;                -- pracovní proměnná
      hidden_fields: c_class_hidden_field_helper;-- manipulátor se skrytými složkami

    begin  
      -- inicializovat manipulátor se skrytými složkami
      hidden_fields.set_context(sym_primary_context(base_type^));

      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- Instance := Proměnná
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar),
            bl^.xvar)
          )
        );

      -- if Instance <> NIL and then Instance^.@STATUS = STATUS_INITED then
      --   Instance^.EXIT;
      --   end if;
      hidden_fields.a_make_test_status(curr,bl^.bprolog,binfo,xinfo,
        -- precondition
        x_make_op_ne(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar),
          x_make_imm_nil(curr,xinfo,ptempvar^.typ.getctype)
          ),
        -- instance
        x_make_deref(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar)
          ),
        -- testovaný příznak
        csf_initialized,
        -- sekvence příkazů
        b_make_list(
          b_make_cmd(curr,binfo,
            x_make_call_spec(curr,xinfo,tst_exit,nil,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                ),
              nil,nil,nil,nil
              )
            ),
          nulllist
          )
        );
      end declare;
   
  -- je to nějaký indexovaný typ (tzn. bude se volat přímo speciální metoda se specifikací rozsahu?)
  elsif base_type<>nil and then base_type^.stype in dts_index
  -- a má bázový typ definovanou metodu EXIT?
  and then a_find_special_method(base_type^,tst_exit)<>nil then
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext
      srange       : pentity_type;               -- typ rozsahu
      crange       : texecuterange;              -- specifikace rozsahu
      ptempvar     : pentity_var;                -- pracovní proměnná

    begin
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- založit pracovní proměnnou
      a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

      -- Instance := Proměnná
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar),
            bl^.xvar)
          )
        );

      -- zjistit rozsah podle typu
      -- unconstrained pole - velikost inicializace dána rozsahem 0..RANGE-1
      if base_type^.stype=dt_uarray then
        -- dolní mez zpracovávaného rozsahu
        crange.low:=x_make_imm_uniint(curr,xinfo,ui_0);

        -- horní mez zpracovávaného rozsahu
        crange.high:=x_make_op_unary(curr,xinfo,un_pred,
          x_make_attribute(curr,xinfo,atc_dynamic,atf_size,ata_array_length,inttype_size,
            x_make_deref(curr,xinfo,
              x_make_component_var(curr,xinfo,ptempvar)
              )
            )
          );

      -- unconstrained string - velikost inicializace dána rozsahem 1..RANGE
      elsif base_type^.stype=dt_ustring then
        -- dolní mez zpracovávaného rozsahu
        crange.low:=x_make_imm_uniint(curr,xinfo,ui_1);

        -- horní mez zpracovávaného rozsahu
        crange.high:=
            x_make_attribute(curr,xinfo,atc_dynamic,atf_length,ata_string_length,inttype_size,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                )
              )

      -- string a array - velikost inicializace dána rozsahem lval..hval
      elsif base_type^.stype=dt_array or base_type^.stype=dt_string then
        -- zjistit rozsah bázového typu
        srange:=base_type^.srange.getctype;

        -- dolní mez zpracovávaného rozsahu
        crange.low:=x_make_imm_uniint(curr,xinfo,srange^.lval);

        -- horní mez zpracovávaného rozsahu
        crange.high:=x_make_imm_uniint(curr,xinfo,srange^.hval);

      else verify({VERIFY=}001470,true);
        end if;

      -- if Instance<>nil then
      --   Instance^.EXIT(crange);
      --   end if;
      a_list_append(bl^.bprolog,
        b_make_if(curr,binfo,
          b_make_list(
            b_make_if_cond(curr,binfo,
              x_make_op_ne(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar),
                x_make_imm_nil(curr,xinfo,bl^.xvar^.t.getctype)
                ),
              b_make_list(
                a_type_make_call(curr,binfo,xinfo,tst_exit,base_type^,crange,
                  x_make_deref(curr,xinfo,
                    x_make_component_var(curr,xinfo,ptempvar)
                    )
                  ),
                nil
                )
              ),
            nil
            )
          )
        );
      end declare;

  -- je to jiný typ, u kterého budeme volat EXIT? (pro UNCHECKED pointery bez bázového typu se nevolá)
  elsif base_type<>nil then
  -- %%TODO provádět jenom pro složené typy (?)
  -- %%TODO a jenom pro CLASS pointery nebo pointery na objekt, který má EXIT metodu
    declare var
      binfo        : blinfo;                     -- kontext
      xinfo        : expinfo;                    -- kontext

    begin
      -- připravit kontexty
      a_prepare_info(binfo,xinfo);

      -- if Instance<>nil then
      --  Instance^.EXIT
      --  end if;
      a_list_append(bl^.bprolog,
        b_make_if(curr,binfo,
          b_make_list(
            b_make_if_cond(curr,binfo,
              x_make_op_ne(curr,xinfo,
                bl^.xvar,
                x_make_imm_nil(curr,xinfo,bl^.xvar^.t.getctype)
                ),
              b_make_list(
                b_make_cmd(curr,binfo,
                  x_make_call_spec(curr,xinfo,tst_exit,nil,
                    x_make_deref(curr,xinfo,bl^.xvar),
                    nil,
                    nil,
                    nil,nil
                    )
                  ),
                nil
                )
              ),
            nil
            )
          )
        );
      end declare;
    end if;
  end a_block_discard;



----------------------------------------------------------------------------------------------------
procedure a_block_adjust (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbladjust) =             -- analyzovavý příkaz
-- příkaz ADJUST
----------------------------------------------------------------------------------------------------
with
  ca_analyzer.ca_analyze;

var
  binfo            : blinfo;                     -- kontext
  xinfo            : expinfo;                    -- kontext
  base             : typeview;                   -- bázový typ pointeru
  ptempvar         : pentity_var;                -- pracovní proměnná
  typ              : pentity_type;               -- popis bázového typu pointeru 
  porgvar          : pexpnode;                   -- původní proměnná
  crange_exit      : texecuterange;              -- rozsah provádění pro metodu exit
  crange_entry     : texecuterange;              -- rozsah provádění pro metodu entry

    ------------------------------------------------------------------------------------------------
    procedure compute_variable_size (
        _variable  : in pentity_var;             -- proměnná
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual;             -- skutečný atribut
        _ata_type  : in pentity_type) =          -- typ skutečného atributu
    -- Z attributů proměnné ptempvar zjistí velikost.
    ------------------------------------------------------------------------------------------------
    begin
      -- vypočítat velikost
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,_variable),
            x_make_attribute(curr,xinfo,atc_dynamic,_atf,_ata,_ata_type,
              x_make_deref(curr,xinfo,
                x_make_component_var(curr,xinfo,ptempvar)
                )
              )
            )
          )
        );
      end compute_variable_size;



    ------------------------------------------------------------------------------------------------
    procedure compute_range_size (
        _variable  : in pentity_var) =           -- proměnná
    -- Z attributů proměnné ptempvar zjistí velikost.
    ------------------------------------------------------------------------------------------------
    begin
      -- vypočítat velikost
      a_list_append(bl^.bprolog,
        b_make_cmd(curr,binfo,
          x_make_op_assign(curr,xinfo,
            x_make_component_var(curr,xinfo,_variable),
            bl^.xrange
            )
          )
        );
      end compute_range_size;



    ------------------------------------------------------------------------------------------------
    procedure create_exit_range (
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual;             -- skutečný atribut
        _ata_type  : in pentity_type) =          -- typ skutečného atributu
    -- Z attributů proměnné ptempvar zjistí velikost a vygeneruje rozsah deinicializace.
    ------------------------------------------------------------------------------------------------
    var
      pexithighvar : pentity_var;                -- pracovní proměnná pro rozsah
      pexitlowvar  : pentity_var;                -- pracovní proměnná pro rozsah

    begin
      -- založit pracovní proměnnou pro spodní deinicializační mez
      a_create_temp_var(curr,pexitlowvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_range_size(pexitlowvar);

      -- spodní deinicializační mez zpracovávaného rozsahu
      crange_exit.low:=x_make_op_unary(curr,xinfo,un_succ,
        x_make_component_var(curr,xinfo,pexitlowvar)
        );

      -- založit pracovní proměnnou pro horní deinicializační mez
      a_create_temp_var(curr,pexithighvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_variable_size(pexithighvar,_atf,_ata,_ata_type);

      -- spodní deinicializační mez zpracovávaného rozsahu
      crange_exit.high:=x_make_component_var(curr,xinfo,pexithighvar);
      end create_exit_range;



    ------------------------------------------------------------------------------------------------
    procedure create_entry_range (
        _atf       : in tattrformal;             -- formální atribut
        _ata       : in tattractual;             -- skutečný atribut
        _ata_type  : in pentity_type) =          -- typ skutečného atributu
    -- Z attributů proměnné ptempvar zjistí velikost a vygeneruje rozsah deinicializace.
    ------------------------------------------------------------------------------------------------
    var
      pentryhighvar : pentity_var;               -- pracovní proměnná pro rozsah
      pentrylowvar  : pentity_var;               -- pracovní proměnná pro rozsah

    begin
      -- založit pracovní proměnnou pro horní inicializační mez
      a_create_temp_var(curr,pentryhighvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_range_size(pentryhighvar);

      -- horní inicializační mez zpracovávaného rozsahu
      crange_entry.high:=x_make_component_var(curr,xinfo,pentryhighvar);

      -- založit pracovní proměnnou pro dolní inicializační mez
      a_create_temp_var(curr,pentrylowvar,bl^.xrange^.t.getctype);

      -- vypočítat velikost
      compute_variable_size(pentrylowvar,_atf,_ata,_ata_type);

      -- spodní inicializační mez zpracovávaného rozsahu
      crange_entry.low:=x_make_op_unary(curr,xinfo,un_succ,
        x_make_component_var(curr,xinfo,pentrylowvar)
        );
      end create_entry_range;


begin
  -- zjistit bázový typ pointeru
  base:=bl^.xvar^.t.getbase(curr);

  -- analyzovat bázový typ
  if base.getutype<>nil then
    if base.isclass
      then ca_analyzer.ca_analyze.a_entity(base.getctype)
      else a_type(base.getctype);
      end if;
    end if;

  -- bázový typ pointeru
  typ:=base.getutype;

  -- umíme tento typ adjustovat?
  if typ<>nil and typ^.stype in dts_unconstrained then
    -- analyzovat bázový typ
    a_type(typ);

    -- připravit kontexty
    a_prepare_info(binfo,xinfo);

    -- založit pracovní proměnnou
    a_create_temp_var(curr,ptempvar,bl^.xvar^.t.getctype);

    -- změnit příkaz ADJUST na realokaci pracovní proměnné
    porgvar:=bl^.xvar;
    bl^.xvar:=x_make_component_var(curr,xinfo,ptempvar);

    -- unconstrainted string
    -- if range<length then @exit range+1..length
    if typ^.stype=dt_ustring then
      -- deinicializace
      create_exit_range(atf_length,ata_string_length,inttype_size);

    -- unconstrainted array
    -- if range<size then @exit range+1..size
    -- if range>size then @entry size+1..range
    elsif typ^.stype=dt_uarray then 
      -- deinicializace
      create_exit_range(atf_size,ata_array_length,inttype_size);

      -- inicializace
      create_entry_range(atf_size,ata_array_length,inttype_size);
      end if;

    -- pro pole i string zavolat metodu EXIT
    a_list_append(bl^.bprolog,
      a_type_make_call(curr,binfo,xinfo,tst_exit,base.getctype^,crange_exit,
        x_make_deref(curr,xinfo,
          x_make_component_var(curr,xinfo,ptempvar)
          )
        )
      );

    -- pro pole zavoláme inicializaci nových prvku
    if typ^.stype=dt_uarray then
      -- zavolat metodu INIT
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_init,base.getctype^,crange_entry,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );

      -- zavolat metodu ENTRY
      a_list_append(bl^.bepilog,
        a_type_make_call(curr,binfo,xinfo,tst_entry,base.getctype^,crange_entry,
          x_make_deref(curr,xinfo,
            x_make_component_var(curr,xinfo,ptempvar)
            )
          )
        );
      end if;

    -- Proměnná := Instance
    a_list_append(bl^.bepilog,
      b_make_cmd(curr,binfo,
        x_make_op_assign(curr,xinfo,
          porgvar,
          x_make_component_var(curr,xinfo,ptempvar))
        )
      );

  -- tohle by se stávat nemělo
  else
    verify({VERIFY=}000730,true);
    end if;
  end a_block_adjust;



----------------------------------------------------------------------------------------------------
procedure a_block_delay (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldelay) =              -- analyzovavý příkaz
-- příkaz DELAY
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_delay;



----------------------------------------------------------------------------------------------------
procedure a_block_if (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblif) =                 -- analyzovavý příkaz
-- příkaz IF
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_if;



----------------------------------------------------------------------------------------------------
procedure a_block_loop (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblloop) =               -- analyzovavý příkaz
-- příkaz LOOP
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
#if #declared ondra; #and then; ondra then;
  -- metrika
  if bl^.cond<>nil then
    succ bl_loop_until;
    end if;
#end if;

  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_loop;



----------------------------------------------------------------------------------------------------
procedure a_block_for (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblfor) =                -- analyzovavý příkaz
-- příkaz FOR
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(sym_build_context(curr.entity,bl^.for_region){curr},newcontext,bl,bl^.sub);
  end a_block_for;



----------------------------------------------------------------------------------------------------
procedure a_block_while (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhile) =              -- analyzovavý příkaz
-- příkaz WHILE
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_while;



----------------------------------------------------------------------------------------------------
procedure a_block_case (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblcase) =               -- analyzovavý příkaz
-- příkaz CASE
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_case;



----------------------------------------------------------------------------------------------------
procedure a_block_accept (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblaccept) =             -- analyzovavý příkaz
-- příkaz ACCEPT
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_accept;



----------------------------------------------------------------------------------------------------
procedure a_block_block (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- blok příkazu
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;             -- nový kontext pro vnořené příkazy

begin
  -- připravit nový kontext pro vnořené příkazy
  newcontext:=blcontext;
  succ newcontext.blevel;

  -- kompilátorem generovaná část <INIT>
  a_block_sequence(curr,newcontext,bl,bl^.binit);

  -- kompilátorem generovaná část <ENTRY>
  a_block_sequence(curr,newcontext,bl,bl^.bentry);

  -- vlastní blok
  a_block_sequence(curr,newcontext,bl,bl^.sub);

  -- část CATCH
  a_block_sequence(curr,newcontext,bl,bl^.bcatch);

  -- část ROLLBACK
  a_block_sequence(curr,newcontext,bl,bl^.brollback);

  -- část COMMIT
  a_block_sequence(curr,newcontext,bl,bl^.bcommit);

  -- část LEAVE
  a_block_sequence(curr,newcontext,bl,bl^.bleave);

  -- kompilátorem generovaná část <EXIT>
  a_block_sequence(curr,newcontext,bl,bl^.bexit);
  end a_block_block;



----------------------------------------------------------------------------------------------------
procedure a_block_sequential (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- sekvenční blok příkazu
----------------------------------------------------------------------------------------------------
begin
  -- analyzovat blok příkazů
  a_block_block(curr,blcontext,bl); 
  end a_block_sequential;



----------------------------------------------------------------------------------------------------
procedure a_block_protected (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblblock) =              -- analyzovavý příkaz
-- protected blok příkazu
----------------------------------------------------------------------------------------------------
begin
  -- analyzovat blok příkazů
  a_block_block(curr,blcontext,bl); 
  end a_block_protected;



----------------------------------------------------------------------------------------------------
procedure a_block_declare (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbldeclare) =            -- analyzovavý příkaz
-- blok příkazu s lokálními deklaracemi
----------------------------------------------------------------------------------------------------
var
  declare_context  : tcontext;                   -- kontext DECLARE bloku

begin
  -- připravit si kontext
  declare_context:=sym_build_context(curr.entity,bl^.declare_region);

  -- vygenerovat inicializaci a finalizaci proměnných
  a_block_process_vars(declare_context,bl,mc_auto,false,false);

  -- analyzovat blok příkazů
  a_block_block(declare_context,blcontext,bl);
  end a_block_declare;



----------------------------------------------------------------------------------------------------
procedure a_block_asm (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblasm) =                -- analyzovavý příkaz
-- kod v assembleru
----------------------------------------------------------------------------------------------------
begin
  -- nic nedělat
  end a_block_asm;



----------------------------------------------------------------------------------------------------
procedure a_block_label (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pbllabel) =              -- analyzovavý příkaz
-- návěští
----------------------------------------------------------------------------------------------------
begin
  -- poznamenat úroveň vnoření
  bl^.plabel^.level:=blcontext.blevel;
  end a_block_label;



----------------------------------------------------------------------------------------------------
procedure a_block_when_m (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhen_m) =             -- analyzovavý příkaz
-- větev obsluhy zprávy
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_when_m;



----------------------------------------------------------------------------------------------------
procedure a_block_when_c (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblwhen_c) =             -- analyzovavý příkaz
-- větev CASE
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_when_c;



----------------------------------------------------------------------------------------------------
procedure a_block_if_cond (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblif_cond) =            -- analyzovavý příkaz
-- větev IF
----------------------------------------------------------------------------------------------------
begin
  a_block_sequence(curr,blcontext,bl,bl^.sub);
  end a_block_if_cond;



----------------------------------------------------------------------------------------------------
procedure a_block_loop1 (
    curr           : in tcontext;                -- aktuální kontext
    blcontext      : in tblcontext;              -- kontext analyzovaného uzlu
    bl             : in pblloop1) =              -- analyzovavý příkaz
-- jednoprůchodový cyklus
----------------------------------------------------------------------------------------------------
var
  newcontext       : tblcontext;                 -- nový kontext pro vnořené příkazy

begin
  -- připravit kontext
  prepare_loop_context(blcontext,newcontext);

  -- analyzovat vnitřek cyklu
  a_block_sequence(curr,newcontext,bl,bl^.sub);
  end a_block_loop1;



----------------------------------------------------------------------------------------------------
procedure a_block_sequence =
-- Formální kontrola posloupnosti příkazů.
----------------------------------------------------------------------------------------------------
with
  advanced,
  advanced.low_level,
  advanced.low_level.bit_operations;

var
  p                : pblnode;

begin
  -- analýza všech příkazů
  p:=list.first;
  while p<>nil loop
    -- do příkazu dosadit aktuální úroveň vnoření vzhledem k begin..end blokům
    p^.blevel:=blcontext.blevel;

    -- typ příkazu zahrnout do množiny lokálně vnořených příkazů
    --%%TODO(UNION) bltop^.loc_cmd+blocktypeset:[p^.btype];
    bit_set(bltop^.loc_cmd,t_bit_index(p^.btype:ord));

  #if #declared ondra; #and then; ondra then;
    -- metrika
    succ bl_metrics[p^.btype];
  #end if;

    -- formální kontrola příkazu
    case p^.btype
      -- jednoduché příkazy
      when bt_cmd         do a_block_cmd(curr,blcontext,pblcmd(p));
      when bt_break       do a_block_break(curr,blcontext,pblbreak(p));
      when bt_return      do a_block_return(curr,blcontext,pblreturn(p));
      when bt_raise       do a_block_raise(curr,blcontext,pblraise(p));
      when bt_send        do a_block_send(curr,blcontext,pblsend(p));
      when bt_goto        do a_block_goto(curr,blcontext,pblgoto(p));
      when bt_new         do a_block_new(curr,blcontext,pblnew(p));
      when bt_discard     do a_block_discard(curr,blcontext,pbldiscard(p));
      when bt_adjust      do a_block_adjust(curr,blcontext,pbladjust(p));
      when bt_delay       do a_block_delay(curr,blcontext,pbldelay(p));
      -- složené příkazy
      when bt_if          do a_block_if(curr,blcontext,pblif(p));
      when bt_loop        do a_block_loop(curr,blcontext,pblloop(p));
      when bt_for         do a_block_for(curr,blcontext,pblfor(p));
      when bt_while       do a_block_while(curr,blcontext,pblwhile(p));
      when bt_case        do a_block_case(curr,blcontext,pblcase(p));
      when bt_accept      do a_block_accept(curr,blcontext,pblaccept(p));
      when bt_block       do a_block_block(curr,blcontext,pblblock(p));
      when bt_protected   do a_block_protected(curr,blcontext,pblblock(p));
      when bt_sequential  do a_block_sequential(curr,blcontext,pblblock(p));
      when bt_declare     do a_block_declare(curr,blcontext,pbldeclare(p));
      when bt_asm         do a_block_asm(curr,blcontext,pblasm(p));
      -- pomocné uzly
      when bt_label       do a_block_label(curr,blcontext,pbllabel(p));
      when bt_when_m      do a_block_when_m(curr,blcontext,pblwhen_m(p));
      when bt_when_c      do a_block_when_c(curr,blcontext,pblwhen_c(p));
      when bt_if_cond     do a_block_if_cond(curr,blcontext,pblif_cond(p));
      -- uzly použité poprvé při optimalizaci
      when bt_loop1       do a_block_loop1(curr,blcontext,pblloop1(p));
      when others do verify({VERIFY=}000603,true);
      end case;

    -- aktualizovat množinu globálně vnořených příkazů
    bltop^.tra_cmd+p^.tra_cmd;

    -- aktualizovat příznak globálně vnořených vnějších skoků
    bltop^.tra_outer or p^.tra_outer;
    --%%X A co declare???
    if p^.btype<>bt_block 
      then bltop^.loc_outer or p^.loc_outer;
      else bltop^.tra_outer or p^.loc_outer;
      end if;

    -- další příkaz
    p:=p^.next;
    end loop;

  -- do množiny globálně vnořených příkazů započítat
  -- množinu lokálně vnořených příkazů
  bltop^.tra_cmd+bltop^.loc_cmd;

  -- do příznaku globálně vnořených vnějších skoků
  -- započítat příznak lokálně vnořených vnějších skoků
  {bltop^.tra_outer:=bltop^.tra_outer or bltop^.loc_outer;}
  end a_block_sequence;



----------------------------------------------------------------------------------------------------
procedure a_block =
-- Analýza bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  blcontext        : tblcontext;             -- kontext analyzovaného uzlu

begin
  verify({VERIFY=}000477,bl=nil);

  -- připravit kontext analýzy uzlu
  blcontext.blevel:=0;

  -- do top-level bloku dosadit počáteční úroveň vnoření
  bl^.blevel:=blcontext.blevel;

  -- analyzovat blok
  a_block_block(sym_primary_context(curr),blcontext,bl);
  end a_block;



----------------------------------------------------------------------------------------------------
procedure a_block_process_vars =
-- Zpracuje proměnné v uvedeném kontextu a vygeneruje inicializační/finalizační kód (volá postupně
-- [a_var_init], [a_var_entry] a [a_var_exit] do zadaného bloku.
----------------------------------------------------------------------------------------------------
with
  ca_analyzer.ca_var;

var
  binfo            : blinfo;                     -- kontext
  xinfo            : expinfo;                    -- kontext

begin
  -- připravit kontexty
  a_prepare_info(binfo,xinfo);

  -- inicializace statických lokálních proměnných (jen tříd)
  a_var_init(curr,bl^.binit,binfo,xinfo,mclass,recursive,classonly);

  -- zavolat entry statických lokálních proměnných
  a_var_entry(curr,bl^.bentry,binfo,xinfo,mclass,recursive);

  -- zavolat exit statických lokálních proměnných
  a_var_exit(curr,bl^.bexit,binfo,xinfo,mclass,recursive);

  -- zavolat rollback statických lokálních proměnných
  a_var_rollback(curr,bl^.brollback{???},binfo,xinfo,mclass,recursive);

  -- zavolat commit statických lokálních proměnných
  a_var_commit(curr,bl^.bcommit{???},binfo,xinfo,mclass,recursive);
  end a_block_process_vars;



end ca_block;
