----------------------------------------------------------------------------------------------------
module private cl_ia32 =
-- P©eklada‡ Flexu.
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_base,
  cc_base.cc_sym,
  cp_cpu,
  cp_cpu.cp_32,
  cl_map;

----------------------------------------------------------------------------------------------------
class private linkresolver_ia32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------

    with
      cx_expr,
      cx_expr.cx_def,
      cc_def.cc_var,
      cp_cpu.cp_32.cp_metadata,
      cg_gen,
      cg_gen.cg_ia32,
      cg_gen.cg_ia32.ci_struct
    #if debug2 then;
      ,cl_link.cl_debug
      #if codeview then;
      ,cl_link.cl_debug.cl_codeview
      #end if;
    #end if;
      ;  -- %%TODO(WITH) P©edˆlat na v¡ce WITH

    var
      -- v˜pl¤: NOPy
      fill_nops    : static const array t_unsigned8 of t_unsigned8 := [for others use $90];

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      imagebase:=_ibase;
      gran:=_gran;
      calign:=_calign;
      dalign:=_dalign;
      for s in tsegment loop
        seg[s].start:=_start;
        seg[s].len:=0;
        end loop;
      seg[tseg_code].start:=_ibase+_start;
      compi:=_compi;
      end init;



    ------------------------------------------------------------------------------------------------
    override trace =
    -- Projde tabulku relokac¡ symbolu CURR a pro ka‘d˜ symbol zavol¡ MARK.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure mark_entity (entity : pentity) =
        -- Pro zadanou entitu zavol  [mark], nen¡-li to pr vˆ zpracov van  entita.
        --------------------------------------------------------------------------------------------
        begin
          if entity<>curr then 
            mark(entity); 
            end if;
          end mark_entity;
    
    var
      zarad            : t_logical;                  -- T-zaradit na vyhodnocen¡ relokac¡
      pi               : picodeinst;

    begin
      -- je v–bec co trasovat ?
      if curr^.codegen=nil then 
        return; 
        end if;

      -- proj¡t v¨echny instance
      pi:=picodegen_subprog(curr^.codegen)^.ifirst;
      zarad:=false;
      while pi<>nil loop
        if pi^.r<>nil and then pi^.r^:length>0 then
          -- za©adit na vyhodnocen¡ relokac¡
          zarad:=true;

          -- ozna‡it symboly
          for i in pi^.r^:range loop
            case pi^.r^[i].relo_info.rtype
              when irt_none      do {nic nedˆlat};
              when irt_entity    do mark_entity(pi^.r^[i].relo_info.rentity);
              when irt_imm       do
                  if pexpimm(pi^.r^[i].relo_info.rexpr)^.linked=ls_undef then
                    pexpimm(pi^.r^[i].relo_info.rexpr)^.linked:=ls_used;
                    cdata.add(^pexpimm(pi^.r^[i].relo_info.rexpr)^.imm,pexpimm(pi^.r^[i].relo_info.rexpr)^.t.getctype);
                    end if;
              when irt_interface do mark_entity(pi^.r^[i].relo_info.rinterface^.refclass.getcentity);
              when others do verify(202,true);
              end case;
            end loop;
          end if;
        pi:=pi^.next;
        end loop;
      if zarad then reloc.add(curr); end if;
      end trace;



    ------------------------------------------------------------------------------------------------
    static assign_var_addresses =
    -- P©idˆl¡ adresy promˆnn˜m.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu,
      cp_cpu.cp_32,
      cp_cpu.cp_32.cp_def;

    var
      pvar             : pentity_var;                -- promˆnn 
      tmp_addr         : tunidata_addr;

    begin
      -- je v–bec co p©idˆlovat ?
      if list.list=nil then
        return;
        end if;

      for i in list.list^:range loop
        -- pro zjednodu¨en¡
        pvar:=pentity_var(list.list^[i]);
        verify(387,pvar^.linked<>ls_used or pvar^.etype<>et_var);

        -- alokovat pamˆŸ
        new picodegen_var(pvar^.codegen);

        -- p©idˆlit adresu
        picodegen_var(pvar^.codegen)^.addr:=addr.get_address_and_adjust(unidata_size_to_unsigned(pvar^.typ.getctype^.size));

        -- ozna‡it symbol jako vyhodnocen˜
        pvar^.linked:=ls_linked;

        -- zapsat do map filu
        tmp_addr:=prg32_to_unidata_addr(picodegen_var(pvar^.codegen)^.addr);
        map_static_variable(sym_get_qid(pvar),tmp_addr,pvar^.typ.getctype^.size);
        end loop;
      end assign_var_addresses;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_special_methods (
        codegen    : in picodegen_type;          -- ©¡d¡c¡ struktura gener toru k¢du
        ptyp       : in pentity_type) =          -- typ
    -- Do deskriptoru typu dosad¡ adresy speci ln¡ch metod.
    ------------------------------------------------------------------------------------------------
    var
      srch         : tentitysearch;              -- hled tko

    begin
      -- adresy speci ln¡ch metod
      srch.find_et_first(ptyp,rc_primary,et_special,[]);
      while srch.psym<>nil loop
        verify(412,(pentity_special(srch.psym)^.linked<>ls_linked)
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst=nil) 
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst
                  <>picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ilast));

        -- doplnit adresu instance do deskriptoru typu
        p_desc_type(picodegen_type(ptyp^.codegen)^.desc)^.spec_ptr[pentity_special(srch.psym)^.spectype]:=picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst^.cstart;
        --picodegen_addr(pdefspecial(srch.psym)^.codegen)^.addr;
        
        -- dal¨¡ speci ln¡ metoda
        srch.find_et_next;
        end loop;
      end build_type_descriptor_special_methods;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor_virtual_methods (
        interface  : in p_class_interface;       -- interface t©¡dy
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Do deskriptoru typu dosad¡ adresy virtu ln¡ch metod.
    ------------------------------------------------------------------------------------------------
    var
      pmethod      : pentity_code;
      reg_size     : t_mod_unsigned;

    begin
      reg_size:=t_mod_unsigned((t_mod_unsigned(picodegen_interface(interface^.codegen)^.vtable^:last)-t_mod_unsigned(picodegen_interface(interface^.codegen)^.vtable^:first)+1)*4);

      -- velikost tabulky virtu ln¡ metod zapo‡¡tat do celkov‚ho sou‡tu velikost– komponent deskriptoru
      addr.register_size({%%TODO(COMPATIBILITY}t_unsigned(reg_size));

      -- zpracovat v¨echny virtu ln¡ metody ve virtu ln¡ tabulce
      for vindex in 1..interface^.get_vtable_size loop
        -- dohledat implementaci virtu ln¡ metody
        pmethod:=interface^.get_virtual_method(vindex);
        verify(528,pmethod=nil or else (pmethod^.linked<>ls_linked
                or picodegen_subprog(pmethod^.codegen)^.ifirst=nil
                or picodegen_subprog(pmethod^.codegen)^.ifirst<>picodegen_subprog(pmethod^.codegen)^.ilast));

        -- doplnit adresu
        picodegen_interface(interface^.codegen)^.vtable^[interface^.normalize_vindex(vindex)]:=picodegen_subprog(pmethod^.codegen)^.ifirst^.cstart;
        end loop;
      end build_class_descriptor_virtual_methods;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_base (
        codegen    : in picodegen_type;          -- ©¡d¡c¡ struktura gener toru k¢du
        ptyp       : in pentity_type;            -- typ
        fake_tag   : in t_logical;               -- T-sestavujeme fake tag
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- P©iprav¡ z klad deskriptoru typu.
    -- Jestli‘e deskriptor typu odpov¡d  fake tagu, potom za p©edka zvol¡ sama sebe, v opa‡n‚m
    -- p©¡padˆ skute‡n‚ho p©edka dodan‚ho typu.
    ------------------------------------------------------------------------------------------------
    begin
      --%%RTTI

      -- p©idˆlit adresu a zapo‡¡tat velikost deskriptoru
      codegen^.addr:=addr.get_address;
      addr.register_size(codegen^.size{%%TODO(COMPATIBILITY) desc^:size});

      -- atribut :size
      codegen^.desc^.size:=unidata_size_to_unsigned(ptyp^.size);

      -- datov˜ typ
      codegen^.desc^.dtype:=datatype_code_table[ptyp^.stype];

      -- :tag p©edka
      if ptyp^.ancestor.isset then
        declare var
          ancestor : pentity_type;               -- p©edek

        begin
          -- p©edek pro zjednodu¨en¡
          if fake_tag
            -- pro fake tag pou‘¡t rovnou dodan˜ typ
            then ancestor:=ptyp;
            -- jinak naj¡t skute‡n‚ho p©edka
            else ancestor:=ptyp^.ancestor.getcentity;
            end if;

          -- na to aby mohl m¡t tag, mus¡ b˜t tagged
          if tf_tagged in ancestor^.tflags then
            verify(389,ancestor^.linked<>ls_linked or ancestor^.codegen=nil or ancestor^.codegen=codegen);
            codegen^.desc^.ancestor_tag:=picodegen_type(ancestor^.codegen)^.addr;
            end if;
          end declare;
        end if;
      end build_type_descriptor_base;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor (
        pclass     : in pentity_type;            -- t©¡da
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Sestav¡ deskriptor t©¡dy.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

        --------------------------------------------------------------------------------------------
        procedure new_codegen (
            interface : in p_class_interface;    -- interface t©¡dy
            is_exposed: in t_logical) =          -- T-je to exposovan˜ interface
        -- Alokuje ©¡d¡c¡ strukturu gener toru k¢du a deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        begin
          -- alokovat ©¡d¡c¡ strukturu
          new picodegen_interface(interface^.codegen);

          -- vypo‡¡tat velikost
          -- %%TODO(COMPATIBILITY) odstranit
          picodegen_interface(interface^.codegen)^.size:=t_desc_class:size;

          -- alokovat deskriptor
          new p_desc_class(picodegen_interface(interface^.codegen)^.desc);

          -- alokovat tabulku virtu ln¡ch metod
          new picodegen_interface(interface^.codegen)^.vtable range interface^.get_vtable_size;

          -- alokovat tabulku interfac–
          if is_exposed and then pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces>0 then
            new picodegen_interface(interface^.codegen)^.itable range pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces;
            end if;
          end new_codegen;



        --------------------------------------------------------------------------------------------
        procedure build_all (
            interface : in p_class_interface;    -- interface t©¡dy
            is_exposed: in t_logical) =          -- T-je to exposovan˜ interface
        -- Sestav¡ cel˜ deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        begin
          -- p©ipravit z klad deskriptoru typu
          build_type_descriptor_base(interface^.codegen,interface^.refclass.getcentity,is_exposed,addr);

          -- dosadit adresy speci ln¡ch metod
          build_type_descriptor_special_methods(interface^.codegen,interface^.refclass.getcentity);

          -- dosadit adresy virtu ln¡ch metod
          build_class_descriptor_virtual_methods(interface,addr);

          -- dosadit adresy interfac–
          {...}

          -- nyn¡ je ji‘ velikost v¨ech slo‘ek deskriptoru zapo‡¡tan , m–‘eme posunout adresu
          addr.compute_next_address;
          end build_all;

    var
      interface    : p_class_interface;          -- interface t©¡dy

    begin
      ----- zpracovat nativn¡ rozhran¡ t©¡dy -----
      -- z¡skat nativn¡ interface
      interface:=pclass^.interfaces^.get_native_interface;

      -- alokovat ©¡d¡c¡ strukturu deskriptor
      new_codegen(interface,false);

      -- zkop¡rovat pointer na ©¡d¡c¡ strukturu p©¡mo do t©¡dy
      pclass^.codegen:=interface^.codegen;

      -- sestavit deskriptor
      build_all(interface,false);


      ----- zpracovat v¨echny exposovan‚ interfacy -----
      declare var
        it         : c_list_iterator;            -- iter tor p©es rozhran¡ t©¡dy

      begin
        -- p©ipravit iter tor
        pclass^.interfaces^.get_exposed_interfaces(it);

        -- zpracovat v¨echny exposovan‚ interfacy
        while it.get(interface) loop
          -- alokovat ©¡d¡c¡ strukturu deskriptoru
          new_codegen(interface,true);

          -- sestavit deskriptor
          build_all(interface,true);
          end loop;
        end declare;
      end build_class_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor (
        ptyp       : in pentity_type;            -- typ
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Sestav¡ deskriptor typu jin‚ho ne‘ t©¡dy.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat pamˆŸ
      new picodegen_type(ptyp^.codegen);

      -- vypo‡¡tat velikost deskriptoru
      picodegen_type(ptyp^.codegen)^.size:=t_desc_type:size;

      -- alokovat deskriptor typu
      new p_desc_type(picodegen_type(ptyp^.codegen)^.desc);

      -- p©ipravit z klad deskriptoru typu
      build_type_descriptor_base(ptyp^.codegen,ptyp,false,addr);

      -- dosadit adresy speci ln¡ch metod
      build_type_descriptor_special_methods(ptyp^.codegen,ptyp);

      -- nyn¡ je ji‘ velikost v¨ech slo‘ek deskriptoru zapo‡¡tan , m–‘eme posunout adresu
      addr.compute_next_address;
      end build_type_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptors =
    -- Sestaven¡ deskriptor– typ–.
    ------------------------------------------------------------------------------------------------
    var
      ptyp         : pentity_type;               -- typ

    begin
      -- je v–bec co sestavovat ?
      if list.list=nil then
        return;
        end if;

      -- zpracovat v¨echny typy
      for i in list.list^:range loop
        -- pro zjednodu¨en¡
        ptyp:=pentity_type(list.list^[i]);
        verify(386,ptyp^.linked<>ls_used or ptyp^.etype not in ets_type or ptyp^.codegen<>nil);

        -- sestavit deskriptor pro tento typ
        if ptyp^.stype=dt_class
          then build_class_descriptor(ptyp,addr);
          else build_type_descriptor(ptyp,addr);
          end if;

        -- ozna‡it symbol jako vyhodnocen˜
        ptyp^.linked:=ls_linked;

        -- ozna‡it symbol jako vyhodnocen˜
        ptyp^.linked:=ls_linked;
        end loop;
      end build_type_descriptors;
   

      
    ------------------------------------------------------------------------------------------------
    static resolve_relocations =
    -- Vyhodnot¡ relokace dan‚ho symbolu.
    ------------------------------------------------------------------------------------------------
    with
      cg_gen.cg_ia32.ci_code,
      cg_gen.cg_ia32.ci_code.ci_instr;
    
    var
      modtemp   : t_mod_unsigned32;

    begin
      -- je v–bec co vyhodnocovat ?
      if inst.r=nil then 
        return; 
        end if;

      for i in inst.r^:range loop -- with inst.r^[i] loop
        declare var
          r        : inst.r^:base;

        begin
          -- pro zjednodu¨en¡, aŸ se neup¡¨eme
          r:=inst.r^[i];

          case r.relo_info.rtype
            -- pr zdn  relokace
            when irt_none     do { nic nedˆlat };

            -- symbol
            when irt_entity do
                case pentity(r.relo_info.rentity)^.etype
                  -- promˆnn 
                  when et_var  do 
                      verify(590,not r.absolute);
                      setfield(inst,r.disp,picodegen_var(pentity(r.relo_info.rentity)^.codegen)^.addr);
                      
                      -- zapamatuj
                      insertrelocaddrsorted(r.disp+picodegen_var(pentity(r.relo_info.rentity)^.codegen)^.addr);

                  -- procedura
                  when et_procedure do
                      if pentity_procedure(r.relo_info.rentity)^.import_info<>nil
                        
                        -- extern¡ symbol
                        then 
                          verify(591,not r.absolute);
                          setfield(inst,r.disp,getindirect(pentity_procedure(r.relo_info.rentity)));
                          
                          -- zapamatuj
                          insertrelocaddrsorted(r.disp+getindirect(pentity_procedure(r.relo_info.rentity)));
                        
                        -- norm ln¡ symbol }{%%X A kter  instance to je ?
                        else
                          if not r.absolute
                            then 
                              modtemp:=t_mod_unsigned32(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                              modtemp-t_mod_unsigned32((r.nextip+inst.cstart));
                              setfield(inst,r.disp,t_unsigned32(modtemp));
                            else 
                              setfield(inst,r.disp,picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                              
                              -- zapamatuj
                              insertrelocaddrsorted(r.disp+picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                              end if;
                          end if;

                  -- program, metoda, speci ln  metoda, kompila‡n¡ jednotka
                  when et_program, et_static, et_virtual, et_override, et_special, et_compile do
                      {%%X A kter  instance to je ? }
                      if not r.absolute
                        then 
                          modtemp:=t_mod_unsigned32(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                          modtemp-t_mod_unsigned32((r.nextip+inst.cstart));
                          setfield(inst,r.disp,t_unsigned32(modtemp));
                        else 
                          setfield(inst,r.disp,picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                          
                          -- zapamatuj
                          insertrelocaddrsorted(r.disp+picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                          end if;

                  -- ‡¡slo zpr vy
                  when et_message do
                      verify(592,not r.absolute);
                      setfield(inst,r.disp,unimsg_to_unsigned(pentity_message(r.relo_info.rentity)^.num));

                  -- tag typu/t©¡dy
                  when et_type,et_class do
                      verify(593,not r.absolute);
                      setfield(inst,r.disp,picodegen_type(pentity_type(r.relo_info.rentity)^.codegen)^.addr);
                      
                      -- zapamatuj
                      insertrelocaddrsorted(r.disp+picodegen_type(pentity_type(r.relo_info.rentity)^.codegen)^.addr);

                  when others do verify(33,true);
                  end case;                       

            -- p©¡m  hodnota
            when irt_imm do
                verify(307,not r.absolute);
                setfield(inst,r.disp,picodegen_imm(pexpimm(r.relo_info.rexpr)^.imm.codegen)^.addr);
                
                -- zapamatuj
                insertrelocaddrsorted(r.disp+picodegen_imm(pexpimm(r.relo_info.rexpr)^.imm.codegen)^.addr);

            -- interface t©¡dy
            when irt_interface do
                verify(695,not r.absolute);
                setfield(inst,r.disp,picodegen_type(r.relo_info.rinterface^.codegen)^.addr);
                
                -- zapamatuj
                insertrelocaddrsorted(r.disp+picodegen_type(r.relo_info.rinterface^.codegen)^.addr);

            when others do verify(203,true);
            end case;
          end declare;
        end loop;
      end resolve_relocations;



    ------------------------------------------------------------------------------------------------
    override link_segment_code =
    -- Segment: k¢d.
    ------------------------------------------------------------------------------------------------
    var
      block            : pimemblock;                 -- p©idˆlen˜ blok pamˆti
      p                : picodeinst;

    begin
      -- p©idˆlit adresy v¨em instanc¡m
      if code.list<>nil then
        for i in code.list^:range loop
          verify(594,code.list^[i]^.linked<>ls_used);

          --write_line(sym_get_qid(code.list^[i]));

          -- p©idˆlit adresy v¨em instanc¡m
          p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;
          loop
            -- p©idˆlit adresu
            p^.cstart:=_address.get_address_and_adjust(p^.c^:length);

            -- zapsat do listingu
            map_start_subprogram(sym_get_qid(code.list^[i]),unsigned_to_unidata_addr(p^.cstart));

            -- vypsat parametry
            if p^.profile.par<>nil then
              for j in p^.profile.par^:range loop
                map_automatic_variable(sym_get_qid(p^.profile.par^[j].pparam),
                    signed_to_unidata_addr(p^.profile.par^[j].ofs),
                    unsigned_to_unidata_size(p^.profile.par^[j].size));
                end loop;
              end if;

            -- vypsat lok ln¡ promˆnn‚
            block:=p^.layout.first;
            while block<>nil loop
              if block^.pvar<>nil
                then map_automatic_variable(sym_get_qid(block^.pvar),
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                else map_automatic_variable('<temporary>',
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                end if;
              block:=block^.next;
              end loop;

            -- © dkov‚ informace
            map_subprogram_lineinfo(unsigned_to_unidata_addr(p^.cstart),p^.di);

            -- konec
            map_end_subprogram;

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;

          -- ozna‡it za slinkovan‚
          code.list^[i]^.linked:=ls_linked;
          end loop;
        end if;
      end link_segment_code;



    ------------------------------------------------------------------------------------------------
    override link_segment_type_descriptors =
    -- Segment: deskriptory typ–.
    ------------------------------------------------------------------------------------------------
    begin
      build_type_descriptors(typedesc,_address);
      end link_segment_type_descriptors;



    ------------------------------------------------------------------------------------------------
    override link_segment_const =
    -- Segment: konstanty.
    ------------------------------------------------------------------------------------------------
    var
      pimm             : pimm_value;                 -- ukl dan  p©¡m  hodnota
      bin              : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      binsize          : tunidata_size;              -- velikost bin rn¡ho tvaru

    begin
      if cdata.list<>nil then
        for i in cdata.list^:range loop
          -- pro zjednodu¨en¡
          pimm:=cdata.list^[i].pimm;
          if pimm^.codegen=nil then
            -- alokovat pamˆŸ
            new picodegen_imm(pimm^.codegen);

            -- vypo‡¡tat po‘adovanou velikost pamˆti
            cpu^.getimmstoragesize(pimm^,cdata.list^[i].ptyp,binsize);

            -- p©idˆlit adresu
            picodegen_imm(pimm^.codegen)^.addr:=_address.get_address_and_adjust(unidata_size_to_unsigned(binsize));
            end if;
          end loop;
        end if;
      end link_segment_const;



    ------------------------------------------------------------------------------------------------
    override link_segment_init_var =
    -- Segment: inicializovan‚ promˆnn‚.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(idata,_address);
      end link_segment_init_var;



    ------------------------------------------------------------------------------------------------
    override link_segment_uninit_var =
    -- Segment: neinicializovan‚ promˆnn‚.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(data,_address);
      end link_segment_uninit_var;



    ------------------------------------------------------------------------------------------------
    override link =
    -- Sestaven¡.
    ------------------------------------------------------------------------------------------------
    with
      standard,standard.console, standard.conversions,
      cc_base,cc_base.cc_sym;

    var
      segment_address : c_address_aligner_32;    -- p©idˆlova‡ adres segment–

        --------------------------------------------------------------------------------------------
        procedure link_segment (
            _name  : in t_char32ustr;            -- popisn‚ jm‚no segmentu pro listing
            _seg   : in tsegment;                -- sestavovan˜ segment
          --_proc  : in p_link_segment;          -- metoda pro sestaven¡ zadan‚ho segmentu
            _align : in t_unsigned32) =          -- zarovn n¡ v r mci segementu
        -- Sestaven¡ zadan‚ho segmentu.
        --------------------------------------------------------------------------------------------
        var
          local_address : c_address_aligner_32;  -- p©idˆlova‡ adres v r mci segmentu

        begin
          -- zapsat do listingu za‡ tek segmentu
          map_start_segment(_name);

          -- po‡ te‡n¡ adresa segmentu
          seg[_seg].start:=segment_address.get_address;

          -- inicializovat p©idˆlova‡ adres v r mci segmentu
          local_address.init(segment_address.get_address,_align);

          -- vlastn¡ sestaven¡
          case _seg
            when tseg_code     do link_segment_code(local_address);
            when tseg_typedesc do link_segment_type_descriptors(local_address);
            when tseg_const    do link_segment_const(local_address);
            when tseg_init     do link_segment_init_var(local_address);
            when tseg_data     do link_segment_uninit_var(local_address);
            when tseg_import   do link_segment_import(local_address);
            when tseg_export   do link_segment_export(local_address);
            end case;

          -- vypo‡¡tat d‚lku segmentu
          seg[_seg].len:=local_address.get_address-segment_address.get_address;

          -- vypo‡¡tat adresu p©¡¨t¡ho segmentu
          segment_address.shift_address(seg[_seg].len);

          -- konec segmentu
          map_end_segment;
          end link_segment;

    var
      pimm             : pimm_value;                 -- ukl dan  p©¡m  hodnota
      bin              : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      binsize          : tunidata_size;              -- velikost bin rn¡ho tvaru
      p                : picodeinst;
      k                : t_unsigned32;               -- aktu ln¡ adresa
      ud_addr          : tunidata_addr;              -- adresa objektu
      ud_size          : tunidata_size;              -- velikost objektu
      avail            : t_logical;                  -- T-automatick  promˆnn  m  p©i©azenu adresu
      srch             : tentitysearch;
      block            : pimemblock;                 -- p©idˆlen˜ blok pamˆti

    begin
      -- inicializovat p©idˆlova‡ adres segment–
      segment_address.init(seg[tseg_code].start,gran);

      ----- F ze 1: vypo‡¡tat adresy k¢du -----
      -- p©idˆlit adresy v¨em instanc¡m
      link_segment('Code',tseg_code,calign);

      ----- F ze 2: p©idˆlit adresy promˆnn˜ch, konstant a deskriptor– -----
      -- 1. deskriptory typ–
      link_segment('Type Descriptors',tseg_typedesc,dalign);

      -- 2. konstanty
      link_segment('Constants',tseg_const,dalign);

      -- 3. inicializovan‚ promˆnn‚
      link_segment('Initialized Variables',tseg_init,dalign);

      -- 4. neinicializovan‚ promˆnn‚
      link_segment('Uninitialized Variables',tseg_data,dalign);

      ----- F ze 3.1 : p©ipravit importovan‚ funkce -----
      -- sestavit tabulku importovan˜ch funkc¡
      link_segment('Import',tseg_import,1);

      ----- F ze 3.2 : p©ipravit exportovan‚ funkce -----
      -- sestavit tabulku exportovan˜ch funkc¡
      link_segment('Export',tseg_export,1);

      ----- F ze 3.3 : vyhodnotit odkazy v k¢du -----
      if reloc.list<>nil then
        for i in reloc.list^:range loop
          p:=picodegen_subprog(reloc.list^[i]^.codegen)^.ifirst;
          loop
            -- vyhodnotit
            resolve_relocations(p^);

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;
          end loop;
        end if;

      ----- F ze 4 : debug informace -----
    #if debug2 then;
      -- jaky typ debug informaci budeme generovat
      if not cfg_no_debug_info then
      #if codeview then;
        case debug_mode
          -- CodeView debug inforation
          when tdit_codeview do new p_codeview(debug_info);
          end case;
      #end if;
        end if;

      -- generujeme nejake debug informace ?
      if debug_info<>nil then
        -- inicializace debug informaci
        debug_info^.init;

        -- sestavime strom s debug informacemi
        debug_info^.linkdebuginfo(compi,^this);
        end if;
    #end if;
      end link;



    ------------------------------------------------------------------------------------------------
    override info =
    -- V˜pis souhrnn˜ch informac¡ do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;



    ------------------------------------------------------------------------------------------------
    override getaddrbase =
    -- Adresa, ke kter‚ se vztahuj¡ relokace.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(imagebase);
      end getaddrbase;



    ------------------------------------------------------------------------------------------------
    override getentrypoint =
    -- Entrypoint programu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(picodegen_subprog(compi^.codegen)^.ifirst^.cstart);
      end getentrypoint;



    ------------------------------------------------------------------------------------------------
    override checkseg =
    -- True, pokud se m  zadan˜ segment zahrnout do EXE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=seg[_seg].len>0;
      end checkseg;



    ------------------------------------------------------------------------------------------------
    override getsegbase =
    -- B zov  adresa segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(seg[_seg].start);
      end getsegbase;



    ------------------------------------------------------------------------------------------------
    override getsegtotal =
    -- Celkov  velikost segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unidata_size(seg[_seg].len);
      end getsegtotal;



    ------------------------------------------------------------------------------------------------
    override writesegment =
    -- Do v˜stupn¡ho souboru zap¡¨e zadan˜ segment.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

    var
      bin          : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      allocsize    : tunidata_size;              -- velikost alokovan‚ pamˆti

        --------------------------------------------------------------------------------------------
        procedure write_imm (
            imm    : in timm_value;              -- p©¡m  hodnota
            ptyp   : in pentity_type;            -- typ
            full   : in t_logical) =             -- T-ulo‘it v d‚lce typu, F-v min. d‚lce
        -- Zap¡¨e do souboru p©¡mou hodnotu.
        --------------------------------------------------------------------------------------------
        with
          advanced,
          advanced.low_level;

        use
          advanced.low_level.unchecked_memory_access;

        var
          binsize  : tunidata_size;              -- velikost bin rn¡ho tvaru
          fill     : t_unsigned32;               -- velikost zarovn n¡
          x        : t_unsigned32;
          ud       : tunidata_size;

        begin
          -- ur‡it velikost bin rn¡ho tvaru
          cpu^.getimmstoragesize(imm,ptyp,binsize);

          -- realokovat pamˆŸ
          {%%X Nekompatibiln¡ s 64-bitovou implementac¡ }
          if binsize>allocsize

            -- alokovat nov˜ blok
            then
              discard bin;
              allocsize:=binsize;
              new bin range unidata_size_to_unsigned(allocsize);

            -- jinak jen fillznout ten star˜
            else
              unchecked_memory_access.memory_fill_zero(bin^,unidata_size_to_unsigned(allocsize))
              end if;

          -- sestavit bin rn¡ tvar
          cpu^.immtobinary(imm,ptyp,bin^,binsize);

          -- zapsat
          os^.writex(bin^,unidata_size_to_unsigned(binsize));

          -- vypo‡¡tat d‚lku zarovn n¡
          if full
            -- (+v˜pl¤ za konstantou krat¨¡ ne‘ je typ)
            then
              x:=unidata_size_to_unsigned(ptyp^.size);
              fill:=unidata_size_to_unsigned(ptyp^.size-binsize);
              if x mod dalign<>0 then 
                fill+(dalign-(x mod dalign)); 
                end if;
            -- (nezarovn v  se na velikost typu ale na velikost konstanty)
            else
              fill:=unidata_size_to_unsigned(binsize);
              if fill mod dalign<>0
                then fill:=dalign-(fill mod dalign);
                else fill:=0;
                end if;
              end if;

          -- zarovnat
          ffillz(os,fill);
          end write_imm;



        --------------------------------------------------------------------------------------------
        procedure write_type_desc (
            codegen: in picodegen_type) =        -- deskriptor typu
        -- Zap¡¨e do souboru deskriptor typu.
        --------------------------------------------------------------------------------------------
        begin
          -- zapsat deskriptor
          os^.writex(codegen^.desc^,t_desc_type:size{%%TODO(COMPATIBILITY) codegen^.desc^:size});

          -- zarovnat
          if codegen^.size{%%TODO(COMPATIBILITY) desc^:size} mod dalign<>0 then 
            os^.writex(fill_nops,dalign-(codegen^.size{%%TODO(COMPATIBILITY) desc^:size} mod dalign)); 
            end if;
          end write_type_desc;



        --------------------------------------------------------------------------------------------
        procedure write_class_desc (
            codegen: in picodegen_interface) =   -- deskriptor t©¡dy (resp. interfacu)
        -- Zap¡¨e do souboru deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        var
          size     : t_unsigned;                 -- kumulativn¡ velikost v¨ech slo‘ek
          modtemp  : t_mod_unsigned;

        begin
          -- z klad tvo©¡ deskriptor typu
          os^.writex(codegen^.desc^,t_desc_class:size{%%TODO(COMPATIBILITY) codegen^.desc^:size});
          size+t_desc_class:size{%%TODO(COMPATIBILITY) codegen^.desc^:size};

          -- n sleduje virtu ln¡ tabulka
          if codegen^.vtable<>nil then
            modtemp:=(t_mod_unsigned(codegen^.vtable^:last)-t_mod_unsigned(codegen^.vtable^:first)+1)*4;
            os^.writex(codegen^.vtable^,t_unsigned(modtemp));
                       {%%TODO(COMPATIBILITY) codegen^.vtable^:size);}
            size+t_unsigned(modtemp);
            end if;

          -- a tabulka interfac– 
          {...}

          -- zarovn n¡
          if size mod dalign<>0 then 
            os^.writex(fill_nops,dalign-(size mod dalign)); 
            end if;
          end write_class_desc;



    var
      pvar             : pentity_var;                -- promˆnn 
      size             : t_unsigned32;               -- velikost promˆnn‚
      fill             : t_unsigned32;               -- velikost dodate‡n‚ v˜plnˆ
      imm              : pimm_value;                 -- p©¡m  hodnota
      pcodegen         : picodegen_type;
      p                : picodeinst;

    begin
      case _seg
        -- k¢d
        when tseg_code do
            for i in code.list^:range loop
              p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;

              -- zapsat v¨echny instance
              loop
                -- zapsat instrukce
                os^.writex(p^.c^[p^.c^:first],p^.c^:length);

                -- zarovnat
                if p^.c^:length mod calign<>0 then 
                  os^.writex(fill_nops,calign-(p^.c^:length mod calign)); 
                  end if;

                -- dal¨¡ instance
                p:=p^.next;
                until p=nil;
              end loop;

        -- deskriptory typ–
        when tseg_typedesc do
            for i in typedesc.list^:range loop
              if typedesc.list^[i]^.etype=et_class
                -- pro t©¡du se mus¡ zapsat deskriptory v¨ech interfac–
                then
                  declare var
                    it        : c_list_iterator; -- iter tor p©es rozhran¡ t©¡dy
                    interface : p_class_interface; -- interface t©¡dy

                  begin
                    -- p©ipravit iter tor
                    pentity_type(typedesc.list^[i])^.interfaces^.get_all_interfaces(it);

                    -- zpracovat v¨echny exposovan‚ interfacy
                    while it.get(interface) loop
                      write_class_desc(interface^.codegen);
                      end loop;
                    end declare;

                -- pro typ pouze jeden deskriptor
                else
                  write_type_desc(typedesc.list^[i]^.codegen);
                  end if;
              end loop;

        -- konstanty
        when tseg_const do
            allocsize:=uds_0;
            bin:=nil;
            for i in cdata.list^:range loop
              write_imm(cdata.list^[i].pimm^,cdata.list^[i].ptyp,false);
              end loop;
            discard bin;

        -- inicializovan  data
        when tseg_init do
            allocsize:=uds_0;
            bin:=nil;
            for i in idata.list^:range loop 
              write_imm(pentity_var(idata.list^[i])^.init.getimm^,pentity_var(idata.list^[i])^.typ.getctype,true); 
              end loop;
            discard bin;

        -- neinicializovan  data
        when tseg_data do { nen¡ co zapisovat };

        -- importy
        when tseg_import do { nev¡m jak zapsat };

        -- exporty
        when tseg_export do { nev¡m jak zapsat };

        when others do verify(204,true);
        end case;
      end writesegment;



    ------------------------------------------------------------------------------------------------
    virtual getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=0;
      end getindirect;

    end linkresolver_ia32;



----------------------------------------------------------------------------------------------------
class private linkresolver_ia32_win32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: Win32 na IA-32.
----------------------------------------------------------------------------------------------------

    with
      cp_cpu.cp_32.cp_def,
      cp_os,
      cp_os.cp_win32;

    ------------------------------------------------------------------------------------------------
    override link_segment_import =
    -- Linkov n¡ segmentu: importovan‚ entity.
    ------------------------------------------------------------------------------------------------
    with
      standard.templates;

    begin
      -- je v–bec co importovat ?
      if import.list=nil or else import.list^:length=0 then 
        map_write_line('No imported entities');
        return; 
        end if;

      -- set©¡dit importovan‚ funkce
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=import.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pimportinfo(pentity_procedure(import.list^[j])^.import_info)^.libname>pimportinfo(pentity_procedure(import.list^[j+1])^.import_info)^.libname then
              --%%TODO(#TEMPLATE) exchange(import.list^[j],import.list^[j+1]);
              declare var
                psym : pentity;
              begin
                psym:=import.list^[j];
                import.list^[j]:=import.list^[j+1];
                import.list^[j+1]:=psym;
                end declare;
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;

      -- p©i©adit adresy na adresy procedur
      for i in import.list^:range loop
        -- mezera p©i zmˆnˆ knihovny
        if i>import.list^:first and pimportinfo(pentity_procedure(import.list^[i-1])^.import_info)^.libname<>pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname then
          _address.shift_address(lprg32);
          end if;

        -- adresa
        pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.addr:=_address.get_address_and_adjust(lprg32);
        end loop;

      -- mezera za posledn¡ knihovnou
      _address.shift_address(lprg32);
      end link_segment_import;



    ------------------------------------------------------------------------------------------------
    override link_segment_export =
    -- Linkov n¡ segmentu: exportovan‚ entity.
    ------------------------------------------------------------------------------------------------
    with 
      standard.templates,                           
      cc_def.cc_var;

    begin
      -- je v–bec co exportovat ?
      if export_list.list=nil or else export_list.list^:length=0 then 
        map_write_line('No exported entities');
        return; 
        end if;

      -- zjistit plne kvalifikovana jmena exportu
      for i in export_list.list^:range loop
        pexportinfo(pentity_procedure(export_list.list^[i])^.export_info)^.export_name:=sym_get_qid(export_list.list^[i]);
        end loop;
      
      -- set©¡dit podle exportovan˜ch jmen
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=export_list.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pexportinfo(pentity_procedure(export_list.list^[j])^.export_info)^.export_name>pexportinfo(pentity_procedure(export_list.list^[j+1])^.export_info)^.export_name then
              --%%TODO(#TEMPLATE) exchange(export_list.list^[j],export_list.list^[j+1]);
              declare var
                psym : pentity;
              begin
                psym:=export_list.list^[j];
                export_list.list^[j]:=export_list.list^[j+1];
                export_list.list^[j+1]:=psym;
                end declare;
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;

      -- vypsat exporty do listingu
      map_write_line('Exported symbols:');
      for i in export_list.list^:range loop
        map_exported_entity(sym_get_qid(export_list.list^[i]));
        end loop;
      end link_segment_export;



    ------------------------------------------------------------------------------------------------
    override getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=pimportinfo(proc^.import_info)^.addr;
      end getindirect;
    
    end linkresolver_ia32_win32;



end cl_ia32;