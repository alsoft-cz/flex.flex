----------------------------------------------------------------------------------------------------
module private cl_ia32 =
-- Překladač Flexu.
-- Vyhodnocovač cross-referencí a adres: IA-32.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.04.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_gc,
  cc_base,
  cc_base.cc_sym,
  cp_os,
  cp_cpu,
  cp_cpu.cp_32,
  cp_cpu.cp_32.cp_def,
  cl_map;

----------------------------------------------------------------------------------------------------
#template build_section (section,data_buffer,build_method,parameters);
-- Volání sestavení section image-specifickou metodou.
----------------------------------------------------------------------------------------------------
  declare var
    wr             : c_stream_binary_writer;     -- binární zapisovač do streamu

  begin
    -- připravit zapisovač
    wr.init_writer(^c_output_stream:(data_buffer));

    -- sestavit sekci image-specifickou metodou
    image_specific.build_method(wr,parameters);

    -- konec dat
    c_output_stream:(data_buffer).write_eod;
    
    -- zaznamenat celkovou velikost dat sekce
    declare var
      size         : t_offset;
    begin  
      c_output_stream:(data_buffer).get_flow(size);
      _address.shift_address(size);
      --seg[section].len:=size;
      end declare;
    end declare;
  #end build_section;



----------------------------------------------------------------------------------------------------
class private abstract c_link_resolver_ia32 =
-- Vyhodnocovač cross-referencí a adres: IA-32.
----------------------------------------------------------------------------------------------------

    with
      cx_expr,
      cx_expr.cx_def,
      cc_def.cc_var,
      cp_cpu.cp_32.cp_metadata,
      cg_gen,
      cg_gen.cg_ia32,
      cg_gen.cg_ia32.ci_struct,
      cl_link.cl_debug
      #if codeview then;,
      cl_link.cl_debug.cl_codeview
      #end if;
      ;  -- %%TODO(WITH) Předělat na více WITH

    var
      -- výplň: NOPy
      fill_nops    : static const array t_unsigned8 of t_unsigned8 := [for others use $90];

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      imagebase:=unicode_addr_to_unsigned(_ibase);
      gran:=_gran;
      calign:=_calign;
      dalign:=_dalign;
      for s in t_image_section loop
        seg[s].start:=_start;
        seg[s].len:=0;
        end loop;
      seg[tis_code].start:=imagebase+_start;
      compi:=_compi;
      end init;



    ------------------------------------------------------------------------------------------------
    override trace =
    -- Projde tabulku relokací symbolu CURR a pro každý symbol zavolí MARK.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure mark_entity (entity : pentity) =
        -- Pro zadanou entitu zavolá [mark], není-li to právě zpracovávaná entita.
        --------------------------------------------------------------------------------------------
        begin
          if entity<>curr then 
            verify({VERIFY=}001385,entity=nil);
            mark_single(entity); 
            end if;
          end mark_entity;

    var
      zarad            : t_logical;                  -- T-zaradit na vyhodnocení relokací
      pi               : picodeinst;

    begin
      -- je vůbec co trasovat ?
      if curr^.codegen=nil then 
        return; 
        end if;

      -- projít všechny instance
      pi:=picodegen_subprog(curr^.codegen)^.ifirst;
      zarad:=false;
      while pi<>nil loop
        if pi^.r<>nil and then pi^.r^:length>0 then
          -- zařadit na vyhodnocení relokací
          zarad:=true;

          -- označit symboly
          for i in pi^.r^:range loop
            case pi^.r^[i].relo_info.rtype
              when irt_none      do {nic nedělat};
              when irt_entity    do mark_entity(pi^.r^[i].relo_info.rentity);
              when irt_imm       do
                  if pexpimm(pi^.r^[i].relo_info.rexpr)^.linked=ls_undef then
                    pexpimm(pi^.r^[i].relo_info.rexpr)^.linked:=ls_used;
                    cdata.add(^pexpimm(pi^.r^[i].relo_info.rexpr)^.imm,pexpimm(pi^.r^[i].relo_info.rexpr)^.t.getctype);
                    end if;
              when irt_interface do mark_entity(pi^.r^[i].relo_info.rinterface^.refclass.getcentity);
              when irt_section   do {nic nedělat};
              when others do verify({VERIFY=}000202,true);
              end case;
            end loop;
          end if;
        pi:=pi^.next;
        end loop;
      if zarad then reloc.add(curr); end if;
      end trace;



    ------------------------------------------------------------------------------------------------
    static assign_var_addresses =
    -- Přidělí adresy proměnným.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu,
      cp_cpu.cp_32,
      cp_cpu.cp_32.cp_def;

    var
      pvar             : pentity_var;                -- proměnná
      tmp_addr         : tunidata_addr;

    begin
      -- je vůbec co přidělovat ?
      if list.list=nil then
        return;
        end if;

      for i in list.list^:range loop
        -- pro zjednodušení
        pvar:=pentity_var(list.list^[i]);
        verify({VERIFY=}000387,pvar^.linked<>ls_used or pvar^.etype<>et_var);

        -- alokovat paměť
        new picodegen_var(pvar^.codegen);
        c_garbage_collector.get_instance^.register_record(pvar^.codegen);

        -- přidělit adresu
        picodegen_var(pvar^.codegen)^.addr:=addr.get_address_and_adjust(unidata_size_to_unsigned(pvar^.typ.getctype^.size));

        -- označit symbol jako vyhodnocený
        pvar^.linked:=ls_linked;

        -- zapsat do map filu
        tmp_addr:=prg32_to_unidata_addr(picodegen_var(pvar^.codegen)^.addr);
        map_static_variable(sym_get_qid(pvar),tmp_addr,pvar^.typ.getctype^.size);
        end loop;
      end assign_var_addresses;



    ------------------------------------------------------------------------------------------------
    #template new_entity_descriptor (
        codegen,                                 -- řídící struktura
        codegen_type,                            -- typ pointeru na typ řídící struktury
        desc_type);                              -- typ pointeru na typ deskriptoru
    -- Alokuje řídící strukturu generátoru kódu a deskriptor.
    ------------------------------------------------------------------------------------------------
      -- alokovat paměť
      new codegen_type(codegen);
      c_garbage_collector.get_instance^.register_record(codegen);

      -- vypočítat velikost deskriptoru
      codegen_type(codegen)^.desc_size:=desc_type:base:size;

      -- alokovat deskriptor typu
      new desc_type(codegen_type(codegen)^.desc);
      c_garbage_collector.get_instance^.register_record(codegen_type(codegen)^.desc);
      #end new_entity_descriptor;



    ------------------------------------------------------------------------------------------------
    #template set_tag (
        base_addr,                               -- bázová absolutní adresa struktury, ve které je položka
        tag_field,                               -- položka, do které se ukládá tag
        src_codegen,                             -- řídící struktura entity jejíž tag se zjišťuje
        src_partition_id);                       -- ID partition, do které spadá entita jejíž tag se zjišťuje
    -- Přiřadí do položky [tag_field] hodnotu tagu entity reprezentované řídící strukturou 
    -- [src_codegen] a vygeneruje odpovídající load-time relokaci.
    ------------------------------------------------------------------------------------------------
      verify({VERIFY=}000820,src_codegen=nil);

      -- přiřadit do položky tag
      tag_field:=picodegen_metadata(src_codegen)^.desc_addr;

      -- vygenerovat relokaci
      add_relocation(src_partition_id,base_addr+tag_field:position,trd_absolute);
      -- %%TOOD(RELOCATION) Hynkůůůůů
      #end set_tag;



    ------------------------------------------------------------------------------------------------
    static get_vtable_size (
        codegen    : in picodegen_interface)     -- řídící struktura generátoru kódu
        return t_unsigned =                      -- velikost virtuální tabulky
    -- Zjistí velikost virtuální tabulky.
    ------------------------------------------------------------------------------------------------
    begin
      result:=codegen^.vtable^:length*codegen^.vtable^:base:size;
      end get_vtable_size;



    ------------------------------------------------------------------------------------------------
    static get_itable_size (
        codegen    : in picodegen_interface)     -- řídící struktura generátoru kódu
        return t_unsigned =                      -- velikost tabulky interfaců
    -- Zjistí velikost interfaců.                           
    ------------------------------------------------------------------------------------------------
    begin
      result:=codegen^.itable^:length*codegen^.itable^:base:size+codegen^.itable^:length:size;
      end get_itable_size;



    ------------------------------------------------------------------------------------------------
    static get_vtable_addr (
        codegen    : in picodegen_interface)     -- řídící struktura generátoru kódu
        return t_unsigned =                      -- adresa virtuální tabulky
    -- Zjistí absolutní adresu virtuální tabulky.
    ------------------------------------------------------------------------------------------------
    begin
      -- virtuální tabulka leží hned za deskriptorem
      result:=codegen^.desc_addr+codegen^.desc_size;
      end get_vtable_addr;



    ------------------------------------------------------------------------------------------------
    static get_itable_addr (
        codegen    : in picodegen_interface)     -- řídící struktura generátoru kódu
        return t_unsigned =                      -- adresa tabulky interfaců
    -- Zjistí absolutní adresu tabulky interfaců.                           
    ------------------------------------------------------------------------------------------------
    begin
      -- tabulka interfaců leží hned za virtuální tabulkou
      result:=get_vtable_addr(codegen)+get_vtable_size(codegen);
      end get_itable_addr;



    ------------------------------------------------------------------------------------------------
    static get_itable_entry_addr (
        codegen    : in picodegen_interface;     -- řídící struktura generátoru kódu
        index      : in t_interface_table:range) -- index položky tabulky interfaců
        return t_unsigned =                      -- adresa tabulky interfaců
    -- Zjistí absolutní adresu [index]-té položky tabulky interfaců.
    ------------------------------------------------------------------------------------------------
    begin
      -- tabulka interfaců leží hned za virtuální tabulkou
      result:=p_desc_class(codegen^.desc)^.itable+codegen^.itable^:length:size+codegen^.itable^:base:size*(index-1);
      end get_itable_entry_addr;



    ------------------------------------------------------------------------------------------------
    static build_entity_descriptor (
        codegen    : in picodegen_metadata;      -- řídící struktura generátoru kódu
        entity     : in pentity;                 -- entita, obecně nezávislá na řídící struktuře
        addr       : in out c_address_aligner_32;-- přidělovač adres
        fake_tag   : in t_logical := false) =    -- T-sestavujeme fake deskriptor
    -- Sestaví základ deskriptoru každé entity. 
    -- Deskriptoru přidělí adresu, a to metodou pro vícekrokový posun.
    --
    -- Upozornění: Tato procedura musí být volána jako první pro každý deskriptor. Před samotným
    -- deskriptorem alokuje prostor pro jeho kvalifikovaný identifikátor.
    ------------------------------------------------------------------------------------------------
    begin
      -- kvalifikovaný identifikátor entity
      -- %%TODO(QID) dodělat generování kvalifikovaného identifikátoru
      codegen^.desc_qid:=entity^.id;
      if codegen^.desc_qid<>nil then
        codegen^.desc^.id:=addr.get_address_and_adjust(4+codegen^.desc_qid^:length*4);
        end if;

      -- přidělit adresu a započítat velikost deskriptoru 
      -- (musí se dělat až po přidělení prostoru pro identifikátor)
      codegen^.desc_addr:=addr.get_address;
      addr.register_size(codegen^.desc_size{%%TODO(COMPATIBILITY) desc^:size});

      -- kód entity
      codegen^.desc^.etype:=entity_code_table[entity^.etype];

      -- předek
      declare var
        ancestor   : pentity;                    -- předek

      begin
        -- zvolit předka s ohledem na fakeovost deskriptoru
        if fake_tag
          -- pro fake tag použít rovnou dodanou entitu
          then ancestor:=entity;
          -- jinak najít skutečného předkae
          else ancestor:=entity^.ancestor.getuentity;
          end if;

        -- nalezl-li se, tak doplnit do deskriptoru jeho tag
        if ancestor<>nil then
          verify({VERIFY=}000389,not fake_tag and then ancestor^.linked<>ls_linked);
          verify({VERIFY=}000968,ancestor^.codegen=nil);
          verify({VERIFY=}000969,not fake_tag and then ancestor^.codegen=entity^.codegen);
          set_tag(codegen^.desc_addr,codegen^.desc^.ancestor_tag,ancestor^.codegen,ancestor^.partition_id);
          end if;
        end declare;
      end build_entity_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_special_methods (
        codegen    : in picodegen_type;          -- řídící struktura generátoru kódu
        ptyp       : in pentity_type) =          -- typ
    -- Do deskriptoru typu dosadí adresy speciálních metod.
    ------------------------------------------------------------------------------------------------
    var
      srch         : tentitysearch;              -- hledátko

    begin
      -- adresy speciálních metod
      srch.find_et_first(ptyp,rc_primary,et_special,[]);
      while srch.psym<>nil loop
        verify({VERIFY=}000412,(pentity_special(srch.psym)^.linked<>ls_linked)
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst=nil) 
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst
                  <>picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ilast));

        -- doplnit adresu instance do deskriptoru typu
        p_desc_type(picodegen_type(ptyp^.codegen)^.desc)^.spec_ptr[pentity_special(srch.psym)^.spectype]:=picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst^.cstart;

        -- zapamatovat si relokaci pro generování EXE
        add_relocation(srch.psym^.partition_id,codegen^.desc_addr+t_desc_type.spec_ptr:position+pentity_special(srch.psym)^.spectype:ord*t_desc_type.spec_ptr:base:size,trd_absolute);

        -- další speciální metoda
        srch.find_et_next;
        end loop;
      end build_type_descriptor_special_methods;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor_virtual_methods (
        interface  : in p_class_interface;       -- interface třídy
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Do deskriptoru typu dosadí adresy virtuálních metod.
    ------------------------------------------------------------------------------------------------
    var
      vtable_addr  : tdata32;                    -- absolutní adresa virtuální tabulky

    begin
      -- velikost tabulky virtuální metod započítat do celkového součtu velikostí komponent deskriptoru
      addr.register_size(get_vtable_size(interface^.codegen));

      -- vypočítat absolutní adresu virtuální tabulky, bude se hodit
      vtable_addr:=get_vtable_addr(interface^.codegen);

      -- poznamenat adresu tabulky virtuálních metod pro nepřímý přístup
      p_desc_class(picodegen_interface(interface^.codegen)^.desc)^.vtable:=vtable_addr;

      -- zapamatovat si relokaci pro generování EXE
      add_relocation(curr_partition,picodegen_interface(interface^.codegen)^.desc_addr+t_desc_class.vtable:position,trd_absolute);

      -- zpracovat všechny virtuální metody ve virtuální tabulce
      for vindex in 1..interface^.get_vtable_size loop
        declare var
          pmethod  : pentity_code;

        begin           
          -- dohledat implementaci virtuální metody
          pmethod:=interface^.get_virtual_method(vindex);
          verify({VERIFY=}000528,pmethod=nil or else (pmethod^.linked<>ls_linked
                  or picodegen_subprog(pmethod^.codegen)^.ifirst=nil
                  or picodegen_subprog(pmethod^.codegen)^.ifirst<>picodegen_subprog(pmethod^.codegen)^.ilast));

          -- doplnit adresu
          picodegen_interface(interface^.codegen)^.vtable^[interface^.normalize_vindex(vindex)]:=picodegen_subprog(pmethod^.codegen)^.ifirst^.cstart;

          -- zapamatovat si relokaci pro generování EXE
          add_relocation(pmethod^.partition_id,vtable_addr+interface^.normalize_vindex(vindex)*t_vptr_table:base:size,trd_absolute);
          end declare;
        end loop;
      end build_class_descriptor_virtual_methods;



    ------------------------------------------------------------------------------------------------
    static build_prepare_class_descriptor_interfaces (
        interface  : in p_class_interface;       -- interface třídy
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Do deskriptoru typu dosadí informace o interfacech.
    -- Část 1: příprava tabulky interfaců.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes.lists;

    var
      it           : c_list_iterator;            -- iterátor přes rozhraní třídy
      exposed_iface: p_class_interface;          -- exposovaný interface
      itable_addr  : t_unsigned;                 -- absolutní adresa tabulky interfaců

    begin
      verify({VERIFY=}000724,picodegen_interface(interface^.codegen)^.itable=nil);

      -- vypočítat absolutní adresu tabulky interfaců, bude se hodit
      itable_addr:=get_itable_addr(interface^.codegen);

      -- poznamenat adresu tabulky interfaců pro nepřímý přístup
      p_desc_class(picodegen_interface(interface^.codegen)^.desc)^.itable:=itable_addr;

      -- zapamatovat si relokaci pro generování EXE
      add_relocation(curr_partition,picodegen_interface(interface^.codegen)^.desc_addr+t_desc_class.itable:position,trd_absolute);

      -- připravit iterátor
      pentity_type(interface^.refclass.getcentity)^.interfaces^.get_exposed_interfaces(it);

      -- pro každý exposovaný interface vygenerovat záznam do tabulky interfaců
      while it.get(exposed_iface) loop
        declare var
          ref_iface: t_ref_interface;            -- položka tabulky interfaců

        begin
          -- Přesunuto do jiné fáze. V této době ještě nejsou k dispozici fake tagy interfaců.
          -- -- doplnit tag třídy-interfacu
          -- set_tag(itable_addr,
          --         ref_iface.class_tag,
          --         picodegen_interface(exposed_iface^.codegen));

          -- doplnit offset instance interfaceu v rámci nadřazené instance
          ref_iface.offset:=unidata_addr_to_imm32(pentity_var(exposed_iface^.instance.getcentity)^.addr);

          -- přidat novou položku do tabulky interfaců
          picodegen_interface(interface^.codegen)^.itable^ & ref_iface;
          verify({VERIFY=}001006,picodegen_interface(interface^.codegen)^.itable^:length<>exposed_iface^.interface_index);
          end declare;
        end loop;

      -- velikost tabulky interfaců započítat do celkového součtu velikostí komponent deskriptoru
      addr.register_size(get_itable_size(interface^.codegen));
      end build_prepare_class_descriptor_interfaces;



    ------------------------------------------------------------------------------------------------
    static build_finalize_class_descriptor_interfaces (
        native_iface : in p_class_interface) =   -- interface třídy
    -- Do deskriptoru typu dosadí informace o interfacech.
    -- Část 2: doplnění tagů interfaců.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes.lists;

    var
      it           : c_list_iterator;            -- iterátor přes rozhraní třídy
      exposed_iface: p_class_interface;          -- exposovaný interface

    begin
      verify({VERIFY=}001004,picodegen_interface(native_iface^.codegen)^.itable=nil);

      -- připravit iterátor
      pentity_type(native_iface^.refclass.getcentity)^.interfaces^.get_exposed_interfaces(it);

      -- pro každý exposovaný interface vygenerovat záznam do tabulky interfaců
      while it.get(exposed_iface) loop
        --p_desc_class(picodegen_interface(native_iface^.codegen)^.desc)^.itable+t_interface_table:length:size+t_interface_table:base:size*(exposed_iface^.interface_index-1),

        -- doplnit tag třídy-interfacu
        set_tag(get_itable_entry_addr(native_iface^.codegen,exposed_iface^.interface_index),
                picodegen_interface(native_iface^.codegen)^.itable^[exposed_iface^.interface_index].class_tag,
                picodegen_interface(exposed_iface^.codegen),
                curr_partition{exposed_iface^.instance.getcentity^.partition_id});
        end loop;
      end build_finalize_class_descriptor_interfaces;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_base (
        codegen    : in picodegen_type;          -- řídící struktura generátoru kódu
        ptyp       : in pentity_type;            -- typ
        fake_tag   : in t_logical;               -- T-sestavujeme fake tag
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Připraví základ deskriptoru typu (zajišťuje též volání [build_entity_descriptor]).
    -- Jestliže deskriptor typu odpovídá fake tagu, potom za předka zvolí sama sebe, v opačném
    -- případě skutečného předka dodaného typu.
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}000821,tf_tagged not in ptyp^.tflags or else (ptyp^.ancestor.isset and then tf_tagged not in pentity_type(ptyp^.ancestor.getcentity)^.tflags));

      -- připravit základ deskriptoru entity
      build_entity_descriptor(codegen,ptyp,addr,fake_tag);

      -- atribut :size
      p_desc_type(codegen^.desc)^.size:=unidata_size_to_unsigned(ptyp^.size);

      -- datový typ
      p_desc_type(codegen^.desc)^.dtype:=datatype_code_table[ptyp^.stype];
      end build_type_descriptor_base;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor (
        pclass     : in pentity_type;            -- třída
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Sestaví deskriptor třídy.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

        --------------------------------------------------------------------------------------------
        procedure new_codegen (
            interface : in p_class_interface;    -- interface třídy
            is_exposed: in t_logical) =          -- T-je to exposovaný interface
        -- Alokuje řídící strukturu generátoru kódu a deskriptor třídy.
        --------------------------------------------------------------------------------------------
        begin
          -- alokovat řídící strukturu
          new_entity_descriptor(interface^.codegen,picodegen_interface,p_desc_class);

          -- alokovat tabulku virtuálních metod
          new picodegen_interface(interface^.codegen)^.vtable range interface^.get_vtable_size;
          c_garbage_collector.get_instance^.register_memblock(picodegen_interface(interface^.codegen)^.vtable);

          -- alokovat tabulku interfaců
          if not is_exposed and then pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces>0 then
            new picodegen_interface(interface^.codegen)^.itable range pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces;
            c_garbage_collector.get_instance^.register_memblock(picodegen_interface(interface^.codegen)^.itable);
            end if;
          end new_codegen;



        --------------------------------------------------------------------------------------------
        procedure build_all (
            interface : in p_class_interface;    -- interface třídy
            is_exposed: in t_logical) =          -- T-je to exposovaný interface
        -- Sestaví celý deskriptor třídy.
        --------------------------------------------------------------------------------------------
        begin
          -- připravit základ deskriptoru typu
          build_type_descriptor_base(interface^.codegen,interface^.refclass.getcentity,is_exposed,addr);

          -- dosadit adresy speciálních metod
          build_type_descriptor_special_methods(interface^.codegen,interface^.refclass.getcentity);

          -- dosadit adresy virtuálních metod
          build_class_descriptor_virtual_methods(interface,addr);

          -- dosadit adresy interfaců
          if not is_exposed and then pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces>0 then
            build_prepare_class_descriptor_interfaces(interface,addr);
            end if;

          -- nyní je již velikost všech složek deskriptoru započítaná, můžeme posunout adresu
          addr.compute_next_address;
          end build_all;

    var
      native_iface : p_class_interface;          -- interface třídy

    begin
      ----- zpracovat nativní rozhraní třídy -----
      -- získat nativní interface
      native_iface:=pclass^.interfaces^.get_native_interface;

      -- alokovat řídící strukturu deskriptor
      new_codegen(native_iface,false);

      -- zkopírovat pointer na řídící strukturu přímo do třídy
      pclass^.codegen:=native_iface^.codegen;

      -- sestavit deskriptor
      build_all(native_iface,false);


      ----- zpracovat všechny exposované interfacy -----
      declare var
        it            : c_list_iterator;         -- iterátor přes rozhraní třídy
        exposed_iface : p_class_interface;       -- exposovaný interface

      begin
        -- připravit iterátor
        pclass^.interfaces^.get_exposed_interfaces(it);

        -- zpracovat všechny exposované interfacy
        while it.get(exposed_iface) loop
          -- alokovat řídící strukturu deskriptoru
          new_codegen(exposed_iface,true);

          -- sestavit deskriptor
          build_all(exposed_iface,true);
          end loop;
        end declare;

      ---- do nativního rozhraní dosadit vypočtené tagy interfaců ----
      if pclass^.interfaces^.exposed_interfaces>0 then
        build_finalize_class_descriptor_interfaces(native_iface);
        end if;
      end build_class_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor (
        ptyp       : in pentity_type;            -- typ
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Sestaví deskriptor typu jiného než třídy.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat paměť
      if ptyp^.stype    in dts_index   then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_indexed);
      elsif ptyp^.stype in dts_base    then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_based);
      elsif ptyp^.stype in dts_ordinal then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_ordinal);
      else                                  new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type);
      end if;

      -- připravit základ deskriptoru typu
      build_type_descriptor_base(ptyp^.codegen,ptyp,false,addr);

      -- dosadit adresy speciálních metod
      build_type_descriptor_special_methods(ptyp^.codegen,ptyp);

      -- dosadit vlastnosti specifické pro typy s bázovým typem
      -- Pozor, takový "^unchecked" žádnou bázi nemá.
      if ptyp^.stype in dts_base and then ptyp^.base.isset then
        -- tag typu báze
        set_tag(picodegen_type(ptyp^.codegen)^.desc_addr,
                p_desc_type_based(picodegen_type(ptyp^.codegen)^.desc)^.base_tag,
                ptyp^.base.getctype^.codegen,
                ptyp^.base.getctype^.partition_id);
        end if;

      -- dosadit vlastnosti specifické pro typy s rozsahem
      if ptyp^.stype in dts_index then
        -- tag typu rozsahu
        set_tag(picodegen_type(ptyp^.codegen)^.desc_addr,
                p_desc_type_indexed(picodegen_type(ptyp^.codegen)^.desc)^.range_tag,
                ptyp^.srange.getctype^.codegen,
                ptyp^.srange.getctype^.partition_id);
        end if;

      -- dosadit vlastnosti specifické pro ordinální typy
      if ptyp^.stype in dts_ordinal then
        -- dolní a horní mez typu
        p_desc_type_ordinal(picodegen_type(ptyp^.codegen)^.desc)^.first:=uniint_to_imm32(ptyp^.lval);
        p_desc_type_ordinal(picodegen_type(ptyp^.codegen)^.desc)^.last :=uniint_to_imm32(ptyp^.hval);
        end if;

      -- nyní je již velikost všech složek deskriptoru započítaná, můžeme posunout adresu
      addr.compute_next_address;
      end build_type_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_message_descriptor (
        pmsg       : in pentity_message;         -- zpráva
        addr       : in out c_address_aligner_32) = -- přidělovač adres
    -- Sestaví deskriptor zprávy.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat paměť
      new_entity_descriptor(pmsg^.codegen,picodegen_message,p_desc_message);

      -- připravit základ deskriptoru entity
      build_entity_descriptor(pmsg^.codegen,pmsg,addr);

      -- tag typu zprávy
      set_tag(picodegen_message(pmsg^.codegen)^.desc_addr,
              p_desc_message(picodegen_message(pmsg^.codegen)^.desc)^.type_tag,
              pmsg^.typ.getctype^.codegen,
              pmsg^.typ.getctype^.partition_id);

      -- nyní je již velikost všech složek deskriptoru započítaná, můžeme posunout adresu
      addr.compute_next_address;
      end build_message_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_metadata =
    -- Sestavení metadat.
    ------------------------------------------------------------------------------------------------
    begin
      -- je vůbec co sestavovat ?
      if list.list=nil then
        return;
        end if;

      -- zpracovat všechny typy
      for i in list.list^:range loop
        declare var
          entity   : pentity;                    -- entita

        begin
          -- pro zjednodušení
          entity:=list.list^[i];
          verify({VERIFY=}000386,entity^.linked<>ls_used or entity^.codegen<>nil);

          -- sestavit deskriptor pro tuto entitu
          case entity^.etype
            -- typ
            when et_type    do build_type_descriptor(entity,addr);

            -- třída
            when et_class   do build_class_descriptor(entity,addr);

            -- zpráva
            when et_message do build_message_descriptor(entity,addr);

            -- pro nic jiného metadata generovat neumíme
            when others do verify({VERIFY=}000822,true)
            end case;

          -- označit symbol jako vyhodnocený
          entity^.linked:=ls_linked;
          end declare;
        end loop;
      end build_metadata;
   

      
    ------------------------------------------------------------------------------------------------
    static resolve_relocations =
    -- Vyhodnotí relokace daného symbolu.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding,
      cg_gen.cg_ia32.ci_code,
      cg_gen.cg_ia32.ci_code.ci_instr;

    begin
      -- je vůbec co vyhodnocovat ?
      if inst.r=nil then
        return;
        end if;

      for i in inst.r^:range loop -- with inst.r^[i] loop
        declare

          var
            r      : inst.r^:base;

          ------------------------------------------------------------------------------------------
          procedure set_absolute (
              value: in t_unsigned32;            -- hodnota relokabilního pole
              local: in t_logical := false) =    -- T-vynutit relokaci do této partition
          -- Dosadí hodnotu absolutní relokace a udělá ji load-time relokabilní.
          ------------------------------------------------------------------------------------------
          begin
            -- dosadit hodnotu absolutní relokace do kódu
            verify({VERIFY=}000590,not r.absolute);
            setfield(inst,r.disp,value);
            
            -- zapamatovat si relokaci pro generování EXE
            if local
              then add_relocation(curr_partition,inst.cstart+r.disp,trd_absolute);
              else add_relocation(r.relo_info.rpartition,inst.cstart+r.disp,trd_absolute);
              end if;
            end set_absolute;

          ------------------------------------------------------------------------------------------
          procedure set_relative (
              value: in t_unsigned32) =
          -- Dosadí hodnotu relativní relokace.
          ------------------------------------------------------------------------------------------
          var
            modtemp : t_mod_unsigned32;

          begin
            -- dosadit hodnotu relativní relokace do kódu
            modtemp:=t_mod_unsigned32(value);
            modtemp-t_mod_unsigned32(r.nextip+inst.cstart);
            setfield(inst,r.disp,t_unsigned32(modtemp));

            -- pokud relokace směřuje do cizí parition, pak generovat i load-time relokaci
            if r.relo_info.rpartition<>curr_partition then
              add_relocation(r.relo_info.rpartition,inst.cstart+r.disp,trd_relative);
              end if;
            end set_relative;

        begin
          -- pro zjednodušení, ať se neupíšeme
          r:=inst.r^[i];

          case r.relo_info.rtype
            -- prázdná relokace
            when irt_none      do { nic nedělat };

            -- symbol
            when irt_entity    do
                case pentity(r.relo_info.rentity)^.etype
                  -- proměnná
                  when et_var do set_absolute(picodegen_var(pentity(r.relo_info.rentity)^.codegen)^.addr);

                  -- procedura
                  when et_procedure,et_static do
                      if is_imported(r.relo_info.rentity,^aux_registry)
                        
                        -- externí symbol
                        then set_absolute(getindirect(pentity_procedure(r.relo_info.rentity)),for local use true);
                        
                        -- normální symbol %%X A která instance to je ?
                        else 
                          {%%X A která instance to je ? }
                          if not r.absolute
                            then set_relative(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                            else set_absolute(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                            end if;
                          end if;

                  -- program, virtuální metoda, override, speciálná metoda, kompilační jednotka
                  when et_program,et_virtual,et_override,et_special,et_compile do
                      {%%X A která instance to je ? }
                      if not r.absolute
                        then set_relative(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                        else set_absolute(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                        end if;

                  -- tag zprávy
                  when et_message do set_absolute(picodegen_message(pentity_message(r.relo_info.rentity)^.codegen)^.desc_addr);

                  -- tag typu/třídy
                  when et_type,et_class do set_absolute(picodegen_type(pentity_type(r.relo_info.rentity)^.codegen)^.desc_addr);

                  when others do verify({VERIFY=}000033,true);
                  end case;                       

            -- přímá hodnota
            when irt_imm       do set_absolute(picodegen_imm(pexpimm(r.relo_info.rexpr)^.imm.codegen)^.addr);

            -- interface třídy
            when irt_interface do set_absolute(picodegen_type(r.relo_info.rinterface^.codegen)^.desc_addr);

            -- adresa sekce v image
            when irt_section   do set_absolute(unicode_addr_to_unsigned(getsegbase(r.relo_info.rsection)));
            end case;
          end declare;
        end loop;
      end resolve_relocations;



    ------------------------------------------------------------------------------------------------
    override link_section_code =
    -- Segment: kód.
    ------------------------------------------------------------------------------------------------
    var
      block            : pimemblock;                 -- přidělený blok paměti
      p                : picodeinst;

    begin
      -- přidělit adresy všem instancím
      if code.list<>nil then
        for i in code.list^:range loop
          verify({VERIFY=}000594,code.list^[i]^.linked<>ls_used);

          --write_line(sym_get_qid(code.list^[i]));

          -- přidělit adresy všem instancím
          p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;
          loop
            verify({VERIFY=}001375,p=nil);

            -- přidělit adresu
            p^.cstart:=_address.get_address_and_adjust(p^.c^:length);

            -- zapsat do listingu
            map_start_subprogram(sym_get_qid(code.list^[i]),unsigned_to_unidata_addr(p^.cstart));

            -- vypsat parametry
            if p^.profile.par<>nil then
              for j in p^.profile.par^:range loop
                map_automatic_variable(sym_get_qid(p^.profile.par^[j].pparam),
                    signed_to_unidata_addr(p^.profile.par^[j].ofs),
                    unsigned_to_unidata_size(p^.profile.par^[j].size));
                end loop;
              end if;

            -- vypsat lokální proměnné
            block:=p^.layout.first;
            while block<>nil loop
              if block^.pvar<>nil
                then map_automatic_variable(sym_get_qid(block^.pvar),
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                else map_automatic_variable('<temporary>',
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                end if;
              block:=block^.next;
              end loop;

            -- řádkové informace
            map_subprogram_lineinfo(unsigned_to_unidata_addr(p^.cstart),p^.di);

            -- konec
            map_end_subprogram;

            -- další instance
            p:=p^.next;
            until p=nil;

          -- označit za slinkované
          code.list^[i]^.linked:=ls_linked;
          end loop;
        end if;
      end link_section_code;



    ------------------------------------------------------------------------------------------------
    override link_section_flex_metadata =
    -- Segment: deskriptory typů.
    ------------------------------------------------------------------------------------------------
    begin
      build_metadata(metadata,_address);
      end link_section_flex_metadata;



    ------------------------------------------------------------------------------------------------
    override link_section_flex_relocations =
    -- Linkování segmentu: flex relokace. 
    ------------------------------------------------------------------------------------------------
    var
      it           : c_relocations_iterator;
      
    begin 
      -- vyhodnotit odkazy v kódu
      if reloc.list<>nil then
        for i in reloc.list^:range loop
          declare var
            p      : picodeinst;
          begin
            p:=picodegen_subprog(reloc.list^[i]^.codegen)^.ifirst;
            loop
              -- vyhodnotit
              resolve_relocations(p^);

              -- další instance
              p:=p^.next;
              until p=nil;
            end declare;
          end loop;
        end if;

      -- připravit iterátor setříděných seznamů relokabilních adres
      iterate_relocations(it);
      
      -- sestavit image-specifickou relokační tabulku
      #expand build_section;
        #for section      use; tis_flex_relocations
        #for data_buffer  use; data_flex_relocations
        #for build_method use; build_flex_relocations
        #for parameters   use; getsegbase(tis_flex_relocations),p_link_resolver(^this)^,it
                                                 --%%TODO(COMPATIBILITY) ^^^^^^^^^^^^^^
        #end build_section;
      end link_section_flex_relocations;



    ------------------------------------------------------------------------------------------------
    override link_section_constants =
    -- Segment: konstanty.
    ------------------------------------------------------------------------------------------------
    var
      pimm             : pimm_value;                 -- ukládaná přímá hodnota
      binsize          : tunidata_size;              -- velikost binárního tvaru

    begin
      if cdata.list<>nil then
        for i in cdata.list^:range loop
          -- pro zjednodušení
          pimm:=cdata.list^[i].pimm;
          if pimm^.codegen=nil then
            -- alokovat paměť
            new picodegen_imm(pimm^.codegen);
            c_garbage_collector.get_instance^.register_record(pimm^.codegen);

            -- vypočítat požadovanou velikost paměti
            cpu^.getimmstoragesize(pimm^,cdata.list^[i].ptyp,binsize);

            -- přidělit adresu
            picodegen_imm(pimm^.codegen)^.addr:=_address.get_address_and_adjust(unidata_size_to_unsigned(binsize));
            end if;
          end loop;
        end if;
      end link_section_constants;



    ------------------------------------------------------------------------------------------------
    override link_section_initialized_data =
    -- Segment: inicializované proměnné.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(idata,_address);
      end link_section_initialized_data;



    ------------------------------------------------------------------------------------------------
    override link_section_uninitialized_data =
    -- Segment: neinicializované proměnné.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(data,_address);
      end link_section_uninitialized_data;



    ------------------------------------------------------------------------------------------------
    override link =
    -- Sestavení.
    ------------------------------------------------------------------------------------------------
    with
      standard,
      standard.conversions,
      cc_base,
      cc_base.cc_sym;

    var
      segment_address : c_address_aligner_32;    -- přidělovač adres segmentů

        --------------------------------------------------------------------------------------------
        procedure link_section (
            _name  : in t_char32ustr;            -- popisné jméno segmentu pro listing
            _seg   : in t_image_section;         -- sestavovaný segment
          --_proc  : in p_link_section;          -- metoda pro sestavení zadaného segmentu
            _align : in t_unsigned32) =          -- zarovnání v rámci segementu
        -- Sestavení zadaného segmentu.
        --------------------------------------------------------------------------------------------
        var
          local_address : c_address_aligner_32;  -- přidělovač adres v rámci segmentu

        begin
          -- zapsat do listingu začátek segmentu
          map_start_segment(_name);

          -- počáteční adresa segmentu
          seg[_seg].start:=segment_address.get_address;

          -- inicializovat přidělovač adres v rámci segmentu
          local_address.init(segment_address.get_address,_align);

          -- vlastní sestavení
          case _seg    
            when tis_code               do link_section_code(local_address,image_specific);
            when tis_constants          do link_section_constants(local_address,image_specific);
            when tis_initialized_data   do link_section_initialized_data(local_address,image_specific);
            when tis_uninitialized_data do link_section_uninitialized_data(local_address,image_specific);
            when tis_flex_metadata      do link_section_flex_metadata(local_address,image_specific);
            when tis_flex_relocations   do link_section_flex_relocations(local_address,image_specific);
            when tis_import_table       do link_section_import_table(local_address,image_specific);
            when tis_import_metadata    do link_section_import_metadata(local_address,image_specific);
            when tis_export_metadata    do link_section_export_metadata(local_address,image_specific);
            end case;

          -- vypočítat délku segmentu
          seg[_seg].len:=local_address.get_address-segment_address.get_address;

          -- vypočítat adresu příštího segmentu
          segment_address.shift_address(seg[_seg].len);

          -- konec segmentu
          map_end_segment;
          end link_section;

    begin
      -- inicializovat přidělovač adres segmentů
      segment_address.init(seg[tis_code].start,gran);

      ----- Fáze 1: přidělit adresy ve všech segmentech -----
      -- 1. kód
      link_section('Code',tis_code,calign);

      -- 2. metadata
      link_section('Flex Metadata',tis_flex_metadata,dalign);

      -- 3. konstanty
      link_section('Constants',tis_constants,dalign);

      -- 4. inicializované proměnné
      link_section('Initialized Variables',tis_initialized_data,dalign);

      -- 5. neinicializované proměnné
      link_section('Uninitialized Variables',tis_uninitialized_data,dalign);

      -- 2. připravit importované funkce
      link_section('Import Table',tis_import_table,1);

      -- 3. připravit importované funkce
      link_section('Import Metadata',tis_import_metadata,1);

      -- 4. připravit exportované funkce
      link_section('Export Metadata',tis_export_metadata,1);
              
      -- 1. připravit tabulku run-time relokací
      link_section('Flex Relocations',tis_flex_relocations,1);


      ----- Fáze 2: debug informace -----
      -- jaky typ debug informaci budeme generovat
      if not cfg_no_debug_info then
      #if codeview then;
        case debug_mode
          -- CodeView debug inforation
          when tdit_codeview do 
              new p_codeview(debug_info);
              c_garbage_collector.get_instance^.register_class(debug_info);

          end case;
      #end if;
        end if;

      -- generujeme nejake debug informace ?
      if debug_info<>nil then
        -- inicializace debug informaci
        debug_info^.init;

        -- sestavime strom s debug informacemi
        debug_info^.linkdebuginfo(compi,^this);
        end if;
      end link;



    ------------------------------------------------------------------------------------------------
    override info =
    -- Výpis souhrnných informací do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;



    ------------------------------------------------------------------------------------------------
    override getaddrbase =
    -- Adresa, ke které se vztahují relokace.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(imagebase);
      end getaddrbase;



    ------------------------------------------------------------------------------------------------
    override getentrypoint =
    -- Entrypoint programu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(picodegen_subprog(compi^.codegen)^.ifirst^.cstart);
      end getentrypoint;



    ------------------------------------------------------------------------------------------------
    override checkseg =
    -- True, pokud se má zadaný segment zahrnout do EXE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=seg[_seg].len>0;
      end checkseg;



    ------------------------------------------------------------------------------------------------
    override getsegbase =
    -- Bázová adresa segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(seg[_seg].start);
      end getsegbase;



    ------------------------------------------------------------------------------------------------
    override getsegtotal =
    -- Celková velikost segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unidata_size(seg[_seg].len);
      end getsegtotal;



    ------------------------------------------------------------------------------------------------
    override write_section =
    -- Do výstupního souboru zapíše zadaný segment.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

    var
      bin          : p_unsigned8array;           -- ukládaná přímá hodnota v binárním tvaru
      allocsize    : tunidata_size;              -- velikost alokované paměti

        --------------------------------------------------------------------------------------------
        procedure write_imm (
            imm    : in timm_value;              -- přímá hodnota
            ptyp   : in pentity_type;            -- typ
            full   : in t_logical) =             -- T-uložit v délce typu, F-v min. délce
        -- Zapíše do souboru přímou hodnotu.
        --------------------------------------------------------------------------------------------
        with
          advanced,
          advanced.low_level;

        use
          advanced.low_level.unchecked_memory_access;

        var
          binsize  : tunidata_size;              -- velikost binárního tvaru
          fill     : t_unsigned32;               -- velikost zarovnání
          x        : t_unsigned32;

        begin
          -- určit velikost binárního tvaru
          cpu^.getimmstoragesize(imm,ptyp,binsize);

          -- realokovat paměť
          {%%X Nekompatibilní s 64-bitovou implementací }
          if binsize>allocsize

            -- alokovat nový blok
            then
              discard bin;
              allocsize:=binsize;
              new bin range unidata_size_to_unsigned(allocsize);

            -- jinak jen fillznout ten starý
            else
              unchecked_memory_access.memory_fill_zero(bin^,unidata_size_to_unsigned(allocsize))
              end if;

          -- sestavit binární tvar
          cpu^.immtobinary(imm,ptyp,bin^,binsize);

          -- zapsat
          os^.write_unchecked_part(bin^,unidata_size_to_unsigned(binsize));

          -- vypočítat délku zarovnání
          if full
            -- (+výplň za konstantou kratší než je typ)
            then
              x:=unidata_size_to_unsigned(ptyp^.size);
              fill:=unidata_size_to_unsigned(ptyp^.size-binsize);
              if x mod dalign<>0 then 
                fill+(dalign-(x mod dalign)); 
                end if;
            -- (nezarovnává se na velikost typu ale na velikost konstanty)
            else
              fill:=unidata_size_to_unsigned(binsize);
              if fill mod dalign<>0
                then fill:=dalign-(fill mod dalign);
                else fill:=0;
                end if;
              end if;

          -- zarovnat
          ffillz(os,fill);
          end write_imm;



        --------------------------------------------------------------------------------------------
        #template write_padding (size);
        -- Zapíše do výstupního streamu potřebné zarovnání
        --------------------------------------------------------------------------------------------
          if size mod dalign<>0 then 
            os^.write_unchecked_part(fill_nops,dalign-(size mod dalign)); 
            end if;
          #end write_padding;



        --------------------------------------------------------------------------------------------
        #template write_and_pad (data,size);
        -- Zapíše do výstupního streamu data a potřebné zarovnání
        --------------------------------------------------------------------------------------------
          -- zapsat
          os^.write_unchecked_part(data,size);

          -- zarovnat
          write_padding(size);
          #end write_and_pad;



        --------------------------------------------------------------------------------------------
        procedure write_desc_entity_base (
            codegen: in picodegen_metadata;      -- řídící struktura s deskriptorem entity
            size   : out t_unsigned) =           -- kumulativní velikost všech složek deskriptoru
        -- Zapíše do souboru základ deskriptoru entity.
        --------------------------------------------------------------------------------------------
        begin
          -- zapsat identifikátor
          if codegen^.desc_qid<>nil then
            write_and_pad(codegen^.desc_qid^,4+codegen^.desc_qid^:length*4);
            end if;

          -- zapsat deskriptor 
          os^.write_unchecked_part(codegen^.desc^,codegen^.desc_size{%%TODO(COMPATIBILITY) codegen^.desc^:size});
          size+codegen^.desc_size;
          end write_desc_entity_base;



        --------------------------------------------------------------------------------------------
        procedure write_desc_class (
            codegen: in picodegen_interface) =   -- deskriptor třídy (resp. interfacu)
        -- Zapíše do souboru deskriptor třídy.
        --------------------------------------------------------------------------------------------
        var
          size     : t_unsigned;                 -- kumulativní velikost všech složek

        begin
          -- základ tvoří deskriptor entity
          write_desc_entity_base(codegen,size);

          -- následuje virtuální tabulka
          if codegen^.vtable<>nil then
            os^.write_unchecked_part(codegen^.vtable^,get_vtable_size(codegen));
                       {%%TODO(COMPATIBILITY) codegen^.vtable^:size);}
            size+get_vtable_size(codegen);
            end if;

          -- a tabulka interfaců 
          if codegen^.itable<>nil then
            os^.write_unchecked_part(codegen^.itable^,get_itable_size(codegen));
            size+get_itable_size(codegen);
            end if;

          -- zarovnání
          write_padding(size);
          end write_desc_class;



        --------------------------------------------------------------------------------------------
        procedure write_desc_entity (
            codegen: in picodegen_metadata) =    -- deskriptor entity
        -- Zapíše do souboru deskriptor typu.
        --------------------------------------------------------------------------------------------
        var
          size     : t_unsigned;                 -- kumulativní velikost všech složek

        begin
          -- základ tvoří deskriptor entity
          write_desc_entity_base(codegen,size);

          -- zarovnání
          write_padding(size);
          end write_desc_entity;

    var
      pvar             : pentity_var;                -- proměnná
      size             : t_unsigned32;               -- velikost proměnné
      fill             : t_unsigned32;               -- velikost dodatečné výplně
      imm              : pimm_value;                 -- přímá hodnota
      p                : picodeinst;

    begin
      case _seg
        -- kód
        when tis_code do
            for i in code.list^:range loop
              p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;

              -- zapsat všechny instance
              loop
                -- zapsat instrukce
                os^.write_unchecked_part(p^.c^[p^.c^:first],p^.c^:length);

                -- zarovnat
                if p^.c^:length mod calign<>0 then 
                  os^.write_unchecked_part(fill_nops,calign-(p^.c^:length mod calign)); 
                  end if;

                -- další instance
                p:=p^.next;
                until p=nil;
              end loop;

        -- metadata
        when tis_flex_metadata do
            for i in metadata.list^:range loop
              if metadata.list^[i]^.etype=et_class

                -- pro třídu se musí zapsat deskriptory všech interfaců
                then
                  declare var
                    it        : c_list_iterator; -- iterátor přes rozhraní třídy
                    interface : p_class_interface; -- interface třídy

                  begin
                    -- připravit iterátor
                    pentity_type(metadata.list^[i])^.interfaces^.get_all_interfaces(it);

                    -- zpracovat všechny exposované interfacy
                    while it.get(interface) loop
                      write_desc_class(interface^.codegen);
                      end loop;
                    end declare;

                -- pro ostatní typy entit je to mnohem jednodušší
                else
                  write_desc_entity(metadata.list^[i]^.codegen);
                  end if;
              end loop;

        -- konstanty
        when tis_constants do
            allocsize:=uds_0;
            bin:=nil;
            for i in cdata.list^:range loop
              write_imm(cdata.list^[i].pimm^,cdata.list^[i].ptyp,false);
              end loop;
            discard bin;

        -- inicializovaná data
        when tis_initialized_data do
            allocsize:=uds_0;
            bin:=nil;
            for i in idata.list^:range loop 
              write_imm(pentity_var(idata.list^[i])^.init.getimm^,pentity_var(idata.list^[i])^.typ.getctype,true); 
              end loop;
            discard bin;

        -- neinicializovaná data
        --when tis_initialized_data do { není co zapisovat };

        -- importní tabulka
        when tis_import_table     do
            -- %%TODO(LIB) Nepoužívat přímo [_target] ale nějaké [get_target_stream]
            os^.set_lazy_buffer(false);
            data_import_table.transfer_buffered_packets(os^._target);
            c_output_stream:(data_import_table).close;
            os^.set_lazy_buffer(true);
        
        -- importní metadata
        when tis_import_metadata  do 
            -- %%TODO(LIB) Nepoužívat přímo [_target] ale nějaké [get_target_stream]
            os^.set_lazy_buffer(false);
            data_import_metadata.transfer_buffered_packets(os^._target);
            c_output_stream:(data_import_metadata).close;
            os^.set_lazy_buffer(true);

        -- exportní metadata
        when tis_export_metadata  do 
            -- %%TODO(LIB) Nepoužívat přímo [_target] ale nějaké [get_target_stream]
            os^.set_lazy_buffer(false);
            data_export_metadata.transfer_buffered_packets(os^._target);
            c_output_stream:(data_export_metadata).close;
            os^.set_lazy_buffer(true);
        
        -- Flex relokace
        when tis_flex_relocations do 
            -- %%TODO(LIB) Nepoužívat přímo [_target] ale nějaké [get_target_stream]
            os^.set_lazy_buffer(false);
            data_flex_relocations.transfer_buffered_packets(os^._target);
            c_output_stream:(data_flex_relocations).close;
            os^.set_lazy_buffer(true);
 
        when others do verify({VERIFY=}000204,true);
        end case;
      end write_section;



    ------------------------------------------------------------------------------------------------
    virtual getindirect =
    -- Vrátí nepřímou adresu importovaného podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=0;
      end getindirect;

    end c_link_resolver_ia32;



----------------------------------------------------------------------------------------------------
class private c_link_resolver_ia32_win32 =
-- Vyhodnocovač cross-referencí a adres: Win32 na IA-32.
----------------------------------------------------------------------------------------------------

    with
      cp_cpu.cp_32.cp_def,
      cp_os,
      cp_os.cp_win32;

    ------------------------------------------------------------------------------------------------
    override link_section_import_table =
    -- Linkování segmentu: importované entity - tabulka.
    ------------------------------------------------------------------------------------------------
    with
      standard.templates,
      cc_binding;

    begin
      -- je vůbec co importovat ?
      if import.list=nil or else import.list^:length=0 then 
        map_write_line('No imported entities');
        return; 
        end if;

      -- setřídit importované funkce
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=import.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pimportinfo(get_import_info(import.list^[j]  ,^aux_registry))^.libname^>
               pimportinfo(get_import_info(import.list^[j+1],^aux_registry))^.libname^ then
              exchange(import.list^[j],import.list^[j+1]);
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;

      -- %%TODO(PORTABILITY) Nepatří náhodou níže uvedený FOR cyklus do [c_link_resolver_image_specific]?
      
      -- přiřadit adresy na adresy procedur
      for i in import.list^:range loop
        declare var
          import_info : pimportinfo;             -- importní informace aktuální entity
          
        begin  
          -- pro zjednodušení si zjistit importní informace aktuální entity
          import_info:=pimportinfo(get_import_info(import.list^[i],^aux_registry));
          
          -- mezera při změně knihovny
          if i>import.list^:first and pimportinfo(get_import_info(import.list^[i-1],^aux_registry))^.libname^<>import_info^.libname^ then
            _address.shift_address(lprg32);
            end if;

          -- adresa
          import_info^.addr:=unsigned_to_unicode_addr(_address.get_address_and_adjust(lprg32));
          end declare;
        end loop;

      -- mezera za poslední knihovnou
      _address.shift_address(lprg32);
      end link_section_import_table;



    ------------------------------------------------------------------------------------------------
    override link_section_import_metadata =
    -- Linkování segmentu: importované entity - systémová metadata.
    ------------------------------------------------------------------------------------------------
    var
      wr_table     : c_stream_binary_writer;     -- binární zapisovač do streamu
      wr_metadata  : c_stream_binary_writer;     -- binární zapisovač do streamu

    begin
      -- připravit zapisovač
      wr_table.init_writer(^c_output_stream:(data_import_table));
      wr_metadata.init_writer(^c_output_stream:(data_import_metadata));

      -- sestavit sekci image-specifickou metodou
      image_specific.build_import_table_and_metadata(wr_table,wr_metadata,getsegbase(tis_import_table),getsegbase(tis_import_metadata),p_link_resolver(^this)^,import);
                                                                                                                         --%%TODO(COMPATIBILITY) ^^^^^^^^^^^^^^
      -- konec dat
      c_output_stream:(data_import_table).write_eod;
      c_output_stream:(data_import_metadata).write_eod;

      -- zaznamenat celkovou velikost data sekce importních metadat (velikost sekce importní tabulky
      -- se již vypočetla v předchozím kroku [link_section_import_table]).
      declare var
        size         : t_offset;
      begin  
        c_output_stream:(data_import_metadata).get_flow(size);
        _address.shift_address(size);
        --seg[tis_import_metadata].len:=size;
        end declare;
      end link_section_import_metadata;



    ------------------------------------------------------------------------------------------------
    override link_section_export_metadata =
    -- Linkování segmentu: exportované entity - systémová metadata.
    ------------------------------------------------------------------------------------------------
    with 
      standard.templates,                           
      cc_binding,
      cc_def.cc_var;

    begin
      -- je vůbec co exportovat ?
      if sys_export_list.list=nil or else sys_export_list.list^:length=0 then 
        map_write_line('No exported entities');
        return; 
        end if;

      -- zjistit plne kvalifikovana jmena exportu
      for i in sys_export_list.list^:range loop
        declare var
          export_info : pexportinfo;
          
        begin
          -- zjistit si informace o exportu
          export_info:=get_export_info(sys_export_list.list^[i]);
          
          -- pokud nebylo explicitně určeno exportní jméno, použít kvalifikovaný identifikátor entity
          if export_info^.export_name=nil then
            export_info^.export_name:=string_to_external_entity_ident(sym_get_qid(sys_export_list.list^[i]));
            end if;
          end declare;  
        end loop;
       
      -- setřídit podle exportovaných jmen
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=sys_export_list.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pexportinfo(get_export_info(sys_export_list.list^[j]))^.export_name^>pexportinfo(get_export_info(sys_export_list.list^[j+1]))^.export_name^ then
              exchange(sys_export_list.list^[j],sys_export_list.list^[j+1]);
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;
        
      -- sestavit image-specifickou exportní tabulku
      #expand build_section;
        #for section      use; tis_export_metadata
        #for data_buffer  use; data_export_metadata
        #for build_method use; build_export_metadata
        #for parameters   use; getsegbase(tis_export_metadata),sys_export_list
        #end build_section;

      -- vypsat exporty do listingu
      map_write_line('Exported symbols:');
      for i in sys_export_list.list^:range loop
        map_exported_entity(sym_get_qid(sys_export_list.list^[i]));
        end loop;
      end link_section_export_metadata;



    ------------------------------------------------------------------------------------------------
    override getindirect =
    -- Vrátí nepřímou adresu importovaného podprogramu.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding;
      
    begin
      result:=unicode_addr_to_unsigned(pimportinfo(get_import_info(proc,^aux_registry))^.addr);
      end getindirect;
    
    end c_link_resolver_ia32_win32;



end cl_ia32;
