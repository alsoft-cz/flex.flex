----------------------------------------------------------------------------------------------------
module private cl_ia32 =
-- P©eklada‡ Flexu.
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_base,
  cc_base.cc_sym,
  cp_cpu,
  cp_cpu.cp_32,
  cp_cpu.cp_32.cp_def,
  cl_map;

----------------------------------------------------------------------------------------------------
class private linkresolver_ia32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------

    with
      cx_expr,
      cx_expr.cx_def,
      cc_def.cc_var,
      cp_cpu.cp_32.cp_metadata,
      cg_gen,
      cg_gen.cg_ia32,
      cg_gen.cg_ia32.ci_struct
    #if debug2 then;
      ,cl_link.cl_debug
      #if codeview then;
      ,cl_link.cl_debug.cl_codeview
      #end if;
    #end if;
      ;  -- %%TODO(WITH) P©edˆlat na v¡ce WITH

    var
      -- v˜pl¤: NOPy
      fill_nops    : static const array t_unsigned8 of t_unsigned8 := [for others use $90];

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      imagebase:=_ibase;
      gran:=_gran;
      calign:=_calign;
      dalign:=_dalign;
      for s in tsegment loop
        seg[s].start:=_start;
        seg[s].len:=0;
        end loop;
      seg[tseg_code].start:=_ibase+_start;
      compi:=_compi;
      end init;



    ------------------------------------------------------------------------------------------------
    override trace =
    -- Projde tabulku relokac¡ symbolu CURR a pro ka‘d˜ symbol zavol¡ MARK.
    ------------------------------------------------------------------------------------------------

        --------------------------------------------------------------------------------------------
        procedure mark_entity (entity : pentity) =
        -- Pro zadanou entitu zavol  [mark], nen¡-li to pr vˆ zpracov van  entita.
        --------------------------------------------------------------------------------------------
        begin
          if entity<>curr then 
            mark(entity); 
            end if;
          end mark_entity;
    
    var
      zarad            : t_logical;                  -- T-zaradit na vyhodnocen¡ relokac¡
      pi               : picodeinst;

    begin
      -- je v–bec co trasovat ?
      if curr^.codegen=nil then 
        return; 
        end if;

      -- proj¡t v¨echny instance
      pi:=picodegen_subprog(curr^.codegen)^.ifirst;
      zarad:=false;
      while pi<>nil loop
        if pi^.r<>nil and then pi^.r^:length>0 then
          -- za©adit na vyhodnocen¡ relokac¡
          zarad:=true;

          -- ozna‡it symboly
          for i in pi^.r^:range loop
            case pi^.r^[i].relo_info.rtype
              when irt_none      do {nic nedˆlat};
              when irt_entity    do mark_entity(pi^.r^[i].relo_info.rentity);
              when irt_imm       do
                  if pexpimm(pi^.r^[i].relo_info.rexpr)^.linked=ls_undef then
                    pexpimm(pi^.r^[i].relo_info.rexpr)^.linked:=ls_used;
                    cdata.add(^pexpimm(pi^.r^[i].relo_info.rexpr)^.imm,pexpimm(pi^.r^[i].relo_info.rexpr)^.t.getctype);
                    end if;
              when irt_interface do mark_entity(pi^.r^[i].relo_info.rinterface^.refclass.getcentity);
              when others do verify(202,true);
              end case;
            end loop;
          end if;
        pi:=pi^.next;
        end loop;
      if zarad then reloc.add(curr); end if;
      end trace;



    ------------------------------------------------------------------------------------------------
    static assign_var_addresses =
    -- P©idˆl¡ adresy promˆnn˜m.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu,
      cp_cpu.cp_32,
      cp_cpu.cp_32.cp_def;

    var
      pvar             : pentity_var;                -- promˆnn 
      tmp_addr         : tunidata_addr;

    begin
      -- je v–bec co p©idˆlovat ?
      if list.list=nil then
        return;
        end if;

      for i in list.list^:range loop
        -- pro zjednodu¨en¡
        pvar:=pentity_var(list.list^[i]);
        verify(387,pvar^.linked<>ls_used or pvar^.etype<>et_var);

        -- alokovat pamˆŸ
        new picodegen_var(pvar^.codegen);

        -- p©idˆlit adresu
        picodegen_var(pvar^.codegen)^.addr:=addr.get_address_and_adjust(unidata_size_to_unsigned(pvar^.typ.getctype^.size));

        -- ozna‡it symbol jako vyhodnocen˜
        pvar^.linked:=ls_linked;

        -- zapsat do map filu
        tmp_addr:=prg32_to_unidata_addr(picodegen_var(pvar^.codegen)^.addr);
        map_static_variable(sym_get_qid(pvar),tmp_addr,pvar^.typ.getctype^.size);
        end loop;
      end assign_var_addresses;



    ------------------------------------------------------------------------------------------------
    #template new_entity_descriptor (
        codegen,                                 -- ©¡d¡c¡ struktura
        codegen_type,                            -- typ pointeru na typ ©¡d¡c¡ struktury
        desc_type);                              -- typ pointeru na typ deskriptoru
    -- Alokuje ©¡d¡c¡ strukturu gener toru k¢du a deskriptor.
    ------------------------------------------------------------------------------------------------
      -- alokovat pamˆŸ
      new codegen_type(codegen);

      -- vypo‡¡tat velikost deskriptoru
      codegen_type(codegen)^.desc_size:=desc_type:base:size;

      -- alokovat deskriptor typu
      new desc_type(codegen_type(codegen)^.desc);
      #end new_entity_descriptor;



    ------------------------------------------------------------------------------------------------
    #template set_tag (
        base_addr,                               -- b zov  absolutn¡ adresa struktury, ve kter‚ je polo‘ka
        tag_field,                               -- polo‘ka, do kter‚ se ukl d  tag
        src_codegen);                            -- ©¡d¡c¡ struktura entity jej¡‘ tag se zji¨Ÿuje
    -- P©i©ad¡ do polo‘ky [tag_field] hodnotu tagu entity reprezentovan‚ ©¡d¡c¡ strukturou 
    -- [src_codegen] a vygeneruje odpov¡daj¡c¡ load-time relokaci.
    ------------------------------------------------------------------------------------------------
      verify(721,src_codegen=nil);

      -- p©i©adit do polo‘ky tag
      tag_field:=picodegen_metadata(src_codegen)^.desc_addr;

      -- vygenerovat relokaci
      add_relocation(base_addr+tag_field:position);
      -- %%TOOD(RELOCATION) Hynk–––––
      #end set_tag;



    ------------------------------------------------------------------------------------------------
    static get_vtable_size (
        codegen    : in picodegen_interface)     -- ©¡d¡c¡ struktura gener toru k¢du
        return t_unsigned =                      -- velikost virtu ln¡ tabulky
    -- Zjist¡ velikost virtu ln¡ tabulky.
    ------------------------------------------------------------------------------------------------
    begin
      result:=codegen^.vtable^:length*codegen^.vtable^:base:size;
      end get_vtable_size;



    ------------------------------------------------------------------------------------------------
    static get_itable_size (
        codegen    : in picodegen_interface)     -- ©¡d¡c¡ struktura gener toru k¢du
        return t_unsigned =                      -- velikost tabulky interfac–
    -- Zjist¡ velikost interfac–.                           
    ------------------------------------------------------------------------------------------------
    begin
      result:=codegen^.itable^:length*codegen^.itable^:base:size+codegen^.itable^:length:size;
      end get_itable_size;



    ------------------------------------------------------------------------------------------------
    static get_vtable_addr (
        codegen    : in picodegen_interface)     -- ©¡d¡c¡ struktura gener toru k¢du
        return t_unsigned =                      -- adresa virtu ln¡ tabulky
    -- Zjist¡ absolutn¡ adresu virtu ln¡ tabulky.
    ------------------------------------------------------------------------------------------------
    begin
      -- virtu ln¡ tabulka le‘¡ hned za deskriptorem
      result:=codegen^.desc_addr+codegen^.desc_size;
      end get_vtable_addr;



    ------------------------------------------------------------------------------------------------
    static get_itable_addr (
        codegen    : in picodegen_interface)     -- ©¡d¡c¡ struktura gener toru k¢du
        return t_unsigned =                      -- adresa tabulky interfac–
    -- Zjist¡ absolutn¡ adresu tabulky interfac–.                           
    ------------------------------------------------------------------------------------------------
    begin
      -- tabulka interfac– le‘¡ hned za virtu ln¡ tabulkou
      result:=get_vtable_addr(codegen)+get_vtable_size(codegen);
      end get_itable_addr;



    ------------------------------------------------------------------------------------------------
    static build_entity_descriptor (
        codegen    : in picodegen_metadata;      -- ©¡d¡c¡ struktura gener toru k¢du
        entity     : in pentity;                 -- entita, obecnˆ nez visl  na ©¡d¡c¡ struktu©e
        addr       : in out c_address_aligner_32;-- p©idˆlova‡ adres
        fake_tag   : in t_logical := false) =    -- T-sestavujeme fake deskriptor
    -- Sestav¡ z klad deskriptoru ka‘d‚ entity. 
    -- Deskriptoru p©idˆl¡ adresu, a to metodou pro v¡cekrokov˜ posun.
    --
    -- Upozornˆn¡: Tato procedura mus¡ b˜t vol na jako prvn¡ pro ka‘d˜ deskriptor. P©ed samotn˜m
    -- deskriptorem alokuje prostor pro jeho kvalifikovan˜ identifik tor.
    ------------------------------------------------------------------------------------------------
    begin
      -- kvalifikovan˜ identifik tor entity
      -- %%TODO(QID) dodˆlat generov n¡ kvalifikovan‚ho identifik toru
      codegen^.desc_qid:=entity^.id;
      if codegen^.desc_qid<>nil then
        codegen^.desc^.id:=addr.get_address_and_adjust(4+codegen^.desc_qid^:length*4);
        end if;

      -- p©idˆlit adresu a zapo‡¡tat velikost deskriptoru 
      -- (mus¡ se dˆlat a‘ po p©idˆlen¡ prostoru pro identifik tor)
      codegen^.desc_addr:=addr.get_address;
      addr.register_size(codegen^.desc_size{%%TODO(COMPATIBILITY) desc^:size});

      -- k¢d entity
      codegen^.desc^.etype:=entity_code_table[entity^.etype];

      -- p©edek
      declare var
        ancestor   : pentity;                    -- p©edek

      begin
        -- zvolit p©edka s ohledem na fakeovost deskriptoru
        if fake_tag
          -- pro fake tag pou‘¡t rovnou dodanou entitu
          then ancestor:=entity;
          -- jinak naj¡t skute‡n‚ho p©edkae
          else ancestor:=entity^.ancestor.getuentity;
          end if;

        -- nalezl-li se, tak doplnit do deskriptoru jeho tag
        if ancestor<>nil then
          verify(389,ancestor^.linked<>ls_linked or ancestor^.codegen=nil or ancestor^.codegen=entity^.codegen);
          set_tag(codegen^.desc_addr,codegen^.desc^.ancestor_tag,ancestor^.codegen);
          end if;
        end declare;
      end build_entity_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_special_methods (
        codegen    : in picodegen_type;          -- ©¡d¡c¡ struktura gener toru k¢du
        ptyp       : in pentity_type) =          -- typ
    -- Do deskriptoru typu dosad¡ adresy speci ln¡ch metod.
    ------------------------------------------------------------------------------------------------
    var
      srch         : tentitysearch;              -- hled tko

    begin
      -- adresy speci ln¡ch metod
      srch.find_et_first(ptyp,rc_primary,et_special,[]);
      while srch.psym<>nil loop
        verify(412,(pentity_special(srch.psym)^.linked<>ls_linked)
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst=nil) 
                or (picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst
                  <>picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ilast));

        -- doplnit adresu instance do deskriptoru typu
        p_desc_type(picodegen_type(ptyp^.codegen)^.desc)^.spec_ptr[pentity_special(srch.psym)^.spectype]:=picodegen_subprog(pentity_special(srch.psym)^.codegen)^.ifirst^.cstart;

        -- zapamatovat si relokaci pro generov n¡ EXE
        add_relocation(codegen^.desc_addr+t_desc_type.spec_ptr:position+pentity_special(srch.psym)^.spectype:ord*t_desc_type.spec_ptr:base:size);

        -- dal¨¡ speci ln¡ metoda
        srch.find_et_next;
        end loop;
      end build_type_descriptor_special_methods;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor_virtual_methods (
        interface  : in p_class_interface;       -- interface t©¡dy
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Do deskriptoru typu dosad¡ adresy virtu ln¡ch metod.
    ------------------------------------------------------------------------------------------------
    var
    { reg_size     : t_mod_unsigned; }
      vtable_addr  : tdata32;                    -- absolutn¡ adresa virtu ln¡ tabulky

    begin
      -- velikost tabulky virtu ln¡ metod zapo‡¡tat do celkov‚ho sou‡tu velikost¡ komponent deskriptoru
      addr.register_size(get_vtable_size(interface^.codegen));

      -- vypo‡¡tat absolutn¡ adresu virtu ln¡ tabulky, bude se hodit
      vtable_addr:=get_vtable_addr(interface^.codegen);

      -- poznamenat adresu tabulky virtu ln¡ch metod pro nep©¡m˜ p©¡stup
      p_desc_class(picodegen_interface(interface^.codegen)^.desc)^.vtable:=vtable_addr;

      -- zapamatovat si relokaci pro generov n¡ EXE
      add_relocation(picodegen_interface(interface^.codegen)^.desc_addr+t_desc_class.vtable:position);

      -- zpracovat v¨echny virtu ln¡ metody ve virtu ln¡ tabulce
      for vindex in 1..interface^.get_vtable_size loop
        declare var
          pmethod  : pentity_code;

        begin           
          -- dohledat implementaci virtu ln¡ metody
          pmethod:=interface^.get_virtual_method(vindex);
          verify(528,pmethod=nil or else (pmethod^.linked<>ls_linked
                  or picodegen_subprog(pmethod^.codegen)^.ifirst=nil
                  or picodegen_subprog(pmethod^.codegen)^.ifirst<>picodegen_subprog(pmethod^.codegen)^.ilast));

          -- doplnit adresu
          picodegen_interface(interface^.codegen)^.vtable^[interface^.normalize_vindex(vindex)]:=picodegen_subprog(pmethod^.codegen)^.ifirst^.cstart;

          -- zapamatovat si relokaci pro generov n¡ EXE
          add_relocation(vtable_addr+interface^.normalize_vindex(vindex)*t_vptr_table:base:size);
          end declare;
        end loop;
      end build_class_descriptor_virtual_methods;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor_interfaces (
        interface  : in p_class_interface;       -- interface t©¡dy
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Do deskriptoru typu dosad¡ informace o interfacech.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes.lists;

    var
      it           : c_list_iterator;            -- iter tor p©es rozhran¡ t©¡dy
      exposed_iface: p_class_interface;          -- exposovan˜ interface
      itable_addr  : t_unsigned;                 -- absolutn¡ adresa tabulky interfac–

    begin
      verify(724,picodegen_interface(interface^.codegen)^.itable=nil);

      -- vypo‡¡tat absolutn¡ adresu tabulky interfac–, bude se hodit
      itable_addr:=get_itable_addr(interface^.codegen);

      -- p©ipravit iter tor
      pentity_type(interface^.refclass.getcentity)^.interfaces^.get_exposed_interfaces(it);

      -- pro ka‘d˜ exposovan˜ interface vygenerovat z znam do tabulky interfac–
      while it.get(exposed_iface) loop
        declare var
          ref_iface: t_ref_interface;            -- polo‘ka tabulky interfac–

        begin
          -- doplnit tag t©¡dy-interfacu
          set_tag(itable_addr,
                  ref_iface.class_tag,
                  picodegen_interface(exposed_iface^.refclass.getcentity^.codegen));

          -- doplnit offset instance interfaceu v r mci nad©azen‚ instance
          ref_iface.offset:=unidata_addr_to_imm32(pentity_var(exposed_iface^.instance.getcentity)^.addr);

          -- p©idat novou polo‘ku do tabulky interfac–
          picodegen_interface(interface^.codegen)^.itable^ & ref_iface;
          end declare;
        end loop;

      -- velikost tabulky interfac– zapo‡¡tat do celkov‚ho sou‡tu velikost¡ komponent deskriptoru
      addr.register_size(get_itable_size(interface^.codegen));
      end build_class_descriptor_interfaces;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor_base (
        codegen    : in picodegen_type;          -- ©¡d¡c¡ struktura gener toru k¢du
        ptyp       : in pentity_type;            -- typ
        fake_tag   : in t_logical;               -- T-sestavujeme fake tag
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- P©iprav¡ z klad deskriptoru typu (zaji¨Ÿuje t‚‘ vol n¡ [build_entity_descriptor]).
    -- Jestli‘e deskriptor typu odpov¡d  fake tagu, potom za p©edka zvol¡ sama sebe, v opa‡n‚m
    -- p©¡padˆ skute‡n‚ho p©edka dodan‚ho typu.
    ------------------------------------------------------------------------------------------------
    begin
      verify(720,tf_tagged not in ptyp^.tflags or else (ptyp^.ancestor.isset and then tf_tagged not in pentity_type(ptyp^.ancestor.getcentity)^.tflags));

      -- p©ipravit z klad deskriptoru entity
      build_entity_descriptor(codegen,ptyp,addr,fake_tag);

      -- atribut :size
      p_desc_type(codegen^.desc)^.size:=unidata_size_to_unsigned(ptyp^.size);

      -- datov˜ typ
      p_desc_type(codegen^.desc)^.dtype:=datatype_code_table[ptyp^.stype];
      end build_type_descriptor_base;



    ------------------------------------------------------------------------------------------------
    static build_class_descriptor (
        pclass     : in pentity_type;            -- t©¡da
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Sestav¡ deskriptor t©¡dy.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

        --------------------------------------------------------------------------------------------
        procedure new_codegen (
            interface : in p_class_interface;    -- interface t©¡dy
            is_exposed: in t_logical) =          -- T-je to exposovan˜ interface
        -- Alokuje ©¡d¡c¡ strukturu gener toru k¢du a deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        begin
          -- alokovat ©¡d¡c¡ strukturu
          new_entity_descriptor(interface^.codegen,picodegen_interface,p_desc_class);

          -- alokovat tabulku virtu ln¡ch metod
          new picodegen_interface(interface^.codegen)^.vtable range interface^.get_vtable_size;

          -- alokovat tabulku interfac–
          if not is_exposed and then pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces>0 then
            new picodegen_interface(interface^.codegen)^.itable range pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces;
            end if;
          end new_codegen;



        --------------------------------------------------------------------------------------------
        procedure build_all (
            interface : in p_class_interface;    -- interface t©¡dy
            is_exposed: in t_logical) =          -- T-je to exposovan˜ interface
        -- Sestav¡ cel˜ deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        begin
          -- p©ipravit z klad deskriptoru typu
          build_type_descriptor_base(interface^.codegen,interface^.refclass.getcentity,is_exposed,addr);

          -- dosadit adresy speci ln¡ch metod
          build_type_descriptor_special_methods(interface^.codegen,interface^.refclass.getcentity);

          -- dosadit adresy virtu ln¡ch metod
          build_class_descriptor_virtual_methods(interface,addr);

          -- dosadit adresy interfac–
          if not is_exposed and then pentity_type(interface^.refclass.getcentity)^.interfaces^.exposed_interfaces>0 then
            build_class_descriptor_interfaces(interface,addr);
            end if;

          -- nyn¡ je ji‘ velikost v¨ech slo‘ek deskriptoru zapo‡¡tan , m–‘eme posunout adresu
          addr.compute_next_address;
          end build_all;

    var
      interface    : p_class_interface;          -- interface t©¡dy

    begin
      ----- zpracovat nativn¡ rozhran¡ t©¡dy -----
      -- z¡skat nativn¡ interface
      interface:=pclass^.interfaces^.get_native_interface;

      -- alokovat ©¡d¡c¡ strukturu deskriptor
      new_codegen(interface,false);

      -- zkop¡rovat pointer na ©¡d¡c¡ strukturu p©¡mo do t©¡dy
      pclass^.codegen:=interface^.codegen;

      -- sestavit deskriptor
      build_all(interface,false);


      ----- zpracovat v¨echny exposovan‚ interfacy -----
      declare var
        it         : c_list_iterator;            -- iter tor p©es rozhran¡ t©¡dy

      begin
        -- p©ipravit iter tor
        pclass^.interfaces^.get_exposed_interfaces(it);

        -- zpracovat v¨echny exposovan‚ interfacy
        while it.get(interface) loop
          -- alokovat ©¡d¡c¡ strukturu deskriptoru
          new_codegen(interface,true);

          -- sestavit deskriptor
          build_all(interface,true);
          end loop;
        end declare;
      end build_class_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_type_descriptor (
        ptyp       : in pentity_type;            -- typ
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Sestav¡ deskriptor typu jin‚ho ne‘ t©¡dy.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat pamˆŸ
      if ptyp^.stype    in dts_index   then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_indexed);
      elsif ptyp^.stype in dts_base    then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_based);
      elsif ptyp^.stype in dts_ordinal then new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type_ordinal);
      else                                  new_entity_descriptor(ptyp^.codegen,picodegen_type,p_desc_type);
      end if;

      -- p©ipravit z klad deskriptoru typu
      build_type_descriptor_base(ptyp^.codegen,ptyp,false,addr);

      -- dosadit adresy speci ln¡ch metod
      build_type_descriptor_special_methods(ptyp^.codegen,ptyp);

      -- dosadit vlastnosti specifick‚ pro typy s b zov˜m typem
      if ptyp^.stype in dts_base then
        -- tag typu b ze
        set_tag(picodegen_type(ptyp^.codegen)^.desc_addr,p_desc_type_based(picodegen_type(ptyp^.codegen)^.desc)^.base_tag,ptyp^.base.getctype^.codegen);
        end if;

      -- dosadit vlastnosti specifick‚ pro typy s rozsahem
      if ptyp^.stype in dts_index then
        -- tag typu rozsahu
        set_tag(picodegen_type(ptyp^.codegen)^.desc_addr,p_desc_type_indexed(picodegen_type(ptyp^.codegen)^.desc)^.range_tag,ptyp^.srange.getctype^.codegen);
        end if;

      -- dosadit vlastnosti specifick‚ pro ordin ln¡ typy
      if ptyp^.stype in dts_ordinal then
        -- doln¡ a horn¡ mez typu
        p_desc_type_ordinal(picodegen_type(ptyp^.codegen)^.desc)^.first:=uniint_to_imm32(ptyp^.lval);
        p_desc_type_ordinal(picodegen_type(ptyp^.codegen)^.desc)^.last :=uniint_to_imm32(ptyp^.hval);
        end if;

      -- nyn¡ je ji‘ velikost v¨ech slo‘ek deskriptoru zapo‡¡tan , m–‘eme posunout adresu
      addr.compute_next_address;
      end build_type_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_message_descriptor (
        pmsg       : in pentity_message;         -- zpr va
        addr       : in out c_address_aligner_32) = -- p©idˆlova‡ adres
    -- Sestav¡ deskriptor zpr vy.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat pamˆŸ
      new_entity_descriptor(pmsg^.codegen,picodegen_message,p_desc_message);

      -- p©ipravit z klad deskriptoru entity
      build_entity_descriptor(pmsg^.codegen,pmsg,addr);

      -- tag typu zpr vy
      set_tag(picodegen_message(pmsg^.codegen)^.desc_addr,p_desc_message(picodegen_message(pmsg^.codegen)^.desc)^.type_tag,pmsg^.typ.getctype^.codegen);

      -- nyn¡ je ji‘ velikost v¨ech slo‘ek deskriptoru zapo‡¡tan , m–‘eme posunout adresu
      addr.compute_next_address;
      end build_message_descriptor;



    ------------------------------------------------------------------------------------------------
    static build_metadata =
    -- Sestaven¡ metadat.
    ------------------------------------------------------------------------------------------------
    begin
      -- je v–bec co sestavovat ?
      if list.list=nil then
        return;
        end if;

      -- zpracovat v¨echny typy
      for i in list.list^:range loop
        declare var
          entity   : pentity;                    -- entita

        begin
          -- pro zjednodu¨en¡
          entity:=list.list^[i];
          verify(386,entity^.linked<>ls_used or entity^.codegen<>nil);

          -- sestavit deskriptor pro tuto entitu
          case entity^.etype
            -- typ
            when et_type    do build_type_descriptor(entity,addr);

            -- t©¡da
            when et_class   do build_class_descriptor(entity,addr);

            -- zpr va
            when et_message do build_message_descriptor(entity,addr);

            -- pro nic jin‚ho metadata generovat neum¡me
            when others do verify(719,true)
            end case;

          -- ozna‡it symbol jako vyhodnocen˜
          entity^.linked:=ls_linked;
          end declare;
        end loop;
      end build_metadata;
   

      
    ------------------------------------------------------------------------------------------------
    static resolve_relocations =
    -- Vyhodnot¡ relokace dan‚ho symbolu.
    ------------------------------------------------------------------------------------------------
    with
      cg_gen.cg_ia32.ci_code,
      cg_gen.cg_ia32.ci_code.ci_instr;

    begin
      -- je v–bec co vyhodnocovat ?
      if inst.r=nil then 
        return; 
        end if;

      for i in inst.r^:range loop -- with inst.r^[i] loop
        declare 
        
          var
            r      : inst.r^:base;

          ------------------------------------------------------------------------------------------
          procedure set_absolute (
              value: in t_unsigned32) =
          -- Dosad¡ hodnotu absolutn¡ relokace a udˆl  ji load-time relokabiln¡.
          ------------------------------------------------------------------------------------------
          begin
            -- dosadit hodnotu absolutn¡ relokace do k¢du
            verify(590,not r.absolute);
            setfield(inst,r.disp,value);
            
            -- zapamatovat si relokaci pro generov n¡ EXE
            add_relocation(inst.cstart+r.disp);
            end set_absolute;

          ------------------------------------------------------------------------------------------
          procedure set_relative (
              value: in t_unsigned32) =
          -- Dosad¡ hodnotu relativn¡ relokace.
          ------------------------------------------------------------------------------------------
          var
            modtemp : t_mod_unsigned32;

          begin
            modtemp:=t_mod_unsigned32(value);
            modtemp-t_mod_unsigned32(r.nextip+inst.cstart);
            setfield(inst,r.disp,t_unsigned32(modtemp));
            end set_relative;

        begin
          -- pro zjednodu¨en¡, aŸ se neup¡¨eme
          r:=inst.r^[i];

          case r.relo_info.rtype
            -- pr zdn  relokace
            when irt_none     do { nic nedˆlat };

            -- symbol
            when irt_entity do
                case pentity(r.relo_info.rentity)^.etype
                  -- promˆnn 
                  when et_var do set_absolute(picodegen_var(pentity(r.relo_info.rentity)^.codegen)^.addr);

                  -- procedura
                  when et_procedure do
                      if pentity_procedure(r.relo_info.rentity)^.import_info<>nil
                        
                        -- extern¡ symbol
                        then set_absolute(getindirect(pentity_procedure(r.relo_info.rentity)));
                        
                        -- norm ln¡ symbol }{%%X A kter  instance to je ?
                        else 
                          if not r.absolute
                            then set_relative(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                            else set_absolute(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                            end if;
                          end if;

                  -- program, metoda, speci ln  metoda, kompila‡n¡ jednotka
                  when et_program, et_static, et_virtual, et_override, et_special, et_compile do
                      {%%X A kter  instance to je ? }
                      if not r.absolute
                        then set_relative(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                        else set_absolute(picodegen_subprog(pentity(r.relo_info.rentity)^.codegen)^.ifirst^.cstart);
                        end if;

                  -- tag zpr vy
                  when et_message do set_absolute(picodegen_message(pentity_message(r.relo_info.rentity)^.codegen)^.desc_addr);

                  -- tag typu/t©¡dy
                  when et_type,et_class do set_absolute(picodegen_type(pentity_type(r.relo_info.rentity)^.codegen)^.desc_addr);

                  when others do verify(33,true);
                  end case;                       

            -- p©¡m  hodnota
            when irt_imm do set_absolute(picodegen_imm(pexpimm(r.relo_info.rexpr)^.imm.codegen)^.addr);

            -- interface t©¡dy
            when irt_interface do set_absolute(picodegen_type(r.relo_info.rinterface^.codegen)^.desc_addr);

            when others do verify(203,true);
            end case;
          end declare;
        end loop;
      end resolve_relocations;



    ------------------------------------------------------------------------------------------------
    override link_segment_code =
    -- Segment: k¢d.
    ------------------------------------------------------------------------------------------------
    var
      block            : pimemblock;                 -- p©idˆlen˜ blok pamˆti
      p                : picodeinst;

    begin
      -- p©idˆlit adresy v¨em instanc¡m
      if code.list<>nil then
        for i in code.list^:range loop
          verify(594,code.list^[i]^.linked<>ls_used);

          --write_line(sym_get_qid(code.list^[i]));

          -- p©idˆlit adresy v¨em instanc¡m
          p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;
          loop
            -- p©idˆlit adresu
            p^.cstart:=_address.get_address_and_adjust(p^.c^:length);

            -- zapsat do listingu
            map_start_subprogram(sym_get_qid(code.list^[i]),unsigned_to_unidata_addr(p^.cstart));

            -- vypsat parametry
            if p^.profile.par<>nil then
              for j in p^.profile.par^:range loop
                map_automatic_variable(sym_get_qid(p^.profile.par^[j].pparam),
                    signed_to_unidata_addr(p^.profile.par^[j].ofs),
                    unsigned_to_unidata_size(p^.profile.par^[j].size));
                end loop;
              end if;

            -- vypsat lok ln¡ promˆnn‚
            block:=p^.layout.first;
            while block<>nil loop
              if block^.pvar<>nil
                then map_automatic_variable(sym_get_qid(block^.pvar),
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                else map_automatic_variable('<temporary>',
                         signed_to_unidata_addr(block^.ofs),
                         unsigned_to_unidata_size(block^.size));
                end if;
              block:=block^.next;
              end loop;

            -- © dkov‚ informace
            map_subprogram_lineinfo(unsigned_to_unidata_addr(p^.cstart),p^.di);

            -- konec
            map_end_subprogram;

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;

          -- ozna‡it za slinkovan‚
          code.list^[i]^.linked:=ls_linked;
          end loop;
        end if;
      end link_segment_code;



    ------------------------------------------------------------------------------------------------
    override link_segment_metadata =
    -- Segment: deskriptory typ–.
    ------------------------------------------------------------------------------------------------
    begin
      build_metadata(metadata,_address);
      end link_segment_metadata;



    ------------------------------------------------------------------------------------------------
    override link_segment_const =
    -- Segment: konstanty.
    ------------------------------------------------------------------------------------------------
    var
      pimm             : pimm_value;                 -- ukl dan  p©¡m  hodnota
      bin              : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      binsize          : tunidata_size;              -- velikost bin rn¡ho tvaru

    begin
      if cdata.list<>nil then
        for i in cdata.list^:range loop
          -- pro zjednodu¨en¡
          pimm:=cdata.list^[i].pimm;
          if pimm^.codegen=nil then
            -- alokovat pamˆŸ
            new picodegen_imm(pimm^.codegen);

            -- vypo‡¡tat po‘adovanou velikost pamˆti
            cpu^.getimmstoragesize(pimm^,cdata.list^[i].ptyp,binsize);

            -- p©idˆlit adresu
            picodegen_imm(pimm^.codegen)^.addr:=_address.get_address_and_adjust(unidata_size_to_unsigned(binsize));
            end if;
          end loop;
        end if;
      end link_segment_const;



    ------------------------------------------------------------------------------------------------
    override link_segment_init_var =
    -- Segment: inicializovan‚ promˆnn‚.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(idata,_address);
      end link_segment_init_var;



    ------------------------------------------------------------------------------------------------
    override link_segment_uninit_var =
    -- Segment: neinicializovan‚ promˆnn‚.
    ------------------------------------------------------------------------------------------------
    begin
      assign_var_addresses(data,_address);
      end link_segment_uninit_var;



    ------------------------------------------------------------------------------------------------
    override link =
    -- Sestaven¡.
    ------------------------------------------------------------------------------------------------
    with
      standard,standard.console, standard.conversions,
      cc_base,cc_base.cc_sym;

    var
      segment_address : c_address_aligner_32;    -- p©idˆlova‡ adres segment–

        --------------------------------------------------------------------------------------------
        procedure link_segment (
            _name  : in t_char32ustr;            -- popisn‚ jm‚no segmentu pro listing
            _seg   : in tsegment;                -- sestavovan˜ segment
          --_proc  : in p_link_segment;          -- metoda pro sestaven¡ zadan‚ho segmentu
            _align : in t_unsigned32) =          -- zarovn n¡ v r mci segementu
        -- Sestaven¡ zadan‚ho segmentu.
        --------------------------------------------------------------------------------------------
        var
          local_address : c_address_aligner_32;  -- p©idˆlova‡ adres v r mci segmentu

        begin
          -- zapsat do listingu za‡ tek segmentu
          map_start_segment(_name);

          -- po‡ te‡n¡ adresa segmentu
          seg[_seg].start:=segment_address.get_address;

          -- inicializovat p©idˆlova‡ adres v r mci segmentu
          local_address.init(segment_address.get_address,_align);

          -- vlastn¡ sestaven¡
          case _seg
            when tseg_code     do link_segment_code(local_address);
            when tseg_metadata do link_segment_metadata(local_address);
            when tseg_const    do link_segment_const(local_address);
            when tseg_init     do link_segment_init_var(local_address);
            when tseg_data     do link_segment_uninit_var(local_address);
            when tseg_import   do link_segment_import(local_address);
            when tseg_export   do link_segment_export(local_address);
            end case;

          -- vypo‡¡tat d‚lku segmentu
          seg[_seg].len:=local_address.get_address-segment_address.get_address;

          -- vypo‡¡tat adresu p©¡¨t¡ho segmentu
          segment_address.shift_address(seg[_seg].len);

          -- konec segmentu
          map_end_segment;
          end link_segment;

    var
      pimm             : pimm_value;                 -- ukl dan  p©¡m  hodnota
      bin              : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      binsize          : tunidata_size;              -- velikost bin rn¡ho tvaru
      p                : picodeinst;
      k                : t_unsigned32;               -- aktu ln¡ adresa
      ud_addr          : tunidata_addr;              -- adresa objektu
      ud_size          : tunidata_size;              -- velikost objektu
      avail            : t_logical;                  -- T-automatick  promˆnn  m  p©i©azenu adresu
      srch             : tentitysearch;
      block            : pimemblock;                 -- p©idˆlen˜ blok pamˆti

    begin
      -- inicializovat p©idˆlova‡ adres segment–
      segment_address.init(seg[tseg_code].start,gran);

      ----- F ze 1: vypo‡¡tat adresy k¢du -----
      -- p©idˆlit adresy v¨em instanc¡m
      link_segment('Code',tseg_code,calign);

      ----- F ze 2: p©idˆlit adresy promˆnn˜ch, konstant a deskriptor– -----
      -- 1. metadata
      link_segment('Metadata',tseg_metadata,dalign);

      -- 2. konstanty
      link_segment('Constants',tseg_const,dalign);

      -- 3. inicializovan‚ promˆnn‚
      link_segment('Initialized Variables',tseg_init,dalign);

      -- 4. neinicializovan‚ promˆnn‚
      link_segment('Uninitialized Variables',tseg_data,dalign);

      ----- F ze 3.1 : p©ipravit importovan‚ funkce -----
      -- sestavit tabulku importovan˜ch funkc¡
      link_segment('Import',tseg_import,1);

      ----- F ze 3.2 : p©ipravit exportovan‚ funkce -----
      -- sestavit tabulku exportovan˜ch funkc¡
      link_segment('Export',tseg_export,1);

      ----- F ze 3.3 : vyhodnotit odkazy v k¢du -----
      if reloc.list<>nil then
        for i in reloc.list^:range loop
          p:=picodegen_subprog(reloc.list^[i]^.codegen)^.ifirst;
          loop
            -- vyhodnotit
            resolve_relocations(p^);

            -- dal¨¡ instance
            p:=p^.next;
            until p=nil;
          end loop;
        end if;

      ----- F ze 4 : debug informace -----
    #if debug2 then;
      -- jaky typ debug informaci budeme generovat
      if not cfg_no_debug_info then
      #if codeview then;
        case debug_mode
          -- CodeView debug inforation
          when tdit_codeview do new p_codeview(debug_info);
          end case;
      #end if;
        end if;

      -- generujeme nejake debug informace ?
      if debug_info<>nil then
        -- inicializace debug informaci
        debug_info^.init;

        -- sestavime strom s debug informacemi
        debug_info^.linkdebuginfo(compi,^this);
        end if;
    #end if;
      end link;



    ------------------------------------------------------------------------------------------------
    override info =
    -- V˜pis souhrnn˜ch informac¡ do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;



    ------------------------------------------------------------------------------------------------
    override getaddrbase =
    -- Adresa, ke kter‚ se vztahuj¡ relokace.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(imagebase);
      end getaddrbase;



    ------------------------------------------------------------------------------------------------
    override getentrypoint =
    -- Entrypoint programu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(picodegen_subprog(compi^.codegen)^.ifirst^.cstart);
      end getentrypoint;



    ------------------------------------------------------------------------------------------------
    override checkseg =
    -- True, pokud se m  zadan˜ segment zahrnout do EXE.
    ------------------------------------------------------------------------------------------------
    begin
      result:=seg[_seg].len>0;
      end checkseg;



    ------------------------------------------------------------------------------------------------
    override getsegbase =
    -- B zov  adresa segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unicode_addr(seg[_seg].start);
      end getsegbase;



    ------------------------------------------------------------------------------------------------
    override getsegtotal =
    -- Celkov  velikost segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=unsigned_to_unidata_size(seg[_seg].len);
      end getsegtotal;



    ------------------------------------------------------------------------------------------------
    override writesegment =
    -- Do v˜stupn¡ho souboru zap¡¨e zadan˜ segment.
    ------------------------------------------------------------------------------------------------
    with
      standard.classes,
      standard.classes.lists;

    var
      bin          : p_unsigned8array;           -- ukl dan  p©¡m  hodnota v bin rn¡m tvaru
      allocsize    : tunidata_size;              -- velikost alokovan‚ pamˆti

        --------------------------------------------------------------------------------------------
        procedure write_imm (
            imm    : in timm_value;              -- p©¡m  hodnota
            ptyp   : in pentity_type;            -- typ
            full   : in t_logical) =             -- T-ulo‘it v d‚lce typu, F-v min. d‚lce
        -- Zap¡¨e do souboru p©¡mou hodnotu.
        --------------------------------------------------------------------------------------------
        with
          advanced,
          advanced.low_level;

        use
          advanced.low_level.unchecked_memory_access;

        var
          binsize  : tunidata_size;              -- velikost bin rn¡ho tvaru
          fill     : t_unsigned32;               -- velikost zarovn n¡
          x        : t_unsigned32;
          ud       : tunidata_size;

        begin
          -- ur‡it velikost bin rn¡ho tvaru
          cpu^.getimmstoragesize(imm,ptyp,binsize);

          -- realokovat pamˆŸ
          {%%X Nekompatibiln¡ s 64-bitovou implementac¡ }
          if binsize>allocsize

            -- alokovat nov˜ blok
            then
              discard bin;
              allocsize:=binsize;
              new bin range unidata_size_to_unsigned(allocsize);

            -- jinak jen fillznout ten star˜
            else
              unchecked_memory_access.memory_fill_zero(bin^,unidata_size_to_unsigned(allocsize))
              end if;

          -- sestavit bin rn¡ tvar
          cpu^.immtobinary(imm,ptyp,bin^,binsize);

          -- zapsat
          os^.writex(bin^,unidata_size_to_unsigned(binsize));

          -- vypo‡¡tat d‚lku zarovn n¡
          if full
            -- (+v˜pl¤ za konstantou krat¨¡ ne‘ je typ)
            then
              x:=unidata_size_to_unsigned(ptyp^.size);
              fill:=unidata_size_to_unsigned(ptyp^.size-binsize);
              if x mod dalign<>0 then 
                fill+(dalign-(x mod dalign)); 
                end if;
            -- (nezarovn v  se na velikost typu ale na velikost konstanty)
            else
              fill:=unidata_size_to_unsigned(binsize);
              if fill mod dalign<>0
                then fill:=dalign-(fill mod dalign);
                else fill:=0;
                end if;
              end if;

          -- zarovnat
          ffillz(os,fill);
          end write_imm;



        --------------------------------------------------------------------------------------------
        #template write_padding (size);
        -- Zap¡¨e do v˜stupn¡ho streamu pot©ebn‚ zarovn n¡
        --------------------------------------------------------------------------------------------
          if size mod dalign<>0 then 
            os^.writex(fill_nops,dalign-(size mod dalign)); 
            end if;
          #end write_padding;



        --------------------------------------------------------------------------------------------
        #template write_and_pad (data,size);
        -- Zap¡¨e do v˜stupn¡ho streamu data a pot©ebn‚ zarovn n¡
        --------------------------------------------------------------------------------------------
          -- zapsat
          os^.writex(data,size);

          -- zarovnat
          write_padding(size);
          #end write_and_pad;



        --------------------------------------------------------------------------------------------
        procedure write_desc_entity_base (
            codegen: in picodegen_metadata;      -- ©¡d¡c¡ struktura s deskriptorem entity
            size   : out t_unsigned) =           -- kumulativn¡ velikost v¨ech slo‘ek deskriptoru
        -- Zap¡¨e do souboru z klad deskriptoru entity.
        --------------------------------------------------------------------------------------------
        begin
          -- zapsat identifik tor
          if codegen^.desc_qid<>nil then
            write_and_pad(codegen^.desc_qid^,4+codegen^.desc_qid^:length*4);
            end if;

          -- zapsat deskriptor 
          os^.writex(codegen^.desc^,codegen^.desc_size{%%TODO(COMPATIBILITY) codegen^.desc^:size});
          size+codegen^.desc_size;
          end write_desc_entity_base;



        --------------------------------------------------------------------------------------------
        procedure write_desc_class (
            codegen: in picodegen_interface) =   -- deskriptor t©¡dy (resp. interfacu)
        -- Zap¡¨e do souboru deskriptor t©¡dy.
        --------------------------------------------------------------------------------------------
        var
          size     : t_unsigned;                 -- kumulativn¡ velikost v¨ech slo‘ek

        begin
          -- z klad tvo©¡ deskriptor entity
          write_desc_entity_base(codegen,size);

          -- n sleduje virtu ln¡ tabulka
          if codegen^.vtable<>nil then
            os^.writex(codegen^.vtable^,get_vtable_size(codegen));
                       {%%TODO(COMPATIBILITY) codegen^.vtable^:size);}
            size+get_vtable_size(codegen);
            end if;

          -- a tabulka interfac– 
          if codegen^.itable<>nil then
            os^.writex(codegen^.itable^,get_itable_size(codegen));
            size+get_itable_size(codegen);
            end if;

          -- zarovn n¡
          write_padding(size);
          end write_desc_class;



        --------------------------------------------------------------------------------------------
        procedure write_desc_entity (
            codegen: in picodegen_metadata) =    -- deskriptor entity
        -- Zap¡¨e do souboru deskriptor typu.
        --------------------------------------------------------------------------------------------
        var
          size     : t_unsigned;                 -- kumulativn¡ velikost v¨ech slo‘ek

        begin
          -- z klad tvo©¡ deskriptor entity
          write_desc_entity_base(codegen,size);

          -- zarovn n¡
          write_padding(size);
          end write_desc_entity;

    var
      pvar             : pentity_var;                -- promˆnn 
      size             : t_unsigned32;               -- velikost promˆnn‚
      fill             : t_unsigned32;               -- velikost dodate‡n‚ v˜plnˆ
      imm              : pimm_value;                 -- p©¡m  hodnota
      pcodegen         : picodegen_type;
      p                : picodeinst;

    begin
      case _seg
        -- k¢d
        when tseg_code do
            for i in code.list^:range loop
              p:=picodegen_subprog(code.list^[i]^.codegen)^.ifirst;

              -- zapsat v¨echny instance
              loop
                -- zapsat instrukce
                os^.writex(p^.c^[p^.c^:first],p^.c^:length);

                -- zarovnat
                if p^.c^:length mod calign<>0 then 
                  os^.writex(fill_nops,calign-(p^.c^:length mod calign)); 
                  end if;

                -- dal¨¡ instance
                p:=p^.next;
                until p=nil;
              end loop;

        -- metadata
        when tseg_metadata do
            for i in metadata.list^:range loop
              if metadata.list^[i]^.etype=et_class

                -- pro t©¡du se mus¡ zapsat deskriptory v¨ech interfac–
                then
                  declare var
                    it        : c_list_iterator; -- iter tor p©es rozhran¡ t©¡dy
                    interface : p_class_interface; -- interface t©¡dy

                  begin
                    -- p©ipravit iter tor
                    pentity_type(metadata.list^[i])^.interfaces^.get_all_interfaces(it);

                    -- zpracovat v¨echny exposovan‚ interfacy
                    while it.get(interface) loop
                      write_desc_class(interface^.codegen);
                      end loop;
                    end declare;

                -- pro ostatn¡ typy entit je to mnohem jednodu¨¨¡
                else
                  write_desc_entity(metadata.list^[i]^.codegen);
                  end if;
              end loop;

        -- konstanty
        when tseg_const do
            allocsize:=uds_0;
            bin:=nil;
            for i in cdata.list^:range loop
              write_imm(cdata.list^[i].pimm^,cdata.list^[i].ptyp,false);
              end loop;
            discard bin;

        -- inicializovan  data
        when tseg_init do
            allocsize:=uds_0;
            bin:=nil;
            for i in idata.list^:range loop 
              write_imm(pentity_var(idata.list^[i])^.init.getimm^,pentity_var(idata.list^[i])^.typ.getctype,true); 
              end loop;
            discard bin;

        -- neinicializovan  data
        when tseg_data do { nen¡ co zapisovat };

        -- importy
        when tseg_import do { nev¡m jak zapsat };

        -- exporty
        when tseg_export do { nev¡m jak zapsat };

        when others do verify(204,true);
        end case;
      end writesegment;



    ------------------------------------------------------------------------------------------------
    virtual getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=0;
      end getindirect;

    end linkresolver_ia32;



----------------------------------------------------------------------------------------------------
class private linkresolver_ia32_win32 =
-- Vyhodnocova‡ cross-referenc¡ a adres: Win32 na IA-32.
----------------------------------------------------------------------------------------------------

    with
      cp_cpu.cp_32.cp_def,
      cp_os,
      cp_os.cp_win32;

    ------------------------------------------------------------------------------------------------
    override link_segment_import =
    -- Linkov n¡ segmentu: importovan‚ entity.
    ------------------------------------------------------------------------------------------------
    with
      standard.templates;

    begin
      -- je v–bec co importovat ?
      if import.list=nil or else import.list^:length=0 then 
        map_write_line('No imported entities');
        return; 
        end if;

      -- set©¡dit importovan‚ funkce
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=import.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pimportinfo(pentity_procedure(import.list^[j])^.import_info)^.libname>pimportinfo(pentity_procedure(import.list^[j+1])^.import_info)^.libname then
              --%%TODO(#TEMPLATE) exchange(import.list^[j],import.list^[j+1]);
              declare var
                psym : pentity;
              begin
                psym:=import.list^[j];
                import.list^[j]:=import.list^[j+1];
                import.list^[j+1]:=psym;
                end declare;
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;

      -- p©i©adit adresy na adresy procedur
      for i in import.list^:range loop
        -- mezera p©i zmˆnˆ knihovny
        if i>import.list^:first and pimportinfo(pentity_procedure(import.list^[i-1])^.import_info)^.libname<>pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname then
          _address.shift_address(lprg32);
          end if;

        -- adresa
        pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.addr:=_address.get_address_and_adjust(lprg32);
        end loop;

      -- mezera za posledn¡ knihovnou
      _address.shift_address(lprg32);
      end link_segment_import;



    ------------------------------------------------------------------------------------------------
    override link_segment_export =
    -- Linkov n¡ segmentu: exportovan‚ entity.
    ------------------------------------------------------------------------------------------------
    with 
      standard.templates,                           
      cc_def.cc_var;

    begin
      -- je v–bec co exportovat ?
      if export_list.list=nil or else export_list.list^:length=0 then 
        map_write_line('No exported entities');
        return; 
        end if;

      -- zjistit plne kvalifikovana jmena exportu
      for i in export_list.list^:range loop
        pexportinfo(pentity_procedure(export_list.list^[i])^.export_info)^.export_name:=sym_get_qid(export_list.list^[i]);
        end loop;
      
      -- set©¡dit podle exportovan˜ch jmen
      declare var
        zmena      : t_logical;
        i_sort     : t_unsigned;

      begin
        i_sort:=export_list.list^:length;
        loop
          zmena:=false;
          for j in 1..i_sort-1 loop
            if pexportinfo(pentity_procedure(export_list.list^[j])^.export_info)^.export_name>pexportinfo(pentity_procedure(export_list.list^[j+1])^.export_info)^.export_name then
              --%%TODO(#TEMPLATE) exchange(export_list.list^[j],export_list.list^[j+1]);
              declare var
                psym : pentity;
              begin
                psym:=export_list.list^[j];
                export_list.list^[j]:=export_list.list^[j+1];
                export_list.list^[j+1]:=psym;
                end declare;
              zmena:=true;
              end if;
            end loop;
          pred i_sort;
          until not zmena or i_sort=1;
        end declare;

      -- vypsat exporty do listingu
      map_write_line('Exported symbols:');
      for i in export_list.list^:range loop
        map_exported_entity(sym_get_qid(export_list.list^[i]));
        end loop;
      end link_segment_export;



    ------------------------------------------------------------------------------------------------
    override getindirect =
    -- Vr t¡ nep©¡mou adresu importovan‚ho podprogramu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=pimportinfo(proc^.import_info)^.addr;
      end getindirect;
    
    end linkresolver_ia32_win32;



end cl_ia32;