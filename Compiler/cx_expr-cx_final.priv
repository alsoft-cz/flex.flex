----------------------------------------------------------------------------------------------------
module private cx_final =
-- P©eklada‡ Flexu.
-- Finalizace v˜razu.
----------------------------------------------------------------------------------------------------
-- Ondra : 01.08.2001 : Vytvo©il.
----------------------------------------------------------------------------------------------------

with
  cc_attr,cc_sym,cc_type,
  cx_util,cx_imm;


type
  t_final_context  = record
    assign_typ     : typeview;                   -- skutecny typ prirazovaciho vyrazu finalizace
    end record;

----------------------------------------------------------------------------------------------------
procedure selectusage (
    actual         : in expusage;                -- aktu ln¡ pou‘it¡ v˜razu
    proposed       : in expusage)                -- navr‘en‚ pou‘it¡ v˜razu
                   return expusage =             -- zvolen‚ pou‘it¡ v˜razu
-- Zvol¡ lep¨¡ pou‘it¡ v˜razu. Pokud je aktu ln¡ pou‘¡t¡ EU_FORMAL, preferuje v‘dy to, jinak 
-- navr‘en‚.
----------------------------------------------------------------------------------------------------
begin
  if actual=eu_formal
    then result:=eu_formal;
    else result:=proposed;
    end if;
  end selectusage;


-- %%HYNEK - zobecnit??
----------------------------------------------------------------------------------------------------
procedure t_is_ranged (
    typ            : in typeview)
                     return t_logical =
-- vrati T, pokud je zadany typ "ranged" - ma logicke meze mensi nez jsou fyzicke meze argumentu
-- [typ] musi byt dts_ordinal, jinak zpusobi interni chybu
----------------------------------------------------------------------------------------------------
var
  penttyp          : pentity_type;               -- entita reprezentujici typ
  typsize          : tunidata_size;              -- velikost typu v bajtech
  phlval           : tuniint;                    -- fyzicka dolni unimeze typu
  phhval           : tuniint;                    -- fyzicka horni unimeze typu

begin
  -- souvisejici entita typu vyrazu
  penttyp:=typ.getctype;

  -- vyraz je ranged pouze pro ordinalni typy
  verify({VERIFY=}000717,penttyp^.stype not in dts_ordinal);

  -- zjisti parametry typu
  cpu^.getordparams1(penttyp^.stype, penttyp^.bits,typsize,phlval,phhval);

  -- porovnej logicke a fyzicke meze
  result:=penttyp^.lval<>phlval or penttyp^.hval<>phhval;
  end t_is_ranged;



----------------------------------------------------------------------------------------------------
procedure do_final (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpnode;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context; -- kontext finalizace
    catch_mode     : in t_catch_mode:=catch_mode_implicit); -- zp–sob, jak zachyt vat chyby resume_error
-- Finalizace.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_final_operator (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpoper;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace oper tor–.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure c_final (
        curr       : in tcontext;       -- p©ekl dan˜ prvek
        expr       : in pexpnode;   -- v˜raz
        ptyp       : in typeview;   -- po‘adovan˜ typ v˜razu
        usage      : in expusage;   -- pou‘it¡ v˜razu
        info       : in expinfo;    -- informace o pr–bˆhu anal˜zy
        fin_context: in out t_final_context) = -- kontext finalizace
    -- Finalizace.
    ------------------------------------------------------------------------------------------------
    begin
      -- zp–sob z©etˆzen¡ je touhle dobou ji‘ ur‡en

      -- %%X Zde je oper tor v n- rn¡m tvaru ale p©i ur‡ov n¡ CONCATKIND byl
      -- je¨tˆ v bin rn¡m. Nem–‘e se st t, ‘e by byl chybn˜ ? (snad ne)

      -- prov‚st typovou kontrolu se spr vn˜m typem
      case expr^.concatkind
        -- substring nebo subpole
        when nck_substring, nck_subarray do do_final(curr,expr,ptyp,usage,info,fin_context);

        -- komponenta
        when nck_component do do_final(curr,expr,ptyp.getbase(curr),usage,info,fin_context);

        when others do verify({VERIFY=}000375,true);
        end case;
      end c_final;

var
  el               : pexpnode;                   -- podv˜razy
  er               : pexpnode;                   -- podv˜razy
  er0              : pexpnode;                   -- podv˜razy
  er_zprac         : t_logical;                  -- finalizace prav˜ch podv˜raz–                
  el_type          : typeview;
  er_type          : typeview;                   
  ass_type         : typeview;
  a                : tuniint;                    -- hodnota konst. operandu


begin
  -- oddˆlit podv˜razy 
  expr^.get(el,er0);

  -- reset typ prirazeni
  fin_context.assign_typ:=nulltype;
  
  -- finalizovat lev˜ podv˜raz
  if expr^.assign

    -- p©i©azen¡ 
    then
      if expr^.oper=op_assign
        then do_final(curr,el,nulltype,eu_write,info,fin_context);
        else do_final(curr,el,nulltype,eu_change,info,fin_context);
        end if;

    -- norm ln¡ oper tor 
    else
      case expoperinfo[expr^.oper].tc
        when tc_none    do do_final(curr,el,nulltype,eu_read,info,fin_context);
        when tc_left    do do_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when tc_right   do do_final(curr,el,nulltype,eu_read,info,fin_context);
        when tc_both    do do_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when tc_concat  do c_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when others     do verify({VERIFY=}000373,true);
        end case;
      end if;
  
  -- mame typ prirazeni?
  if fin_context.assign_typ.getutype=nil

    -- NE - pouzi typ vyrazu
    then ass_type:=expr^.t;

    -- ANO - pouzi jej
    else ass_type:=fin_context.assign_typ;
    end if;
  
  -- finalizovat prav˜ podv˜raz 
  {%%X a co UNCHECKED ? }
  er:=er0;
  er_zprac:=true;
  while er<>nil loop
    -- finalizovat
    case expoperinfo[expr^.oper].tc
      when tc_none   do do_final(curr,er,nulltype,eu_read,info,fin_context);
      when tc_left   do do_final(curr,er,nulltype,eu_read,info,fin_context);
      when tc_right  do do_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when tc_both   do do_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when tc_concat do c_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when others    do verify({VERIFY=}000374,true);
      end case;

    -- povedla se finalizace podv˜razu ? 
    er_zprac:=er_zprac and (er^.zprac>=ep_final);

    -- dal¨¡ prav˜ podv˜raz 
    er:=er^.next;
    end loop;

  -- typy podvyrazu
  el_type:=el^.t;
  er_type:=er0^.t;

  -- *** Kontroly rozsahu
  
  -- operator
  case expr^.oper
    
    -- scitani, odcitani, nasobeni
    when op_add,op_sub,op_mul do
      -- typ vyrazu s plnym pohledem, ordinalni a bez modularni aritmetiky
      if t_is_nonmod_ordinal(expr^.t) then
        -- treba provest overflow kontrolu a kontrolu mezi vysledku
        expr^.set_run_check(rchcl_gen,rch_ordinal_overflow);
      
        -- ma typ vyrazu logicke meze mensi nez fyzicke?
        if t_is_ranged(expr^.t) then
          -- ano - provest jeste kontrolu mezi
          expr^.set_run_check(rchcl_gen,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_gen,expr^.t);
          end if;
        end if;

      -- typ vysledku s plnym pohledem, ordinalni a bez modularni aritmetiky
      if expr^.assign and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu?
      and then not t_is_range_inclusive(ass_type,expr^.t)
        then
          -- kontrola rozsahu
          expr^.set_run_check(rchcl_load,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_load,ass_type);
          end if;
    
    -- prirazeni
    when op_assign do
      -- zdroj je nekonstantn¡ full ordinal
      if er0^.ntype<>nt_imm and then t_is_sts(er_type,dts_ordinal)
      -- c¡l je nemodul rn¡ full ordinal
      and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu?
      and then not t_is_range_inclusive(ass_type,er_type)
        then
          -- kontrola rozsahu
          er0^.set_run_check(rchcl_load,rch_ordinal_range);
          er0^.set_rangecheck_type(rchcl_load,ass_type);
          end if;

    when others do ;
    end case;
  
  -- povedla se finalizace podv˜raz– ? 
  if (el^.zprac<ep_final) or not er_zprac {(er^.zprac<ep_final)} then
    el:=nil;
    return;
    end if;

  -- detekovat chyby konst. v˜raz–
  case expr^.oper
    -- celo‡¡seln‚ dˆlen¡ (zbytek po dˆlen¡)
    when op_idiv,op_imod do
      -- zkontrolovat prav‚ operandy
      er:=er0;
      while er<>nil loop
        -- prav˜ operand konstantn¡
        if er^.ntype=nt_imm then
          -- na‡¡st hodnotu prav‚ho operandu
          load_uniint(pexpimm(er)^.imm,a);

          -- X div 0 --> chyba
          if a=ui_0 then
            ce^.seterror({CCERR=}000543,ce_divzero);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          end if;

        er:=er^.next;
        end loop;

    -- shift doleva, doprava
    when op_shl,op_shr do
      -- zkontrolovat prav‚ operandy
      er:=er0;
      while er<>nil loop
        -- prav˜ operand konstantn¡
        if er^.ntype=nt_imm then
          -- na‡¡st hodnotu prav‚ho operandu
          load_uniint(pexpimm(er)^.imm,a);

          -- prav˜ operand z porn˜
          if a<ui_0 then
            ce^.seterror({CCERR=}000544,ce_shift);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          end if;

        er:=er^.next;
        end loop;
    
    when others do

    end case;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_operator;



----------------------------------------------------------------------------------------------------
procedure a_final_unary (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpunary;      -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace un rn¡ch oper tor–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  ass_type         : typeview;                   -- skutecny typ prirazeni
  a                : tuniint;                    -- hodnota konst. operandu

begin
  -- oddˆlit podv˜razy
  expr^.get(el);

  -- reset tyou prirazeni
  fin_context.assign_typ:=nulltype;

  -- finalizace podv˜razu
  if expr^.assign

    -- p©i©azen¡
    then do_final(curr,el,nulltype,eu_write,info,fin_context);

    -- norm ln¡ oper tor
    else do_final(curr,el,expr^.t,eu_read,info,fin_context);
    end if;

  -- operace nad p©¡mou ordin ln¡ hodnotou
  if t_is_sts(expr^.t,dts_ordinal) and el^.ntype=nt_imm then
    -- na‡¡st hodnotu operandu
    load_uniint(pexpimm(el)^.imm,a);

    -- p©edch–dce prvn¡ hodnoty
    if (expr^.oper=un_pred and a=expr^.t.getlval())
    -- n sledn¡k posledn¡ hodnoty
    or (expr^.oper=un_succ and a=expr^.t.gethval())
      then
        ce^.seterror({CCERR=}000545,ce_resultrange);
        expr^.errpos;
        ce^.raiseerror;
        end if;
    end if;

  -- mame typ prirazeni?
  if fin_context.assign_typ.getutype=nil
    -- NE - pouzi typ vyrazu
    then ass_type:=fin_context.assign_typ;
    
    -- ANO - pouzi jej
    else ass_type:=expr^.t;
    end if;
  
  case expr^.oper
    -- operatory scitani, odcitani, nasobeni
    when un_succ, un_pred, un_minus, un_abs do
      -- typ vyrazu s plnym pohledem, ordinalni a bez modularni aritmetiky
      if t_is_nonmod_ordinal(expr^.t) then
        -- treba provest overflow kontrolu a kontrolu mezi vysledku
        expr^.set_run_check(rchcl_gen,rch_ordinal_overflow);
    
        -- ma typ vyrazu logicke meze mensi nez fyzicke
        if t_is_ranged(expr^.t) then
          -- ano - provest jeste kontrolu mezi
          expr^.set_run_check(rchcl_gen,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_gen,expr^.t);
          end if;
        end if;

      -- typ vysledku s plnym pohledem, ordinalni a bez modularni aritmetiky
      if expr^.assign and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
      and then not t_is_range_inclusive(ass_type,expr^.t)
        then
          -- kontrola rozsahu
          expr^.set_run_check(rchcl_load,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_load,ass_type);
          end if;
   
    when others do ;
    end case;

  -- povedla se finalizace podv˜razu ? 
  if el^.zprac<ep_final then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_unary;



----------------------------------------------------------------------------------------------------
procedure a_final_component (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpcomponent;  -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace komponenty.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;                -- souvisej¡c¡ entita
  instance         : pexpnode;               -- souvisej¡c¡ instance t©¡dy

begin
{
  -- finalizovat podv˜raz
  if expr^.sub<>nil then do_final(curr,expr^.sub,nulltype,usage,info,fin_context); end if;

  {%%X Co se tady d  finalizovat ? }
}
  
  -- komponenta se pouzije pro zapis?
  if usage in expusageset:[eu_write,eu_change] then
    -- nastav typ prirazeni
    fin_context.assign_typ:=expr^.t;
    end if;

  case expr^.nclass
    -- promˆnn 
    when nc_var do
        -- souvisej¡c¡ entita
        psym:=expr^.getsymbol;

        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          -- nen¡ souvisej¡c¡ entita slo‘ka nˆ‡eho ?
          if (psym=nil) or (pentity_var(psym)^.mclass in mcs_offset)
            -- pokud o entitˆ nic nev¡m, nebo je to nˆ‡¡ slo‘ka, finalizovat pro stejn‚ pou‘it¡
            then do_final(curr,expr^.sub,nulltype,usage,info,fin_context);
            -- jinak finalizovat pro ‡istˆ form ln¡ pou‘it¡
            else do_final(curr,expr^.sub,nulltype,eu_formal,info,fin_context);
            end if;
          end if;

        -- m  cenu bl¡‘e zkoumat jen pokusy o z pis
        if usage in expusageset:[eu_write,eu_change] then
          -- zkontrolovat podle souvisej¡c¡ entity
          if psym<>nil then
            case psym^.etype
              -- promˆnn 
              when et_var   do
                  -- zkontrolovat m¢d p©¡stupu
                  --%%X Identick‚ s kontrolou v a_final_deref => zobecnit do procedury
                  case pentity_var(psym)^.vaccess
                    -- bez omezen¡ => z pis povolen
                    when va_norm      do { ok };

                    -- konstantn¡ => z pis zak z n
                    when va_const     do
                        ce^.seterror({CCERR=}000424,ce_i_write_access);
                        expr^.errpos;
                        ce^.resumeerror;

                    -- chr nˆn  => z pis nˆkde povolen, nˆkde zak z n => zkoumat d l
                    when va_protected do
                        if not sym_is_included_or_ancestor(curr.entity,sym_get_container(psym)) then
                          ce^.seterror({CCERR=}000425,ce_i_write_access);
                          expr^.errpos;
                          ce^.resumeerror;
                          end if;

                    when others do verify({VERIFY=}000605,true);
                    end case;

              -- parametr
              when et_param do
                  -- zapisovat nelze do IN parametru
                  if pentity_param(psym)^.mode=pm_in then
                    ce^.seterror({CCERR=}000426,ce_i_write_access);
                    expr^.errpos;
                    ce^.resumeerror;
                    end if;

              -- nic jin‚ho neum¡me
              when others do verify({VERIFY=}000604,true);
              end case;
            end if;
          end if;

    -- hodnota
    when nc_value do
        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,usage,info,fin_context);
          end if;

        -- z pis nen¡ povolen
        verify({VERIFY=}000607,usage in expusageset:[eu_write,eu_change]);

    -- procedura
    when nc_proc do
        -- souvisej¡c¡ entita
        psym:=expr^.getsymbol;

        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          -- bude n s zaj¡mat potenci ln¡ instance t©¡dy
          x_classinstance(expr^.sub,instance);

          -- nen¡ to metoda s uvedenou instanc¡ t©¡dy ?
          if usage=eu_addr and then psym<>nil and then pentity_subprogram(psym)^.instance<>tip_none 
          and then instance<>nil and then instance^.nclass<>nc_type
            -- zji¨Ÿuje se adresa metody => nepochybnˆ bude pot©eba i adresa instance
            then do_final(curr,expr^.sub,nulltype,eu_addr,info,fin_context);
            -- jak‚koliv jin‚ zp–soby pou‘it¡ indikuj¡ finalizaci podv˜razu pro form ln¡ pou‘it¡
            else do_final(curr,expr^.sub,nulltype,eu_formal,info,fin_context);
            end if;
          end if;

        -- je povolen jen form ln¡ p©¡stup a z¡sk n¡ adresy
        verify({VERIFY=}000608,usage not in expusageset:[eu_formal,eu_addr]);

    -- zpr va
    when nc_message     do
        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen form ln¡ p©¡stup a z¡sk n¡ adresy
        verify({VERIFY=}000609,usage not in expusageset:[eu_formal,eu_addr]);

    -- typ
    when nc_type do
        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen form ln¡ p©¡stup a pou‘it¡ hodnoty (tagu)
        verify({VERIFY=}000620,usage not in expusageset:[{%%X Doplnˆno EU_READ, je to dob©e??}eu_read,eu_use,eu_formal]);

    -- nˆco jin‚ho
    when others do
        -- finalizovat podv˜raz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen form ln¡ p©¡stup
        verify({VERIFY=}000606,usage not in expusageset:[{%%X Doplnˆno EU_NONE}eu_none,eu_formal]);
    end case;

  -- povedla se finalizace podv˜razu ? 
  if (expr^.sub<>nil) and (expr^.sub^.zprac<ep_final) then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_component;



----------------------------------------------------------------------------------------------------
procedure a_final_imm (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpimm;        -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in  expinfo;       -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace p©¡m‚ hodnoty.
----------------------------------------------------------------------------------------------------
var
  change           : t_logical;                  -- T-zmˆnila se reprezentace konstanty

begin
  verify({VERIFY=}000887,usage=eu_write);
  if ptyp.tview<>tview_null

    -- po‘adov n konkr‚tn¡ typ konstanty
    then
      if not t_equal(expr^.t,ptyp) then
        -- konvertovat p©¡mou hodnotu
        imm_settype(curr,expr^.imm,expr^.t,ptyp,change);

        -- zmˆnit typ v˜razu pokud se zmˆnila reprezentace
        -- nebo pokud po‘adujeme ready-to-use hodnotu
        -- nebo pokud byl p–vodn¡ typ univerz ln¡
        if change or (usage=eu_use) or t_is_sts(expr^.t,dts_unitype) then
          expr^.t:=ptyp;
          end if;
        end if;

      -- test spr vnosti
      if (expr^.t.tview=tview_full) and (usage in expusageset:[eu_read,eu_use,eu_formal]) then
        imm_check(curr,expr^.imm,expr^.t);
        end if;

    -- nen¡ ur‡en typ 
    else
      -- prov‚st test mez¡
      if (expr^.t.tview=tview_full) and (usage in expusageset:[eu_use,eu_formal]) then
        imm_check(curr,expr^.imm,expr^.t);
        end if;
      end if;

  -- %%X ?
  --verifyx({VERIFY=}000531,(expr^.imm.ic=ic_set and expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize)
  --         or (expr^.imm.ic=ic_array and expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize)
  --         or (expr^.imm.ic=ic_record and expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize),expr^.pos);

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;

catch
  when resume_error, compiler_error do
      expr^.errpos;
      raise;
  end a_final_imm;



----------------------------------------------------------------------------------------------------
procedure a_final_call (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexplist;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace vol n¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arg              : pexpitem;                   -- argumenty
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty

begin
  -- oddˆlit podv˜razy
  expr^.get(el,arg);

  -- finalizovat podv˜raz
  do_final(curr,el,nulltype,eu_addr,info,fin_context);

  -- finalizovat argumenty
  vyhodnoceno:=true;
  while arg<>nil loop
    if arg^.zprac=pred ep_final then
      verify({VERIFY=}001008,arg^.sub=nil);

      -- souvis¡ s argumentem nˆjak˜ v˜raz, kter˜ by ¨el finalizovat?
      --if arg^.sub<>nil then
        case pentity_param(arg^.sym)^.mode
          -- IN
          when pm_in    do do_final(curr,arg^.sub,arg^.t,eu_use,info,fin_context);

          -- OUT
          when pm_out   do do_final(curr,arg^.sub,arg^.t,eu_write,info,fin_context);

          -- IN OUT
          when pm_inout do do_final(curr,arg^.sub,arg^.t,eu_change,info,fin_context);

          when others   do verify({VERIFY=}000180,true);
          end case;
      --  end if;

      -- ozna‡it za finalizovan˜
      if {arg^.sub=nil or else} arg^.sub^.zprac>=ep_final then
        arg^.zprac:=ep_final;
        end if;
      end if;

    -- poda©ilo se argument finalizovat ? 
    vyhodnoceno and arg^.zprac>=ep_final;

    -- dal¨¡ argument 
    arg:=pexpitem(arg^.next);
    end loop;

  -- povedla se finalizace podv˜raz– ?
  if el^.zprac<ep_final or not vyhodnoceno then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_call;



----------------------------------------------------------------------------------------------------
procedure a_final_range (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexprange;      -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace rozsahu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  er               : pexpnode;                   -- podv˜razy

begin
  -- oddˆlit podv˜razy 
  expr^.get(el,er);

  -- finalizovat lev˜ podv˜raz 
  do_final(curr,el,expr^.t{nulltype},usage,info,fin_context);

  -- finalizovat prav˜ podv˜raz 
  do_final(curr,er,expr^.t{nulltype},usage,info,fin_context);

  -- povedla se finalizace podv˜raz– ? 
  if (el^.zprac<ep_final) or (er^.zprac<ep_final) then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_range;



----------------------------------------------------------------------------------------------------
procedure a_final_index (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpindex;      -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace indexu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  er               : pexpnode;                   -- podv˜razy
  el_range         : typeview;
  er_type          : typeview;                   

begin
  -- oddˆlit podv˜razy
  expr^.get(el,er);

  -- finalizovat lev˜ podv˜raz
  do_final(curr,el,nulltype,usage,info,fin_context);

  -- finalizovat prav˜ podv˜raz 
  do_final(curr,er,el^.t.getrange(curr),eu_use,info,fin_context);

  -- typy podvyrazu
  el_range:=el^.t.getrange(el^.t.getctype^.context);
  er_type:=er^.t;

  -- pravy podvyraz konstanta?
  if er^.ntype<>nt_imm
  -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
  and then not t_is_range_inclusive(el_range,er_type)
    then
      -- jedna se o indexovani retezce?
      if el^.t.stype in dts_string
        
        -- ano - kontrola indexovani retezce
        then
          expr^.set_run_check(rchcl_gen,rch_stringindex_range);

        -- ne - bezna kontrola rozsahu
        else 
          er^.set_run_check(rchcl_load,rch_ordinal_range);
          er^.set_rangecheck_type(rchcl_load,el_range);
          end if;
      end if;

  -- povedla se finalizace podv˜raz– ? 
  if (el^.zprac<ep_final) or (er^.zprac<ep_final) then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_index;



----------------------------------------------------------------------------------------------------
procedure a_final_ref (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpref;        -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace reference.
----------------------------------------------------------------------------------------------------
begin
  -- finalizovat podv˜raz 
  do_final(curr,expr^.sub,nulltype,eu_addr,info,fin_context);

  -- povedla se finalizace podv˜razu ? 
  if expr^.sub^.zprac<ep_final then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_ref;



----------------------------------------------------------------------------------------------------
procedure a_final_deref (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpderef;      -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace dereference.
----------------------------------------------------------------------------------------------------
begin
  -- finalizovat podv˜raz
  do_final(curr,expr^.sub,nulltype,selectusage(usage,eu_read),info,fin_context);

  -- m  cenu bl¡‘e zkoumat jen pokusy o z pis
  if usage in expusageset:[eu_write,eu_change] then
    -- zkontrolovat m¢d p©¡stupu
    {%%X Identick‚ s kontrolou v a_final_component => zobecnit do procedury }
    case expr^.sub^.t.getpaccess
      -- bez omezen¡ => z pis povolen
      when va_norm      do { ok };

      -- konstantn¡ => z pis zak z n
      when va_const     do
          ce^.seterror({CCERR=}000427,ce_i_write_access);
          expr^.errpos;
          ce^.resumeerror;

      -- chr nˆn  => z pis nˆkde povolen, nˆkde zak z n => zkoumat d l
      when va_protected do
          if not sym_is_included_or_ancestor(curr.entity,sym_get_container(expr^.sub^.t.getctype)) then
            ce^.seterror({CCERR=}000428,ce_i_write_access);
            expr^.errpos;
            ce^.resumeerror;
            end if;

      when others do verify({VERIFY=}000610,true);
      end case;
    end if;

  -- povedla se finalizace podv˜razu ?
  if expr^.sub^.zprac<ep_final then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_deref;



----------------------------------------------------------------------------------------------------
procedure a_final_attrib (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpattrib;     -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace atributu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arglist          : pexpitem;                   -- skute‡n‚ parametry
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny slo‘ky

begin
  -- oddˆlit podv˜razy
  expr^.get(el,arglist);

  -- finalizovat lev˜ podv˜raz
  vyhodnoceno:=true;
  if expr^.atf=atf_none

    -- u‘ivatelem definovan˜ atribut 
    then
      unimplemented({UNIMP=}000051);

    -- jazykem definovan˜ atribut 
    else
      {%%X Do nˆkter˜ch dynamick˜ch atribut– se nesm¡ p©i©azovat. }
      -- Test se d  s v˜hodou d t sem.                             

      case expr^.aclass
        {%%X Je pravda, ‘e pro ka‘d˜ statick˜ atribut je pou‘it¡ EU_FORMAL ? }
        when atc_static  do do_final(curr,el,nulltype,eu_formal,info,fin_context);
        {%%X Nen¡ t©eba pro dynamick‚ atributy nˆkdy zmˆnit pou‘it¡ ? }
        when atc_dynamic do do_final(curr,el,nulltype,usage,info,fin_context);
      --when atc_generic do u_nimplemented(50);
        when others      do verify({VERIFY=}000128,true);
        end case;
      vyhodnoceno:=vyhodnoceno and (el^.zprac>=ep_final);
      end if;

  -- finalizovat seznam argument–
  while arglist<>nil loop
    unimplemented({UNIMP=}000049);
    end loop;

  -- povedlo se vyhodnocen¡ v¨ech podv˜raz– ?
  if not vyhodnoceno then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena
  expr^.zprac:=ep_final;
  end a_final_attrib;



----------------------------------------------------------------------------------------------------
procedure a_final_typecast (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexplist;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace p©etypov n¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arg              : pexpitem;                   -- argument
  er               : pexpitem;
  
begin
  -- oddˆlit podv˜razy 
  expr^.get(el,arg);
  er:=arg^.sub;

  -- finalizovat lev˜ podv˜raz 
  do_final(curr,el,nulltype,eu_formal,info,fin_context);

  -- finalizovat prav˜ podv˜raz 
  do_final(curr,arg^.sub,nulltype,usage,info,fin_context);
  arg^.zprac:=arg^.sub^.zprac;

  -- pro typecast nekonstanta full view, ordinal
  if er^.ntype<>nt_imm and then t_is_sts(er^.t,dts_ordinal)
  -- po‘adov n je full view, ordinal', nemodul rn¡
  and then t_is_nonmod_ordinal(expr^.t)
  -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
  and then not t_is_range_inclusive(expr^.t,er^.t)
    then
      -- provest kontrolu mezi
      er^.set_run_check(rchcl_load,rch_ordinal_range);
      er^.set_rangecheck_type(rchcl_load,expr^.t);
      end if;
  
  -- povedla se finalizace podv˜raz– ? 
  if (el^.zprac<ep_final) or (arg^.zprac<ep_final) then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_typecast;



----------------------------------------------------------------------------------------------------
procedure a_final_interface_cast (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    expr           : in pexpinterfacecast;       -- v˜raz
    ptyp           : in typeview;                -- po‘adovan˜ typ v˜razu
    usage          : in expusage;                -- pou‘it¡ v˜razu
    info           : in expinfo;                 -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace p©etypov n¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  er               : pexpnode;                   -- podv˜raz

begin
  -- oddˆlit podv˜razy 
  expr^.get(el,er);

  -- finalizovat lev˜ podv˜raz 
  do_final(curr,el,nulltype,eu_formal,info,fin_context);

  -- finalizovat prav˜ podv˜raz 
  do_final(curr,er,nulltype,usage,info,fin_context);

  -- povedla se finalizace podv˜raz– ? 
  if el^.zprac<ep_final or er^.zprac<ep_final then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_final_aggregate (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpaggregate;  -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace agreg tu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- slo‘ky                                      
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny slo‘ky                        

begin
  -- oddˆlit podv˜razy 
  expr^.get(el,arglist);

  -- finalizovat lev˜ podv˜raz 
  if el<>nil
    then
      do_final(curr,el,nulltype,eu_formal,info,fin_context);
      vyhodnoceno:=el^.zprac>=ep_final;
    else
      vyhodnoceno:=true;
      end if;

  -- finalizovat slo‘ky (kolik je definov no slo‘ek, nen¡ jich p©¡li¨?)

  -- pole, ©etˆzec
  if t_is_sts(expr^.t,[dt_array,{dt_uarray,}dt_string{,dt_ustring}]) then
    verify({VERIFY=}000895,expr^.t.tview<>tview_full);

    declare var
      len          : tuniint;                    -- po‡et slo‘ek
    begin
      -- zjistit max. po‡et konst. slo‘ek
      imm_get_length(expr^.imm,len);

      -- nep©ekro‡il index mez pole ?
      if len>expr^.t.getrange(curr).getlength then
        ce^.seterror({CCERR=}000550,ce_toomanyitems);
        expr^.errpos;
        {%%X ce^.raiseerror};
        ce^.resumeerror;
        end if;
      end declare;
    end if;

  -- povedla se finalizace podv˜raz– ? 
  if not vyhodnoceno then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_aggregate;



----------------------------------------------------------------------------------------------------
procedure a_final_message (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexplist;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace vol n¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arg              : pexpitem;                   -- argumenty
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     

begin
  -- oddˆlit podv˜razy 
  expr^.get(el,arg);

  -- finalizovat podv˜raz 
  do_final(curr,el,nulltype,eu_addr,info,fin_context);

  -- finalizovat argumenty 
  vyhodnoceno:=true;
  while arg<>nil loop
    -- finalizovat argument 
    case expr^.ntype
      -- p©ijet¡ zpr vy 
      when nt_send   do do_final(curr,arg^.sub,arg^.t,eu_use,info,fin_context);

      -- odesl n¡ zpr vy
      when nt_accept do do_final(curr,arg^.sub,arg^.t,eu_write,info,fin_context);

      when others    do verify({VERIFY=}000306,true);
      end case;
    arg^.zprac:=arg^.sub^.zprac;

    -- poda©ilo se argument finalizovat ? 
    vyhodnoceno:=vyhodnoceno and (arg^.zprac>=ep_final);

    -- dal¨¡ argument 
    arg:=pexpitem(arg^.next);
    end loop;

  -- povedla se finalizace podv˜raz– ? 
  if (el^.zprac<ep_final) or not vyhodnoceno then return; end if;

  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_message;

  

----------------------------------------------------------------------------------------------------
procedure a_final_this (
    curr           : in tcontext;       -- p©ekl dan˜ prvek
    expr           : in pexpthis;       -- v˜raz
    ptyp           : in typeview;       -- po‘adovan˜ typ v˜razu
    usage          : in expusage;       -- pou‘it¡ v˜razu
    info           : in expinfo;        -- informace o pr–bˆhu anal˜zy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace THIS.
----------------------------------------------------------------------------------------------------
begin
  -- nen¡ co finalizovat 
  
  -- finalizace £spˆ¨nˆ dokon‡ena 
  expr^.zprac:=ep_final;
  end a_final_this;



----------------------------------------------------------------------------------------------------
procedure do_final =
-- Finalizace.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000126,expr=nil);

  -- zpracov vat jen v˜razy z bezprost©ednˆ p©edchoz¡ f ze 
  if expr^.zprac<>pred ep_final then return; end if;

  -- zpracovat jen v˜razy, ve kter˜ch se neobjevila chyba v p©edchoz¡ch pr–chodech
  if expr^.erroneous then return end if;

  -- zkontrolovat v˜raz 
  case expr^.ntype
    -- oper tor 
    when nt_operator  do a_final_operator(curr,pexpoper(expr),ptyp,usage,info,fin_context);;

    -- un rn¡ oper tor
    when nt_unary     do a_final_unary(curr,pexpunary(expr),ptyp,usage,info,fin_context);;

    -- komponenta
    when nt_component do a_final_component(curr,pexpcomponent(expr),ptyp,usage,info,fin_context);;

    -- p©¡m  hodnota
    when nt_imm       do a_final_imm(curr,pexpimm(expr),ptyp,usage,info,fin_context);;

    -- vol n¡ procedury
    when nt_call      do a_final_call(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- rozsah
    when nt_range     do a_final_range(curr,pexprange(expr),ptyp,usage,info,fin_context);;

    -- index pole
    when nt_index     do a_final_index(curr,pexpindex(expr),ptyp,usage,info,fin_context);;

    -- reference
    when nt_ref       do a_final_ref(curr,pexpref(expr),ptyp,usage,info,fin_context);;

    -- dereference
    when nt_deref     do a_final_deref(curr,pexpderef(expr),ptyp,usage,info,fin_context);;

    -- atribut
    when nt_attrib    do a_final_attrib(curr,pexpattrib(expr),ptyp,usage,info,fin_context);;

    -- p©etypov n¡
    when nt_typecast  do a_final_typecast(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- interface cast
    when nt_interface_cast do a_final_interface_cast(curr,pexpinterfacecast(expr),ptyp,usage,info,fin_context);;

    -- agreg t
    when nt_aggregate do a_final_aggregate(curr,pexpaggregate(expr),ptyp,usage,info,fin_context);;

    -- odesl n¡ zpr vy
    when nt_send      do a_final_message(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- p©ijet¡ zpr vy
    when nt_accept    do a_final_message(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- THIS
    when nt_this      do a_final_this(curr,pexpthis(expr),ptyp,usage,info,fin_context);;

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others       do verify({VERIFY=}000127,true);
    end case;

catch 
  when resume_error do
      -- kontrola
      verify({VERIFY=}000857,expr^.zprac>=ep_final);

      -- nastavit p©¡znak, ‘e tento uzel byl chybn˜
      expr^.erroneous:=true;

      -- znovu vyvolat vyj¡mku
      if not node_catch_resume_error(catch_mode,expr^.ntype) then raise;end if;
  end do_final;



----------------------------------------------------------------------------------------------------
procedure a_final =
-- Finalizace.                                                                
----------------------------------------------------------------------------------------------------
var
  fin_context : t_final_context;

begin
  do_final(curr,expr,ptyp,usage,info,fin_context,catch_mode);
  end a_final;



end cx_final;
