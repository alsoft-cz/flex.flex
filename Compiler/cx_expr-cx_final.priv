----------------------------------------------------------------------------------------------------
module private cx_final =
-- Překladač Flexu.
-- Finalizace výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 01.08.2001 : Vytvořil.
----------------------------------------------------------------------------------------------------

with
  cc_attr,cc_sym,cc_type,
  cx_util,cx_imm;


type
  t_final_context  = record
    assign_typ     : typeview;                   -- skutecny typ prirazovaciho vyrazu finalizace
    end record;

----------------------------------------------------------------------------------------------------
procedure selectusage (
    actual         : in expusage;                -- aktuální použití výrazu
    proposed       : in expusage)                -- navržené použití výrazu
                   return expusage =             -- zvolené použití výrazu
-- Zvolí lepší použití výrazu. Pokud je aktuální použítí EU_FORMAL, preferuje vždy to, jinak 
-- navržené.
----------------------------------------------------------------------------------------------------
begin
  if actual=eu_formal
    then result:=eu_formal;
    else result:=proposed;
    end if;
  end selectusage;


-- %%HYNEK - zobecnit??
----------------------------------------------------------------------------------------------------
procedure t_is_ranged (
    typ            : in typeview)
                     return t_logical =
-- vrati T, pokud je zadany typ "ranged" - ma logicke meze mensi nez jsou fyzicke meze argumentu
-- [typ] musi byt dts_ordinal, jinak zpusobi interni chybu
----------------------------------------------------------------------------------------------------
var
  penttyp          : pentity_type;               -- entita reprezentujici typ
  typsize          : tunidata_size;              -- velikost typu v bajtech
  phlval           : tuniint;                    -- fyzicka dolni unimeze typu
  phhval           : tuniint;                    -- fyzicka horni unimeze typu

begin
  -- souvisejici entita typu vyrazu
  penttyp:=typ.getctype;

  -- vyraz je ranged pouze pro ordinalni typy
  verify({VERIFY=}000717,penttyp^.stype not in dts_ordinal);

  -- zjisti parametry typu
  cpu^.getordparams1(penttyp^.stype, penttyp^.bits,typsize,phlval,phhval);

  -- porovnej logicke a fyzicke meze
  result:=penttyp^.lval<>phlval or penttyp^.hval<>phhval;
  end t_is_ranged;



----------------------------------------------------------------------------------------------------
procedure do_final (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpnode;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context; -- kontext finalizace
    catch_mode     : in t_catch_mode:=catch_mode_implicit); -- způsob, jak zachytávat chyby resume_error
-- Finalizace.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_final_operator (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpoper;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace operátorů.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure c_final (
        curr       : in tcontext;       -- překládaný prvek
        expr       : in pexpnode;   -- výraz
        ptyp       : in typeview;   -- požadovaný typ výrazu
        usage      : in expusage;   -- použití výrazu
        info       : in expinfo;    -- informace o průběhu analýzy
        fin_context: in out t_final_context) = -- kontext finalizace
    -- Finalizace.
    ------------------------------------------------------------------------------------------------
    begin
      -- způsob zřetězení je touhle dobou již určen

      -- %%X Zde je operátor v n-árním tvaru ale při určování CONCATKIND byl
      -- ještě v binárním. Nemůže se stát, že by byl chybný ? (snad ne)

      -- provést typovou kontrolu se správným typem
      case expr^.concatkind
        -- substring nebo subpole
        when nck_substring, nck_subarray do do_final(curr,expr,ptyp,usage,info,fin_context);

        -- komponenta
        when nck_component do do_final(curr,expr,ptyp.getbase(curr),usage,info,fin_context);

        when others do verify({VERIFY=}000375,true);
        end case;
      end c_final;

var
  el               : pexpnode;                   -- podvýrazy
  er               : pexpnode;                   -- podvýrazy
  er0              : pexpnode;                   -- podvýrazy
  er_zprac         : t_logical;                  -- finalizace pravých podvýrazů                
  el_type          : typeview;
  er_type          : typeview;                   
  ass_type         : typeview;
  a                : tuniint;                    -- hodnota konst. operandu


begin
  -- oddělit podvýrazy 
  expr^.get(el,er0);

  -- reset typ prirazeni
  fin_context.assign_typ:=nulltype;
  
  -- finalizovat levý podvýraz
  if expr^.assign

    -- přiřazení 
    then
      if expr^.oper=op_assign
        then do_final(curr,el,nulltype,eu_write,info,fin_context);
        else do_final(curr,el,nulltype,eu_change,info,fin_context);
        end if;

    -- normální operátor 
    else
      case expoperinfo[expr^.oper].tc
        when tc_none    do do_final(curr,el,nulltype,eu_read,info,fin_context);
        when tc_left    do do_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when tc_right   do do_final(curr,el,nulltype,eu_read,info,fin_context);
        when tc_both    do do_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when tc_concat  do c_final(curr,el,expr^.t ,eu_read,info,fin_context);
        when others     do verify({VERIFY=}000373,true);
        end case;
      end if;
  
  -- mame typ prirazeni?
  if fin_context.assign_typ.getutype=nil

    -- NE - pouzi typ vyrazu
    then ass_type:=expr^.t;

    -- ANO - pouzi jej
    else ass_type:=fin_context.assign_typ;
    end if;
  
  -- finalizovat pravý podvýraz 
  {%%X a co UNCHECKED ? }
  er:=er0;
  er_zprac:=true;
  while er<>nil loop
    -- finalizovat
    case expoperinfo[expr^.oper].tc
      when tc_none   do do_final(curr,er,nulltype,eu_read,info,fin_context);
      when tc_left   do do_final(curr,er,nulltype,eu_read,info,fin_context);
      when tc_right  do do_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when tc_both   do do_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when tc_concat do c_final(curr,er,expr^.t ,eu_read,info,fin_context);
      when others    do verify({VERIFY=}000374,true);
      end case;

    -- povedla se finalizace podvýrazu ? 
    er_zprac:=er_zprac and (er^.zprac>=ep_final);

    -- další pravý podvýraz 
    er:=er^.next;
    end loop;

  -- typy podvyrazu
  el_type:=el^.t;
  er_type:=er0^.t;

  -- *** Kontroly rozsahu
  
  -- operator
  case expr^.oper
    
    -- scitani, odcitani, nasobeni
    when op_add,op_sub,op_mul do
      -- typ vyrazu s plnym pohledem, ordinalni a bez modularni aritmetiky
      if t_is_nonmod_ordinal(expr^.t) then
        -- treba provest overflow kontrolu a kontrolu mezi vysledku
        expr^.set_run_check(rchcl_gen,rch_ordinal_overflow);
      
        -- ma typ vyrazu logicke meze mensi nez fyzicke?
        if t_is_ranged(expr^.t) then
          -- ano - provest jeste kontrolu mezi
          expr^.set_run_check(rchcl_gen,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_gen,expr^.t);
          end if;
        end if;

      -- typ vysledku s plnym pohledem, ordinalni a bez modularni aritmetiky
      if expr^.assign and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu?
      and then not t_is_range_inclusive(ass_type,expr^.t)
        then
          -- kontrola rozsahu
          expr^.set_run_check(rchcl_load,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_load,ass_type);
          end if;
    
    -- prirazeni
    when op_assign do
      -- zdroj je nekonstantní full ordinal
      if er0^.ntype<>nt_imm and then t_is_sts(er_type,dts_ordinal)
      -- cíl je nemodulární full ordinal
      and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu?
      and then not t_is_range_inclusive(ass_type,er_type)
        then
          -- kontrola rozsahu
          er0^.set_run_check(rchcl_load,rch_ordinal_range);
          er0^.set_rangecheck_type(rchcl_load,ass_type);
          end if;

    when others do ;
    end case;
  
  -- povedla se finalizace podvýrazů ? 
  if (el^.zprac<ep_final) or not er_zprac {(er^.zprac<ep_final)} then
    el:=nil;
    return;
    end if;

  -- detekovat chyby konst. výrazů
  case expr^.oper
    -- celočíselné dělení (zbytek po dělení)
    when op_idiv,op_imod do
      -- zkontrolovat pravé operandy
      er:=er0;
      while er<>nil loop
        -- pravý operand konstantní
        if er^.ntype=nt_imm then
          -- načíst hodnotu pravého operandu
          load_uniint(pexpimm(er)^.imm,a);

          -- X div 0 --> chyba
          if a=ui_0 then
            ce^.seterror({CCERR=}000543,ce_divzero);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          end if;

        er:=er^.next;
        end loop;

    -- shift doleva, doprava
    when op_shl,op_shr do
      -- zkontrolovat pravé operandy
      er:=er0;
      while er<>nil loop
        -- pravý operand konstantní
        if er^.ntype=nt_imm then
          -- načíst hodnotu pravého operandu
          load_uniint(pexpimm(er)^.imm,a);

          -- pravý operand záporný
          if a<ui_0 then
            ce^.seterror({CCERR=}000544,ce_shift);
            expr^.errpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          end if;

        er:=er^.next;
        end loop;
    
    when others do

    end case;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_operator;



----------------------------------------------------------------------------------------------------
procedure a_final_unary (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpunary;      -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace unárních operátorů.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  ass_type         : typeview;                   -- skutecny typ prirazeni
  a                : tuniint;                    -- hodnota konst. operandu

begin
  -- oddělit podvýrazy
  expr^.get(el);

  -- reset tyou prirazeni
  fin_context.assign_typ:=nulltype;

  -- finalizace podvýrazu
  if expr^.assign

    -- přiřazení
    then do_final(curr,el,nulltype,eu_write,info,fin_context);

    -- normální operátor
    else do_final(curr,el,expr^.t,eu_read,info,fin_context);
    end if;

  -- operace nad přímou ordinální hodnotou
  if t_is_sts(expr^.t,dts_ordinal) and el^.ntype=nt_imm then
    -- načíst hodnotu operandu
    load_uniint(pexpimm(el)^.imm,a);

    -- předchůdce první hodnoty
    if (expr^.oper=un_pred and a=expr^.t.getlval())
    -- následník poslední hodnoty
    or (expr^.oper=un_succ and a=expr^.t.gethval())
      then
        ce^.seterror({CCERR=}000545,ce_resultrange);
        expr^.errpos;
        ce^.raiseerror;
        end if;
    end if;

  -- mame typ prirazeni?
  if fin_context.assign_typ.getutype=nil
    -- NE - pouzi typ vyrazu
    then ass_type:=fin_context.assign_typ;
    
    -- ANO - pouzi jej
    else ass_type:=expr^.t;
    end if;
  
  case expr^.oper
    -- operatory scitani, odcitani, nasobeni
    when un_succ, un_pred, un_minus, un_abs do
      -- typ vyrazu s plnym pohledem, ordinalni a bez modularni aritmetiky
      if t_is_nonmod_ordinal(expr^.t) then
        -- treba provest overflow kontrolu a kontrolu mezi vysledku
        expr^.set_run_check(rchcl_gen,rch_ordinal_overflow);
    
        -- ma typ vyrazu logicke meze mensi nez fyzicke
        if t_is_ranged(expr^.t) then
          -- ano - provest jeste kontrolu mezi
          expr^.set_run_check(rchcl_gen,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_gen,expr^.t);
          end if;
        end if;

      -- typ vysledku s plnym pohledem, ordinalni a bez modularni aritmetiky
      if expr^.assign and then t_is_nonmod_ordinal(ass_type)
      -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
      and then not t_is_range_inclusive(ass_type,expr^.t)
        then
          -- kontrola rozsahu
          expr^.set_run_check(rchcl_load,rch_ordinal_range);
          expr^.set_rangecheck_type(rchcl_load,ass_type);
          end if;
   
    when others do ;
    end case;

  -- povedla se finalizace podvýrazu ? 
  if el^.zprac<ep_final then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_unary;



----------------------------------------------------------------------------------------------------
procedure a_final_component (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpcomponent;  -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace komponenty.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;                -- související entita
  instance         : pexpnode;               -- související instance třídy

begin
{
  -- finalizovat podvýraz
  if expr^.sub<>nil then do_final(curr,expr^.sub,nulltype,usage,info,fin_context); end if;

  {%%X Co se tady dá finalizovat ? }
}
  
  -- komponenta se pouzije pro zapis?
  if usage in expusageset:[eu_write,eu_change] then
    -- nastav typ prirazeni
    fin_context.assign_typ:=expr^.t;
    end if;

  case expr^.nclass
    -- proměnná
    when nc_var do
        -- související entita
        psym:=expr^.getsymbol;

        -- finalizovat podvýraz
        if expr^.sub<>nil then
          -- není související entita složka něčeho ?
          if (psym=nil) or (pentity_var(psym)^.mclass in mcs_offset)
            -- pokud o entitě nic nevím, nebo je to něčí složka, finalizovat pro stejné použití
            then do_final(curr,expr^.sub,nulltype,usage,info,fin_context);
            -- jinak finalizovat pro čistě formální použití
            else do_final(curr,expr^.sub,nulltype,eu_formal,info,fin_context);
            end if;
          end if;

        -- má cenu blíže zkoumat jen pokusy o zápis
        if usage in expusageset:[eu_write,eu_change] then
          -- zkontrolovat podle související entity
          if psym<>nil then
            case psym^.etype
              -- proměnná
              when et_var   do
                  -- zkontrolovat mód přístupu
                  --%%X Identické s kontrolou v a_final_deref => zobecnit do procedury
                  case pentity_var(psym)^.vaccess
                    -- bez omezení => zápis povolen
                    when va_norm      do { ok };

                    -- konstantní => zápis zakázán
                    when va_const     do
                        ce^.seterror({CCERR=}000424,ce_i_write_access);
                        expr^.errpos;
                        ce^.resumeerror;

                    -- chráněná => zápis někde povolen, někde zakázán => zkoumat dál
                    when va_protected do
                        if not sym_is_included_or_ancestor(curr.entity,sym_get_container(psym)) then
                          ce^.seterror({CCERR=}000425,ce_i_write_access);
                          expr^.errpos;
                          ce^.resumeerror;
                          end if;

                    when others do verify({VERIFY=}000605,true);
                    end case;

              -- parametr
              when et_param do
                  -- zapisovat nelze do IN parametru
                  if pentity_param(psym)^.mode=pm_in then
                    ce^.seterror({CCERR=}000426,ce_i_write_access);
                    expr^.errpos;
                    ce^.resumeerror;
                    end if;

              -- nic jiného neumíme
              when others do verify({VERIFY=}000604,true);
              end case;
            end if;
          end if;

    -- hodnota
    when nc_value do
        -- finalizovat podvýraz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,usage,info,fin_context);
          end if;

        -- zápis není povolen
        verify({VERIFY=}000607,usage in expusageset:[eu_write,eu_change]);

    -- procedura
    when nc_proc do
        -- související entita
        psym:=expr^.getsymbol;

        -- finalizovat podvýraz
        if expr^.sub<>nil then
          -- bude nás zajímat potenciální instance třídy
          x_classinstance(expr^.sub,instance);

          -- není to metoda s uvedenou instancí třídy ?
          if usage=eu_addr and then psym<>nil and then pentity_subprogram(psym)^.instance<>tip_none 
          and then instance<>nil and then instance^.nclass<>nc_type
            -- zjišťuje se adresa metody => nepochybně bude potřeba i adresa instance
            then do_final(curr,expr^.sub,nulltype,eu_addr,info,fin_context);
            -- jakékoliv jiné způsoby použití indikují finalizaci podvýrazu pro formální použití
            else do_final(curr,expr^.sub,nulltype,eu_formal,info,fin_context);
            end if;
          end if;

        -- je povolen jen formální přístup a získání adresy
        verify({VERIFY=}000608,usage not in expusageset:[eu_formal,eu_addr]);

    -- zpráva
    when nc_message     do
        -- finalizovat podvýraz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen formální přístup a získání adresy
        verify({VERIFY=}000609,usage not in expusageset:[eu_formal,eu_addr]);

    -- typ
    when nc_type do
        -- finalizovat podvýraz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen formální přístup a použití hodnoty (tagu)
        verify({VERIFY=}000620,usage not in expusageset:[{%%X Doplněno EU_READ, je to dobře??}eu_read,eu_use,eu_formal]);

    -- něco jiného
    when others do
        -- finalizovat podvýraz
        if expr^.sub<>nil then
          do_final(curr,expr^.sub,nulltype,eu_formal{usage},info,fin_context);
          end if;

        -- je povolen jen formální přístup
        verify({VERIFY=}000606,usage not in expusageset:[{%%X Doplněno EU_NONE}eu_none,eu_formal]);
    end case;

  -- povedla se finalizace podvýrazu ? 
  if (expr^.sub<>nil) and (expr^.sub^.zprac<ep_final) then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_component;



----------------------------------------------------------------------------------------------------
procedure a_final_imm (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpimm;        -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in  expinfo;       -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace přímé hodnoty.
----------------------------------------------------------------------------------------------------
var
  change           : t_logical;                  -- T-změnila se reprezentace konstanty

begin
  verify({VERIFY=}000887,usage=eu_write);
  if ptyp.tview<>tview_null

    -- požadován konkrétní typ konstanty
    then
      if not t_equal(expr^.t,ptyp) then
        -- konvertovat přímou hodnotu
        imm_settype(curr,expr^.imm,expr^.t,ptyp,change);

        -- změnit typ výrazu pokud se změnila reprezentace
        -- nebo pokud požadujeme ready-to-use hodnotu
        -- nebo pokud byl původní typ univerzální
        if change or (usage=eu_use) or t_is_sts(expr^.t,dts_unitype) then
          expr^.t:=ptyp;
          end if;
        end if;

      -- test správnosti
      if (expr^.t.tview=tview_full) and (usage in expusageset:[eu_read,eu_use,eu_formal]) then
        imm_check(curr,expr^.imm,expr^.t);
        end if;

    -- není určen typ 
    else
      -- provést test mezí
      if (expr^.t.tview=tview_full) and (usage in expusageset:[eu_use,eu_formal]) then
        imm_check(curr,expr^.imm,expr^.t);
        end if;
      end if;

  -- %%X ?
  --verifyx({VERIFY=}000531,(expr^.imm.ic=ic_set and expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize)
  --         or (expr^.imm.ic=ic_array and expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize)
  --         or (expr^.imm.ic=ic_record and expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize),expr^.pos);

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;

catch
  when resume_error, compiler_error do
      expr^.errpos;
      raise;
  end a_final_imm;



----------------------------------------------------------------------------------------------------
procedure a_final_call (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexplist;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace volání.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argumenty
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty

begin
  -- oddělit podvýrazy
  expr^.get(el,arg);

  -- finalizovat podvýraz
  do_final(curr,el,nulltype,eu_addr,info,fin_context);

  -- finalizovat argumenty
  vyhodnoceno:=true;
  while arg<>nil loop
    if arg^.zprac=pred ep_final then
      verify({VERIFY=}001008,arg^.sub=nil);

      -- souvisí s argumentem nějaký výraz, který by šel finalizovat?
      --if arg^.sub<>nil then
        case pentity_param(arg^.sym)^.mode
          -- IN
          when pm_in    do do_final(curr,arg^.sub,arg^.t,eu_use,info,fin_context);

          -- OUT
          when pm_out   do do_final(curr,arg^.sub,arg^.t,eu_write,info,fin_context);

          -- IN OUT
          when pm_inout do do_final(curr,arg^.sub,arg^.t,eu_change,info,fin_context);

          when others   do verify({VERIFY=}000180,true);
          end case;
      --  end if;

      -- označit za finalizovaný
      if {arg^.sub=nil or else} arg^.sub^.zprac>=ep_final then
        arg^.zprac:=ep_final;
        end if;
      end if;

    -- podařilo se argument finalizovat ? 
    vyhodnoceno and arg^.zprac>=ep_final;

    -- další argument 
    arg:=pexpitem(arg^.next);
    end loop;

  -- povedla se finalizace podvýrazů ?
  if el^.zprac<ep_final or not vyhodnoceno then return; end if;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_call;



----------------------------------------------------------------------------------------------------
procedure a_final_range (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexprange;      -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace rozsahu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  er               : pexpnode;                   -- podvýrazy

begin
  -- oddělit podvýrazy 
  expr^.get(el,er);

  -- finalizovat levý podvýraz 
  do_final(curr,el,expr^.t{nulltype},usage,info,fin_context);

  -- finalizovat pravý podvýraz 
  do_final(curr,er,expr^.t{nulltype},usage,info,fin_context);

  -- povedla se finalizace podvýrazů ? 
  if (el^.zprac<ep_final) or (er^.zprac<ep_final) then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_range;



----------------------------------------------------------------------------------------------------
procedure a_final_index (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpindex;      -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace indexu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýrazy
  er               : pexpnode;                   -- podvýrazy
  el_range         : typeview;
  er_type          : typeview;                   

begin
  -- oddělit podvýrazy
  expr^.get(el,er);

  -- finalizovat levý podvýraz
  do_final(curr,el,nulltype,usage,info,fin_context);

  -- finalizovat pravý podvýraz 
  do_final(curr,er,el^.t.getrange(curr),eu_use,info,fin_context);

  -- typy podvyrazu
  el_range:=el^.t.getrange(el^.t.getctype^.context);
  er_type:=er^.t;

  -- pravy podvyraz konstanta?
  if er^.ntype<>nt_imm
  -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
  and then not t_is_range_inclusive(el_range,er_type)
    then
      -- jedna se o indexovani retezce?
      if el^.t.stype in dts_string
        
        -- ano - kontrola indexovani retezce
        then
          expr^.set_run_check(rchcl_gen,rch_stringindex_range);

        -- ne - bezna kontrola rozsahu
        else 
          er^.set_run_check(rchcl_load,rch_ordinal_range);
          er^.set_rangecheck_type(rchcl_load,el_range);
          end if;
      end if;

  -- povedla se finalizace podvýrazů ? 
  if (el^.zprac<ep_final) or (er^.zprac<ep_final) then return; end if;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_index;



----------------------------------------------------------------------------------------------------
procedure a_final_ref (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpref;        -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace reference.
----------------------------------------------------------------------------------------------------
begin
  -- finalizovat podvýraz 
  do_final(curr,expr^.sub,nulltype,eu_addr,info,fin_context);

  -- povedla se finalizace podvýrazu ? 
  if expr^.sub^.zprac<ep_final then return; end if;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_ref;



----------------------------------------------------------------------------------------------------
procedure a_final_deref (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpderef;      -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace dereference.
----------------------------------------------------------------------------------------------------
begin
  -- finalizovat podvýraz
  do_final(curr,expr^.sub,nulltype,selectusage(usage,eu_read),info,fin_context);

  -- má cenu blíže zkoumat jen pokusy o zápis
  if usage in expusageset:[eu_write,eu_change] then
    -- zkontrolovat mód přístupu
    {%%X Identické s kontrolou v a_final_component => zobecnit do procedury }
    case expr^.sub^.t.getpaccess
      -- bez omezení => zápis povolen
      when va_norm      do { ok };

      -- konstantní => zápis zakázán
      when va_const     do
          ce^.seterror({CCERR=}000427,ce_i_write_access);
          expr^.errpos;
          ce^.resumeerror;

      -- chráněná => zápis někde povolen, někde zakázán => zkoumat dál
      when va_protected do
          if not sym_is_included_or_ancestor(curr.entity,sym_get_container(expr^.sub^.t.getctype)) then
            ce^.seterror({CCERR=}000428,ce_i_write_access);
            expr^.errpos;
            ce^.resumeerror;
            end if;

      when others do verify({VERIFY=}000610,true);
      end case;
    end if;

  -- povedla se finalizace podvýrazu ?
  if expr^.sub^.zprac<ep_final then return; end if;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_deref;



----------------------------------------------------------------------------------------------------
procedure a_final_attrib (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpattrib;     -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace atributu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arglist          : pexpitem;                   -- skutečné parametry
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny složky

begin
  -- oddělit podvýrazy
  expr^.get(el,arglist);

  -- finalizovat levý podvýraz
  vyhodnoceno:=true;
  if expr^.atf=atf_none

    -- uživatelem definovaný atribut 
    then
      unimplemented({UNIMP=}000051);

    -- jazykem definovaný atribut 
    else
      {%%X Do některých dynamických atributů se nesmí přiřazovat. }
      -- Test se dá s výhodou dát sem.                             

      case expr^.aclass
        {%%X Je pravda, že pro každý statický atribut je použití EU_FORMAL ? }
        when atc_static  do do_final(curr,el,nulltype,eu_formal,info,fin_context);
        {%%X Není třeba pro dynamické atributy někdy změnit použití ? }
        when atc_dynamic do do_final(curr,el,nulltype,usage,info,fin_context);
      --when atc_generic do u_nimplemented(50);
        when others      do verify({VERIFY=}000128,true);
        end case;
      vyhodnoceno:=vyhodnoceno and (el^.zprac>=ep_final);
      end if;

  -- finalizovat seznam argumentů
  while arglist<>nil loop
    unimplemented({UNIMP=}000049);
    end loop;

  -- povedlo se vyhodnocení všech podvýrazů ?
  if not vyhodnoceno then return; end if;

  -- finalizace úspěšně dokončena
  expr^.zprac:=ep_final;
  end a_final_attrib;



----------------------------------------------------------------------------------------------------
procedure a_final_typecast (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexplist;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace přetypování.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argument
  er               : pexpitem;
  
begin
  -- oddělit podvýrazy 
  expr^.get(el,arg);
  er:=arg^.sub;

  -- finalizovat levý podvýraz 
  do_final(curr,el,nulltype,eu_formal,info,fin_context);

  -- finalizovat pravý podvýraz 
  do_final(curr,arg^.sub,nulltype,usage,info,fin_context);
  arg^.zprac:=arg^.sub^.zprac;

  -- pro typecast nekonstanta full view, ordinal
  if er^.ntype<>nt_imm and then t_is_sts(er^.t,dts_ordinal)
  -- požadován je full view, ordinal', nemodulární
  and then t_is_nonmod_ordinal(expr^.t)
  -- rozsah zdrojoveho ani stejny ani podmnozinou ciloveho typu
  and then not t_is_range_inclusive(expr^.t,er^.t)
    then
      -- provest kontrolu mezi
      er^.set_run_check(rchcl_load,rch_ordinal_range);
      er^.set_rangecheck_type(rchcl_load,expr^.t);
      end if;
  
  -- povedla se finalizace podvýrazů ? 
  if (el^.zprac<ep_final) or (arg^.zprac<ep_final) then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_typecast;



----------------------------------------------------------------------------------------------------
procedure a_final_interface_cast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in pexpinterfacecast;       -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    usage          : in expusage;                -- použití výrazu
    info           : in expinfo;                 -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace přetypování.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  er               : pexpnode;                   -- podvýraz

begin
  -- oddělit podvýrazy 
  expr^.get(el,er);

  -- finalizovat levý podvýraz 
  do_final(curr,el,nulltype,eu_formal,info,fin_context);

  -- finalizovat pravý podvýraz 
  do_final(curr,er,nulltype,usage,info,fin_context);

  -- povedla se finalizace podvýrazů ? 
  if el^.zprac<ep_final or er^.zprac<ep_final then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_final_aggregate (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpaggregate;  -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace agregátu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- složky                                      
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny složky                        

begin
  -- oddělit podvýrazy 
  expr^.get(el,arglist);

  -- finalizovat levý podvýraz 
  if el<>nil
    then
      do_final(curr,el,nulltype,eu_formal,info,fin_context);
      vyhodnoceno:=el^.zprac>=ep_final;
    else
      vyhodnoceno:=true;
      end if;

  -- finalizovat složky (kolik je definováno složek, není jich příliš?)

  -- pole, řetězec
  if t_is_sts(expr^.t,[dt_array,{dt_uarray,}dt_string{,dt_ustring}]) then
    verify({VERIFY=}000895,expr^.t.tview<>tview_full);

    declare var
      len          : tuniint;                    -- počet složek
    begin
      -- zjistit max. počet konst. složek
      imm_get_length(expr^.imm,len);

      -- nepřekročil index mez pole ?
      if len>expr^.t.getrange(curr).getlength then
        ce^.seterror({CCERR=}000550,ce_toomanyitems);
        expr^.errpos;
        {%%X ce^.raiseerror};
        ce^.resumeerror;
        end if;
      end declare;
    end if;

  -- povedla se finalizace podvýrazů ? 
  if not vyhodnoceno then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_aggregate;



----------------------------------------------------------------------------------------------------
procedure a_final_message (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexplist;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace volání.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argumenty
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     

begin
  -- oddělit podvýrazy 
  expr^.get(el,arg);

  -- finalizovat podvýraz 
  do_final(curr,el,nulltype,eu_addr,info,fin_context);

  -- finalizovat argumenty 
  vyhodnoceno:=true;
  while arg<>nil loop
    -- finalizovat argument 
    case expr^.ntype
      -- přijetí zprávy 
      when nt_send   do do_final(curr,arg^.sub,arg^.t,eu_use,info,fin_context);

      -- odeslání zprávy
      when nt_accept do do_final(curr,arg^.sub,arg^.t,eu_write,info,fin_context);

      when others    do verify({VERIFY=}000306,true);
      end case;
    arg^.zprac:=arg^.sub^.zprac;

    -- podařilo se argument finalizovat ? 
    vyhodnoceno:=vyhodnoceno and (arg^.zprac>=ep_final);

    -- další argument 
    arg:=pexpitem(arg^.next);
    end loop;

  -- povedla se finalizace podvýrazů ? 
  if (el^.zprac<ep_final) or not vyhodnoceno then return; end if;

  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_message;

  

----------------------------------------------------------------------------------------------------
procedure a_final_this (
    curr           : in tcontext;       -- překládaný prvek
    expr           : in pexpthis;       -- výraz
    ptyp           : in typeview;       -- požadovaný typ výrazu
    usage          : in expusage;       -- použití výrazu
    info           : in expinfo;        -- informace o průběhu analýzy
    fin_context    : in out t_final_context) = -- kontext finalizace
-- Finalizace THIS.
----------------------------------------------------------------------------------------------------
begin
  -- není co finalizovat 
  
  -- finalizace úspěšně dokončena 
  expr^.zprac:=ep_final;
  end a_final_this;



----------------------------------------------------------------------------------------------------
procedure do_final =
-- Finalizace.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000126,expr=nil);

  -- zpracovávat jen výrazy z bezprostředně předchozí fáze 
  if expr^.zprac<>pred ep_final then return; end if;

  -- zpracovat jen výrazy, ve kterých se neobjevila chyba v předchozích průchodech
  if expr^.erroneous then return end if;

  -- zkontrolovat výraz 
  case expr^.ntype
    -- operátor 
    when nt_operator  do a_final_operator(curr,pexpoper(expr),ptyp,usage,info,fin_context);;

    -- unární operátor
    when nt_unary     do a_final_unary(curr,pexpunary(expr),ptyp,usage,info,fin_context);;

    -- komponenta
    when nt_component do a_final_component(curr,pexpcomponent(expr),ptyp,usage,info,fin_context);;

    -- přímá hodnota
    when nt_imm       do a_final_imm(curr,pexpimm(expr),ptyp,usage,info,fin_context);;

    -- volání procedury
    when nt_call      do a_final_call(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- rozsah
    when nt_range     do a_final_range(curr,pexprange(expr),ptyp,usage,info,fin_context);;

    -- index pole
    when nt_index     do a_final_index(curr,pexpindex(expr),ptyp,usage,info,fin_context);;

    -- reference
    when nt_ref       do a_final_ref(curr,pexpref(expr),ptyp,usage,info,fin_context);;

    -- dereference
    when nt_deref     do a_final_deref(curr,pexpderef(expr),ptyp,usage,info,fin_context);;

    -- atribut
    when nt_attrib    do a_final_attrib(curr,pexpattrib(expr),ptyp,usage,info,fin_context);;

    -- přetypování
    when nt_typecast  do a_final_typecast(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- interface cast
    when nt_interface_cast do a_final_interface_cast(curr,pexpinterfacecast(expr),ptyp,usage,info,fin_context);;

    -- agregát
    when nt_aggregate do a_final_aggregate(curr,pexpaggregate(expr),ptyp,usage,info,fin_context);;

    -- odeslání zprávy
    when nt_send      do a_final_message(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- přijetí zprávy
    when nt_accept    do a_final_message(curr,pexplist(expr),ptyp,usage,info,fin_context);;

    -- THIS
    when nt_this      do a_final_this(curr,pexpthis(expr),ptyp,usage,info,fin_context);;

    -- jiné symboly tu nemají co dělat
    when others       do verify({VERIFY=}000127,true);
    end case;

catch 
  when resume_error do
      -- kontrola
      verify({VERIFY=}000857,expr^.zprac>=ep_final);

      -- nastavit příznak, že tento uzel byl chybný
      expr^.erroneous:=true;

      -- znovu vyvolat vyjímku
      if not node_catch_resume_error(catch_mode,expr^.ntype) then raise;end if;
  end do_final;



----------------------------------------------------------------------------------------------------
procedure a_final =
-- Finalizace.                                                                
----------------------------------------------------------------------------------------------------
var
  fin_context : t_final_context;

begin
  do_final(curr,expr,ptyp,usage,info,fin_context,catch_mode);
  end a_final;



end cx_final;
