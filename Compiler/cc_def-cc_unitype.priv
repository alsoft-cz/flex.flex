----------------------------------------------------------------------------------------------------
module private cc_unitype =
-- Překladač Flexu.
-- Definice lexiálních symbolů.
----------------------------------------------------------------------------------------------------
-- Ondra : 26.04.2000 : Vytvořil
----------------------------------------------------------------------------------------------------



----- Hodnoty elementárních konstant ---------------------------------------------------------------
const
  -- NIL
  ui_nil           = nil;
  uc_nil           = nil;
  ur_nil           = nil;
  ul_nil           = nil;

  -- rozsah podporovaných číselných soustav
  ui_radix_first   = [ 2,for others use 0];
  ui_radix_last    = [36,for others use 0];

  -- základ dšestnáctkové soustavy
  ui_radix_hex     = [16,for others use 0];

  -- přesnost univerzálního celého čísla
  ui_precision     = [uniint_precision,for others use 0];

  -- malá čísla
  ui_minus_1       = [for others use $FF];
  ui_minus_2       = [$FE,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF];
  ui_0             = [  0,for others use 0];
  ui_1             = [  1,for others use 0];
  ui_2             = [  2,for others use 0];
  ui_3             = [  3,for others use 0];
  ui_4             = [  4,for others use 0];
  ui_5             = [  5,for others use 0];
  ui_6             = [  6,for others use 0];
  ui_7             = [  7,for others use 0];
  ui_8             = [  8,for others use 0];
  ui_9             = [  9,for others use 0];
  ui_100           = [100,for others use 0];

  -- velká čísla
  ui_0_FFFF        = [$FF,$FF,$FF,$FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_1_0           = [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_1_1           = [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_2_0           = [0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

  -- rozsah univerzálního celého čísla
  ui_first         = [for 1..(uniint_precision div 8)-1 use $00, for others use $80];
  ui_last          = [for 1..(uniint_precision div 8)-1 use $FF, for others use $7F];

  -- rozsah univerzálního znaku jako univerzální integer
  ui_unichar_first = [for others use 0];
  ui_unichar_last  = [for tuniint:first..tuniint:first+tunichar:size-1 use $FF,for others use 0];

  -- malá reálná čísla
  ur_minus_1       = [for negative use true,  for mantissa use ui_1, for exponent use ui_0];
  ur_0             = [for negative use false, for mantissa use ui_0, for exponent use ui_0];
  ur_1             = [for negative use false, for mantissa use ui_1, for exponent use ui_0];
  ur_10            = [for negative use false, for mantissa use ui_5, for exponent use ui_1];

  -- významné adresy
  uda_0            = tunidata_addr(0);

  -- významné velikosti v bytech
  uds_0            = tunidata_size(0);
  uds_1            = tunidata_size(1);
  uds_2            = tunidata_size(2);
  uds_4            = tunidata_size(4);

  -- významné velikosti v bitech
  udb_bits_per_byte= tunidata_bitsize(8);--[ 8,for others use 0];
  udb_1            = tunidata_bitsize(1);
  udb_8            = tunidata_bitsize(8);
  udb_16           = tunidata_bitsize(16);
  udb_32           = tunidata_bitsize(32);
  udb_64           = tunidata_bitsize(64);
  udb_80           = tunidata_bitsize(80);
  udb_128          = tunidata_bitsize(128);

  -- logické hodnoty
  ul_false         = tunilogical:false;
  ul_true          = tunilogical:true;



----------------------------------------------------------------------------------------------------
procedure signed_to_uniint =
-- Převod I na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    stosd
    mov        [edi],eax

    -- a doplnime znamenkem do vyssich bytu
    sar        eax,<t_unsigned8>31
  #if uniint_dwords_1=4 then;
    stosd
    stosd
    stosd
    stosd
  #else;
    #error 'neimplementovano';
  #end if;

{ Tohle je zbytečně složité:
    -- a doplnime znamenkem do vyssich bytu
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    bt         eax,<t_unsigned8>31
    xor        eax,eax
    jnc        @fill
    not        ebx
  @fill:
    stosd
    loop       @fill
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end signed_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniint =
-- Převod I na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

{ Tohle za nás již zařídil kompilátor:
    -- a vyfillzujeme vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    xor        eax,eax
  @fill:
    stosd
    loop       @fill
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniint_power2 =
-- Převod 2^N na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
#if N:size=4 then;
  #syntax asm;
{ Tohle za nás už zařídil kompilátor
    -- vynulujeme vysledek
    mov        edi,result
    xor        eax,eax
    cld
    mov        ecx,uniint_dwords
  @fillz:
    stosd
    loop       @fillz  
}
    -- adresa operandu a požadovaného bitu
    mov        edi,result
    mov        eax,N

    -- nastavit požadovaný bit
    bts        [edi],eax

{ Tohle je blbě:
    -- nastavime odpovidajici bit
    mov        ecx,N
    xor        ebx,ebx 
    shl        cx,<t_unsigned8>3
    mov        bl,ch
    shl        ebx,<t_unsigned8>2
    shr        cl,<t_unsigned8>3
    and        ecx,<t_unsigned32>31
    bts        eax,ecx
    mov        [edi+ebx],eax
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_uniint_power2;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unsigned =
-- Převod UI na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
 -- mov        edi,result
    mov        eax,[esi]
 -- mov        [edi],eax
    mov        result,eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unsigned64 =
-- Převod UI na T_UNSIGNED64.
----------------------------------------------------------------------------------------------------
begin
#if result:size=8 then;
  #syntax asm;
    -- get source and destination addresses
    mov        esi,ui
    mov        edi,result

    -- copy 1st LSDW
    mov        eax,[esi]
    mov        [edi],eax

    -- copy 2nd LSDW
    mov         eax,[esi+4]
    mov         [edi+4],eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_to_unsigned64;



----------------------------------------------------------------------------------------------------
procedure uniint_to_signed =
-- Převod UI na T_SIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
 -- mov        edi,result
    mov        eax,[esi]
 -- mov        [edi],eax
    mov        result,eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_to_signed;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unichar =
-- Převod UI na TUNICHAR.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
  end uniint_to_unichar;



----------------------------------------------------------------------------------------------------
procedure unireal_normalize (
    ur             : in out tunireal);           -- nenormalizovaná reálná hodnota
-- Zarovná nejméně významný bit mantisy doprava. Pokud je mantisa = ui_0, vrátí ur_0.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure uniint_to_unireal =
-- Převod [ui] na [ur].
----------------------------------------------------------------------------------------------------
begin
  result.negative:=uniint_sign(ui);
  result.mantissa:=abs ui;
  result.exponent:=ui_0;
  unireal_normalize(result);
  end uniint_to_unireal;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unilogical =
-- Převod UI na TUNILOGICAL.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
  end uniint_to_unilogical;


{
----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata =
-- Převod UI na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- inicializace
    mov        edi,result
    mov        esi,UI
    mov        ecx,uniint_dwords
    cld

    -- kopirujeme
  @next:
    movsd
    loop       @next
    #end asm;
  end uniint_to_unidata;
}


----------------------------------------------------------------------------------------------------
procedure unilogical_xor_assign =
-- A := A xor B
----------------------------------------------------------------------------------------------------

begin
  A:=logical_to_unilogical(unilogical_to_logical(A) xor unilogical_to_logical(B));
  end unilogical_xor_assign;



----------------------------------------------------------------------------------------------------
procedure unilogical_not =
-- not A
----------------------------------------------------------------------------------------------------
begin
  result:=logical_to_unilogical(not unilogical_to_logical(A));
  end unilogical_not;

  

----------------------------------------------------------------------------------------------------
procedure unichar_to_lexchar =
-- Převod UC na LEXCHAR.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end unichar_to_lexchar;



----------------------------------------------------------------------------------------------------
procedure uniint_load =
-- UI := VAL
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);

begin
#if size:size=4 then;
  #syntax asm;
    mov        edi,ui
    mov        esi,val
    mov        ecx,size
    cld
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jae        @load_larger

    -- namnožit znaménko
    cmp        sign,1
    jne        @plus
    mov        al,<t_unsigned8>[esi+ecx*4-1]
    shl        eax,<t_unsigned8>24
    sar        eax,<t_unsigned8>31
    jmp        @copy
@plus:
    mov        eax,0

@copy:
    -- zkopírovat základ
    rep        movsd

    -- vyplnit znaménkem
    mov        ecx,uniint_dwords
    mov        ebx,size
    shr        ebx,<t_unsigned8>2
    sub        ecx,ebx
    rep        stosd

    -- a konec
    jmp        @end

@load_larger:
    -- přiřadit delší číslo v maximální délce uniint
    mov        ecx,uniint_dwords
    rep        movsd

@end:
{
    -- zjistime zda neni delka cisla vetsi nez maximanlni velikost uniint
    mov        edi,UI
    mov        esi,VAL
    mov        ecx,SIZE
    cld
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jb         @loadsmaller

    -- z vetsiho cisla zkopirujeme jen co muzeme, zbytek se ztrati, kopirujeme po dwordech
    mov        ecx,uniint_dwords
  @loadlarger:
    movsd 
    loop       @loadlarger
    jmp        @konec

    -- mensi cislo zkopirujeme cely, ale po bytech
  @loadsmaller:
    -- pocet kopirovanych bytu
    mov       ecx,SIZE
    mov       edx,uniint_dwords
    --shr       edx,<t_unsigned8>2
    shl       edx,<t_unsigned8>2
    -- pocet bytu pro znamenko
    sub       edx,ecx
    cmp       ecx,0
    je        @fillplus

  @next:
    --movsb
    mov       al,[esi]
    mov       [edi],al
    inc       esi
    inc       edi
    loop      @next

    -- a doplmime znamenkem...
    mov       ecx,edx
    bt        eax,<t_unsigned8>7
    jc        @fillminus

  @fillplus:
    -- ...kladnym
    xor       al,al
  @nextplus:
    mov       [edi],al
    inc       edi
    loop      @nextplus
    jmp       @konec

    -- ...nebo zapornym
  @fillminus:
    -- obsahuje cislo vubec znamenko ?
    mov       eax,SIGN 
    cmp       eax,0
    je        @fillplus 

    xor       eax,eax
    not       eax
  @nextminus:
    mov       [edi],eax
    inc       edi 
    loop      @nextminus

    -- a to je konec
  @konec:
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_load;



----------------------------------------------------------------------------------------------------
procedure uniint_store =
-- VAL := UI
----------------------------------------------------------------------------------------------------
const
  uniint_bytes     = uniint_precision div 8;
  uniint_dwords    = uniint_bytes     div 4;

begin
#if size:size=4 then;
  #syntax asm;
    -- zjistime zda neni delka cisla vetsi nez maximanlni velikost uniint
    mov        esi,UI
    mov        edi,VAL
    mov        ecx,SIZE
    cld    
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jb         @storetosmaller

    -- zkopirujeme cely UI
    mov        ecx,uniint_dwords
    rep        movsd
{
  @next:
    mov        eax,[esi]
    mov        [edi],eax
    add        esi,4
    add        edi,4
    loop       @next
}
    -- zjistime znamenko
    sar        eax,<t_unsigned8>31
{
    bt         eax,<t_unsigned8>31
    mov        eax,0
    jnc        @isplus
    not        eax
}
  @isplus:
    mov        ecx,uniint_bytes
    sub        ecx,size
    je         @konec
    rep        stosb
    jmp        @konec

  @storetosmaller:
    mov        ecx,size
    rep        movsb
{
    mov        ecx,uniint_dwords
    rep        movsd
}
    -- a to je konec
  @konec:
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_store;



----------------------------------------------------------------------------------------------------
procedure uniint_sign =
-- True, je-li UI záporné.
----------------------------------------------------------------------------------------------------
const
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,UI
    add        esi,uniint_lastdword

    -- reset výsledku 
    mov        result,0
    mov        eax,[esi]
    clc

    -- zjistíme jak zda je nastaven nejvyšší bit UI
    bt         eax,<t_unsigned8>31
    jnb        @konec

    -- záporné číslo
    inc        result
  @konec:
    #end asm;
  end uniint_sign;

  
  
----------------------------------------------------------------------------------------------------
procedure uniint_add =
-- A + B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku
    mov        esi,A
    mov        edi,B
    mov        ebx,result

    -- sečíst
    mov        ecx,uniint_dwords
    clc
    -- secteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    adc        eax,[edi]
    mov        [ebx],eax
    lahf
    add        esi,4
    add        edi,4
    add        ebx,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_add;



----------------------------------------------------------------------------------------------------
procedure uniint_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A
    mov        edi,B

    -- sečíst 
    mov        ecx,uniint_dwords
    clc
    -- secteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    adc        eax,[edi]
    mov        [esi],eax
    lahf
    add        esi,4
    add        edi,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_add_assign;

  

----------------------------------------------------------------------------------------------------
procedure uniint_sub =
-- A - B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku
    mov        esi,A
    mov        edi,B
    mov        ebx,result

    -- odečíst
    mov        ecx,uniint_dwords
    clc
    -- odecteme vsechny dwordy 
  @next:  
    mov        eax,[esi]
    sbb        eax,[edi]
    mov        [ebx],eax
    lahf
    add        esi,4
    add        edi,4
    add        ebx,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_sub;



----------------------------------------------------------------------------------------------------
procedure uniint_sub_assign =
-- A := A - B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A
    mov        edi,B

    -- sečíst 
    mov        ecx,uniint_dwords
    clc
    -- odecteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    sbb        eax,[edi]
    mov        [esi],eax
    lahf
    add        esi,4
    add        edi,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_sub_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_prepare (
    A              : in tuniint;             
    plusA          : out tuniint;
    sign           : in out t_unsigned32;
    lenA           : out t_unsigned32) =           
-- prevede A na kladne cislo, v SIGN vrati znamenko A a v LENA delku A v bitech
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  rad              : t_unsigned32;              

begin
  #syntax asm;
    -- predzpracujeme operand A a zjistime nejvyssi nastaveny bit
    mov        rad,1
    mov        esi,A
    mov        edi,plusA
    mov        ecx,uniint_dwords
    mov        ebx,uniint_lastdword
    mov        eax,[esi+ebx]
    bt         eax,<t_unsigned8>31
    lahf
    jb         @ma

    -- A je kladne, udela se pouze kopie a zjisti nejvyssi nastaveny bit
    xor        ebx,ebx
  @pa:
    mov        eax,[esi]
    cmp        eax,0
    je         @zerodwordA
    bsr        ebx,eax
    add        ebx,rad
  @zerodwordA:
    mov        [edi],eax
    add        esi,4
    add        edi,4
    add        rad,32
    loop       @pa
    mov        eax,lenA
    mov        [eax],ebx
    jmp        @ka

    -- A je zaporne, udela se kopie a prevede na kladne a zjisti nejvyssi nastaveny bit
    xor        edx,edx
  @ma:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,0
    lahf
    cmp        ebx,0
    je         @zerodwordmA
    bsr        edx,ebx
    add        edx,rad
  @zerodwordmA:
    mov        [edi],ebx
    add        esi,4
    add        edi,4
    add        rad,32
    loop       @ma
    mov        eax,lenA
    mov        [eax],edx
    mov        eax,sign
    inc        <t_unsigned32>[eax]
  @ka:
    #end asm;
  end uniint_prepare;



----------------------------------------------------------------------------------------------------
procedure uniint_mul_assign =
-- A := A * B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

var
  dest             : t_unsigned32;               -- ofset ve vysledku                               
  prenos           : t_unsigned32;               -- prenos do dalsich 32 bitu                       
  srcA             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  srcB             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  vysledek         : tuniint;                    -- docasne ulozeny vysledek                        
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- delka obou operandu v bitech                    
  lenB             : t_unsigned32;               -- delka obou operandu v bitech                    

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  #syntax asm;
    -- inicializace

    -- vypocteme delku A v dwordech
    mov        eax,<t_unsigned32>lenA
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenA,eax

    -- vypocteme delku B v dwordech
    mov        eax,<t_unsigned32>lenB
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenB,eax

    -- vycistime si vysledek
    lea        ebx,vysledek
    mov        ecx,uniint_dwords
  @f:
    mov        [ebx],<t_unsigned32>0
    add        ebx,4
    loop       @f

    -- osetreni trivialnich pripadu (nasobeni 0)
    cmp        lenA,<t_unsigned32>0
    je         @k
    cmp        lenB,<t_unsigned32>0
    jne        @i

    -- vynulovat [A]
    mov        ebx,A
    mov        ecx,uniint_dwords
  @g:
    mov  [ebx+ecx*4-4],<t_unsigned32>0
    loop @g
    jmp        @k

  @i: -- inicializace nasobeni 
    lea        esi,<t_unsigned32>plusA
    mov        srcA,<t_unsigned32>0

  @s:
    lea        edi,<t_unsigned32>plusB
    mov        srcB,<t_unsigned32>0
    mov        prenos,<t_unsigned32>0

  @1: -- nasobime 32-bitova cisla 

    -- kontrola, zda nepretece vysledek, pokud ano preteceni se ztrati 
    mov        eax,srcA
    add        eax,srcB
    mov        dest,eax
    cmp        dest,uniint_dwords
    jnl        @2

    -- vlastni nasobeni 
    mov        eax,[esi]
    mul        <t_unsigned32>[edi]
    add        eax,prenos
    adc        edx,<t_unsigned32>0
    mov        prenos,edx

    -- upravime vysledek 
    lea        ebx,vysledek
    mov        edx,dest
    shl        edx,<t_unsigned8>2
    add        ebx,edx
    add        [ebx],eax
    jnc        @3

    -- preteceni pri scitani 
    inc        dest
    cmp        dest,uniint_dwords
    jnl        @2
    add        ebx,<t_unsigned32>4
    add        [ebx],<t_unsigned32>1
  @3:
    -- dalsich 32 bitu operadnu B 
    add        edi,<t_unsigned32>4
    inc        srcB
    mov        ebx,uniint_dwords
    cmp        srcB,ebx
    jb         @1
  @2:
    -- dalsich 32 bitu operandu A 
    add        esi,<t_unsigned32>4
    inc        srcA
    mov        ebx,uniint_dwords
    cmp        srcA,ebx
    jnl        @z
    jmp        @s

  @z: -- upravime znamenko 
    mov        eax,sign
    cld
    mov        ecx,uniint_dwords
    lea        esi,vysledek
    mov        edi,A
    bt         eax,<t_unsigned8>0
    jnc        @plus
    lahf
  @zn:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [edi],ebx
    add        esi,<t_unsigned32>4
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k
  @plus:
    movsd
    loop       @plus
  @k: -- konec 
    #end asm;
  end uniint_mul_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_mul =
-- A * B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

var
  dest             : t_unsigned32;               -- ofset ve vysledku                               
  prenos           : t_unsigned32;               -- prenos do dalsich 32 bitu                       
  srcA             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  srcB             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- delka obou operandu v bitech                    
  lenB             : t_unsigned32;               -- delka obou operandu v bitech                    

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  #syntax asm;
    -- inicializace

    -- vypocteme delku A v dwordech
    mov        eax,<t_unsigned32>lenA
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenA,eax

    -- vypocteme delku B v dwordech
    mov        eax,<t_unsigned32>lenB
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenB,eax

    -- vycistime si vysledek
    mov        ebx,result
    mov        ecx,uniint_dwords
  @f:
    mov        [ebx],<t_unsigned32>0
    add        ebx,4
    loop       @f

    -- osetreni trivialnich pripadu (nasobeni 0)
    cmp        lenA,<t_unsigned32>0
    je         @k
    cmp        lenB,<t_unsigned32>0
    je         @k

    -- inicializace nasobeni 
    lea        esi,<t_unsigned32>plusA
    mov        srcA,<t_unsigned32>0

  @s:
    lea        edi,<t_unsigned32>plusB
    mov        srcB,<t_unsigned32>0
    mov        prenos,<t_unsigned32>0

  @1: -- nasobime 32-bitova cisla 

    -- kontrola, zda nepretece vysledek, pokud ano preteceni se ztrati 
    mov        eax,srcA
    add        eax,srcB
    mov        dest,eax
    cmp        dest,uniint_dwords
    jnl        @2

    -- vlastni nasobeni 
    mov        eax,[esi]
    mul        <t_unsigned32>[edi]
    add        eax,prenos
    adc        edx,<t_unsigned32>0
    mov        prenos,edx

    -- upravime vysledek 
    mov        ebx,dest
    shl        ebx,<t_unsigned8>2
    add        ebx,result
    add        [ebx],eax
    jnc        @3

    -- preteceni pri scitani 
    inc        dest
    cmp        dest,uniint_dwords
    jnl        @2
    add        ebx,<t_unsigned32>4
    add        [ebx],<t_unsigned32>1
  @3:
    -- dalsich 32 bitu operadnu B 
    add        edi,<t_unsigned32>4
    inc        srcB
    mov        ebx,uniint_dwords
    cmp        srcB,ebx
    jb         @1
  @2:
    -- dalsich 32 bitu operandu A 
    add        esi,<t_unsigned32>4
    inc        srcA
    mov        ebx,uniint_dwords
    cmp        srcA,ebx
    jnl        @z
    jmp        @s

  @z: -- upravime znamenko 
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @k
    lahf
    mov        ecx,uniint_dwords
    mov        esi,result
  @zn:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [esi],ebx
    add        esi,<t_unsigned32>4
    loop       @zn
  @k: -- konec 
    #end asm;
  end uniint_mul;



----------------------------------------------------------------------------------------------------
procedure uniint_shlx (
    A              : in out tuniint) =
-- shl A o 1 dword
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    mov        edi,a  
    add        edi,uniint_lastdword
    mov        ecx,uniint_dwords_1
    mov        esi,edi
    sub        esi,4
    std
  @next:
    movsd
    loop       @next
    xor        eax,eax
    stosd
    cld
    #end asm;
  end uniint_shlx;



----------------------------------------------------------------------------------------------------
procedure uniint_shrx (
    A              : in out tuniint) =
-- shr A o 1 dword
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
  #syntax asm;
    mov        edi,a  
    mov        ecx,uniint_dwords_1
    mov        esi,edi
    add        esi,4
    cld
  @next:
    movsd
    loop       @next
    xor        eax,eax
    stosd
    #end asm;
  end uniint_shrx;



----------------------------------------------------------------------------------------------------
procedure uniint_submulw (
    A              : in out tuniint;             
    B              : in tuniint;                 
    len            : in t_unsigned32;            -- delka operandu B ve dwordech
    W              : in t_unsigned32) =           
-- A := A-B*W
----------------------------------------------------------------------------------------------------
const
  uniint_bytes     = uniint_precision div 8;

begin
  #syntax asm;
    push       ebp

    -- inicializace
    mov        ebx,w
    mov        ecx,uniint_bytes
    mov        edi,b  
    mov        esi,a  
    mov        ebp,len
    shl        ebp,<t_unsigned8>2
    add        ebp,edi
    add        ecx,esi

    -- vynasobit DX:AX:=w*B[di] 
  @next: 
    mov        eax,ebx
    mul        <t_unsigned32>[edi]

    -- odecist soucin od A[si] 
    sub        [esi],eax
    sbb        [esi+4],edx
    jnc        @nocarry

    -- prenos do vyssich radu A 
    push       esi
    add        esi,4
  @iscarry: 
    add        esi,4
    sub        <t_unsigned32>[esi],1
    jc         @iscarry
    pop        esi

  @nocarry: 
    -- pripravit se na dalsi dword
    add        edi,4
    cmp        edi,ebp
    jnb        @konec
    add        esi,4
    jmp        @next

  @konec: 
    pop        ebp
    #end asm;
  end uniint_submulw;



----------------------------------------------------------------------------------------------------
procedure uniint_addw (
    A              : in out tuniint;             
    W              : in t_unsigned32) =           
-- A := A+W
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    mov        edi,a
    mov        ecx,uniint_dwords
    mov        eax,W
    xor        edx,edx
    add        [edi],eax
    jmp        @test
  @next:
    adc        [edi],eax
  @test:
    jnc        @konec
    add        edi,4
    loop       @next
  @konec:
    #end asm;
  end uniint_addw;



----------------------------------------------------------------------------------------------------
procedure uniint_div_assign =
-- A := A div B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

var
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- nejvyssi nastaveny bit v A
  lenB             : t_unsigned32;               -- nejvyssi nastaveny bit v B
  plenB            : t_unsigned32;               -- puvodni delka B
  lenBw            : t_unsigned32;               -- delka B v dwordech            
  rad              : t_unsigned32;               -- aktualni rad vysledku                           
  dv               : t_mod_unsigned32;
  ra               : t_unsigned32;
  shift            : tuniint;

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  -- vyfillzujeme vysledek
  A:=ui_0;

  -- delit ma cenu pouze pokud A je vetsi nez B a A neni 0
  if lenA>=lenB and lenA>0 then

    #syntax asm;
      -- uschovame puvodni delku operandu B
      mov        eax,<t_unsigned32>lenB
      mov        <t_unsigned32>plenB,eax

      -- vypocteme novou
      mov        eax,<t_unsigned32>lenA
      add        eax,<t_unsigned32>31
      mov        ebx,<t_unsigned32>32
      xor        edx,edx
      div        ebx
      mul        ebx
      mov        lenB,eax
      mov        lenBw,eax
      dec        lenBw
      shr        lenBw,<t_unsigned8>5

      -- vypocteme ofset posunu operandu B
      sub        eax,plenB
      lea        edi,shift
      mov        [edi],eax
      #end asm;

    -- zarovnani delitele tak, aby nebyl kratsi nez delenec a zaroven byl deliteny 32
    uniint_shl_assign(plusB,shift);

    -- zjisteni delitele pro vypocet odhadu
    #syntax asm;
      mov        ebx,lenBw
      shl        ebx,<t_unsigned8>2
      lea        edi,plusB
      mov        eax,[edi+ebx]
      mov        dv,eax
      #end asm;

    loop
      loop       
        -- odhadnout podil 
        #syntax asm;
          mov        ebx,lenBw
          shl        ebx,<t_unsigned8>2
          lea        edi,plusA
          mov        eax,[edi+ebx]
          add        ebx,4
          mov        edx,[edi+ebx]
          mov        ecx,dv
          inc        ecx

          -- pokud se preteklo do nuly (=100000000h) nemusim ani nic delit, staci mov
          jnz        @1              
          mov        eax,edx         
          jmp        @2
        @1:   
          div        ecx

        @2:
          mov        ra,eax
          #end asm;

        -- koncime ?
        if ra=0 then break; end if;

        uniint_submulw(plusA,plusB,lenBw+1,ra);
        uniint_addw(A,ra);
        end loop;

      -- shiftnout o dword
      if lenB>=plenB+32 then
        uniint_shrx(plusB);
        uniint_shlx(A);
        lenB-32;
        lenBw-1;

      -- shiftnout o zbyle bity 
      elsif lenB>plenB then
        rad:=lenB-plenB;
        lenB:=plenB;

        #syntax asm;
          lea        edi,shift
          mov        eax,rad
          mov        [edi],eax
          #end asm;

        uniint_shr_assign(plusB,shift);
        uniint_shl_assign(A,shift);
        dv:=dv shr rad;

      -- neni co shiftovat, koncime
      else
        break;
        end if;

      end loop;

    -- obcas se nepodari spravne odhadnout podil a musim si pomoci odcitanim
    while plusA>=plusB loop 
      plusA-plusB; 
      succ A;
      end loop;
    end if;

  -- kopie a pripadne vytvoreni zaporneho cisla
  #syntax asm;
    -- inicializace a zjisteni vysledneho znamenka
    mov        edi,A
    xor        ebx,ebx
    mov        ecx,uniint_dwords
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @isplus

    -- prevedeni cisla na zaporne
    lahf
  @zn:
    mov        ebx,[edi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [edi],ebx
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k

    -- zkopirovani do vyskledku
  @isplus:
    mov        eax,[edi+ebx]
    mov        [edi+ebx],eax
    add        ebx,4
    loop       @isplus

  @k: -- konec 
    #end asm;
  end uniint_div_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_div =
-- A div B
----------------------------------------------------------------------------------------------------
begin
  result:=A;
  uniint_div_assign(result,B);
  end uniint_div;



----------------------------------------------------------------------------------------------------
procedure uniint_mod_assign =
-- A := A mod B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

var
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- nejvyssi nastaveny bit v A                  
  lenB             : t_unsigned32;               -- nejvyssi nastaveny bit v B                  
  plenB            : t_unsigned32;               -- puvodni delka B
  lenBw            : t_unsigned32;               -- delka B v dwordech
  rad              : t_unsigned32;               -- aktualni rad vysledku                           
  dv               : t_mod_unsigned32;
  ra               : t_unsigned32;
  shift            : tuniint;

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  if lenA>=lenB and lenA>0 then
    #syntax asm;
      -- uschovame puvodni delku operandu B
      mov        eax,<t_unsigned32>lenB
      mov        <t_unsigned32>plenB,eax

      -- vypocteme novou
      mov        eax,<t_unsigned32>lenA
      add        eax,<t_unsigned32>31
      mov        ebx,<t_unsigned32>32
      xor        edx,edx
      div        ebx
      mul        ebx
      mov        lenB,eax
      mov        lenBw,eax
      dec        lenBw
      shr        lenBw,<t_unsigned8>5

      -- vypocteme ofset posunu operandu B
      sub        eax,plenB
      lea        edi,shift
      mov        [edi],eax
      #end asm;

    -- zarovnani delitele tak, aby nebyl kratsi nez delenec a zaroven byl deliteny 32
    uniint_shl_assign(plusB,shift);

    -- zjisteni delitele pro vypocet odhadu
    #syntax asm;
      mov        ebx,lenBw
      shl        ebx,<t_unsigned8>2
      lea        edi,plusB
      mov        eax,[edi+ebx]
      mov        dv,eax
      #end asm;

    loop
      loop       
        -- odhadnout podil 
        #syntax asm;
          mov        ebx,lenBw
          shl        ebx,<t_unsigned8>2
          lea        edi,plusA
          mov        eax,[edi+ebx]
          add        ebx,4
          mov        edx,[edi+ebx]
          mov        ecx,dv
          inc        ecx

          -- pokud se preteklo do nuly (=100000000h) nemusim ani nic delit, staci mov
          jnz        @1              
          mov        eax,edx         
          jmp        @2
        @1:   
          div        ecx

        @2:
          mov        ra,eax
          #end asm;

        -- koncime ?
        if ra=0 then break; end if;

        uniint_submulw(plusA,plusB,lenBw+1,ra);
        end loop;

      -- shiftnout o dword
      if lenB>=plenB+32 then
        uniint_shrx(plusB);
        lenB-32;
        lenBw-1;

      -- shiftnout o zbyle bity 
      elsif lenB>plenB then
        rad:=lenB-plenB;
        lenB:=plenB;

        #syntax asm;
          lea        edi,shift
          mov        eax,rad
          mov        [edi],eax
          #end asm;

        uniint_shr_assign(plusB,shift);
        dv:=dv shr rad;

      -- neni co shiftovat, koncime
      else
        break;
        end if;

      end loop;

    -- obcas se nepodari spravne odhadnout podil a musim si pomoci odcitanim
    while plusA>=plusB loop plusA-plusB; end loop;
    end if;

  -- kopie a pripadne vytvoreni zaporneho cisla
  #syntax asm;
    -- inicializace a zjisteni vysledneho znamenka
    mov        esi,A
    lea        edi,plusA
    xor        ebx,ebx
    mov        ecx,uniint_dwords
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @isplus

    -- prevedeni cisla na zaporne
    lahf
  @zn:
    mov        ebx,[edi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [esi],ebx
    add        esi,<t_unsigned32>4
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k

    -- zkopirovani do vyskledku
  @isplus:
    mov        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @isplus

  @k: -- konec 
    #end asm;
  end uniint_mod_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_mod =
-- A mod B
----------------------------------------------------------------------------------------------------
begin
  result:=A;
  uniint_mod_assign(result,B);
  end uniint_mod;



----------------------------------------------------------------------------------------------------
procedure uniint_shl_assign =
-- [a] := [a] shl [b]
----------------------------------------------------------------------------------------------------
const
  uniint_words     = uniint_precision div 16;
  uniint_words_1   = uniint_words-1;

begin
  #syntax asm;
    -- load shift count into ECX
    mov         esi,b
    mov         ecx,[esi]
    
    -- load 1st operand address
    mov         edi,a
    mov         esi,edi

    -- separate word-shift count and (0..15) bit shift count into CH and CL
    shl         cx,<t_unsigned8>4
    shr         cl,<t_unsigned8>4

    -- load word-shift to EBX
    xor         ebx,ebx
    mov         bx,cx
    shr         bx,<t_unsigned8>8

    -- compute operand source/destination addresses
    mov         eax,ebx
    shl         eax,<t_unsigned8>1
    add         edi,eax

    -- compute number of iterations
    neg         bl
    add         bl,<t_unsigned8>uniint_words_1

    -- load initial word
    xor         edx,edx
    mov         dx,[esi+ebx*2]

    -- bit shift, discard MSW and save LSW into MSW of EAX
    shl         edx,cl
    mov         ax,dx
    shl         eax,<t_unsigned8>16

    -- iteration
  @nextW:
    dec         bl
    js          @finalW

    -- load word
    xor         edx,edx
    mov         dx,[esi+ebx*2]

    -- bit shift, add carry to previously saved word, store it to destination and save the current one
    shl         edx,cl
    xor         ax,ax
    or          eax,edx
    rol         eax,<t_unsigned8>16
    mov         [edi+ebx*2+2],ax
    jmp         @nextW

    -- store final word
  @finalW:
    shr         eax,<t_unsigned8>16
    mov         [edi],ax

    -- load word-shift count to ECX
    shr         cx,<t_unsigned8>8

    -- zero-pad remaining words
  @zero_pad:
    xor         eax,eax

  @nextW_0:
    dec         cl
    js          @end
    mov         [esi+ecx*2],ax
    jmp         @nextW_0

  @end:
  #end asm;
  end uniint_shl_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_shl =
-- [a] shl [b]
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  uniint_shl_assign(result,b);
  end uniint_shl;



{
----------------------------------------------------------------------------------------------------
procedure uniint_shl_assign =
-- A := A shl B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;
  uniint_maxshl    = tuniint:[uniint_precision,for others use 0];
  uniint_minshl    = tuniint:[for others use 0];
  uniint_treshhold = tuniint:[5,for others use 0];

var
  source           : t_unsigned32;               -- ofset zdrojoveho (vyssiho) dwordu               
  destination      : t_unsigned32;               -- ofset ciloveho dwordu                           

begin
  -- osetrime krajni pripady
  if b>uniint_minshl then
    -- kratky posun
    if b<=uniint_treshhold then
      #syntax asm;
        mov        esi,A
        mov        edi,B
        mov        edx,<t_unsigned32>[edi]

      -- posun
      @nextstep:
        xor        ebx,ebx
        mov        ecx,uniint_dwords

      -- clear carry and save flags
        clc
        pushf

      -- posun uniint o 1 bit
      @nextdword:
        mov        eax,[esi+ebx]

      -- load flags, rotate through carry and save flags
        popf
        rcl        eax,1
        pushf

      -- next dw
        mov        [esi+ebx],eax
        add        ebx,4
        loop       @nextdword

      -- clean stack
        popf

      @k1:
        dec        edx
        cmp        edx,0
        jne        @nextstep                  
        #end asm;

    -- dlouhy posun
    elsif b<uniint_maxshl then
      #syntax asm;
        -- adresy operandů a výsledku 
        mov        esi,A
        mov        edi,B
        mov        ecx,<t_unsigned32>[edi]
        -- do EDX dostaneme pocet dwordu o ktere rotujeme, v CL pocet bitu o kolik rotovat dwordy
        shl        cx,<t_unsigned8>3
        shr        cl,<t_unsigned8>3
        xor        edx,edx
        mov        dl,ch
        dec        edx
        shl        edx,<t_unsigned8>2

        -- zjistime adresy zdrojovych a ciloveho dwordu
        mov        ebx,uniint_lastdword
        mov        destination,ebx 
        sub        ebx,edx
        mov        source,ebx 

      @next:
        -- nepodtekl nam zdroj dat ?
        sub        source,4
        jb         @underH

        -- necteme kopirovany dword 
        mov        ebx,source
        mov        eax,[esi+ebx]

        -- orotujeme o prislusny pocet bitu
        shl        eax,cl
        not        cl
        inc        cl

        -- nacteme nizsi dword
        sub        ebx,4
        jb         @save
        mov        edx,[esi+ebx]

        -- orotujeme ho o komplement doprava
        shr        edx,cl
        not        cl
        inc        cl

        -- spojime vysledek
        or         eax,edx
        jmp        @save

      @underH:
        -- nacitana data podtekla - doplnime nulama
        xor        eax,eax 

      @save:
        -- ulozime prave spocteny dword
        mov        ebx,destination
        mov        [esi+ebx],eax

        -- dalsi krok 
        sub        destination,4
        jb         @konec
        jmp        @next
      @konec:
        #end asm;

    -- rotujeme mimo rozsah, takze muzeme vynulovat vysledek
    else
      #syntax asm;
        -- adresy operandů a výsledku 
        mov        esi,A
        mov        ecx,uniint_dwords
      @fillz:
        mov        [esi],<t_unsigned32>0
        add        esi,4 
        loop       @fillz
        #end asm;
      end if;
    end if;
  end uniint_shl_assign;
}
  


----------------------------------------------------------------------------------------------------
procedure uniint_shr_assign =
-- [a] := [a] shr [b]
----------------------------------------------------------------------------------------------------
const
  uniint_words     = uniint_precision div 16;
  uniint_words_1   = uniint_words-1;

begin
  #syntax asm;
    -- load shift count into ECX
    mov         esi,b
    mov         ecx,[esi]
    
    -- load 1st operand address
    mov         edi,a
    mov         esi,edi

    -- separate word-shift count and (0..15) bit shift count into CH and CL
    shl         cx,<t_unsigned8>4
    shr         cl,<t_unsigned8>4

    -- load word-shift to EBX
    xor         ebx,ebx
    mov         bx,cx
    shr         bx,<t_unsigned8>8

    -- CL <- 16-CL
    neg         cl
    add         cl,<t_unsigned8>16

    -- compute operand source/destination addresses
    mov         eax,ebx
    shl         eax,<t_unsigned8>1
    add         esi,eax

    -- compute number of iterations
    neg         bl
    add         bl,<t_unsigned8>uniint_words_1

    -- load initial word
    xor         edx,edx
    mov         dx,[esi]

    -- bit shift, discard LSW and save MSW into LSW of EAX
    shl         edx,cl
    shr         edx,<t_unsigned8>16
    mov         eax,edx

    -- iteration
  @nextW:
    dec         bl
    js          @finalW

    -- load word
    inc         esi
    inc         esi
    xor         edx,edx
    mov         dx,[esi]

    -- bit shift, add carry to previously saved word, store it to destination and save the current one
    shl         edx,cl
    or          eax,edx
    mov         [edi],ax
    inc         edi
    inc         edi
    shr         eax,<t_unsigned8>16
    jmp         @nextW

    -- store final word
  @finalW:
    mov         [edi],ax

    -- load word-shift count to ECX
    shr         cx,<t_unsigned8>8

    -- zero-pad remaining words
  @zero_pad:
    xor         eax,eax

  @nextW_0:
    dec         cl
    js          @end
    inc         edi
    inc         edi
    mov         [edi],ax
    jmp         @nextW_0

  @end:
  #end asm;
  end uniint_shr_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_shr =
-- [a] shr [b]
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  uniint_shr_assign(result,b);
  end uniint_shr;



{
----------------------------------------------------------------------------------------------------
procedure uniint_shr_assign =
-- A := A shr B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;
  uniint_maxshr    = tuniint:[uniint_precision,for others use 0];
  uniint_minshr    = tuniint:[for others use 0];
  uniint_treshhold = tuniint:[5,for others use 0];

var
  source           : t_unsigned32;                -- ofset zdrojoveho (nizsiho) dwordu               
  destination      : t_unsigned32;                -- ofset ciloveho dwordu                           

begin
  -- osetrime krajni pripady
  if b>uniint_minshr then
    -- kratky posun
    if b<=uniint_treshhold then
      #syntax asm;
        mov        esi,A
        mov        edi,B
        mov        edx,<t_unsigned32>[edi]

      -- posun
      @nextstep:
        mov        ecx,uniint_dwords
        clc

      -- posun uniint o 1 bit
      @nextdword:
        mov        eax,[esi+ecx*4-4]
        rcr        eax,1
        mov        [esi+ecx*4-4],eax
        loop       @nextdword

      @k1:
        dec        edx
        cmp        edx,0
        jne        @nextstep                  
        #end asm;

    -- dlouhy posun
    elsif b<uniint_maxshr then
      #syntax asm;
        -- adresy operandů a výsledku 
        mov        esi,A
        mov        edi,B
        mov        ecx,<t_unsigned32>[edi]
        -- do EDX dostaneme pocet dwordu o ktere rotujeme, v CL pocet bitu o kolik rotovat dwordy
        shl        cx,<t_unsigned8>3
        shr        cl,<t_unsigned8>3
        xor        edx,edx
        mov        dl,ch
        shl        edx,<t_unsigned8>2

        -- zjistime adresy zdrojovych a ciloveho dwordu
        mov        ebx,0
        mov        destination,ebx
        add        ebx,edx
        mov        source,ebx 

      @next:
        -- nepodtekl nam zdroj dat ?
        cmp        source,uniint_lastdword
        jg         @underH

        -- necteme kopirovany dword 
        mov        ebx,source
        mov        eax,[esi+ebx]

        -- orotujeme o prislusny pocet bitu
        shr        eax,cl
        not        cl
        inc        cl

        -- nacteme nizsi dword
        add        ebx,4
        cmp        ebx,uniint_lastdword
        jg         @save
        mov        edx,[esi+ebx]

        -- orotujeme ho o komplement doleva
        shl        edx,cl
        not        cl
        inc        cl

        -- spojime vysledek
        or         eax,edx
        jmp        @save

      @underH:
        -- nacitana data podtekla - doplnime nulama
        xor        eax,eax 

      @save:
        -- ulozime prave spocteny dword
        mov        ebx,destination
        mov        [esi+ebx],eax

        -- dalsi krok 
        add        source,4
        add        destination,4
        cmp        destination,uniint_lastdword
        jg         @konec
        jmp        @next
      @konec:
        #end asm;

    -- rotujeme mimo rozsah, takze muzeme vynulovat vysledek
    else
      #syntax asm;
        -- adresy operandů a výsledku 
        mov        esi,A
        mov        ecx,uniint_dwords
      @fillz:
        mov        [esi],<t_unsigned32>0
        add        esi,4 
        loop       @fillz
        #end asm;
      end if;
    end if;
  end uniint_shr_assign;
}

  

----------------------------------------------------------------------------------------------------
procedure uniint_and_assign =
-- A := A and B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    and        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
    #end asm;
  end uniint_and_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_and =
-- A and B
----------------------------------------------------------------------------------------------------
begin
  result:=A;
  uniint_and_assign(result,B);
  end uniint_and;



----------------------------------------------------------------------------------------------------
procedure uniint_or_assign =
-- A := A or B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    or         eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
    #end asm;
  end uniint_or_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_xor_assign =
-- A := A xor B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    xor        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
    #end asm;
  end uniint_xor_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_neg =
-- - A
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  -result;
  end uniint_neg;


  
----------------------------------------------------------------------------------------------------
procedure uniint_neg_assign =
-- A := - A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        edi,A

    -- inicializace
    mov        ecx,uniint_dwords
    clc
    cld

    -- znegovat
@1: mov        eax,0
    sbb        eax,[edi]
    stosd
    loop       @1

{
    -- adresy operandů a výsledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    stc
    lahf

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        edx,[esi+ebx]
    not        edx
    sahf
    adc        edx,0
    lahf
    mov        [esi+ebx],edx
    add        ebx,4
    loop       @next
  @konec:
}
    #end asm;
  end uniint_neg_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_not =
-- not A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  result:=A;
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        edi,result

    -- inicializace
    mov        ecx,uniint_dwords

    -- znegovat
@1: not        <t_unsigned32>[edi+ecx*4-4]
    loop       @1
    #end asm;
  end uniint_not;


  
----------------------------------------------------------------------------------------------------
procedure uniint_not_assign =
-- A := not A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        edi,A

    -- inicializace
    mov        ecx,uniint_dwords

    -- znegovat
@1: not        <t_unsigned32>[edi+ecx*4-4]
    loop       @1
    #end asm;
  end uniint_not_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_abs_assign =
-- A := abs A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- zjistime znamenko A 
    mov        esi,A
    mov        ebx,uniint_lastdword
    mov        eax,[esi+ebx]
    bt         eax,<t_unsigned8>31
    lahf
    jnb        @konec
    mov        ecx,uniint_dwords

    -- A je zaporne, prevede se na kladne
  @ma:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,0
    lahf
    mov        [esi],ebx
    add        esi,4
    loop       @ma
  @konec:
    #end asm;
  end uniint_abs_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_abs =
-- abs [a]   
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  uniint_abs_assign(result);
  end uniint_abs;



----------------------------------------------------------------------------------------------------
procedure uniint_succ_assign =
-- A := succ A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    add        eax,1
    mov        [esi+ebx],eax
    jnc        @konec
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_succ_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_pred =
-- pred A
----------------------------------------------------------------------------------------------------
begin
  result:=A;
  pred result;
  end uniint_pred;



----------------------------------------------------------------------------------------------------
procedure uniint_pred_assign =
-- A := pred A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    sub        eax,1
    mov        [esi+ebx],eax
    jnc        @konec
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_pred_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_lt =
-- A < B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A < B
  @mensi:
    mov        ebx,<t_unsigned32>1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_lt;



----------------------------------------------------------------------------------------------------
procedure uniint_le =
-- A <= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A < B
  @mensi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_le;



----------------------------------------------------------------------------------------------------
procedure uniint_gt =
-- A > B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand• a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A > B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_gt;



----------------------------------------------------------------------------------------------------
procedure uniint_ge =
-- A >= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A >= B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_ge;


{
----------------------------------------------------------------------------------------------------
procedure uniint_ge_unidata =
-- A >= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A >= B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_ge_unidata;
}


----------------------------------------------------------------------------------------------------
procedure uniint_is_multiple =
-- True if and only if [ui] = x*[base], x from N0.
----------------------------------------------------------------------------------------------------
begin
  result:=ui_0=(ui mod base);
  end uniint_is_multiple;



----------------------------------------------------------------------------------------------------
procedure uniint_is_power2 =
-- True, je-li A nějaká mocnina dvojky.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);

begin
  #syntax asm;
    -- inicializace
    mov        edi,A
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    mov        <t_unsigned32>result,ebx

    -- otestujeme dalsi dword
  @next:
    mov        eax,[edi]

    -- zjistime, zda dword obsahuje nejake nastavene bity
  @test:
    cmp        eax,0
    je         @iszero

    -- nebyl uz nahodou nejaky bit nekdy nastaven ? pokud ano, A neni mocnina 2
    cmp        ebx,0
    jne        @konec

    -- zjistime prvni nastaveny bit, shodime ho a poznamename si do ebx ze nejaky takovy existuje
    bsr        edx,eax
    btr        eax,edx
    inc        ebx

    -- neni v dwordu jeste nejaky jiny nastaveny bit ?
    jmp        @test
  @iszero:
    add        edi,4
    loop       @next

    -- ulozime vysledek testu
    mov        <t_unsigned32>result,ebx
  @konec:
    #end asm;
  end uniint_is_power2;



----------------------------------------------------------------------------------------------------
procedure uniint_get_power2 =
-- Exponent, je-li A nějaká mocnina dvojky.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);
  uniint_lastdword = (uniint_precision div 8)-4;

begin
#if result:size=4 then;
  #syntax asm;
    -- inicializace
    mov        edi,A
    add        edi,uniint_lastdword
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    mov        edx,uniint_lastdword
    shl        edx,<t_unsigned8>3

    -- najdeme nejvyssi nenulovy dword
  @next:
    mov        eax,[edi]
    cmp        eax,0
    jne        @bitset
    sub        edi,4
    sub        edx,32 
    loop       @next
    jmp        @konec

    -- nasli jsme nejaky bit, zjistime jeho absolutni pozici a koncime
  @bitset:
    bsr        ebx,eax
    add        ebx,edx

    -- ulozime vysledek
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_get_power2;

  

----------------------------------------------------------------------------------------------------
procedure uniint_length =
-- Délka intervalu: B - A + 1
----------------------------------------------------------------------------------------------------
begin
  result:=b-a+ui_1;
  end uniint_length;



----------------------------------------------------------------------------------------------------
procedure uniint_test_shrink =
-- True, pokud A je větší než SIZE bytů nebo má chybné znaménko.
----------------------------------------------------------------------------------------------------
const
  uniint_bytes     = uniint_precision div 8;

begin
#if result:size=4 then;
  #syntax asm;
    --                                                                    
    --                                                                    
    --                                                                    
    --      +-----------+-----------+                                     
    --      | edx bytu  | ecx bytu  |                                     
    --      +--+--+--+--+--+--+--+--+                                     
    --      ^        ^           ^                                        
    --      puvodni  |           |                                        
    --      [eax]    |           |                                        
    --               novy        [eax+ecx]                                
    --               [eax]                                                

    cmp     sign,1
    jne     @1

    -- znaménkově
    mov     ecx,uniint_bytes
    sub     ecx,size
    mov     ebx,$000000FF -- bl:=$FF; bh:=$00;
    jecxz   @5
    -- testovat bity
    mov     eax,A
    add     eax,size
    dec     eax -- eax:=^A+SIZE-1;
@3: and     bl,[eax+ecx]
    or      bh,[eax+ecx]
    dec     ecx
    jnz     @3
    -- byly to samé jedničky => záporné
    cmp     bh,$00 -- = samé nuly
    je      @6
    cmp     bl,$FF -- = samé jedničky
    je      @7
    mov     eax,1  -- = něco mezi tím => určitě přetečení
    jmp     @4
    -- samé nuly, nejvyšší bit musí být též 0
@6: movzx   eax,<t_unsigned8>[eax]
    shr     eax,<t_unsigned8>7
    jmp     @4
    -- samé jedničky, nejvyšší bit musí být též 1
@7: movzx   eax,<t_unsigned8>[eax]
    shr     eax,<t_unsigned8>7
    xor     eax,1
    jmp     @4

@1: -- bezznaménkově
    mov     ecx,uniint_bytes
    sub     ecx,size
    xor     ebx,ebx
    jecxz   @5
    -- nakumulovat testované bity
    mov     eax,A
    add     eax,size
    dec     eax -- eax:=^A+SIZE-1;
@2: or      bl,[eax+ecx]
    dec     ecx
    jnz     @2
    -- vyšla nenula => přetečení
@5: cmp     bl,0
    setnz   al
    and     eax,1

@4: -- předat výsledek
    mov     result,eax

{
    -- inicializace
    mov        esi,A
    add        esi,uniint_lastdword

    -- zjistime znamenko A, pozadovane znamenko a otestujeme na shodu
    mov        eax,[esi]
    mov        ebx,sign
    bt         ebx,<t_unsigned8>0
    jc         @isminus
    mov        dl,0
    bt         eax,<t_unsigned8>31
    jc         @returntrue
    jmp        @testlength
  @isminus:
    mov        dl,$ff
    bt         eax,<t_unsigned8>31
    jnc        @returntrue

    -- otestujeme delku
  @testlength:
    mov        esi,A
    mov        ecx,uniint_dwords
    shl        ecx,<t_unsigned8>2
    mov        ebx,ecx

  @testbyte:
    mov        al,[esi+ebx-1]
    cmp        al,dl
    jne        @comparesize
    dec        ebx
    loop       @testbyte
    mov        ebx,1
  @comparesize:
    cmp        ebx,size
    jbe        @returnfalse

  @returntrue:
    mov        ebx,1
    mov        result,ebx
    jmp        @konec
  @returnfalse:
    mov        ebx,0
    mov        result,ebx
  @konec:
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_test_shrink;



----------------------------------------------------------------------------------------------------
procedure uniint_get_nth_byte =
-- Získá N-tý byte zadaného univerzálního integeru
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned8array(A:unchecked)[n];
  end uniint_get_nth_byte;



----------------------------------------------------------------------------------------------------
procedure uniint_exp10 =
-- 10^[ui] (signed)
----------------------------------------------------------------------------------------------------
begin
  -- 10^0 = 1
  result:=ur_1;

  -- 10^[ui] = (10^abs([ui]))^sign([ui])
  for i in 1..uniint_to_unsigned(abs(ui)) loop
    result*ur_10;
    end loop;

  -- inversion, if needed
  if uniint_sign(ui) then
    result:=ur_1/result;
    end if;
  end uniint_exp10;



----------------------------------------------------------------------------------------------------
procedure char_to_unichar =
-- Převod C na TUNICHAR.
----------------------------------------------------------------------------------------------------
begin
  result:=tunichar(c);
  end char_to_unichar;



----------------------------------------------------------------------------------------------------
procedure unichar_to_uniint =
-- Převod TUNICHAR na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(c:ord);
  end unichar_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unireal_round =
-- Zaokrouhlit [ur] na nejbližší celé číslo.
----------------------------------------------------------------------------------------------------
var
  ceil             : t_logical;

begin
  -- shift mantissa to get exponent 0
  if ur.exponent<ui_0
    -- right shift
    then
      result:=ur.mantissa shr (-ur.exponent-ui_1);

      -- check if rounding needed
      ceil:=(result and ui_1)<>ui_0;

      result shr ui_1;

      -- rounding
      if ceil then succ result; end if;

    -- left shift (beware, there's no overflow detection)
    else
      result:=ur.mantissa shl ur.exponent;
      end if;

  -- add sign
  if ur.negative then -result; end if;
  end unireal_round;



----------------------------------------------------------------------------------------------------
procedure unireal_store_fixed =
-- Stores binary value of fixed-point type.
----------------------------------------------------------------------------------------------------
begin
  uniint_store(unireal_round(ur*uniint_to_unireal(inv_delta)),val,size);
  end unireal_store_fixed;



----------------------------------------------------------------------------------------------------
procedure unireal_store_float =
-- Stores binary value of float-point type.
----------------------------------------------------------------------------------------------------
type
  t_float_precision = enum
    single_prec;
    double_prec;
    extended_prec;
    end enum;

  t_float_parameter = enum
    bits;
    signif_bits;
    exp_bits;
    exp_max;
    end enum;

const
  fpars_tab        : array t_float_precision,t_float_parameter of t_signed32 =
                   [for single_prec   use [32, 24,  8,   127],
                    for double_prec   use [64, 53, 11,  1023],
                    for extended_prec use [80, 64, 15, 16383]];

#template sign_index(float_prec);
  (fpars_tab[(float_prec),bits]-1)
  #end sign_index;

#template exponent_index(float_prec);
  (fpars_tab[(float_prec),signif_bits])
  #end exponent_index;

#template bitsize(float_prec);
  (fpars_tab[(float_prec),bits])
  #end bitsize;

#template significand_bits(float_prec);
  (fpars_tab[(float_prec),signif_bits])
  #end significand_bits;

#template exponent_bits(float_prec);
  (fpars_tab[(float_prec),exp_bits])
  #end exponent_bits;

#template exponent_max(float_prec);
  (fpars_tab[(float_prec),exp_max])
  #end exponent_max;

#template exponent_min(float_prec);
  (-fpars_tab[(float_prec),exp_max]+1)
  #end exponent_min;

#template exponent_bias(float_prec);
  (fpars_tab[(float_prec),exp_max])
  #end exponent_bias;

var
  mask             : tuniint;                    -- bit mask
  deltab           : t_signed32;                 -- bit width difference
  buffer           : tuniint;                    -- working space
  exp              : tuniint;                    -- (biased) exponent
  prec             : t_float_precision;          -- desired precision

begin
  -- set desired precision
  case size
      when  4 do     prec:=  single_prec;
      when  8 do     prec:=  double_prec;
      when 10 do     prec:=extended_prec;
      -- unexpected type size
      when others do verify({VERIFY=}001399,true);
    end case;

  -- handle 0.0
  if ur=ur_0 then
    -- 0.0 will be stored
    return;
    end if;

  -- load working variables
  buffer:=ur.mantissa;
  exp:=ur.exponent;

  -- count inner-representation msb position
  mask:=ui_first;
  deltab:=uniint_precision;
  while (mask and buffer)=ui_0 loop
    mask shr ui_1;
    pred deltab;
    end loop;

  -- normalize exponent
  exp+signed_to_uniint(deltab-1);

  -- count desired precision to inner rep. binary digits difference
  deltab:=significand_bits(prec)-deltab;

  -- set significand
  if deltab<0
    -- mantissa is too long to fit significiand
    then
      -- shrink and round mantissa
      declare var
        carry_flag : tuniint;                    -- carry flag

      begin
        -- fetch carry flag
        if ((mask shr signed_to_uniint(significand_bits(prec))) and buffer)<>ui_0 then
          carry_flag:=ui_1;
          end if;

        -- shrink mantissa
        buffer shr signed_to_uniint(-deltab);

        -- round mantissa
        buffer+carry_flag;
        end declare;

      -- check for overflow
      mask shr signed_to_uniint(-(deltab+1));
      if (mask and buffer)<>ui_0 then
        -- handle overflow
        succ exp;

        -- clear overflow
        buffer xor mask;
        end if;

    -- mantissa is short enough to fit significand
    else
      -- expand mantissa
      buffer shl signed_to_uniint(deltab);
      end if;

  -- exponent too high
  if exp>signed_to_uniint(exponent_max(prec)) then
    -- dump error

  -- exponent too small
  elsif exp<signed_to_uniint(exponent_min(prec)) then
    -- dump warning

    -- 0.0 will be stored
    return;

  -- exponent in range, assemble the result
  else
    -- handle implicit integer bit and include biased exponent
    mask:=ui_1 shl signed_to_uniint(significand_bits(prec)-1);
    exp+signed_to_uniint(exponent_bias(prec));
    if prec<>extended_prec
      -- clear implicit integer bit for single and double precision, shift [exp] accordingly
      then
        buffer xor mask;
        exp shl signed_to_uniint(significand_bits(prec)-1);

      -- set implicit integer bit for extended precision, shift [exp] accordingly
      else
        buffer or mask;
        exp shl signed_to_uniint(significand_bits(prec));
        end if;
    buffer or exp;

    -- set sign bit for negative value
    if unireal_sign(ur) then
      mask:=ui_1 shl signed_to_uniint(sign_index(prec));
      buffer or mask;
      end if;
    end if;

  -- copy [buffer] to [val]
  uniint_store(buffer,val,size);
  end unireal_store_float;



----------------------------------------------------------------------------------------------------
procedure unireal_sign =
-- T-[a] je záporné
----------------------------------------------------------------------------------------------------
begin
  result:=a.negative;
  end unireal_sign;



----------------------------------------------------------------------------------------------------
procedure unireal_abs_assign =
-- [a] := abs([a])
----------------------------------------------------------------------------------------------------
begin
  a.negative:=false;
  end unireal_abs_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_abs =
-- abs([a])
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  result.negative:=false;
  end unireal_abs;



----------------------------------------------------------------------------------------------------
procedure unireal_le =
-- A <= B
----------------------------------------------------------------------------------------------------
var
  tmp              : tunireal;

begin
  tmp:=A-B;
  result:=unireal_sign(tmp) or tmp=ur_0;
  end unireal_le;



----------------------------------------------------------------------------------------------------
procedure unireal_lt =
-- [a] < [b]
----------------------------------------------------------------------------------------------------
begin
  result:=unireal_sign(a-b);
  end unireal_lt;



----------------------------------------------------------------------------------------------------
procedure unireal_ge =
-- [a] >= [b]
----------------------------------------------------------------------------------------------------
begin
  result:=not unireal_lt(a,b);
  end unireal_ge;



----------------------------------------------------------------------------------------------------
procedure unireal_gt =
-- [a] > [b]
----------------------------------------------------------------------------------------------------
begin
  result:=not unireal_le(a,b);
  end unireal_gt;



----------------------------------------------------------------------------------------------------
procedure unireal_neg_assign =
-- [a] := -[a]
----------------------------------------------------------------------------------------------------
begin
  not a.negative;
  end unireal_neg_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_neg =
-- -[a]
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  not result.negative;
  end unireal_neg;



----------------------------------------------------------------------------------------------------
procedure unireal_normalize =
-- Zarovnat nejméně významný bit mantisy doprava. Pokud je mantisa = ui_0, vrátit ur_0.
-- Dále zajist, aby znaménkový bit byl 0.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure minimize_mantissa (
        m          : in out tuniint;
        exp        : in out tuniint) =
    -- Shift mantissa right until lsb is 1.
    ------------------------------------------------------------------------------------------------
    var
      e            : t_signed32;

    begin
      -- count left-side zeros
      #syntax asm;
        -- get addresses
        mov         esi,m
        lea         edi,e

        -- keep shift count at top of stack
        xor         ecx,ecx
        push        ecx

        -- while(![a]&1) [exp]++;
        mov         eax,32

      @next_dw:
        xor         edx,edx
        or          edx,[esi+ecx*4]
        jnz         @per_bit
        add         [esp],eax
        inc         ecx
        jmp         @next_dw

      @per_bit:
        mov         eax,<t_unsigned32>1

      @next_bit:
        mov         ebx,edx
        and         ebx,eax
        jnz         @end
        mov         ebx,[esp]
        inc         ebx
        mov         [esp],ebx
        shl         eax,1
        jmp         @next_bit

        -- store shift count to [e]
      @end:
        pop         ecx
        mov         [edi],ecx
      #end asm;

      -- shr to get lsb=1
      m shr signed_to_uniint(e);
      exp+signed_to_uniint(e);
      end minimize_mantissa;  

begin
  if ur.mantissa=ui_0
    then 
      -- výsledek je 0
      ur:=ur_0;

    else
      -- shr [ur.mantissa] until lsb([ur.mantissa])=1
      minimize_mantissa(ur.mantissa,ur.exponent);

      -- zn. bit je 1 => zkrátit mantisu o 1bit se zaokrouhlením nahoru (ořezaný bit je 1)
      if uniint_sign(ur.mantissa) then
        ur.mantissa shr ui_1;
        if ur.mantissa=ui_last
          then
            ur.mantissa:=ui_1;
            ur.exponent+unsigned_to_uniint(uniint_precision);
          else
            succ ur.mantissa;
            succ ur.exponent;

            -- shr [ur.mantissa] until lsb([ur.mantissa])=1
            minimize_mantissa(ur.mantissa,ur.exponent);
            end if;
        end if;
      end if;
  end unireal_normalize;



----------------------------------------------------------------------------------------------------
procedure unireal_add =
-- [a] + [b]
----------------------------------------------------------------------------------------------------
const
  -- bit mask (signed) uniint MSb
  msb_mask         : tuniint = [for uniint_precision div 8 use $40, for others use 0];

var
  mant2            : tuniint;                    -- mantisa 2. operandu (1. op. je výsledek)
  deltaexp         : tuniint;                    -- rozdíl většího a menšího exponentu
  neg2             : t_logical;                  -- sign of 2nd operand

begin
  -- [a] + [b] = [a.mantissa]*2^[a.exponent] + [b.mantissa]*2^[b.exponent]
  --           = 2^[a.exponent] * ([a.mantissa] + [b.mantissa]*2^([b.exponent]-[a.exponent]))

  -- 1. argument buď ten s větším exponentem
  if a.exponent>b.exponent
    then
      result.mantissa:=a.mantissa;
      mant2:=b.mantissa;
      result.exponent:=a.exponent;
      deltaexp:=a.exponent-b.exponent;
      result.negative:=a.negative;
      neg2:=b.negative;
  
    else
      result.mantissa:=b.mantissa;
      mant2:=a.mantissa;
      result.exponent:=b.exponent;
      deltaexp:=b.exponent-a.exponent;
      result.negative:=b.negative;
      neg2:=a.negative;
    end if;

  -- shift 1st operand's mantissa left without loss of precision
  while (msb_mask and result.mantissa)=ui_0 and deltaexp>ui_0 loop
    result.mantissa shl ui_1;
    pred deltaexp;
    pred result.exponent;
    end loop;

  -- shift 2nd operand's mantissa right (if needed)
  mant2 shr deltaexp;

  -- add mantissas  (method actually depends on signs)
  if result.negative xor neg2
    -- subtraction
    then
      if result.negative
        -- [mant2] - [result.mantissa]
        then result.mantissa:=mant2-result.mantissa;

        -- [result.mantissa] - [mant2]
        else result.mantissa-mant2;
        end if;

      -- sign of result
      if uniint_sign(result.mantissa)
        then
          -result.mantissa;
          result.negative:=true;
        else
          result.negative:=false;
          end if;

    -- addition
    else
      result.mantissa+mant2;
      end if;

  -- normalize [result]
  unireal_normalize(result);
  end unireal_add;

 

----------------------------------------------------------------------------------------------------
procedure unireal_add_assign =
-- [a] := [a] + [b]
----------------------------------------------------------------------------------------------------
begin
  a:=unireal_add(a,b);
  end unireal_add_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_sub_assign =
-- [a] := [a] - [b]
----------------------------------------------------------------------------------------------------
begin
  unireal_add_assign(a,-b);
  end unireal_sub_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_sub =
-- [a] - [b]
----------------------------------------------------------------------------------------------------
begin
  -- [a]-[b] = [a]+(-[b]) = -(-[a]+[b])

  result:=-b;
  unireal_add_assign(result,a);
  end unireal_sub;



----------------------------------------------------------------------------------------------------
procedure unireal_mul_assign =
-- [a] := [a] * [b]
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure uniint_mul_assign_double (
        _a         : in out tuniint;
        _b         : in tuniint;
        _exp       : out tuniint) =
    -- [_a] := MSbits([_a] * [_b]);
    -- Works in double precision.
    -- The result is rounded to fit [tuniint], returns exponent in [_exp].
    ------------------------------------------------------------------------------------------------
    const
      uniint_sign_bit  = uniint_precision-1;     -- bit index of uniint sign bit
      uniint_dwords    = uniint_precision div 32;-- uniint precision in dwords
      uniint_bytes     = uniint_dwords*4;        -- uniint precision in bytes
      uniint_MSdw      = uniint_dwords-1;        -- dword index of the uniint MSdword
      uniint_MSdw_index= uniint_MSdw*4;          -- byte index of the uniint MSdword
      uniint_2x_MSdw   = uniint_dwords*2-1;      -- dword index of the uniint MSdword

    var
      sum2x        : array 0..uniint_2x_MSdw of t_unsigned32 := [for others use 0];

    begin
      #syntax asm;
        -- initialisation
        lea        edi,sum2x                     -- EDI <- addr([sum2x])

        -- iteration over [_a]
        xor        ecx,ecx                       -- k=0,..,uniint_MSdw

      @next_a:
        mov        esi,_a                        -- ESI <- addr([_a])
        mov        ebx,[esi+ecx*4]               -- EBX <- [_a]_k
        push       ecx                           -- save k

        -- iteration over [_b]
        xor        ecx,ecx                       -- l=0,..,uniint_MSdw
        mov        esi,_b                        -- ESI <- addr([_b])
      @next_b:

        -- destination index pre-preparation
        pop        edx                           -- EDX <- k
        push       edx                           -- save k
        push       ecx                           -- save l

        -- dwords multiplication
        mov        eax,[esi+ecx*4]               -- EAX <- [_b]_l
        add        ecx,edx                       -- ECX <- ECX+EDX = l+k
        xor        edx,edx                       -- EDX <- 0
        mul        ebx                           -- EDX:EAX <- EAX*EBX = [_b]_l*[_a]_k
        add        [edi+ecx*4],eax               -- [sum2x]_(l+k) += LSDW([_b]_l*[_a]_k)
        inc        ecx                           -- ECX <- ECX+1 = l+k+1
        adc        [edi+ecx*4],edx               -- [sum2x]_(l+k+1) += MSdw([_b]_l*[_a]_k)+CF

        -- CF additions (note that [EDI+ECX*4] address can never exceed [sum2x] bounds)
      @add_cf:
        jnc        @dw_multiplied                -- CF=0 => dw multiplication done
        inc        ecx                           -- ECX++
        mov        eax,[edi+ecx*4]               -- [sum2x]_(l+k+...) += CF
        adc        eax,0
        mov        [edi+ecx*4],eax
        jmp        @add_cf                       -- goto @add_cf
      @dw_multiplied:

        -- next l
        pop        ecx                           -- ECX <- l
        inc        ecx                           -- l++
        cmp        ecx,uniint_dwords             -- k-[uniint_dwords]
        jne        @next_b                       -- if(k!=[uniint_dwords]) goto @next_b;

        -- next k
        pop        ecx                           -- ECX <- k
        inc        ecx                           -- k++
        cmp        ecx,uniint_dwords             -- k-[uniint_dwords]
        jne        @next_a                       -- if(k!=[uniint_dwords]) goto @next_a;

        -- count dw shifts and bit shifts
        lea        esi,sum2x                     -- ESI <- addr([sum2x])
        mov        ecx,uniint_dwords             -- ECX will accumulate dw-shift count

        -- find the most significient dw of result
      @load_dw:
        dec        ecx                           -- ECX--
        mov        eax,[esi+ecx*4+uniint_bytes]  -- EAX <- dw from MS1/2 of [sum2x], order top-bottom
        xor        ebx,ebx                       -- EBX <- 0
        or         ebx,eax                       -- test for EAX<>0 (=> a significient bit found)
        jnz        @shifts                       -- EAX contains the MS dw of [sum2x]

        -- no significient bit in tested dw
        or         eax,ecx                       -- test if ECX==0
        jz         @result                       -- if all MS1/2 dws are 0 then goto @result
        jmp        @load_dw                      -- next dw

        -- find the most significient bit in the MS dw
      @shifts:
        clc                                      -- CF <- 0
        xor        ebx,ebx                       -- EBX will accumulate trading zeros count

      @next_shl:
        shl        eax,1                         -- EAX<<=1
        inc        ebx                           -- EBX++
        jnc        @next_shl                     -- if(!CF) goto @next_shl;

        -- the MS bit of the MS dw is its top-most bit
        cmp        ebx,1                         -- test if EBX==1
        jne        @count_bits                   -- if(EBX!=1) goto @count_bits;
        xor        ebx,ebx                       -- else EBX <- 0;
        inc        ecx                           --      ECX++
        jmp        @store_exponent               -- goto @exponent

        -- count position of MS bit
      @count_bits:
        neg        ebx                           -- EBX <- -EBX
        add        ebx,33                        -- EBX+=32+1, EBX contains bit-shift count

        -- store the exponent (32*ECX+EBX)
      @store_exponent:
        mov        eax,ecx                       -- EAX <- ECX
        shl        eax,<t_unsigned8>5            -- EAX*=32
        add        eax,ebx                       -- EAX+=EBX
        mov        edi,_exp                      -- EDI <- addr([_exp])
        mov        [edi],eax                     -- [_exp] <- EAX

        -- shift right the result to get the MS bit to LS1/2 of the result
        lea        edi,sum2x                     -- EDI <- addr([sum2x])
        xor        eax,eax                       -- EAX <- 0
        or         eax,ecx                       -- test if ECX==0  (also note that EAX <- ECX)
        jz         @per_bit_shifts               -- if(!ECX) goto @per_bit_shifts;

        -- shift per dw iteration
        mov        esi,edi                       -- ESI <- addr([sum2x])
        shl        eax,<t_unsigned8>2            -- EAX*=4
        add        esi,eax                       -- ESI+=EAX

        add        eax,uniint_bytes              -- EAX contains break index for the loop
        xor        ecx,ecx                       -- ECX <- 0

      @next_dw_mov:
        mov        edx,[esi+ecx]                 -- EDX <- [ESI+ECX]
        mov        [edi+ecx],edx                 -- dw shift
        add        ecx,4                         -- ECX+=4
        cmp        eax,ecx                       -- test if ECX reached the break index
        jne        @next_dw_mov                  -- if(EAX!=ECX) goto @next_dw_mov

        -- shift per 1 bit iteration
      @per_bit_shifts:
        xor        eax,eax                       -- EAX <- 0
        or         eax,ebx                       -- test if EBX==0
        jz         @result                       -- if(EBX==0) goto @result;

        -- shift [sum2x] 1 bit right
        mov        ecx,uniint_dwords             -- ECX <- [uniint_dwords]
        clc                                      -- CF <- 0

      @next_dw_shr:
        mov        eax,[edi+ecx*4]               -- EAX <- [EDI+ECX*4]
        rcr        eax,1                         -- CF,EAX>>1
        mov        [edi+ecx*4],eax               -- [EDI+ECX*4] <- EAX
        dec        ecx                           -- ECX--
        jns        @next_dw_shr                  -- if(ECX>=0) goto @next_dw_shr;

        dec        ebx                           -- EBX--
        jmp        @per_bit_shifts               -- goto @per_bit_shifts

      @result:
        -- if sign bit is set then do one more shr
        lea        edi,sum2x                     -- EDI <- addr([sum2x])
        mov        eax,[edi+uniint_MSdw_index]   -- EAX <- MSdw([sum2x])
        and        eax,$80000000                 -- test if MSb([sum2x]) is set
        jz         @end                          -- if(!MSb([sum2x])) goto @end;

        -- shift result 1 bit right
        mov        ebx,1                         -- EBX <- 1
        xor        edx,edx                       -- EDX <- 0
        mov        ecx,uniint_MSdw               -- ECX <- [uniint_MSdw]
        clc                                      -- CF <- 0

      @next_dw_shr_:
        mov        eax,[edi+ecx*4]               -- EAX <- [EDI+ECX*4]
        rcr        eax,1                         -- CF>>EAX>>1
        mov        [edi+ecx*4],eax               -- [EDI+ECX*4] <- EAX
        dec        ecx                           -- ECX--
        jns        @next_dw_shr_                 -- if(ECX>=0) goto @next_dw_shr_;

        -- round result
        pushf                                    -- push flags to the stack
        xor        ecx,ecx                       -- ECX <- 0
        mov        eax,uniint_dwords             -- EAX <- [uniint_dwords]

      @next_dw_add_:
        popf                                     -- pop flags from stack
        jnc        @inc_exponent                 -- if(!CF) goto @inc_exponent
        mov        edx,[edi+ecx*4]               -- EDX <- [EDI+ECX*4]
        adc        edx,0                         -- EDX+=CF
        mov        [edi+ecx*4],edx               -- [EDI+ECX*4] <- EDX
        pushf                                    -- push flags to stack
        inc        ecx                           -- ECX++
        cmp        eax,ecx                       -- test if ECX reached the break
        jne        @next_dw_add_                 -- if(EAX!=ECX) goto @next_dw_add;

        popf                                     -- pop flags from stack
        jns        @inc_exponent                 -- if(!SF) goto @inc_exponent;

        -- SF => result is 1*2^(exponent+1+[uniint_precision]-1)
        xor        edx,edx                       -- EDX <- 0
        mov        [edi+uniint_MSdw_index],edx   -- store MSdw([sum2x]) == 0
        inc        edx                           -- EDX <- 1
        mov        [edi],edx                     -- store LSdw([sum2x]) == 1
        add        ebx,uniint_sign_bit           -- EBX+=[uniint_precision]-1

        -- increment exponent
      @inc_exponent:
        mov        edi,_exp                      -- EDI <- addr([_exp])
        mov        edx,[edi]                     -- EDX <- [_exp]
        add        edx,ebx                       -- EDX+=EBX
        mov        [edi],edx                     -- [e] <- EDX

        -- copy LS1/2 of [sum2x] to [_a]
      @end:
        lea        esi,sum2x                     -- ESI <- addr([sum2x])
        mov        edi,_a                        -- EDI <- addr([_a])
        mov        ecx,uniint_dwords             -- ECX <- [uniint_dwords]

      @l:
        dec        ecx                           -- ECX--
        mov        edx,[esi+ecx*4]               -- EDX <- [ESI+ECX*4]
        mov        [edi+ecx*4],edx               -- copy dw
        jnz        @l                            -- if(ECX) goto @l;
      #end asm;
      end uniint_mul_assign_double;


var
  delta_exp        : tuniint;                    -- exponent difference

begin
  -- [a] * [b] = [a.mantissa]*2^[a.exponent] * [b.mantissa]*2^[b.exponent]
  --           = [a.mantissa]*[b.mantissa] * 2^([a.exponent]+[b.exponent])

  -- znaménko výsledku
  a.negative xor b.negative;

  -- mantisa výsledku
  uniint_mul_assign_double(a.mantissa,b.mantissa,delta_exp);

  -- exponent výsledku
  a.exponent+(b.exponent+delta_exp);

  -- normalizovat výsledek
  unireal_normalize(a);
  end unireal_mul_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_mul =
-- [a] * [b]
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  unireal_mul_assign(result,b);
  end unireal_mul;



----------------------------------------------------------------------------------------------------
procedure unireal_div_assign =
-- [a] := [a] / [b] pomocí Euklidova algoritmu
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure euklides_assign (
        _a             : in out tuniint;
        b              : in tuniint;
        exp            : in out tuniint) =
    ------------------------------------------------------------------------------------------------
    const
      dw_prec      = uniint_precision div 32;
      dw_prec_min_1= dw_prec-1;
      MSDW_index   = 4*dw_prec_min_1;

    var
      a            : tuniint;
      e            : t_signed32;
      bitpipe      : tuniint;

    begin
      -- copy numerator
      a:=_a;

      -- clear result
      _a:=ui_0;

      #syntax asm;
        lea         edi,a
        mov         esi,b

        -- if(![a]) return;
        mov         ecx,dw_prec_min_1
        xor         edx,edx

      @init_test_loop:
        or          edx,[edi+ecx*4]
        jnz         @fill_bitpipe
        dec         ecx
        jns         @init_test_loop

        -- shr [a] through [bitpipe] until [a]<2*[b]
      @fill_bitpipe:

        -- keep [bitpipe] length on the stack
        xor         ecx,ecx
        push        ecx

        -- [b]*=2
        mov         ebx,dw_prec_min_1
        xor         ah,ah

      @fill_bitpipe_cond_shl:
        mov         edx,[esi+ecx*4]
        sahf
        rcl         edx,1
        lahf
        mov         [esi+ecx*4],edx
        inc         ecx
        cmp         ecx,ebx
        jng         @fill_bitpipe_cond_shl

        -- if([a]<2*[b]) goto @main_loop_init;
      @fill_bitpipe_test:
        mov         ecx,dw_prec_min_1
  
      @fill_bitpipe_test_loop:
        mov         eax,[edi+ecx*4]
        mov         ebx,[esi+ecx*4]
        cmp         eax,ebx
        jb          @main_loop_init
        ja          @fill_bitpipe_body
        dec         ecx
        jns         @fill_bitpipe_test_loop

        -- [a]>>1
      @fill_bitpipe_body:
        mov         ecx,dw_prec_min_1
        clc

      @fill_bitpipe_body_shr_loop:
        mov         edx,[edi+ecx*4]
        rcr         edx,1
        mov         [edi+ecx*4],edx
        dec         ecx
        jns         @fill_bitpipe_body_shr_loop

        -- push CF to bitpipe
        lahf
        xor         ecx,ecx
        lea         edi,bitpipe
        mov         ebx,dw_prec_min_1

      @fill_bitpipe_body_push_loop:
        mov         edx,[edi+ecx*4]
        sahf
        rcl         edx,1
        lahf
        mov         [edi+ecx*4],edx
        inc         ecx
        cmp         ecx,ebx
        jng         @fill_bitpipe_body_push_loop

        -- increment [bitpipe] length
        mov         ecx,[esp]
        inc         ecx
        mov         [esp],ecx

        -- next bit
        lea         edi,a
        jmp         @fill_bitpipe_test

        -- [b]/=2
      @main_loop_init:
        mov         ecx,dw_prec_min_1
        clc
  
      @main_loop_init_loop:
        mov         edx,[esi+ecx*4]
        rcr         edx,1
        mov         [esi+ecx*4],edx
        dec         ecx
        jns         @main_loop_init_loop

        -- if([a]>=[b]) goto @main_loop_sub;
      @main_loop_sub_test:
        lea         edi,a
        mov         esi,b
        mov         ecx,dw_prec_min_1

      @main_loop_sub_test_loop:
        mov         eax,[edi+ecx*4]
        mov         ebx,[esi+ecx*4]
        cmp         eax,ebx
        jb          @main_loop_test
        ja          @main_loop_sub
        dec         ecx
        jns         @main_loop_sub_test_loop

        -- [_a]|=1
      @main_loop_sub:
        mov         edi,_a
        mov         eax,[edi]
        or          eax,1
        mov         [edi],eax

        -- [a]-=[b]
        lea         edi,a
        mov         ebx,dw_prec_min_1
        xor         ecx,ecx
        xor         ah,ah

      @main_loop_sub_loop:
        mov         edx,[esi+ecx*4]
        sahf
        sbb         [edi+ecx*4],edx
        lahf
        inc         ecx
        cmp         ecx,ebx
        jng         @main_loop_sub_loop

        -- if(full([_a]) || empty([bitpipe]) && ![a]) goto @free;
      @main_loop_test:
        mov         esi,_a
        mov         ebx,dw_prec_min_1
        mov         eax,<t_unsigned32>$80000000
        and         eax,[esi+MSDW_index]
        jnz         @free

        mov         ecx,[esp]
        cmp         ecx,0
        jg          @main_loop_bitpipe_length_dec

        -- save flags for further optimization
        clc
        lahf

        xor         ecx,ecx
        xor         edx,edx

      @main_loop_test_loop:
        or          edx,[edi+ecx*4]
        jnz         @main_loop_bitpipe_length_dec
        inc         ecx
        cmp         ecx,ebx
        jng         @main_loop_test_loop

        -- goto @free
        jmp         @free

        -- decrement [bitpipe] length
      @main_loop_bitpipe_length_dec:
        mov         ecx,[esp]
        dec         ecx
        mov         [esp],ecx

        -- if(empty([bitpipe])) skip [bitpipe] shifting;
        sahf
        jng         @main_loop_shl_shr_bitpipe_skip

        -- [a]<<1 through [bitpipe]
      @main_loop_shl:

        -- [bitpipe]>>1
        lea         esi,bitpipe
        mov         ecx,ebx
        clc

      @main_loop_shl_shr_bitpipe:
        mov         edx,[esi+ecx*4]
        rcr         edx,1
        mov         [esi+ecx*4],edx
        dec         ecx
        jns         @main_loop_shl_shr_bitpipe

        -- [a]<<1 through CF
        lahf

      @main_loop_shl_shr_bitpipe_skip:
        xor         ecx,ecx
  
      @main_loop_shl_loop:
        mov         edx,[edi+ecx*4]
        sahf
        rcl         edx,1
        lahf
        mov         [edi+ecx*4],edx
        inc         ecx
        cmp         ecx,ebx
        jng         @main_loop_shl_loop

        -- [_a]<<1
        mov         edi,_a
        xor         ecx,ecx
        xor         ah,ah

      @main_loop_shl_result:
        mov         edx,[edi+ecx*4]
        sahf
        rcl         edx,1
        lahf
        mov         [edi+ecx*4],edx
        inc         ecx
        cmp         ecx,ebx
        jng         @main_loop_shl_result

        -- goto @main_loop_sub_test
        jmp         @main_loop_sub_test

        -- store [bitpipe] length
      @free:
        pop         ecx
        lea         edi,e
        mov         [edi],ecx
    
      @end:
      #end asm;

      -- adjust exponent by [bitpipe] length
      exp+signed_to_uniint(e);
      end euklides_assign;

begin
  -- [a]/[b] = [a.mantissa]*2^[a.exponent] / [b.mantissa]*2^[b.exponent]
  --         = ([a.mantissa]/[b.mantissa])*2^[a.exponent-b.exponent]

  -- znaménko výsledku
  a.negative xor b.negative;

  -- exponent výsledku
  a.exponent-b.exponent;

  -- Euklidův algoritmus pro výpočet podílu mantis [a] a [b]
  euklides_assign(a.mantissa,b.mantissa,a.exponent);

  -- normalizovat [a]
  unireal_normalize(a);
  end unireal_div_assign;



----------------------------------------------------------------------------------------------------
procedure unireal_div =
-- [a] / [b]
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  unireal_div_assign(result,b);
  end unireal_div;



----------------------------------------------------------------------------------------------------
procedure logical_to_unilogical =
-- Převod A na UNILOGICAL.
----------------------------------------------------------------------------------------------------
begin
  result:=tunilogical(a);
  end logical_to_unilogical;



----------------------------------------------------------------------------------------------------
procedure unilogical_to_logical =
-- Převod A na LOGICAL.
----------------------------------------------------------------------------------------------------
begin
  result:=t_logical(a);
  end unilogical_to_logical;



----------------------------------------------------------------------------------------------------
procedure unilogical_to_uniint =
-- Převod A na UNILOGICAL.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,A
    mov        eax,[eax]
    mov        [edi],eax

    -- a vycistime vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    mov        eax,0
    rep stosd
    #end asm;
  end unilogical_to_uniint;


{  
----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata =
-- Převod I na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

    -- a vyfillzujeme vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    xor        eax,eax
  @fill:
    stosd
    loop       @fill
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_unidata;



----------------------------------------------------------------------------------------------------
procedure signed_to_unidata =
-- Převod I na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

    -- a vyssi dwordy vyplníme sign bitem
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    shr        eax,<t_unsigned8>31
  @fill:
    stosd
    loop       @fill
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end signed_to_unidata;



----------------------------------------------------------------------------------------------------
procedure unidata_to_unsigned =
-- Převod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UD
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unidata_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_to_uniint =
-- Převod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- inicializace
    mov        edi,result
    mov        esi,UD
    mov        ecx,uniint_dwords
    cld

    -- kopirujeme
  @next:
    movsd
    loop       @next
    #end asm;
  end unidata_to_uniint;


  
----------------------------------------------------------------------------------------------------
procedure unidata_align =
-- Zarovná A směrem nahoru na hranici dělitelnou ALIGN.
----------------------------------------------------------------------------------------------------
begin
  a:=((a+align-ud_1) div align)*align;
  end unidata_align;



----------------------------------------------------------------------------------------------------
procedure unidata_lt =
-- A < B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandů a výsledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A < B
  @mensi:
    mov        ebx,<t_unsigned32>1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end unidata_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_gt =
-- A > B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- addresses of operands and result
    xor            ebx,ebx
    mov            esi,A
    mov            edi,B
    add            esi,uniint_lastdword
    add            edi,uniint_lastdword

    -- compare sign of A and B
    mov            eax,[esi]
    bt             eax,<t_unsigned8>31
    jnb            @ap

    -- A is negative
@an:
    mov            eax,[edi]
    bt             eax,<t_unsigned8>31
    jnb            @finish
    jmp            @compare

    -- A is positive
@ap:
    mov            eax,[edi]
    bt             eax,<t_unsigned8>31
    jnb            @compare
    jmp            @greater

    -- A and B has the same signs, compare them
@compare:
    mov            ecx,uniint_dwords

    -- compare from high dword down to low dword

    -- A > B
@greater:
    mov            ebx,1

    -- end
@finish:
    mov            <t_unsigned32>result,ebx
    #end asm;
  end unidata_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_mul =
-- A * B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_mul;



----------------------------------------------------------------------------------------------------
procedure unidata_div =
-- A div B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_div;



----------------------------------------------------------------------------------------------------
procedure unidata_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_add;



----------------------------------------------------------------------------------------------------
procedure unidata_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
begin
  a:=a+b;
  end unidata_add_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_sub =
-- A - B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_sub;



----------------------------------------------------------------------------------------------------
procedure uniprg_to_unsigned =
-- Převod UP na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end uniprg_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniprg =
-- Převod T_UNSIGNED na TUNIPRG
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unsigned_to_uniprg;
}


----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata_size =
-- Převod I na TUNIDATA_SIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=i;
  end unsigned_to_unidata_size;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata_addr =
-- Převod I na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=i;
  end unsigned_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure signed_to_unidata_addr =
-- Převod I na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(i:unchecked);
  end signed_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_size =
-- Velmi neobvyklá operace: konverze adresy na velikost
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud);
  end unidata_addr_to_size;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_addr =
-- Velmi neobvyklá operace: konverze velikosti na adresu.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud);
  end unidata_size_to_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_unsigned =
-- Převod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_size_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_to_unsigned =
-- Převod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_bitsize_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_unsigned =
-- Převod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_addr_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_signed =
-- Převod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_signed(UD:unchecked);
  end unidata_addr_to_signed;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_lt = 
-- A < B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)<t_unsigned(B);
  end unidata_bitsize_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_size_lt = 
-- A < B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)<t_unsigned(B);
  end unidata_size_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_size_ge = 
-- A >= B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>=t_unsigned(B);
  end unidata_size_ge;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_ge = 
-- A >= B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>=t_unsigned(B);
  end unidata_bitsize_ge;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_size =
-- Převod UI na TUNIDATA_SIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_size;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_bitsize =
-- Převod UI na TUNIDATA_BITSIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_bitsize;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_addr =
-- Převod UI na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_uniint =
-- Převod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_size_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_to_uniint =
-- Převod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_bitsize_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_uniint =
-- Převod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_addr_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_bits_to_bytes =
-- Převod velikosti v bitech na velikost v bytech se zaokrouhlením nahoru.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=(t_unsigned(ud)+t_unsigned(udb_bits_per_byte)-1) div t_unsigned(udb_bits_per_byte);
  end unidata_bits_to_bytes;



----------------------------------------------------------------------------------------------------
procedure unidata_bytes_to_bits =
-- Převod velikosti v bytech na velikost v bitech.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud)*t_unsigned(udb_bits_per_byte);
  end unidata_bytes_to_bits;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(a)+t_unsigned(b);
  end unidata_addr_add;



----------------------------------------------------------------------------------------------------
procedure unidata_size_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(a)+t_unsigned(b);
  end unidata_size_add;



----------------------------------------------------------------------------------------------------
procedure unidata_size_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(a)+t_unsigned(b);
  end unidata_size_add_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_size_sub =
-- A - B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A)-t_unsigned(B);
  end unidata_size_sub;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mul =
-- A * B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A)*t_unsigned(B);
  end unidata_size_mul;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mul_assign =
-- A := A * B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(A)*t_unsigned(B);
  end unidata_size_mul_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_size_div =
-- A div B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A) div t_unsigned(B);
  end unidata_size_div;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mod =
-- A mod B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A) mod t_unsigned(B);
  end unidata_size_mod;



----------------------------------------------------------------------------------------------------
procedure unidata_size_gt =
-- A > B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>t_unsigned(B);
  end unidata_size_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_gt =
-- A > B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>t_unsigned(B);
  end unidata_addr_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_align_by_size =
-- Zarovná adresu A směrem nahoru na hranici dělitelnou velikostí ALIGN.
----------------------------------------------------------------------------------------------------
var
  B                : tunidata_addr;

begin
  B:=unidata_size_to_addr(align);
  A+B; 
  A-1;
  A div B;
  A*B;
  --%%TODO(OVERLOAD) Tohle ohlásí: Typ výrazu není jednoznačně určen
  --A:=((A+B-1) div B)*B;
  end unidata_addr_align_by_size;
                        


----------------------------------------------------------------------------------------------------
procedure unidata_size_align_to_nearest_power2 =
-- Zarovná dodanou velikost na nejbližší vyšší mocninu dvou. Jestliže je [A] samo o sobě mocninou
-- dvou nebo větší než 2^(A:bits-1), hodnotu nezmění.
----------------------------------------------------------------------------------------------------
with
  advanced.low_level.bit_operations;

var
  low              : t_bit_index;
  high             : t_bit_index;

begin
  -- zjistit první a poslední nastavený bit
  low:=bit_search_first_one(A);
  high:=bit_search_last_one(A);

  -- velikost je nulová
  if low=t_bit_index:first
  -- jestliže to je mocnina dvou
  or else low=high
  -- jestliže je to vyšší než nejvyšší mocnina dvou
  or else high=A:bits-1
    -- potom vrátit beze změn
    then result:=A;
    -- jinak zaokrouhlit na nejbližší vyšší mocninu dvou
    else bit_set(result,high+1);
    end if;
  end unidata_size_align_to_nearest_power2;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_add_assign =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(A)+t_unsigned(B);
  end unidata_addr_add_assign;



----------------------------------------------------------------------------------------------------
procedure unicode_addr_to_unsigned =
-- Převod UP na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(uc);
  end unicode_addr_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_unicode_addr =
-- Převod T_UNSIGNED na TUNICODE_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=x;
  end unsigned_to_unicode_addr;


----------------------------------------------------------------------------------------------------
procedure uniint_to_unicode_addr =
-- Převod UI na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unicode_addr;

end cc_unitype;
