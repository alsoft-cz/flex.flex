----------------------------------------------------------------------------------------------------
module private cc_unitype =
-- P©eklada‡ Flexu.
-- Definice lexi ln¡ch symbol–.
----------------------------------------------------------------------------------------------------
-- Ondra : 26.04.2000 : Vytvo©il
----------------------------------------------------------------------------------------------------



----- Hodnoty element rn¡ch konstant ---------------------------------------------------------------
const
  -- NIL
  ui_nil           = nil;
  uc_nil           = nil;
  ur_nil           = nil;
  ul_nil           = nil;

  -- rozsah podporovan˜ch ‡¡seln˜ch soustav
  ui_radix_first   = [ 2,for others use 0];
  ui_radix_last    = [36,for others use 0];

  -- z klad d¨estn ctkov‚ soustavy
  ui_radix_hex     = [16,for others use 0];

  -- p©esnost univerz ln¡ho cel‚ho ‡¡sla
  ui_precision     = [uniint_precision,for others use 0];

  -- mal  ‡¡sla
  ui_minus_1       = [for others use $FF];
  ui_minus_2       = [$FE,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF];
  ui_0             = [  0,for others use 0];
  ui_1             = [  1,for others use 0];
  ui_2             = [  2,for others use 0];
  ui_3             = [  3,for others use 0];
  ui_4             = [  4,for others use 0];
  ui_5             = [  5,for others use 0];
  ui_6             = [  6,for others use 0];
  ui_7             = [  7,for others use 0];
  ui_8             = [  8,for others use 0];
  ui_9             = [  9,for others use 0];
  ui_100           = [100,for others use 0];

  -- velk  ‡¡sla
  ui_0_FFFF        = [$FF,$FF,$FF,$FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_1_0           = [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_1_1           = [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  ui_2_0           = [0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

  -- rozsah univerz ln¡ho znaku jako univerz ln¡ integer
  ui_unichar_first = [for others use 0];
  ui_unichar_last  = [for tuniint:first..tuniint:first+tunichar:size-1 use $FF,for others use 0];

  -- mal  re ln  ‡¡sla
  ur_0             = [for sign use false, for mantissa use ui_0, for exponent use ui_0];

  -- v˜znamn‚ adresy
  uda_0            = tunidata_addr(0);

  -- v˜znamn‚ velikosti v bytech
  uds_0            = tunidata_size(0);
  uds_1            = tunidata_size(1);
  uds_2            = tunidata_size(2);
  uds_4            = tunidata_size(4);

  -- v˜znamn‚ velikosti v bitech
  udb_bits_per_byte= tunidata_bitsize(8);--[ 8,for others use 0];
  udb_1            = tunidata_bitsize(1);
  udb_8            = tunidata_bitsize(8);
  udb_16           = tunidata_bitsize(16);
  udb_32           = tunidata_bitsize(32);
  udb_64           = tunidata_bitsize(64);
  udb_80           = tunidata_bitsize(80);

  -- logick‚ hodnoty
  ul_false         = tunilogical:false;
  ul_true          = tunilogical:true;



----------------------------------------------------------------------------------------------------
procedure signed_to_uniint =
-- P©evod I na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    stosd
    mov        [edi],eax

    -- a doplnime znamenkem do vyssich bytu
    sar        eax,<t_unsigned8>31
  #if uniint_dwords_1=4 then;
    stosd
    stosd
    stosd
    stosd
  #else;
    #error 'neimplementovano';
  #end if;

{ Tohle je zbyte‡nˆ slo‘it‚:
    -- a doplnime znamenkem do vyssich bytu
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    bt         eax,<t_unsigned8>31
    xor        eax,eax
    jnc        @fill
    not        ebx
  @fill:
    stosd
    loop       @fill
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end signed_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniint =
-- P©evod I na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

{ Tohle za n s ji‘ za©¡dil kompil tor:
    -- a vyfillzujeme vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    xor        eax,eax
  @fill:
    stosd
    loop       @fill
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniint_power2 =
-- P©evod 2^N na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);

begin
#if N:size=4 then;
  #syntax asm;
{ Tohle za n s u‘ za©¡dil kompil tor
    -- vynulujeme vysledek
    mov        edi,result
    xor        eax,eax
    cld
    mov        ecx,uniint_dwords
  @fillz:
    stosd
    loop       @fillz  
}
    -- adresa operandu a po‘adovan‚ho bitu
    mov        edi,result
    mov        eax,N

    -- nastavit po‘adovan˜ bit
    bts        [edi],eax

{ Tohle je blbˆ:
    -- nastavime odpovidajici bit
    mov        ecx,N
    xor        ebx,ebx 
    shl        cx,<t_unsigned8>3
    mov        bl,ch
    shl        ebx,<t_unsigned8>2
    shr        cl,<t_unsigned8>3
    and        ecx,<t_unsigned32>31
    bts        eax,ecx
    mov        [edi+ebx],eax
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_uniint_power2;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unsigned =
-- P©evod UI na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
 -- mov        edi,result
    mov        eax,[esi]
 -- mov        [edi],eax
    mov        result,eax
    #end asm;
#else;
  neimplementovano
  #end if;
  end uniint_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure uniint_to_signed =
-- P©evod UI na T_SIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
 -- mov        edi,result
    mov        eax,[esi]
 -- mov        [edi],eax
    mov        result,eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_to_signed;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unichar =
-- P©evod UI na TUNICHAR.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
  end uniint_to_unichar;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unireal =
-- P©evod UI na UR.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end uniint_to_unireal;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unilogical =
-- P©evod UI na TUNILOGICAL.
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UI
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
  end uniint_to_unilogical;


{
----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata =
-- P©evod UI na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- inicializace
    mov        edi,result
    mov        esi,UI
    mov        ecx,uniint_dwords
    cld

    -- kopirujeme
  @next:
    movsd
    loop       @next
    #end asm;
  end uniint_to_unidata;
}


----------------------------------------------------------------------------------------------------
procedure unilogical_xor_assign =
-- A := A xor B
----------------------------------------------------------------------------------------------------

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B
    mov        eax,[esi]
    xor        eax,[edi]
    mov        [esi],eax
    #end asm;
  end unilogical_xor_assign;



----------------------------------------------------------------------------------------------------
procedure unilogical_not =
-- not A
----------------------------------------------------------------------------------------------------
begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,result
    mov        eax,[esi]
    not        eax
    mov        [esi],eax
    #end asm;
  end unilogical_not;

  

----------------------------------------------------------------------------------------------------
procedure unichar_to_lexchar =
-- P©evod UC na LEXCHAR.
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end unichar_to_lexchar;



----------------------------------------------------------------------------------------------------
procedure uniint_load =
-- UI := VAL
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);

begin
#if size:size=4 then;
  #syntax asm;
    mov        edi,ui
    mov        esi,val
    mov        ecx,size
    cld
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jae        @load_larger

    -- namno‘it znam‚nko
    cmp        sign,1
    jne        @plus
    mov        al,<t_unsigned8>[esi+ecx*4-1]
    shl        eax,<t_unsigned8>24
    sar        eax,<t_unsigned8>31
    jmp        @copy
@plus:
    mov        eax,0

@copy:
    -- zkop¡rovat z klad
    rep        movsd

    -- vyplnit znam‚nkem
    mov        ecx,uniint_dwords
    mov        ebx,size
    shr        ebx,<t_unsigned8>2
    sub        ecx,ebx
    rep        stosd

    -- a konec
    jmp        @end

@load_larger:
    -- p©i©adit del¨¡ ‡¡slo v maxim ln¡ d‚lce uniint
    mov        ecx,uniint_dwords
    rep        movsd

@end:
{
    -- zjistime zda neni delka cisla vetsi nez maximanlni velikost uniint
    mov        edi,UI
    mov        esi,VAL
    mov        ecx,SIZE
    cld
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jb         @loadsmaller

    -- z vetsiho cisla zkopirujeme jen co muzeme, zbytek se ztrati, kopirujeme po dwordech
    mov        ecx,uniint_dwords
  @loadlarger:
    movsd 
    loop       @loadlarger
    jmp        @konec

    -- mensi cislo zkopirujeme cely, ale po bytech
  @loadsmaller:
    -- pocet kopirovanych bytu
    mov       ecx,SIZE
    mov       edx,uniint_dwords
    --shr       edx,<t_unsigned8>2
    shl       edx,<t_unsigned8>2
    -- pocet bytu pro znamenko
    sub       edx,ecx
    cmp       ecx,0
    je        @fillplus

  @next:
    --movsb
    mov       al,[esi]
    mov       [edi],al
    inc       esi
    inc       edi
    loop      @next

    -- a doplmime znamenkem...
    mov       ecx,edx
    bt        eax,<t_unsigned8>7
    jc        @fillminus

  @fillplus:
    -- ...kladnym
    xor       al,al
  @nextplus:
    mov       [edi],al
    inc       edi
    loop      @nextplus
    jmp       @konec

    -- ...nebo zapornym
  @fillminus:
    -- obsahuje cislo vubec znamenko ?
    mov       eax,SIGN 
    cmp       eax,0
    je        @fillplus 

    xor       eax,eax
    not       eax
  @nextminus:
    mov       [edi],eax
    inc       edi 
    loop      @nextminus

    -- a to je konec
  @konec:
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_load;



----------------------------------------------------------------------------------------------------
procedure uniint_store =
-- VAL := UI
----------------------------------------------------------------------------------------------------
const
  uniint_bytes     = uniint_precision div 8;
  uniint_dwords    = uniint_bytes     div 4;

begin
#if size:size=4 then;
  #syntax asm;
    -- zjistime zda neni delka cisla vetsi nez maximanlni velikost uniint
    mov        esi,UI
    mov        edi,VAL
    mov        ecx,SIZE
    cld    
    shr        ecx,<t_unsigned8>2
    cmp        ecx,uniint_dwords
    jb         @storetosmaller

    -- zkopirujeme cely UI
    mov        ecx,uniint_dwords
    rep        movsd
{
  @next:
    mov        eax,[esi]
    mov        [edi],eax
    add        esi,4
    add        edi,4
    loop       @next
}
    -- zjistime znamenko
    sar        eax,<t_unsigned8>31
{
    bt         eax,<t_unsigned8>31
    mov        eax,0
    jnc        @isplus
    not        eax
}
  @isplus:
    mov        ecx,uniint_bytes
    sub        ecx,size
    je         @konec
    rep        stosb
    jmp        @konec

  @storetosmaller:
    mov        ecx,size
    rep        movsb
{
    mov        ecx,uniint_dwords
    rep        movsd
}
    -- a to je konec
  @konec:
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_store;



----------------------------------------------------------------------------------------------------
procedure uniint_sign =
-- True, je-li UI z porn‚.
----------------------------------------------------------------------------------------------------
const
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,UI
    add        esi,uniint_lastdword

    -- reset v˜sledku 
    mov        result,0
    mov        eax,[esi]
    clc

    -- zjist¡me jak zda je nastaven nejvy¨¨¡ bit UI
    bt         eax,<t_unsigned8>31
    jnb        @konec

    -- z porn‚ ‡¡slo
    inc        result
  @konec:
    #end asm;
  end uniint_sign;

  
  
----------------------------------------------------------------------------------------------------
procedure uniint_add =
-- A + B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku
    mov        esi,A
    mov        edi,B
    mov        ebx,result

    -- se‡¡st
    mov        ecx,uniint_dwords
    clc
    -- secteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    adc        eax,[edi]
    mov        [ebx],eax
    lahf
    add        esi,4
    add        edi,4
    add        ebx,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_add;



----------------------------------------------------------------------------------------------------
procedure uniint_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B

    -- se‡¡st 
    mov        ecx,uniint_dwords
    clc
    -- secteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    adc        eax,[edi]
    mov        [esi],eax
    lahf
    add        esi,4
    add        edi,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_add_assign;

  

----------------------------------------------------------------------------------------------------
procedure uniint_sub =
-- A - B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku
    mov        esi,A
    mov        edi,B
    mov        ebx,result

    -- ode‡¡st
    mov        ecx,uniint_dwords
    clc
    -- odecteme vsechny dwordy 
  @next:  
    mov        eax,[esi]
    sbb        eax,[edi]
    mov        [ebx],eax
    lahf
    add        esi,4
    add        edi,4
    add        ebx,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_sub;



----------------------------------------------------------------------------------------------------
procedure uniint_sub_assign =
-- A := A - B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B

    -- se‡¡st 
    mov        ecx,uniint_dwords
    clc
    -- odecteme vsechny dwordy
  @next: 
    mov        eax,[esi]
    sbb        eax,[edi]
    mov        [esi],eax
    lahf
    add        esi,4
    add        edi,4
    dec        ecx
    jecxz      @konec
    sahf
    jmp        @next
  @konec:
    #end asm;
  end uniint_sub_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_prepare (
    A              : in tuniint;             
    plusA          : out tuniint;
    sign           : in out t_unsigned32;
    lenA           : out t_unsigned32) =           
-- prevede A na kladne cislo, v SIGN vrati znamenko A a v LENA delku A v bitech
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  rad              : t_unsigned32;              

begin
  #syntax asm;
    -- predzpracujeme operand A a zjistime nejvyssi nastaveny bit
    mov        rad,1
    mov        esi,A
    mov        edi,plusA
    mov        ecx,uniint_dwords
    mov        ebx,uniint_lastdword
    mov        eax,[esi+ebx]
    bt         eax,<t_unsigned8>31
    lahf
    jb         @ma

    -- A je kladne, udela se pouze kopie a zjisti nejvyssi nastaveny bit
    xor        ebx,ebx
  @pa:
    mov        eax,[esi]
    cmp        eax,0
    je         @zerodwordA
    bsr        ebx,eax
    add        ebx,rad
  @zerodwordA:
    mov        [edi],eax
    add        esi,4
    add        edi,4
    add        rad,32
    loop       @pa
    mov        eax,lenA
    mov        [eax],ebx
    jmp        @ka

    -- A je zaporne, udela se kopie a prevede na kladne a zjisti nejvyssi nastaveny bit
    xor        edx,edx
  @ma:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,0
    lahf
    cmp        ebx,0
    je         @zerodwordmA
    bsr        edx,ebx
    add        edx,rad
  @zerodwordmA:
    mov        [edi],ebx
    add        esi,4
    add        edi,4
    add        rad,32
    loop       @ma
    mov        eax,lenA
    mov        [eax],edx
    mov        eax,sign
    inc        <t_unsigned32>[eax]
  @ka:
    #end asm;
  end uniint_prepare;



----------------------------------------------------------------------------------------------------
procedure uniint_mul_assign =
-- A := A * B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  dest             : t_unsigned32;               -- ofset ve vysledku                               
  prenos           : t_unsigned32;               -- prenos do dalsich 32 bitu                       
  srcA             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  srcB             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  vysledek         : tuniint;                    -- docasne ulozeny vysledek                        
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- delka obou operandu v bitech                    
  lenB             : t_unsigned32;               -- delka obou operandu v bitech                    

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  #syntax asm;
    -- inicializace

    -- vypocteme delku A v dwordech
    mov        eax,<t_unsigned32>lenA
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenA,eax

    -- vypocteme delku B v dwordech
    mov        eax,<t_unsigned32>lenB
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenB,eax

    -- vycistime si vysledek
    lea        ebx,vysledek
    mov        ecx,uniint_dwords
  @f:
    mov        [ebx],<t_unsigned32>0
    add        ebx,4
    loop       @f

    -- osetreni trivialnich pripadu (nasobeni 0)
    cmp        lenA,<t_unsigned32>0
    je         @k
    cmp        lenB,<t_unsigned32>0
    jne        @i

    -- vynulovat [A]
    mov        ebx,A
    mov        ecx,uniint_dwords
  @g:
    mov  [ebx+ecx*4-4],<t_unsigned32>0
    loop @g
    jmp        @k

  @i: -- inicializace nasobeni 
    lea        esi,<t_unsigned32>plusA
    mov        srcA,<t_unsigned32>0

  @s:
    lea        edi,<t_unsigned32>plusB
    mov        srcB,<t_unsigned32>0
    mov        prenos,<t_unsigned32>0

  @1: -- nasobime 32-bitova cisla 

    -- kontrola, zda nepretece vysledek, pokud ano preteceni se ztrati 
    mov        eax,srcA
    add        eax,srcB
    mov        dest,eax
    cmp        dest,uniint_dwords
    jnl        @2

    -- vlastni nasobeni 
    mov        eax,[esi]
    mul        <t_unsigned32>[edi]
    add        eax,prenos
    adc        edx,<t_unsigned32>0
    mov        prenos,edx

    -- upravime vysledek 
    lea        ebx,vysledek
    mov        edx,dest
    shl        edx,<t_unsigned8>2
    add        ebx,edx
    add        [ebx],eax
    jnc        @3

    -- preteceni pri scitani 
    inc        dest
    cmp        dest,uniint_dwords
    jnl        @2
    add        ebx,<t_unsigned32>4
    add        [ebx],<t_unsigned32>1
  @3:
    -- dalsich 32 bitu operadnu B 
    add        edi,<t_unsigned32>4
    inc        srcB
    mov        ebx,uniint_dwords
    cmp        srcB,ebx
    jb         @1
  @2:
    -- dalsich 32 bitu operandu A 
    add        esi,<t_unsigned32>4
    inc        srcA
    mov        ebx,uniint_dwords
    cmp        srcA,ebx
    jnl        @z
    jmp        @s

  @z: -- upravime znamenko 
    mov        eax,sign
    cld
    mov        ecx,uniint_dwords
    lea        esi,vysledek
    mov        edi,A
    bt         eax,<t_unsigned8>0
    jnc        @plus
    lahf
  @zn:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [edi],ebx
    add        esi,<t_unsigned32>4
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k
  @plus:
    movsd
    loop       @plus
  @k: -- konec 
    #end asm;
  end uniint_mul_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_mul =
-- A * B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  dest             : t_unsigned32;               -- ofset ve vysledku                               
  prenos           : t_unsigned32;               -- prenos do dalsich 32 bitu                       
  srcA             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  srcB             : t_unsigned32;               -- ofset ve vstupnich operandech                   
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- delka obou operandu v bitech                    
  lenB             : t_unsigned32;               -- delka obou operandu v bitech                    

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  #syntax asm;
    -- inicializace

    -- vypocteme delku A v dwordech
    mov        eax,<t_unsigned32>lenA
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenA,eax

    -- vypocteme delku B v dwordech
    mov        eax,<t_unsigned32>lenB
    add        eax,<t_unsigned32>31
    shr        eax,<t_unsigned8>5
    mov        lenB,eax

    -- vycistime si vysledek
    mov        ebx,result
    mov        ecx,uniint_dwords
  @f:
    mov        [ebx],<t_unsigned32>0
    add        ebx,4
    loop       @f

    -- osetreni trivialnich pripadu (nasobeni 0)
    cmp        lenA,<t_unsigned32>0
    je         @k
    cmp        lenB,<t_unsigned32>0
    je         @k

  @i: -- inicializace nasobeni 
    lea        esi,<t_unsigned32>plusA
    mov        srcA,<t_unsigned32>0

  @s:
    lea        edi,<t_unsigned32>plusB
    mov        srcB,<t_unsigned32>0
    mov        prenos,<t_unsigned32>0

  @1: -- nasobime 32-bitova cisla 

    -- kontrola, zda nepretece vysledek, pokud ano preteceni se ztrati 
    mov        eax,srcA
    add        eax,srcB
    mov        dest,eax
    cmp        dest,uniint_dwords
    jnl        @2

    -- vlastni nasobeni 
    mov        eax,[esi]
    mul        <t_unsigned32>[edi]
    add        eax,prenos
    adc        edx,<t_unsigned32>0
    mov        prenos,edx

    -- upravime vysledek 
    mov        ebx,dest
    shl        ebx,<t_unsigned8>2
    add        ebx,result
    add        [ebx],eax
    jnc        @3

    -- preteceni pri scitani 
    inc        dest
    cmp        dest,uniint_dwords
    jnl        @2
    add        ebx,<t_unsigned32>4
    add        [ebx],<t_unsigned32>1
  @3:
    -- dalsich 32 bitu operadnu B 
    add        edi,<t_unsigned32>4
    inc        srcB
    mov        ebx,uniint_dwords
    cmp        srcB,ebx
    jb         @1
  @2:
    -- dalsich 32 bitu operandu A 
    add        esi,<t_unsigned32>4
    inc        srcA
    mov        ebx,uniint_dwords
    cmp        srcA,ebx
    jnl        @z
    jmp        @s

  @z: -- upravime znamenko 
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @k
    lahf
    mov        ecx,uniint_dwords
    mov        esi,result
  @zn:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [esi],ebx
    add        esi,<t_unsigned32>4
    loop       @zn
  @k: -- konec 
    #end asm;
  end uniint_mul;



----------------------------------------------------------------------------------------------------
procedure uniint_shlx (
    A              : in out tuniint) =
-- shl A o 1 dword
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    mov        edi,a  
    add        edi,uniint_lastdword
    mov        ecx,uniint_dwords_1
    mov        esi,edi
    sub        esi,4
    std
  @next:
    movsd
    loop       @next
    xor        eax,eax
    stosd
    cld
    #end asm;
  end uniint_shlx;



----------------------------------------------------------------------------------------------------
procedure uniint_shrx (
    A              : in out tuniint) =
-- shr A o 1 dword
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    mov        edi,a  
    mov        ecx,uniint_dwords_1
    mov        esi,edi
    add        esi,4
    cld
  @next:
    movsd
    loop       @next
    xor        eax,eax
    stosd
    #end asm;
  end uniint_shrx;



----------------------------------------------------------------------------------------------------
procedure uniint_submulw (
    A              : in out tuniint;             
    B              : in tuniint;                 
    len            : in t_unsigned32;            -- delka operandu B ve dwordech
    W              : in t_unsigned32) =           
-- A := A-B*W
----------------------------------------------------------------------------------------------------
const
  uniint_bytes     = uniint_precision div 8;

begin
  #syntax asm;
    push       ebp

    -- inicializace
    mov        ebx,w
    mov        ecx,uniint_bytes
    mov        edi,b  
    mov        esi,a  
    mov        ebp,len
    shl        ebp,<t_unsigned8>2
    add        ebp,edi
    add        ecx,esi

    -- vynasobit DX:AX:=w*B[di] 
  @next: 
    mov        eax,ebx
    mul        <t_unsigned32>[edi]

    -- odecist soucin od A[si] 
    sub        [esi],eax
    sbb        [esi+4],edx
    jnc        @nocarry

    -- prenos do vyssich radu A 
    push       esi
    add        esi,4
  @iscarry: 
    add        esi,4
    sub        <t_unsigned32>[esi],1
    jc         @iscarry
    pop        esi

  @nocarry: 
    -- pripravit se na dalsi dword
    add        edi,4
    cmp        edi,ebp
    jnb        @konec
    add        esi,4
    jmp        @next

  @konec: 
    pop        ebp
    #end asm;
  end uniint_submulw;



----------------------------------------------------------------------------------------------------
procedure uniint_addw (
    A              : in out tuniint;             
    W              : in t_unsigned32) =           
-- A := A+W
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    mov        edi,a
    mov        ecx,uniint_dwords
    mov        eax,W
    xor        edx,edx
    add        [edi],eax
    jmp        @test
  @next:
    adc        [edi],eax
  @test:
    jnc        @konec
    add        edi,4
    loop       @next
  @konec:
    #end asm;
  end uniint_addw;



----------------------------------------------------------------------------------------------------
procedure uniint_div_assign =
-- A := A div B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- nejvyssi nastaveny bit v A
  lenB             : t_unsigned32;               -- nejvyssi nastaveny bit v B
  plenB            : t_unsigned32;               -- puvodni delka B
  lenBw            : t_unsigned32;               -- delka B v dwordech            
  rad              : t_unsigned32;               -- aktualni rad vysledku                           
  dv               : t_mod_unsigned32;
  ra               : t_unsigned32;
  shift            : tuniint;

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  -- vyfillzujeme vysledek
  A:=ui_0;

  -- delit ma cenu pouze pokud A je vetsi nez B a A neni 0
  if lenA>=lenB and lenA>0 then

    #syntax asm;
      -- uschovame puvodni delku operandu B
      mov        eax,<t_unsigned32>lenB
      mov        <t_unsigned32>plenB,eax

      -- vypocteme novou
      mov        eax,<t_unsigned32>lenA
      add        eax,<t_unsigned32>31
      mov        ebx,<t_unsigned32>32
      xor        edx,edx
      div        ebx
      mul        ebx
      mov        lenB,eax
      mov        lenBw,eax
      dec        lenBw
      shr        lenBw,<t_unsigned8>5

      -- vypocteme ofset posunu operandu B
      sub        eax,plenB
      lea        edi,shift
      mov        [edi],eax
      #end asm;

    -- zarovnani delitele tak, aby nebyl kratsi nez delenec a zaroven byl deliteny 32
    uniint_shl_assign(plusB,shift);

    -- zjisteni delitele pro vypocet odhadu
    #syntax asm;
      mov        ebx,lenBw
      shl        ebx,<t_unsigned8>2
      lea        edi,plusB
      mov        eax,[edi+ebx]
      mov        dv,eax
      #end asm;

    loop
      loop       
        -- odhadnout podil 
        #syntax asm;
          mov        ebx,lenBw
          shl        ebx,<t_unsigned8>2
          lea        edi,plusA
          mov        eax,[edi+ebx]
          add        ebx,4
          mov        edx,[edi+ebx]
          mov        ecx,dv
          inc        ecx

          -- pokud se preteklo do nuly (=100000000h) nemusim ani nic delit, staci mov
          jnz        @1              
          mov        eax,edx         
          jmp        @2
        @1:   
          div        ecx

        @2:
          mov        ra,eax
          #end asm;

        -- koncime ?
        if ra=0 then break; end if;

        uniint_submulw(plusA,plusB,lenBw+1,ra);
        uniint_addw(A,ra);
        end loop;

      -- shiftnout o dword
      if lenB>=plenB+32 then
        uniint_shrx(plusB);
        uniint_shlx(A);
        lenB-32;
        lenBw-1;

      -- shiftnout o zbyle bity 
      elsif lenB>plenB then
        rad:=lenB-plenB;
        lenB:=plenB;

        #syntax asm;
          lea        edi,shift
          mov        eax,rad
          mov        [edi],eax
          #end asm;

        uniint_shr_assign(plusB,shift);
        uniint_shl_assign(A,shift);
        dv:=dv shr rad;

      -- neni co shiftovat, koncime
      else
        break;
        end if;

      end loop;

    -- obcas se nepodari spravne odhadnout podil a musim si pomoci odcitanim
    while plusA>=plusB loop 
      plusA-plusB; 
      succ A;
      end loop;
    end if;

  -- kopie a pripadne vytvoreni zaporneho cisla
  #syntax asm;
  @z: -- inicializace a zjisteni vysledneho znamenka
    mov        edi,A
    xor        ebx,ebx
    mov        ecx,uniint_dwords
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @isplus

    -- prevedeni cisla na zaporne
    lahf
  @zn:
    mov        ebx,[edi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [edi],ebx
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k

    -- zkopirovani do vyskledku
  @isplus:
    mov        eax,[edi+ebx]
    mov        [edi+ebx],eax
    add        ebx,4
    loop       @isplus

  @k: -- konec 
    #end asm;
  end uniint_div_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_mod_assign =
-- A := A mod B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

var
  plusA            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  plusB            : tuniint;                    -- kladne hodnoty vstupnich operandu               
  sign             : t_unsigned32;               -- znamenko vysledku                               
  lenA             : t_unsigned32;               -- nejvyssi nastaveny bit v A                  
  lenB             : t_unsigned32;               -- nejvyssi nastaveny bit v B                  
  plenB            : t_unsigned32;               -- puvodni delka B
  lenBw            : t_unsigned32;               -- delka B v dwordech
  rad              : t_unsigned32;               -- aktualni rad vysledku                           
  dv               : t_mod_unsigned32;
  ra               : t_unsigned32;
  shift            : tuniint;
  konec            : t_unsigned32; 

begin
  -- prevedeme A a B na kladna cisla a zjistime jejich delku
  uniint_prepare(A,plusA,sign,lenA);
  uniint_prepare(B,plusB,sign,lenB);

  if lenA>=lenB and lenA>0 then
    #syntax asm;
      -- uschovame puvodni delku operandu B
      mov        eax,<t_unsigned32>lenB
      mov        <t_unsigned32>plenB,eax

      -- vypocteme novou
      mov        eax,<t_unsigned32>lenA
      add        eax,<t_unsigned32>31
      mov        ebx,<t_unsigned32>32
      xor        edx,edx
      div        ebx
      mul        ebx
      mov        lenB,eax
      mov        lenBw,eax
      dec        lenBw
      shr        lenBw,<t_unsigned8>5

      -- vypocteme ofset posunu operandu B
      sub        eax,plenB
      lea        edi,shift
      mov        [edi],eax
      #end asm;

    -- zarovnani delitele tak, aby nebyl kratsi nez delenec a zaroven byl deliteny 32
    uniint_shl_assign(plusB,shift);

    -- zjisteni delitele pro vypocet odhadu
    #syntax asm;
      mov        ebx,lenBw
      shl        ebx,<t_unsigned8>2
      lea        edi,plusB
      mov        eax,[edi+ebx]
      mov        dv,eax
      #end asm;

    loop
      loop       
        -- odhadnout podil 
        #syntax asm;
          mov        ebx,lenBw
          shl        ebx,<t_unsigned8>2
          lea        edi,plusA
          mov        eax,[edi+ebx]
          add        ebx,4
          mov        edx,[edi+ebx]
          mov        ecx,dv
          inc        ecx

          -- pokud se preteklo do nuly (=100000000h) nemusim ani nic delit, staci mov
          jnz        @1              
          mov        eax,edx         
          jmp        @2
        @1:   
          div        ecx

        @2:
          mov        ra,eax
          #end asm;

        -- koncime ?
        if ra=0 then break; end if;

        uniint_submulw(plusA,plusB,lenBw+1,ra);
        end loop;

      -- shiftnout o dword
      if lenB>=plenB+32 then
        uniint_shrx(plusB);
        lenB-32;
        lenBw-1;

      -- shiftnout o zbyle bity 
      elsif lenB>plenB then
        rad:=lenB-plenB;
        lenB:=plenB;

        #syntax asm;
          lea        edi,shift
          mov        eax,rad
          mov        [edi],eax
          #end asm;

        uniint_shr_assign(plusB,shift);
        dv:=dv shr rad;

      -- neni co shiftovat, koncime
      else
        break;
        end if;

      end loop;

    -- obcas se nepodari spravne odhadnout podil a musim si pomoci odcitanim
    while plusA>=plusB loop plusA-plusB; end loop;
    end if;

  -- kopie a pripadne vytvoreni zaporneho cisla
  #syntax asm;
  @z: -- inicializace a zjisteni vysledneho znamenka
    mov        esi,A
    lea        edi,plusA
    xor        ebx,ebx
    mov        ecx,uniint_dwords
    mov        eax,sign
    bt         eax,<t_unsigned8>0
    jnc        @isplus

    -- prevedeni cisla na zaporne
    lahf
  @zn:
    mov        ebx,[edi]
    not        ebx
    sahf
    adc        ebx,<t_unsigned8>0
    lahf
    mov        [esi],ebx
    add        esi,<t_unsigned32>4
    add        edi,<t_unsigned32>4
    loop       @zn
    jmp        @k

    -- zkopirovani do vyskledku
  @isplus:
    mov        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @isplus

  @k: -- konec 
    #end asm;
  end uniint_mod_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_shl_assign =
-- A := A shl B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;
  uniint_maxshl    = tuniint:[uniint_precision,for others use 0];
  uniint_minshl    = tuniint:[for others use 0];
  uniint_treshhold = tuniint:[5,for others use 0];

var
  source           : t_unsigned32;               -- ofset zdrojoveho (vyssiho) dwordu               
  destination      : t_unsigned32;               -- ofset ciloveho dwordu                           

begin
  -- osetrime krajni pripady
  if b>uniint_minshl then
    -- kratky posun
    if b<=uniint_treshhold then
      #syntax asm;
        mov        esi,A
        mov        edi,B
        mov        edx,<t_unsigned32>[edi]

      -- posun
      @nextstep:
        xor        ebx,ebx
        mov        ecx,uniint_dwords
        clc

      -- posun uniint o 1 bit
      @nextdword:
        mov        eax,[esi+ebx]
        rcl        eax,1
        mov        [esi+ebx],eax
        add        ebx,4
        dec        ecx
        jecxz      @k1
        jmp        @nextdword

      @k1:
        dec        edx
        cmp        edx,0
        jne        @nextstep                  
        #end asm;

    -- dlouhy posun
    elsif b<uniint_maxshl then
      #syntax asm;
        -- adresy operand– a v˜sledku 
        mov        esi,A
        mov        edi,B
        mov        ecx,<t_unsigned32>[edi]
        -- do EDX dostaneme pocet dwordu o ktere rotujeme, v CL pocet bitu o kolik rotovat dwordy
        shl        cx,<t_unsigned8>3
        shr        cl,<t_unsigned8>3
        xor        edx,edx
        mov        dl,ch
        dec        edx
        shl        edx,<t_unsigned8>2

        -- zjistime adresy zdrojovych a ciloveho dwordu
        mov        ebx,uniint_lastdword
        mov        destination,ebx 
        sub        ebx,edx
        mov        source,ebx 

      @next:
        -- nepodtekl nam zdroj dat ?
        sub        source,4
        jb         @underH

        -- necteme kopirovany dword 
        mov        ebx,source
        mov        eax,[esi+ebx]

        -- orotujeme o prislusny pocet bitu
        shl        eax,cl
        not        cl
        inc        cl

        -- nacteme nizsi dword
        sub        ebx,4
        jb         @save
        mov        edx,[esi+ebx]

        -- orotujeme ho o komplement doprava
        shr        edx,cl
        not        cl
        inc        cl

        -- spojime vysledek
        or         eax,edx
        jmp        @save

      @underH:
        -- nacitana data podtekla - doplnime nulama
        xor        eax,eax 

      @save:
        -- ulozime prave spocteny dword
        mov        ebx,destination
        mov        [esi+ebx],eax

        -- dalsi krok 
        sub        destination,4
        jb         @konec
        jmp        @next
      @konec:
        #end asm;

    -- rotujeme mimo rozsah, takze muzeme vynulovat vysledek
    else
      #syntax asm;
        -- adresy operand– a v˜sledku 
        mov        esi,A
        mov        ecx,uniint_dwords
      @fillz:
        mov        [esi],<t_unsigned32>0
        add        esi,4 
        loop       @fillz
        #end asm;
      end if;
    end if;
  end uniint_shl_assign;

  

----------------------------------------------------------------------------------------------------
procedure uniint_shr_assign =
-- A := A shr B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;
  uniint_maxshr    = tuniint:[uniint_precision,for others use 0];
  uniint_minshr    = tuniint:[for others use 0];
  uniint_treshhold = tuniint:[5,for others use 0];

var
  source           : t_unsigned32;                -- ofset zdrojoveho (nizsiho) dwordu               
  destination      : t_unsigned32;                -- ofset ciloveho dwordu                           

begin
  -- osetrime krajni pripady
  if b>uniint_minshr then
    -- kratky posun
    if b<=uniint_treshhold then
      #syntax asm;
        mov        esi,A
        mov        edi,B
        mov        edx,<t_unsigned32>[edi]

      -- posun
      @nextstep:
        mov        ebx,uniint_lastdword
        mov        ecx,uniint_dwords
        clc

      -- posun uniint o 1 bit
      @nextdword:
        mov        eax,[esi+ebx]
        rcr        eax,1
        mov        [esi+ebx],eax
        sub        ebx,4
        dec        ecx
        jecxz      @k1
        jmp        @nextdword

      @k1:
        dec        edx
        cmp        edx,0
        jne        @nextstep                  
        #end asm;

    -- dlouhy posun
    elsif b<uniint_maxshr then
      #syntax asm;
        -- adresy operand– a v˜sledku 
        mov        esi,A
        mov        edi,B
        mov        ecx,<t_unsigned32>[edi]
        -- do EDX dostaneme pocet dwordu o ktere rotujeme, v CL pocet bitu o kolik rotovat dwordy
        shl        cx,<t_unsigned8>3
        shr        cl,<t_unsigned8>3
        xor        edx,edx
        mov        dl,ch
        shl        edx,<t_unsigned8>2

        -- zjistime adresy zdrojovych a ciloveho dwordu
        mov        ebx,0
        mov        destination,ebx
        add        ebx,edx
        mov        source,ebx 

      @next:
        -- nepodtekl nam zdroj dat ?
        cmp        source,uniint_lastdword
        jg         @underH

        -- necteme kopirovany dword 
        mov        ebx,source
        mov        eax,[esi+ebx]

        -- orotujeme o prislusny pocet bitu
        shr        eax,cl
        not        cl
        inc        cl

        -- nacteme nizsi dword
        add        ebx,4
        cmp        ebx,uniint_lastdword
        jg         @save
        mov        edx,[esi+ebx]

        -- orotujeme ho o komplement doleva
        shl        edx,cl
        not        cl
        inc        cl

        -- spojime vysledek
        or         eax,edx
        jmp        @save

      @underH:
        -- nacitana data podtekla - doplnime nulama
        xor        eax,eax 

      @save:
        -- ulozime prave spocteny dword
        mov        ebx,destination
        mov        [esi+ebx],eax

        -- dalsi krok 
        add        source,4
        add        destination,4
        cmp        destination,uniint_lastdword
        jg         @konec
        jmp        @next
      @konec:
        #end asm;

    -- rotujeme mimo rozsah, takze muzeme vynulovat vysledek
    else
      #syntax asm;
        -- adresy operand– a v˜sledku 
        mov        esi,A
        mov        ecx,uniint_dwords
      @fillz:
        mov        [esi],<t_unsigned32>0
        add        esi,4 
        loop       @fillz
        #end asm;
      end if;
    end if;
  end uniint_shr_assign;

  

----------------------------------------------------------------------------------------------------
procedure uniint_and_assign =
-- A := A and B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    and        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_and_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_or_assign =
-- A := A or B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    or         eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_or_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_xor_assign =
-- A := A xor B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A
    mov        edi,B

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    xor        eax,[edi+ebx]
    mov        [esi+ebx],eax
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_xor_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_neg =
-- - A
----------------------------------------------------------------------------------------------------
begin
  result:=a;
  -result;
  end uniint_neg;


  
----------------------------------------------------------------------------------------------------
procedure uniint_neg_assign =
-- A := - A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        edi,A

    -- inicializace
    mov        ecx,uniint_dwords
    clc
    cld

    -- znegovat
@1: mov        eax,0
    sbb        eax,[edi]
    stosd
    loop       @1

{
    -- adresy operand– a v˜sledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    stc
    lahf

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        edx,[esi+ebx]
    not        edx
    sahf
    adc        edx,0
    lahf
    mov        [esi+ebx],edx
    add        ebx,4
    loop       @next
  @konec:
}
    #end asm;
  end uniint_neg_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_not_assign =
-- A := not A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        edi,A

    -- inicializace
    mov        ecx,uniint_dwords

    -- znegovat
@1: not        <t_unsigned32>[edi+ecx*4-4]
    loop       @1
    #end asm;
  end uniint_not_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_abs_assign =
-- A := abs A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- zjistime znamenko A 
    mov        esi,A
    mov        ebx,uniint_lastdword
    mov        eax,[esi+ebx]
    bt         eax,<t_unsigned8>31
    lahf
    jnb        @konec
    mov        ecx,uniint_dwords

    -- A je zaporne, prevede se na kladne 
  @ma:
    mov        ebx,[esi]
    not        ebx
    sahf
    adc        ebx,0
    lahf
    mov        [esi],ebx
    add        esi,4
    loop       @ma
  @konec:
    #end asm;
  end uniint_abs_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_succ_assign =
-- A := succ A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    add        eax,1
    mov        [esi+ebx],eax
    jnc        @konec
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_succ_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_pred_assign =
-- A := pred A
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    mov        esi,A

    -- inicializace
    mov        ecx,uniint_dwords
    xor        ebx,ebx

    -- aplikujeme and na vsechny dwordy
  @next: 
    mov        eax,[esi+ebx]
    sub        eax,1
    mov        [esi+ebx],eax
    jnc        @konec
    add        ebx,4
    loop       @next
  @konec:
    #end asm;
  end uniint_pred_assign;



----------------------------------------------------------------------------------------------------
procedure uniint_lt =
-- A < B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A < B
  @mensi:
    mov        ebx,<t_unsigned32>1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_lt;



----------------------------------------------------------------------------------------------------
procedure uniint_le =
-- A <= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A < B
  @mensi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_le;



----------------------------------------------------------------------------------------------------
procedure uniint_gt =
-- A > B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operandù a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A > B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_gt;



----------------------------------------------------------------------------------------------------
procedure uniint_ge =
-- A >= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A >= B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_ge;


{
----------------------------------------------------------------------------------------------------
procedure uniint_ge_unidata =
-- A >= B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @konec
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @vetsi

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        eax,<t_unsigned32>[esi]
    jb         @vetsi
    jne        @konec 
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next

    -- A >= B
  @vetsi:
    mov        ebx,1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end uniint_ge_unidata;
}


----------------------------------------------------------------------------------------------------
procedure uniint_is_power2 =
-- True, je-li A nˆjak  mocnina dvojky.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);

begin
  #syntax asm;
    -- inicializace
    mov        edi,A
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    mov        <t_unsigned32>result,ebx

    -- otestujeme dalsi dword
  @next:
    mov        eax,[edi]

    -- zjistime, zda dword obsahuje nejake nastavene bity
  @test:
    cmp        eax,0
    je         @iszero

    -- nebyl uz nahodou nejaky bit nekdy nastaven ? pokud ano, A neni mocnina 2
    cmp        ebx,0
    jne        @konec

    -- zjistime prvni nastaveny bit, shodime ho a poznamename si do ebx ze nejaky takovy existuje
    bsr        edx,eax
    btr        eax,edx
    inc        ebx

    -- neni v dwordu jeste nejaky jiny nastaveny bit ?
    jmp        @test
  @iszero:
    add        edi,4
    loop       @next

  @ispower2:
    -- ulozime vysledek testu
    mov        <t_unsigned32>result,ebx
  @konec:
    #end asm;
  end uniint_is_power2;



----------------------------------------------------------------------------------------------------
procedure uniint_get_power2 =
-- Exponent, je-li A nˆjak  mocnina dvojky.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8 div 4);
  uniint_lastdword = (uniint_precision div 8)-4;

begin
#if result:size=4 then;
  #syntax asm;
    -- inicializace
    mov        edi,A
    add        edi,uniint_lastdword
    mov        ecx,uniint_dwords
    xor        ebx,ebx
    mov        edx,uniint_lastdword
    shl        edx,<t_unsigned8>3

    -- najdeme nejvyssi nenulovy dword
  @next:
    mov        eax,[edi]
    cmp        eax,0
    jne        @bitset
    sub        edi,4
    sub        edx,32 
    loop       @next
    jmp        @konec

    -- nasli jsme nejaky bit, zjistime jeho absolutni pozici a koncime
  @bitset:
    bsr        ebx,eax
    add        ebx,edx

    -- ulozime vysledek
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_get_power2;

  

----------------------------------------------------------------------------------------------------
procedure uniint_length =
-- D‚lka intervalu: B - A + 1
----------------------------------------------------------------------------------------------------
begin
  result:=b-a+ui_1;
  end uniint_length;



----------------------------------------------------------------------------------------------------
procedure uniint_test_shrink =
-- True, pokud A je vˆt¨¡ ne‘ SIZE byt– nebo m  chybn‚ znam‚nko.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = (uniint_precision div 8) div 4;
  uniint_lastdword = (uniint_precision div 8)-4;
  uniint_bytes     = uniint_precision div 8;

begin
#if result:size=4 then;
  #syntax asm;
    --                                                                    
    --                                                                    
    --                                                                    
    --      +-----------+-----------+                                     
    --      | edx bytu  | ecx bytu  |                                     
    --      +--+--+--+--+--+--+--+--+                                     
    --      ^        ^           ^                                        
    --      puvodni  |           |                                        
    --      [eax]    |           |                                        
    --               novy        [eax+ecx]                                
    --               [eax]                                                

    cmp     sign,1
    jne     @1

    -- znam‚nkovˆ
    mov     ecx,uniint_bytes
    sub     ecx,size
    mov     ebx,$000000FF -- bl:=$FF; bh:=$00;
    jecxz   @5
    -- testovat bity
    mov     eax,A
    add     eax,size
    dec     eax -- eax:=^A+SIZE-1;
@3: and     bl,[eax+ecx]
    or      bh,[eax+ecx]
    dec     ecx
    jnz     @3
    -- byly to sam‚ jedni‡ky => z porn‚
    cmp     bh,$00 -- = sam‚ nuly
    je      @6
    cmp     bl,$FF -- = sam‚ jedni‡ky
    je      @7
    mov     eax,1  -- = nˆco mezi t¡m => ur‡itˆ p©ete‡en¡
    jmp     @4
    -- sam‚ nuly, nejvy¨¨¡ bit mus¡ b˜t t‚‘ 0
@6: movzx   eax,<t_unsigned8>[eax]
    shr     eax,<t_unsigned8>7
    jmp     @4
    -- sam‚ jedni‡ky, nejvy¨¨¡ bit mus¡ b˜t t‚‘ 1
@7: movzx   eax,<t_unsigned8>[eax]
    shr     eax,<t_unsigned8>7
    xor     eax,1
    jmp     @4

@1: -- bezznam‚nkovˆ
    mov     ecx,uniint_bytes
    sub     ecx,size
    xor     ebx,ebx
    jecxz   @5
    -- nakumulovat testovan‚ bity
    mov     eax,A
    add     eax,size
    dec     eax -- eax:=^A+SIZE-1;
@2: or      bl,[eax+ecx]
    dec     ecx
    jnz     @2
    -- vy¨la nenula => p©ete‡en¡
@5: cmp     bl,0
    setnz   al
    and     eax,1

@4: -- p©edat v˜sledek
    mov     result,eax

{
    -- inicializace
    mov        esi,A
    add        esi,uniint_lastdword

    -- zjistime znamenko A, pozadovane znamenko a otestujeme na shodu
    mov        eax,[esi]
    mov        ebx,sign
    bt         ebx,<t_unsigned8>0
    jc         @isminus
    mov        dl,0
    bt         eax,<t_unsigned8>31
    jc         @returntrue
    jmp        @testlength
  @isminus:
    mov        dl,$ff
    bt         eax,<t_unsigned8>31
    jnc        @returntrue

    -- otestujeme delku
  @testlength:
    mov        esi,A
    mov        ecx,uniint_dwords
    shl        ecx,<t_unsigned8>2
    mov        ebx,ecx

  @testbyte:
    mov        al,[esi+ebx-1]
    cmp        al,dl
    jne        @comparesize
    dec        ebx
    loop       @testbyte
    mov        ebx,1
  @comparesize:
    cmp        ebx,size
    jbe        @returnfalse

  @returntrue:
    mov        ebx,1
    mov        result,ebx
    jmp        @konec
  @returnfalse:
    mov        ebx,0
    mov        result,ebx
  @konec:
}
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end uniint_test_shrink;



----------------------------------------------------------------------------------------------------
procedure uniint_get_nth_byte =
-- Z¡sk  N-t˜ byte zadan‚ho univerz ln¡ho integeru
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned8array(A:unchecked)[n];
  end uniint_get_nth_byte;



----------------------------------------------------------------------------------------------------
procedure char_to_unichar =
-- P©evod C na TUNICHAR.
----------------------------------------------------------------------------------------------------
begin
  result:=tunichar(c);
  end char_to_unichar;



----------------------------------------------------------------------------------------------------
procedure unichar_to_uniint =
-- P©evod TUNICHAR na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(c:ord);
  end unichar_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unireal_le =
-- A <= B
----------------------------------------------------------------------------------------------------
begin
  raise feature_not_implemented;
  end unireal_le;



----------------------------------------------------------------------------------------------------
procedure logical_to_unilogical =
-- P©evod A na UNILOGICAL.
----------------------------------------------------------------------------------------------------
begin
  result:=tunilogical(a);
  end logical_to_unilogical;



----------------------------------------------------------------------------------------------------
procedure unilogical_to_logical =
-- P©evod A na LOGICAL.
----------------------------------------------------------------------------------------------------
begin
  result:=t_logical(a);
  end unilogical_to_logical;



----------------------------------------------------------------------------------------------------
procedure unilogical_to_uniint =
-- P©evod A na UNILOGICAL.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,A
    mov        eax,[eax]
    mov        [edi],eax

    -- a vycistime vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    mov        eax,0
    rep stosd
    #end asm;
  end unilogical_to_uniint;


{  
----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata =
-- P©evod I na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

    -- a vyfillzujeme vyssi dwordy
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    xor        eax,eax
  @fill:
    stosd
    loop       @fill
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unsigned_to_unidata;



----------------------------------------------------------------------------------------------------
procedure signed_to_unidata =
-- P©evod I na TUNIDATA.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords_1  = (uniint_precision div 8 div 4)-1;

begin
#if I:size=4 then;
  #syntax asm;
    -- zkopirujeme vlastni hodnotu
    mov        edi,result
    mov        eax,I
    mov        [edi],eax

    -- a vyssi dwordy vypln¡me sign bitem
    cld
    add        edi,4
    mov        ecx,uniint_dwords_1
    shr        eax,<t_unsigned8>31
  @fill:
    stosd
    loop       @fill
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end signed_to_unidata;



----------------------------------------------------------------------------------------------------
procedure unidata_to_unsigned =
-- P©evod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
#if result:size=4 then;
  #syntax asm;
    -- zkopirujeme prvnich 32-bitu
    mov        esi,UD
    mov        edi,result
    mov        eax,[esi]
    mov        [edi],eax
    #end asm;
#else;
  #error 'neimplementovano';
  #end if;
  end unidata_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_to_uniint =
-- P©evod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;

begin
  #syntax asm;
    -- inicializace
    mov        edi,result
    mov        esi,UD
    mov        ecx,uniint_dwords
    cld

    -- kopirujeme
  @next:
    movsd
    loop       @next
    #end asm;
  end unidata_to_uniint;


  
----------------------------------------------------------------------------------------------------
procedure unidata_align =
-- Zarovn  A smˆrem nahoru na hranici dˆlitelnou ALIGN.
----------------------------------------------------------------------------------------------------
begin
  a:=((a+align-ud_1) div align)*align;
  end unidata_align;



----------------------------------------------------------------------------------------------------
procedure unidata_lt =
-- A < B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- adresy operand– a v˜sledku 
    xor        ebx,ebx
    mov        esi,A
    mov        edi,B
    add        esi,uniint_lastdword
    add        edi,uniint_lastdword

    -- porovname znamenka A a B
    mov        eax,[esi]
    bt         eax,<t_unsigned8>31
    jnb        @ap
    -- A je zaporne
  @am:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @mensi
    jmp        @compare
    -- A je kladne
  @ap:
    mov        eax,[edi]
    bt         eax,<t_unsigned8>31
    jnb        @compare
    jmp        @konec

    -- A i B maji stejna znamenka, musime je porovnat
  @compare:
    mov        ecx,uniint_dwords
    -- porovnani od nejvysich dword po nejnizsi
  @next:
    mov        eax,[edi] 
    cmp        <t_unsigned32>[esi],eax
    jb         @mensi
    jne        @konec
    sub        esi,<t_unsigned32>4
    sub        edi,<t_unsigned32>4
    loop       @next
    jmp        @konec

    -- A < B
  @mensi:
    mov        ebx,<t_unsigned32>1
    -- konec
  @konec:
    mov        <t_unsigned32>result,ebx
    #end asm;
  end unidata_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_gt =
-- A > B
----------------------------------------------------------------------------------------------------
const
  uniint_dwords    = uniint_precision div 8 div 4;
  uniint_lastdword = (uniint_precision div 8)-4;

begin
  #syntax asm;
    -- addresses of operands and result
    xor            ebx,ebx
    mov            esi,A
    mov            edi,B
    add            esi,uniint_lastdword
    add            edi,uniint_lastdword

    -- compare sign of A and B
    mov            eax,[esi]
    bt             eax,<t_unsigned8>31
    jnb            @ap

    -- A is negative
@an:
    mov            eax,[edi]
    bt             eax,<t_unsigned8>31
    jnb            @finish
    jmp            @compare

    -- A is positive
@ap:
    mov            eax,[edi]
    bt             eax,<t_unsigned8>31
    jnb            @compare
    jmp            @greater

    -- A and B has the same signs, compare them
@compare:
    mov            ecx,uniint_dwords

    -- compare from high dword down to low dword

    -- A > B
@greater:
    mov            ebx,1

    -- end
@finish:
    mov            <t_unsigned32>result,ebx
    #end asm;
  end unidata_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_mul =
-- A * B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_mul;



----------------------------------------------------------------------------------------------------
procedure unidata_div =
-- A div B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_div;



----------------------------------------------------------------------------------------------------
procedure unidata_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_add;



----------------------------------------------------------------------------------------------------
procedure unidata_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
begin
  a:=a+b;
  end unidata_add_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_sub =
-- A - B
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unidata_sub;



----------------------------------------------------------------------------------------------------
procedure uniprg_to_unsigned =
-- P©evod UP na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end uniprg_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_uniprg =
-- P©evod T_UNSIGNED na TUNIPRG
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(LONG_ARITHMETIC)}
  #error 'Jako by ti tady neco chybelo... ;-)';
  end unsigned_to_uniprg;
}


----------------------------------------------------------------------------------------------------
procedure unimsg_to_unsigned =
-- P©evod UM na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(um);
  end unimsg_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unimsg_succ_assign =
-- succ A
----------------------------------------------------------------------------------------------------
begin
  succ t_unsigned(A);
  end unimsg_succ_assign;



----------------------------------------------------------------------------------------------------
procedure unitag_succ_assign =
-- succ A
----------------------------------------------------------------------------------------------------
begin
  succ t_unsigned(A);
  end unitag_succ_assign;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata_size =
-- P©evod I na TUNIDATA_SIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=i;
  end unsigned_to_unidata_size;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_unidata_addr =
-- P©evod I na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=i;
  end unsigned_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure signed_to_unidata_addr =
-- P©evod I na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(i:unchecked);
  end signed_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_size =
-- Velmi neobvykl  operace: konverze adresy na velikost
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud);
  end unidata_addr_to_size;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_addr =
-- Velmi neobvykl  operace: konverze velikosti na adresu.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud);
  end unidata_size_to_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_unsigned =
-- P©evod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_size_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_to_unsigned =
-- P©evod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_bitsize_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_unsigned =
-- P©evod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(UD);
  end unidata_addr_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_signed =
-- P©evod UD na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_signed(UD:unchecked);
  end unidata_addr_to_signed;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_lt = 
-- A < B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)<t_unsigned(B);
  end unidata_bitsize_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_size_lt = 
-- A < B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)<t_unsigned(B);
  end unidata_size_lt;



----------------------------------------------------------------------------------------------------
procedure unidata_size_ge = 
-- A >= B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>=t_unsigned(B);
  end unidata_size_ge;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_ge = 
-- A >= B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>=t_unsigned(B);
  end unidata_bitsize_ge;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_size =
-- P©evod UI na TUNIDATA_SIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_size;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_bitsize =
-- P©evod UI na TUNIDATA_BITSIZE.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_bitsize;



----------------------------------------------------------------------------------------------------
procedure uniint_to_unidata_addr =
-- P©evod UI na TUNIDATA_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=uniint_to_unsigned(ui);
  end uniint_to_unidata_addr;



----------------------------------------------------------------------------------------------------
procedure unidata_size_to_uniint =
-- P©evod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_size_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_bitsize_to_uniint =
-- P©evod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_bitsize_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_to_uniint =
-- P©evod UD na TUNIINT.
----------------------------------------------------------------------------------------------------
begin
  result:=unsigned_to_uniint(t_unsigned(ud));
  end unidata_addr_to_uniint;



----------------------------------------------------------------------------------------------------
procedure unidata_bits_to_bytes =
-- P©evod velikosti v bitech na velikost v bytech se zaokrouhlen¡m nahoru.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=(t_unsigned(ud)+t_unsigned(udb_bits_per_byte)-1) div t_unsigned(udb_bits_per_byte);
  end unidata_bits_to_bytes;



----------------------------------------------------------------------------------------------------
procedure unidata_bytes_to_bits =
-- P©evod velikosti v bytech na velikost v bitech.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(ud)*t_unsigned(udb_bits_per_byte);
  end unidata_bytes_to_bits;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(a)+t_unsigned(b);
  end unidata_addr_add;



----------------------------------------------------------------------------------------------------
procedure unidata_size_add =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(a)+t_unsigned(b);
  end unidata_size_add;



----------------------------------------------------------------------------------------------------
procedure unidata_size_add_assign =
-- A := A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(a)+t_unsigned(b);
  end unidata_size_add_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_size_sub =
-- A - B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A)-t_unsigned(B);
  end unidata_size_sub;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mul =
-- A * B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A)*t_unsigned(B);
  end unidata_size_mul;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mul_assign =
-- A := A * B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(A)*t_unsigned(B);
  end unidata_size_mul_assign;



----------------------------------------------------------------------------------------------------
procedure unidata_size_div =
-- A div B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A) div t_unsigned(B);
  end unidata_size_div;



----------------------------------------------------------------------------------------------------
procedure unidata_size_mod =
-- A mod B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=t_unsigned(A) mod t_unsigned(B);
  end unidata_size_mod;



----------------------------------------------------------------------------------------------------
procedure unidata_size_gt =
-- A > B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>t_unsigned(B);
  end unidata_size_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_gt =
-- A > B
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(A)>t_unsigned(B);
  end unidata_addr_gt;



----------------------------------------------------------------------------------------------------
procedure unidata_addr_align_by_size =
-- Zarovn  adresu A smˆrem nahoru na hranici dˆlitelnou velikost¡ ALIGN.
----------------------------------------------------------------------------------------------------
var
  B                : tunidata_addr;

begin
  B:=unidata_size_to_addr(align);
  A+B; 
  A-1;
  A div B;
  A*B;
  --%%TODO(OVERLOAD) Tohle ohl s¡: Typ v˜razu nen¡ jednozna‡nˆ ur‡en
  --A:=((A+B-1) div B)*B;
  end unidata_addr_align_by_size;


----------------------------------------------------------------------------------------------------
procedure unidata_addr_add_assign =
-- A + B
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(A)+t_unsigned(B);
  end unidata_addr_add_assign;



----------------------------------------------------------------------------------------------------
procedure unicode_addr_to_unsigned =
-- P©evod UP na T_UNSIGNED.
----------------------------------------------------------------------------------------------------
begin
  result:=t_unsigned(uc);
  end unicode_addr_to_unsigned;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_unicode_addr =
-- P©evod T_UNSIGNED na TUNICODE_ADDR.
----------------------------------------------------------------------------------------------------
begin
  t_unsigned(result):=x;
  end unsigned_to_unicode_addr;



end cc_unitype;