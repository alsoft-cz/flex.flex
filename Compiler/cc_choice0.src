----- %%TECH Práce se seznamem výběrů --------------------------------------------------------------
-- Vzhledek k tomu, že Delphi neumí textové substituce, musí být práce se
-- seznamem výběrů řešena jako $INCLUDE a jednotlivé varianty algoritmu se
-- volí pomocí direktiv:
--    CC_CHOICE_CASE    - varianty v CASE
--    CC_CHOICE_ARRAY   - agregát pole/řetězce
--    CC_CHOICE_SET     - agregát množiny
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure choice_extend =
-- Rozšíří CLIST o COUNT položek (pokud je to potřeba).                       
----------------------------------------------------------------------------------------------------
var
  _list            : clist.list:type;

begin
  if clist.list=nil then
    new clist.list range count;
  elsif clist.list^:length+count>clist.list^:last then
    --%%TODO(ADJUST) adjust clist.list range clist.list^:length+count;
    new _list range clist.list^:length+count;
    _list^:=clist.list^;
    discard clist.list;
    clist.list:=_list;
    end if;
  end choice_extend;



----------------------------------------------------------------------------------------------------
procedure choice_add_single =
-- Vloží do seznamu optimalizovaných výběrů jednu hodnotu.                    
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

var
  ui1      : tuniint;
  ui2      : tuniint;
  i        : t_unsigned;
  _x       : clist.list^:base;

    ------------------------------------------------------------------------------------------------
    procedure prepend_clist =
    -- %%TODO(CONCAT) Na začátek řetězce CLIST vloží prvek _X.
    ------------------------------------------------------------------------------------------------
    begin
      succ clist.list^:length;
      for i in reverse clist.list^:first..clist.list^:last-1 loop
        clist.list^[i+1]:=clist.list^[i];
        end loop;
      clist.list^[1]:=_x;
      end prepend_clist;

begin
  -- úplně první hodnota 
  if clist.list=nil or else clist.list^:length=0 then
    -- realokovat paměť 
    choice_extend(clist,1);

    -- přidat jako první prvek %%TODO(AGGREGATE)
    _x.lval:=ui;
    _x.hval:=ui;
  #if cc_choice=CC_CHOICE_ARRAY then;
    _x.val:=imm;
  #end if;
    clist.list^ & _x;

  -- před prvním intervalem (ostře menší) 
  elsif ui<clist.list^[1].lval then
  #if cc_choice<>cc_choice_array then;
    -- vypočítat [1].LVAL-1 
    ui1:=clist.list^[1].lval-ui_1;

    if ui1=ui

      -- těsně před prvním intervalem => prodloužit interval 
      then
        clist.list^[1].lval:=ui;

      -- jinak přidat další interval 
      else #end if;
        -- realokovat paměť 
        choice_extend(clist,1);

        -- přidat jako první %%TODO(AGGREGATE) 
        _x.lval:=ui;
        _x.hval:=ui;
      #if cc_choice=cc_choice_array then;
        _x.val:=imm;
      #end if;
        prepend_clist; --%%TODO(CONCAT) clist.list^:=_x & clist.list^;
      #if cc_choice<>cc_choice_array then;
        end if;
      #end if;

  -- za posledním intervalem (ostře větší) 
  elsif ui>clist.list^[clist.list^:length].hval then
  #if cc_choice<>cc_choice_array then;
    -- vypočítat [last].HVAL+1 
    ui1:=clist.list^[clist.list^:length].hval+ui_1;

    if ui1=ui

      -- těsně za posledním intervalem => prodloužit 
      then
        clist.list^[clist.list^:length].hval:=ui;

      -- jinak přidat další interval 
      else #end if;
        -- realokovat paměť 
        choice_extend(clist,1);

        -- přidat jako poslední %%TODO(AGGREGATE) 
        _x.lval:=ui;
        _x.hval:=ui;
      #if cc_choice=cc_choice_array then;
        _x.val:=imm;
      #end if;
        clist.list^ & _x;
      #if cc_choice<>cc_choice_array then;
        end if;
      #end if;

  -- někde mezi
  else
    -- přidávaná hodnota patří do některého z již existujících intervalů
    -- nebo mezi některé dva existující intervaly
    i:=1;
    loop
      -- spadá do tohoto intervalu ?
      if ui>=clist.list^[i].lval and ui<=clist.list^[i].hval then
        -- ohlásit varování
        if cw_duplicate_choice in context.entity^.compv.warns then
          ce^.setwarning(context,{CCERR=}000001,cw_duplicate_choice);
          -- %%TODO Zobrazovat, který výběr je duplicitní; ce^.setparam(...);
        #if cc_choice=cc_choice_case then;
          choice^.errpos;
        #end if;
          end if;

        -- a konec
        break;

      -- teď je hodnota jistě nad horní mezí (jinak by se zpracovala
      -- v minulé iteraci) a jistě to není poslední interval (jinak by se
      -- zpracovala jako výjima ještě před touto větví IF), takže stačí
      -- testovat proti dolní mezi následujícího intervalu, jestli neleží
      -- mezi I-tým a I+1-ním intervalem.
      elsif ui<clist.list^[i+1].lval then
      #if cc_choice<>cc_choice_array then;
        -- vypočítat [I].HVAL+1 a [I+1].LVAL-1
        ui1:=clist.list^[i].hval+ui_1;
        ui2:=clist.list^[i+1].lval-ui_1;

        -- vyplňuje přesně mezeru mezi intervaly I a I+1 ?
        if ui1=ui2 then
          -- sloučit I-tý a I+1-ní interval %%TODO(SLICE)
          clist.list^[i].hval:=clist.list^[i+1].hval;
          advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+2],clist.list^[i+1],(clist.list^:length-(i+1))*clist.list^[1]:size);
          pred clist.list^:length;

        -- je těsně nad horní mezí I-tého intervalu ?
        elsif ui1=ui then
          -- prodloužit I-tý interval
          clist.list^[i].hval:=ui;

        -- je těsně pod dolní mezí I+1-ního intervalu ?
        elsif ui2=ui then
          -- prodloužit I+1-ní interval
          clist.list^[i+1].lval:=ui;

        -- žádná příznivá situace, musíme přidat interval
        else #end if;
          -- realokovat paměť
          choice_extend(clist,1);

          -- posunout %%TODO(SLICE)
          advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+1],clist.list^[i+2],(clist.list^:length-i)*clist.list^[1]:size);
          succ clist.list^:length;

          -- vložit na místo I+1-ního výběru
          clist.list^[i+1].lval:=ui;
          clist.list^[i+1].hval:=ui;
        #if cc_choice=cc_choice_array then;
          clist.list^[i+1].val:=imm;
        #else;
          end if;
        #end if;

        -- a konec 
        break;
        end if;

      -- další interval 
      succ i;
      end loop;
    end if;
  end choice_add_single;



----------------------------------------------------------------------------------------------------
procedure choice_add_range =
-- Vloží do seznamu optimalizovaných výběrů rozsah hodnot.                    
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

    ------------------------------------------------------------------------------------------------
    procedure delint (
        a          : in t_unsigned;              -- dolní index posloupnosti rušených intervalů
        b          : in t_unsigned) =            -- horní index posloupnosti rušených intervalů
    -- Zruší intervaly v rozsahu A..B.
    ------------------------------------------------------------------------------------------------
    begin
      -- %%TODO(SLICE) 
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[b+1],clist.list^[a],(clist.list^:length-b)*clist.list^[1]:size);
      clist.list^:length-(b-a+1);
      end delint;

type
  -- pozice meze přidávaného intervalu vůči existujícím intervalům
  tboundarypos     = enum
      tbp_between;                               -- mezi dvěma intervaly
      tbp_inside;                                -- uvnitř intervalu
      tbp_attached;                              -- těsně u intervalu
      end enum;
  tboundaryposset  = set of tboundarypos;

var
  ui1              : tuniint;
  ui2              : tuniint;
  i                : t_unsigned;
  j                : t_unsigned;
  lval_pos         : tboundarypos;               -- pozice dolní meze vůči existujícím int.
  hval_pos         : tboundarypos;               -- pozice horní meze vůči existujícím int.
  _x               : clist.list^:base;

    ------------------------------------------------------------------------------------------------
    procedure prepend_clist =
    -- %%TODO(CONCAT) Na začátek řetězce CLIST vloží prvek _X.
    ------------------------------------------------------------------------------------------------
    begin
      succ clist.list^:length;
      for i in reverse clist.list^:first..clist.list^:last-1 loop
        clist.list^[i+1]:=clist.list^[i];
        end loop;
      clist.list^[1]:=_x;
      end prepend_clist;

begin
  -- úplně první hodnota 
  if clist.list=nil or else clist.list^:length=0 then
    -- realokovat paměť 
    choice_extend(clist,1);

    -- přidat jako první prvek 
    _x.lval:=lval;
    _x.hval:=hval;
  #if cc_choice=cc_choice_array then;
    _x.val:=imm;
  #end if;
    clist.list^ & _x;

  -- před prvním intervalem (ostře menší) 
  elsif hval<clist.list^[1].lval then
  #if cc_choice<>cc_choice_array then;
    -- vypočítat [1].LVAL-1 
    ui1:=clist.list^[1].lval-ui_1;

    if ui1=hval

      -- těsně před prvním intervalem => prodloužit 
      then
        clist.list^[1].lval:=lval;

      -- jinak přidat další interval 
      else #end if;
        -- realokovat paměť 
        choice_extend(clist,1);

        -- přidat jako první %%TODO(AGGREGATE) 
        _x.lval:=lval;
        _x.hval:=hval;
      #if cc_choice=cc_choice_array then;
        _x.val:=imm;
      #end if;
        prepend_clist; --%%TODO(CONCAT) clist.list^:=_x & clist.list^;
      #if cc_choice<>cc_choice_array then;
        end if;
      #end if;

  -- za posledním intervalem (ostře větší) 
  elsif lval>clist.list^[clist.list^:length].hval then
  #if cc_choice<>cc_choice_array then;
    -- vypočítat [last].HVAL+1 
    ui1:=clist.list^[clist.list^:length].hval+ui_1;

    if ui1=lval

      -- těsně za posledním intervalem => prodloužit 
      then
        clist.list^[clist.list^:length].hval:=hval;

      -- jinak přidat další interval 
      else #end if; 
        -- realokovat paměť 
        choice_extend(clist,1);

        -- přidat jako poslední %%TODO(AGGREGATE) 
        _x.lval:=lval;
        _x.hval:=hval;
      #if cc_choice=cc_choice_array then;
        _x.val:=imm;
      #end if;
        clist.list^ & _x;
      #if cc_choice<>cc_choice_array then;
        end if;
      #end if;

  -- někde mezi
  else
  #if cc_choice=cc_choice_array then;
    unimplemented({UNIMP=}000131);
  #else;
    -- zjistit, kde leží dolní mez přidávaného intervalu
    i:=1;
    ui1:=lval-ui_1;
    loop
      -- leží před tímto intervalem
      if lval<clist.list^[i].lval then
        lval_pos:=tbp_between;
        break;

      -- leží v tomto intervalu
      elsif lval<=clist.list^[i].hval then
        lval_pos:=tbp_inside;
        break;

      -- leží těsně za tímto intervalem
      elsif ui1=clist.list^[i].hval then
        lval_pos:=tbp_attached;
        break;
        end if;

      -- další interval
      succ i;
      verify({VERIFY=}000533,i>clist.list^:length);
      end loop;

    -- zjistit, kde leží horní mez přidávaného intervalu
    j:=clist.list^:length;
    ui1:=hval-ui_1;
    loop
      -- leží za tímto intervalem
      if hval>clist.list^[j].hval then
        hval_pos:=tbp_between;
        break;

      -- leží v tomto intervalu
      elsif hval>=clist.list^[j].lval then
        hval_pos:=tbp_inside;
        break;

      -- leží těsně před tímto intervalem
      elsif ui1=clist.list^[i].lval then
        hval_pos:=tbp_attached;
        break;
        end if;

      -- další interval
      pred j;
      verify({VERIFY=}000534,j=0);
      end loop;

    -- každá mez intervalu leží v nějakém jiném intervalu
    if (lval_pos=tbp_inside) and (hval_pos=tbp_inside) then
      -- zahrnuje více intervalů ?
      if j>i then
        -- horní mez J-tého intervalu převzít do I-tého
        clist.list^[i].hval:=clist.list^[j].hval;

        -- zrušit (I+1)-ní až J-tý interval
        delint(i+1,j);
        end if;

    -- každá mez leží těsně vedle jiného intervalu
    elsif ((lval_pos=tbp_attached) and (hval_pos=tbp_attached))
    -- nebo levá leží těsně vedle a pravá uvnitř
    or ((lval_pos=tbp_attached) and (hval_pos=tbp_inside))
    -- nebo pravá leží těsně vedle a levá uvnitř
    or ((lval_pos=tbp_inside) and (hval_pos=tbp_attached))
    then
      -- horní mez J-tého intervalu převzít do I-tého
      clist.list^[i].hval:=clist.list^[j].hval;

      -- zrušit (I+1)-ní až J-tý interval
      delint(i+1,j);

    -- celý interval spadá mezi dva intervaly
    elsif (lval_pos=tbp_between) and (hval_pos=tbp_between) and (i=j+1) then
      -- realokovat paměť
      choice_extend(clist,1);

      -- udělat místo v první položce
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i],clist.list^[i+1],(clist.list^:length-i+1)*clist.list^[1]:size);
      succ clist.list^:length;

      -- přidat interval
      clist.list^[i].lval:=lval;
      clist.list^[i].hval:=hval;

    -- celý interval obklopuje jeden či více intervalů
    elsif (lval_pos=tbp_between) and (hval_pos=tbp_between) and (i<=j) then
      -- prodloužit interval            
      clist.list^[i].lval:=lval;
      clist.list^[i].hval:=hval;

      -- zrušit (I+1)-ní až J-tý interval
      if i<j then
        delint(i+1,j);
        end if;

    -- levá mez leží těsně za či uvnitř intervalu, pravá mezi
    elsif (lval_pos in tboundaryposset:[tbp_inside,tbp_attached]) and (hval_pos=tbp_between) then
      -- prodloužit I-tý interval
      clist.list^[i].hval:=hval;

      -- zrušit (I+1)-ní až J-tý interval
      if j>i then
        delint(i+1,j);
        end if;

    -- pravá mez leží těsně před či uvnitř intervalu, levá mezi
    elsif (lval_pos=tbp_between) and (hval_pos in tboundaryposset:[tbp_inside,tbp_attached]) then
      -- prodloužit J-tý interval
      clist.list^[j].lval:=lval;

      -- zrušit I-tý až (J-1)-ní interval
      if j>i then
        delint(i,j-1);
        end if;

    -- jiné případy nemohou nastat
    else 
      verify({VERIFY=}000459,true);
      end if;
  #end if;
    end if;
  end choice_add_range;
