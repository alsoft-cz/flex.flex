----------------------------------------------------------------------------------------------------
module private cx_parse =
-- Překladač Flexu.
-- Syntaktická analýza výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 01.08.2001 : Vytvořil.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure a_jvyraz : texprparseproc;
-- Jednoduchý výraz.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure addoper (
    expr           : in out pexpnode;            -- výraz
    op             : in expopertype;             -- operátor
    assign         : in t_logical;               -- T-přiřazení
    pos            : in lexposblock;             -- pozice operátoru
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Do výrazu doplní binární operátor.
----------------------------------------------------------------------------------------------------
begin
  -- zvýšit strom
  newtree(expr,info,nt_operator);

  -- dosadit operátor
  pexpoper(expr)^.setoper(op,assign);

  -- pozice uzlu
  expr^.setpos(pos);
  end addoper;



----------------------------------------------------------------------------------------------------
procedure addunary (
    expr           : in out pexpnode;            -- výraz
    un             : in expunarytype;            -- operátor
    assign         : in t_logical;               -- T-přiřazení
    pos            : in lexposblock;             -- pozice operátoru
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Do výrazu doplní unární operátor.                                          
----------------------------------------------------------------------------------------------------
begin
  -- zvýšit strom 
  newtree(expr,info,nt_unary);

  -- dosadit operátor 
  pexpunary(expr)^.setoper(un,assign);

  -- pozice uzlu 
  expr^.setpos(pos);
  end addunary;



----------------------------------------------------------------------------------------------------
procedure a_komponenta : texprparseproc =
-- Selektor komponenty.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol                            

begin
  -- identifikátor 
  getlex(curr,lex);
  case lex
    -- identifikátor => komponenta 
    when lex_id do
        -- zvýšit strom
        newtree(expr,info,nt_component);

        -- dosadit identifikátor
        pexpcomponent(expr)^.setid(getlexid()^);
{
    -- Ondra 16.7.2003 : Explicitní volání speciálních metod zakázáno.
    -- ENTRY
    when lex_entry do
        -- zvýšit strom
        newtree(expr,info,nt_callspec);

        -- dosadit typ speciální metody
        pexpcallspec(expr)^.spectype:=tst_entry;

    -- EXIT
    when lex_exit do
        -- zvýšit strom
        newtree(expr,info,nt_callspec);

        -- dosadit typ speciální metody
        pexpcallspec(expr)^.spectype:=tst_exit;

    -- ADJUST
    when lex_adjust do
        -- zvýšit strom
        newtree(expr,info,nt_callspec);

        -- dosadit typ speciální metody
        pexpcallspec(expr)^.spectype:=tst_adjust;
}
    -- nic jiného není selektor
    when others do
        ce^.seterror({CCERR=}000484,ce_x_id);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;

  -- pozice uzlu 
  if expr^.sub<>nil
    then expr^.loadpos(nps_begin,ll_prev);
    else expr^.loadpos(nps_begin,ll_curr);
    end if;
  expr^.loadpos(nps_end,  ll_curr);
  end a_komponenta;



----------------------------------------------------------------------------------------------------
procedure a_pole : texprparseproc =
-- Selektor pole.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol                            

begin
  loop
    -- vznikl nový uzel 
    newtree(expr,info,nt_index);

    -- počáteční pozice uzlu 
    expr^.loadpos(nps_begin,ll_curr);

    -- výběr 
    a_vyber(curr,expr^.sub^.next,info);

    -- koncová pozice uzlu 
    expr^.loadpos(nps_end,ll_curr);

    -- čárka nebo pravá hranatá závorka 
    until not checklex(curr,lex_comma);

  -- pravá hranatá závroka 
  if followlex(curr,lex_rbra) then
    ce^.seterror({CCERR=}000485,ce_x_rbra);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end a_pole;



----------------------------------------------------------------------------------------------------
procedure a_deref : texprparseproc =
-- Dereference.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol                            

begin
  -- vznikl nový uzel 
  newtree(expr,info,nt_deref);

  -- Ondra 11.10.2001 : Poznamenat do jména, že se jméno bude dereferencovat
  expr^.sub^.nflags+nodeflagset:[nf_dereference];

  -- pozice
  expr^.loadpos(nps_both,ll_curr);
  end a_deref;



----------------------------------------------------------------------------------------------------
procedure a_agregat : texprparseproc =
-- Agregát.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  last             : pexpitem;                   -- prvek agregátu
  choice           : pexpnode;                   -- výběr                                       
  pozicni          : t_logical;                  -- T-jsou povoleny poziční parametry           

begin
  -- vznikl nový uzel 
  newtree(expr,info,nt_aggregate);
  if expr^.sub=nil then pexplist(expr)^.qualified:=false; end if;

  -- pozice 
  expr^.loadpos(nps_begin,ll_curr);

  -- %%TECH Pozor: Podvýrazy jsou uspořádány trochu nelogicky. Vazba FOR Výběr USE Výraz vytvoří 
  -- strom ve tvaru:                              
  --                                                                          
  --       o  EXPR  = NT_ITEM                                                  
  --       |                                                                  
  --       | SUB      SUB^.NEXT                                               
  --       +--------+                                                         
  --     Výraz    Výběr                                                       
  --                                                                          
  -- Lépe se s tím pracuje v další analýze, protože Výběr není vždy uveden.   

  looklex(curr,lex);
  if lex<>lex_rbra then
    last:=nil;
    pozicni:=true;
    loop
      -- nový prvek agregátu 
      if last=nil
        then
          newnode(pexpnode(last),info,nt_item);
          if pexplist(expr)^.qualified
            then expr^.sub^.next:=last
            else expr^.sub:=last;
            end if;
        else
          newnode(last^.next,info,nt_item);
          pexpnode(last):=last^.next;
          end if;

      -- mohlo by být FOR 
      if checklex(curr,lex_for)

        -- FOR Výběr USE / FOR OTHERS USE 
        then
          if checklex(curr,lex_others)

            -- OTHERS 
            then
              -- typ složky 
              last^.itype:=ei_others;

            -- výběr 
            else
              -- typ složky 
              last^.itype:=ei_choice;

              -- výběr 
              choice:=nil;
              a_vyber(curr,choice,info);
              end if;

          -- USE 
          if followlex(curr,lex_use) then
            ce^.seterror({CCERR=}000486,ce_x_use);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- dále jsou povoleny jen klíčové prvky 
          pozicni:=false;

        -- není 
        else
          -- typ složky 
          last^.itype:=ei_expr;

          -- jsou povoleny poziční prvky ? 
          if not pozicni then
            ce^.seterror({CCERR=}000487,ce_i_parorder);
            ce^.setinfo(hint_expr_positional_item);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          end if;

      -- hodnota složky (obecně výběr) 
      a_vyber(curr,last^.sub,info);

      -- nezapomenout do výrazu zařadit FOR Výběr USE 
      if last^.itype=ei_choice then last^.sub^.next:=choice; end if;

      -- bylo to FOR OTHERS USE, nic dalšího nesmí následovat 
      -- čárka nebo pravá hranatá závorka 
      until (last^.itype=ei_others) or not checklex(curr,lex_comma);
    end if;

  -- pravá hranatá závroka 
  if followlex(curr,lex_rbra) then
    ce^.seterror({CCERR=}000488,ce_x_rbra);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- pozice 
  expr^.loadpos(nps_end,ll_curr);
  end a_agregat;



----------------------------------------------------------------------------------------------------
procedure a_atribut : texprparseproc =
-- Atribut.
----------------------------------------------------------------------------------------------------
with
  cc_attr;
  
var
  id               : pentityident;               -- identifikátor atributu
        
begin
  -- zvýšit strom
  newtree(expr,info,nt_attrib);

  -- počáteční pozice
  expr^.loadpos(nps_begin,ll_curr);

  -- identifikátor atributu
  a_attrid(curr,id);
  pexpattrib(expr)^.setid(id^);

{
  -- parametry atributu 
  if checklex(curr,lex_lpar) then
    u_nimplemented(39);
    end if;
}
  -- koncová pozice uzlu 
  expr^.loadpos(nps_end,ll_curr);
  end a_atribut;

                 

----------------------------------------------------------------------------------------------------
procedure a_interface_cast : texprparseproc =
-- Interface cast.
----------------------------------------------------------------------------------------------------
begin
  -- zvýšit strom
  newtree(expr,info,nt_interface_cast);

  -- počáteční pozice
  expr^.loadpos(nps_begin,ll_curr);

  -- jméno instance třídy nebo pointeru na ní
  a_jmeno(curr,expr^.sub^.next,info);

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000489,ce_x_rpar);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- koncová pozice uzlu 
  expr^.loadpos(nps_end,ll_curr);
  end a_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_list : texprparseproc =
-- Seznam.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  lex2             : lexsym;                     -- lexikální symbol
  last             : pexpitem;                   -- poslední uzel v seznamu
  pozicni          : t_logical;                  -- T-jsou povoleny poziční parametry
  id               : pentityident;               -- identifikátor parametru

begin
  -- zvýšit strom 
  newtree(expr,info,nt_list);

  -- počáteční pozice uzlu 
  expr^.loadpos(nps_begin,ll_curr);

  -- ze začátku jsou dovoleny poziční parametry 
  pozicni:=true;

  last:=nil;
  loop
    -- další symbol 
    getlex(curr,lex);

    -- jestliže seznam neobsahuje vůbec nic (jen prázdné závorky "()"), tak hned zkončit
    if last=nil and then lex=lex_rpar then
      return;
      end if;

    -- vznikl nový uzel 
    if last=nil
      then
        newnode(pexpnode(last),info,nt_item);
        expr^.sub^.next:=last;
      else
        newnode(last^.next,info,nt_item);
        pexpnode(last):=last^.next;
        end if;

    case lex
      -- implicitní hodnota
      when lex_comma,lex_rpar do
          -- jsou povoleny poziční parametry ?
          if not pozicni then
            ce^.seterror({CCERR=}000490,ce_i_parorder);
            ce^.setinfo(hint_expr_positional_par);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- typ parametru
          last^.itype:=ei_empty;

          -- pozice uzlu
          last^.loadpos(nps_both,ll_curr);

          -- symbol vrátit zpět do vstupu
          ungetlex;

      -- FOR id USE
      when lex_for do
          -- počáteční pozice uzlu
          last^.loadpos(nps_begin,ll_curr);

          -- identifikátor nebo OTHERS
          getlex(curr,lex);
          if lex not in lexsymset:[lex_others,lex_id] then
            ce^.seterror({CCERR=}000491,ce_x_id_others);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;
          if lex=lex_id then
            id:=getlexid;
            end if;

          -- USE
          getlex(curr,lex2);
          if lex2<>lex_use then
            ce^.seterror({CCERR=}000492,ce_x_use);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- typ parametru
          case lex
            when lex_id do
                last^.itype:=ei_ident;
                last^.setid(id^);
            when lex_others do 
                last^.itype:=ei_others;
            when others do verify({VERIFY=}000049,true);
            end case;

          -- výraz
          a_vyraz(curr,last^.sub,info);

          -- koncová pozice parametru
          last^.loadpos(nps_end,ll_curr);

          -- po FOR OTHERS USE nesmí následovat další parametry
          if lex=lex_others then
            getlex(curr,lex);
            if lex<>lex_rpar then
              ce^.seterror({CCERR=}000493,ce_x_rpar);
              ce^.setinfo(hint_expr_last_par);
              ce^.loadpos;
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
              end if;
            break;
            end if;

          -- dále nejsou povoleny poziční parametry
          pozicni:=false;

      -- výraz
      when others do
          -- symbol vrátit zpět do vstupu
          ungetlex;

          -- jsou povoleny poziční parametry ?
          if not pozicni then
            ce^.seterror({CCERR=}000494,ce_i_parorder);
            ce^.setinfo(hint_expr_positional_par);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- typ parametru
          last^.itype:=ei_expr;

          -- počáteční pozice uzlu
          last^.loadpos(nps_begin,ll_curr);

          -- výraz
          a_vyraz(curr,last^.sub,info);

          -- koncová pozice parametru
          last^.loadpos(nps_end,ll_curr);
      end case;

    -- bylo to FOR OTHERS USE, nic dalšího nesmí následovat
    -- čárka nebo pravá hranatá závorka
    until last^.itype=ei_others or not checklex(curr,lex_comma);

  -- pravá závorka 
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000495,ce_x_rpar);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- koncová pozice uzlu 
  expr^.loadpos(nps_end,ll_curr);
  end a_list;



----------------------------------------------------------------------------------------------------
procedure a_selektor : texprparseproc =
-- Selektor.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol                            

begin
  loop
    -- přečíst ze vstupu lexikální symbol 
    getlex(curr,lex);

    case lex
      -- selektor komponenty
      when lex_dot      do a_komponenta(curr,expr,info);

      -- selektor pole
      when lex_lbra     do a_pole(curr,expr,info);

      -- dereference
      when lex_ptr      do a_deref(curr,expr,info);

      -- atribut, kvalifikovaný agregát nebo interface cast
      when lex_col      do
          -- přečíst ze vstupu lexikální symbol
          getlex(curr,lex);
          case lex

            -- kvalifikovaný agregát
            when lex_lbra do a_agregat(curr,expr,info)

            -- interface cast
            when lex_lpar do a_interface_cast(curr,expr,info);

            -- mohl by to být atribut
            when others do
                -- naposledy přečtený symbol vrátit do vstupu
                ungetlex;

                -- atribut
                a_atribut(curr,expr,info);
            end case;

      -- seznam
      when lex_lpar     do a_list(curr,expr,info);

      -- cokoliv jiného již není selektor
      when others       do
          ungetlex;
          break;
      end case;
    end loop;
  end a_selektor;



----------------------------------------------------------------------------------------------------
procedure a_current : texprparseproc =
-- Vazba CURRENT.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  entity           : tcurrentity;                -- zvolená entita

begin
  -- zvýšit strom
  newtree(expr,info,nt_current);

  -- počáteční pozice
  expr^.loadpos(nps_begin,ll_curr);

  -- klíčové slovo 
  getlex(curr,lex);

  -- vyhledat v tabulce entit 
  entity:=entity:first;
  while (entity<entity:last) and (currentityinfo[entity].lex<>lex) loop succ entity; end loop;
  if currentityinfo[entity].lex<>lex then
    ce^.seterror({CCERR=}000496,ce_x_current_selector);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- poznamenat entitu do uzlu 
  pexpcurrent(expr)^.entity:=entity;

  -- koncová pozice uzlu 
  expr^.loadpos(nps_end,ll_curr);
  end a_current;



----------------------------------------------------------------------------------------------------
procedure a_jmeno =
-- Základní člen.
----------------------------------------------------------------------------------------------------
with
  cx_imm;
  
var
  lex              : lexsym;                     -- lexikální symbol                            

begin
  -- %%OLD ve staré verzi se reference zpracovávaly v rámci této procedury    
  -- ale to A) neodpovídalo BNF a B) způsobovalo konflikt v gramatice         
  -- s deklarací pointeru.                                                    

  -- přečíst ze vstupu lexikální symbol 
  getlex(curr,lex);

  case lex
    -- identifikátor nebo jméno speciální metody 
    -- Ondra 16.7.2003 : Explicitní volání speciálních metod zakázáno.
    when lex_id {, lex_entry, lex_exit, lex_adjust} do
        -- naposledy přečtený symbol vrátit do vstupu
        ungetlex;

        -- je to vlastně první komponenta
        a_komponenta(curr,expr,info);

    -- literál: celé číslo
    when lex_numi do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_integer_literal;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_ordinal(pexpimm(expr)^.imm,getlexui{src.sfile^.lastval.ui});

    -- literál: reálné číslo
    when lex_numr do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_real_literal;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_real(pexpimm(expr)^.imm,getlexur{src.sfile^.lastval.ur});

    -- literál: univerzální konstanta
    when lex_nil do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_nil_literal;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_nil(pexpimm(expr)^.imm);

    -- literál: znak
    when lex_char do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_character_literal;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_ordinal(pexpimm(expr)^.imm,getlexui{src.sfile^.lastval.ui});

    -- znakový agregát
    when lex_str do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_character_aggregate;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_string(pexpimm(expr)^.imm,getlexstring{src.sfile^.lastval.pocet,src.sfile^.lastval.prvky});

    -- metaliterál: true, false
    when lex_meta_true, lex_meta_false do
        -- vznikl novy uzel
        newnode(expr,info,nt_imm);
        pexpimm(expr)^.immkind:=iek_logical_metaliteral;

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

        -- ulozit konstantu
        store_ordinal(pexpimm(expr)^.imm,unsigned_to_uniint((lex=lex_meta_true):ord));


    -- THIS
    when lex_this do
        -- vznikl novy uzel
        newnode(expr,info,nt_this);

        -- pozice uzlu
        expr^.loadpos(nps_both,ll_curr);

    -- CURRENT
    when lex_current do a_current(curr,expr,info);

    -- agregát
    when lex_lbra do a_agregat(curr,expr,info);

    -- ( výraz )
    when lex_lpar do
        -- výraz
        a_vyraz(curr,expr,info);

        -- pravá závorka
        getlex(curr,lex);
        if lex<>lex_rpar then
          ce^.seterror({CCERR=}000497,ce_x_rpar);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;

        -- uzávorkování
        expr^.nflags:=nodeflagset:[nf_parenthesized];

        --%%X pozice i se závorkama

    -- cokoliv jiného je chyba
    when others do
        ce^.seterror({CCERR=}000498,ce_x_ex_jmeno);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
    end case;

  -- selektor
  a_selektor(curr,expr,info);

  -- výraz je jméno 
  expr^.nflags+nodeflagset:[nf_name];
  end a_jmeno;



----------------------------------------------------------------------------------------------------
procedure a_cinitel : texprparseproc =
-- Činitel.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  lexun            : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice operátoru
  reflist          : pexpnode;                   -- seznam referencí                            

begin
  -- další symbol 
  getlex(curr,lexun);

  -- je tam unární operátor 
  if lexun in lexsymset:[lex_not,lex_abs,lex_succ,lex_pred]
    then
      -- pozice
      getlexposall(pos,ll_curr);

      -- další symbol 
      getlex(curr,lex)
    else
      lex:=lexun;
      end if;

  -- reference 
  reflist:=nil;
  while lex=lex_ptr loop
    -- zvýšit strom 
    if reflist=nil
      then
        newnode(reflist,info,nt_ref);
        expr:=reflist;
      else
        newnode(reflist^.sub,info,nt_ref);
        reflist:=reflist^.sub;
        end if;

    -- pozice 
    reflist^.loadpos(nps_both,ll_curr);

    -- další symbol 
    getlex(curr,lex);
    end loop;

  -- posledně přečtený prvek vrátit zpět do vstupu 
  ungetlex;

  -- jméno 
  if reflist=nil
    then a_jmeno(curr,expr,info)
    else
      -- zpracovat jméno
      a_jmeno(curr,reflist^.sub,info);

      -- Ondra 18.9.2001 : Poznamenat do jména, že se jméno bude referencovat
      reflist^.sub^.nflags+nodeflagset:[nf_reference];
      end if;

  -- doplnit unární operátor 
  if lexun in lexsymset:[lex_not,lex_abs,lex_succ,lex_pred] then
    -- doplnit operátor 
    addunary(expr,lextounaryoper(lexun),false,pos,info);
    end if;
  end a_cinitel;



----------------------------------------------------------------------------------------------------
procedure a_clen_chain (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpnode;            -- výraz
    _op            : in expopertype;             -- operátor
    assign         : in t_logical;               -- T-přiřazení
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Multiplikační operátor Činitel.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice operátoru
  op               : expopertype;

begin
  op:=_op;
  while op in expopertypeset:[op_mul,op_div,op_idiv,op_imod,op_shl,op_shr] loop
    -- doplnit operátor 
    getlexposall(pos,ll_curr);
    addoper(expr,op,assign,pos,info);

    -- činitel 
    a_cinitel(curr,expr^.sub^.next,info);

    -- aritmetický operátor 
    getlex(curr,lex);
    op:=lextobinaryoper(lex);
    end loop;

  -- naposledy přečtený symbol vrátit do vstupu 
  ungetlex;
  end a_clen_chain;



----------------------------------------------------------------------------------------------------
procedure a_clen : texprparseproc =
-- Člen.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- činitel
  a_cinitel(curr,expr,info);

  -- multiplikační operátor
  getlex(curr,lex);

  -- Multiplikační operátor Činitel
  a_clen_chain(curr,expr,lextobinaryoper(lex),false,info);
  end a_clen;



----------------------------------------------------------------------------------------------------
procedure a_qclen : texprparseproc =
-- Kvalifikovaný člen.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice operátoru

begin
  -- %%X tohle není ještě zcela jasné, zda to tak bude

  -- člen
  a_clen(curr,expr,info);

  -- kvalifikační operátor
  getlex(curr,lex);

  if lex=lex_op1

    -- je tam kvalifikační operátor 
    then
      -- doplnit operátor 
      getlexposall(pos,ll_curr);
      addoper(expr,op_op1,false,pos,info);

      -- člen 
      a_clen(curr,expr^.sub^.next,info);

    -- není tam kvalifikační operátor 
    else
      ungetlex;
      end if;
  end a_qclen;



----------------------------------------------------------------------------------------------------
procedure a_jvyraz_chain (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpnode;            -- výraz
    _op            : in expopertype;             -- operátor
    assign         : in t_logical;               -- T-přiřazení
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Adiční operátor Kvalifikovaný člen.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice operátoru
  op               : expopertype;

begin
  op:=_op;
  while op in expopertypeset:[op_add,op_sub,op_concat] loop
    -- doplnit operátor
    getlexposall(pos,ll_curr);
    addoper(expr,op,assign,pos,info);

    -- kvalifikovaný člen
    a_qclen(curr,expr^.sub^.next,info);

    -- aritmetický operátor
    getlex(curr,lex);
    op:=lextobinaryoper(lex);
    end loop;

  -- naposledy přečtený symbol vrátit do vstupu
  ungetlex;
  end a_jvyraz_chain;



----------------------------------------------------------------------------------------------------
procedure a_jvyraz =
-- Jednoduchý výraz.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice operátoru

begin
  -- unární operátor, pokud existuje
  getlex(curr,lex);

  if lex in lexsymset:[lex_add,lex_sub]

    -- je tam unární operátor
    then
      -- doplnit operátor
      getlexposall(pos,ll_curr);
      addunary(expr,lextounaryoper(lex),false,pos,info);

      -- kvalifikovaný člen
      a_qclen(curr,expr^.sub,info);

    -- není tam unární operátor
    else
      -- naposledy přečtený symbol vrátit do vstupu
      ungetlex;

      -- kvalifikovaný člen
      a_qclen(curr,expr,info);
      end if;

  -- adiční operátor
  getlex(curr,lex);

  -- Adiční operátor Člen
  a_jvyraz_chain(curr,expr,lextobinaryoper(lex),false,info);
  end a_jvyraz;



----------------------------------------------------------------------------------------------------
procedure a_vyber =
-- Výběr.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- výraz nebo rozsah
  a_vyraz(curr,expr,info);

  -- může to být rozsah (řez pole)
  if checklex(curr,lex_ddot) then
    -- %%X Výraz musí být Jednoduchý výraz
    --u_nimplemented(35);

    -- zvýšit strom
    newtree(expr,info,nt_range);

    -- pozice uzlu
    expr^.loadpos(nps_both,ll_curr);

    -- jednoduchý výraz
    a_jvyraz(curr,expr^.sub^.next,info);
    end if;
  end a_vyber;



----------------------------------------------------------------------------------------------------
procedure a_rozsah =
-- Rozsah.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- jednoduchý výraz 
  a_jvyraz(curr,expr,info);

  -- další symbol 
  getlex(curr,lex);
  if lex=lex_ddot

    -- je tam rozsah
    then
      -- zvýšit strom
      newtree(expr,info,nt_range);

      -- pozice uzlu
      expr^.loadpos(nps_both,ll_curr);

      -- jednoduchý výraz
      a_jvyraz(curr,expr^.sub^.next,info);

    -- není, symbol se nás netýkal
    else
      ungetlex;
      end if;
  end a_rozsah;



----------------------------------------------------------------------------------------------------
procedure a_relace : texprparseproc =
-- Relace.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  lex2             : lexsym;                     -- následující lexikální symbol
  pos              : lexposblock;                -- pozice operátoru

begin
  -- jednoduchý výraz
  a_jvyraz(curr,expr,info);

  -- relační operátor
  getlex(curr,lex);

  -- relační operátor
  if lex in lexsymset:[lex_eq,lex_ne,lex_lt,lex_le,lex_gt,lex_ge] then
    -- doplnit operátor
    getlexposall(pos,ll_curr);
    addoper(expr,lextobinaryoper(lex),false,pos,info);

    -- jednoduchý výraz
    a_jvyraz(curr,expr^.sub^.next,info);

  -- množinový relační operátor
  elsif lex in lexsymset:[lex_in,lex_not] then
    -- začátek operátoru 
    getlexpos(pos.b,ll_curr,false);

    -- po NOT musí následovat IN 
    if lex=lex_not then
      getlex(curr,lex2);
      if lex2<>lex_in then
        ce^.seterror({CCERR=}000499,ce_x_in);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;
      end if;

    -- konec operátoru
    getlexpos(pos.e,ll_curr,true);

    -- doplnit operátor
    addoper(expr,lextobinaryoper(lex),false,pos,info);

    -- rozsah/množina
    a_rozsah(curr,expr^.sub^.next,info);

  -- cokoliv jiného nás nezajímá
  else
    ungetlex;
    end if;
  end a_relace;



----------------------------------------------------------------------------------------------------
procedure a_vyraz_chain (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpnode;            -- výraz
    _lex           : in lexsym;                  -- lexikální symbol
    assign         : in t_logical;               -- T-přiřazení
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Logický operátor Relace.
----------------------------------------------------------------------------------------------------
-- %%TECH Na rozdíl od obdobných procedur A_*_CHAIN se zde nepředává rovnou
-- operátor ale jen lexikální symbol. V procedurách A_VYRAZ a A_PRIKAZ odpadá
-- rozpoznávání AND od AND THEN a OR od OR ELSE.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  lex2             : lexsym;                     -- následující lexikální symbol                
  lexoper          : lexsym;                     -- operátor                                    
  op               : expopertype;                -- operátor                                    
  pos              : lexposblock;                -- pozice operátoru                            

begin
  lex:=_lex;
  lexoper:=lex_nul;
  while lex in lexsymset:[lex_and,lex_or,lex_xor] loop

    -- pozice operátoru 
    getlexposall(pos,ll_curr);

    -- mohlo by to být AND THEN 
    if lex=lex_and then
      getlex(curr,lex2);
      if lex2=lex_then
        then
          getlexpos(pos.e,ll_curr,true);
          lex:=lex2
        else
          ungetlex;
          end if;

    -- nebo OR ELSE
    elsif lex=lex_or then
      getlex(curr,lex2);
      if lex2=lex_else
        then
          getlexpos(pos.e,ll_curr,true);
          lex:=lex2
        else
          ungetlex;
          end if;
      end if;

    if lexoper=lex_nul
      -- je to první operátor v řadě
      then
        -- zapamatovat si ho
        lexoper:=lex;

        -- odvodit operátor
        op:=lextobinaryoper(lex);

      -- je to další operátor
      else
        -- operátor musí být stále stejný
        if lex<>lexoper then
          ce^.seterror({CCERR=}000500,ce_i_operator);
          --%%TODO(LIB) ce^.setinfo(formats2(hint_expr_a_and_b_or_c,nptostr(expopertxt,ord(op)),nptostr(expopertxt,ord(lextobinaryoper(lex)))));
          if lex in lexsymset:[lex_then,lex_else]
            then ce^.loadpos2
            else ce^.loadpos;
            end if;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;
        end if;

    -- doplnit operátor
    addoper(expr,op,assign,pos,info);

    -- relace
    a_relace(curr,expr^.sub^.next,info);

    -- přečíst ze vstupu lexikální symbol
    getlex(curr,lex);
    end loop;

  -- naposledy přečtený symbol vrátit do vstupu
  ungetlex;
  end a_vyraz_chain;



----------------------------------------------------------------------------------------------------
procedure a_vyraz =
-- Výraz.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- relace
  a_relace(curr,expr,info);

  -- logický operátor
  getlex(curr,lex);

  -- Logický operátor Relace
  a_vyraz_chain(curr,expr,lex,false,info);
  end a_vyraz;



----------------------------------------------------------------------------------------------------
procedure a_prikaz =
-- Příkaz.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  un               : expunarytype;               -- unární operátor
  op               : expopertype;                -- binární operátor
  upos             : lexposblock;                -- pozice unárního operátoru
  opos             : lexposblock;                -- pozice binárního operátoru

begin
  un:=un_none;
  op:=op_none;

  -- další symbol
  getlex(curr,lex);

  -- mohl by to být unární operátor
  un:=lextounaryoper(lex);
  if un=un_none
    -- nebyl to unární operátor, vrátit zpět
    then ungetlex

    -- byl to unární operátor, zjistit jeho pozici
    else getlexposall(upos,ll_curr);
    end if;

  -- jméno 
  a_jmeno(curr,expr,info);

  -- další symbol 
  getlex(curr,lex);

  -- zde bych sice mohl rozpoznávat AND od AND THEN a OR od OR ELSE          
  -- ale je to zbytečné, A_VYRAZ_CHAIN, kam obojí spadá, si to rozhodne sama 

  -- mohl by to být binární operátor 
  if lex in lexsymset:[lex_else,lex_then]
    -- LEXTOBINARYOPER by LEX_ELSE a LEX_THEN špatně pochopil
    -- jak OR ELSE resp. AND THEN => zbavit se jich zvlášť
    then op:=op_none
    else op:=lextobinaryoper(lex);
    end if;
  if op=op_none then
    ungetlex;
    end if;

  -- musí být uveden alespoň unární nebo binární operátor
{%%TECH Ano, ale ne když je to zrovna volání procedury.
  takový případ rozliším až ve formální kontrole

  if (un=un_none) and (op=op_none) then
    ce^.seterror({CCERR=}000501,ce_x_assign);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
}
  -- přiřazení současně s unárním operátorem je nepřípustné
  if (op=op_assign) and (un<>un_none) then
    ce^.seterror({CCERR=}000502,ce_i_operator);
    ce^.loadpos;
    ce^.setinfo(hint_expr_unary_and_assign);
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- ve zkráceném přiřazení jsou nepřípustné operátory [ NOT ] IN
  -- %%LANG/%%X Je k tomu důvod ?
  -- Vždyť třeba "B in [false]"
  -- dává docela dobrý smysl
  if op in expopertypeset:[op_in,op_notin] then
    ce^.seterror({CCERR=}000503,ce_i_operator);
    ce^.setinfo(hint_expr_not_in_not_allowed);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- nyní již máme jméno, unární a binární operátor

  -- doplnit unární operátor, má-li prioritu vyšší než binární operátor
  if (un<>un_none) and (op<>op_none) and (expunaryinfo[un].pri>expoperinfo[op].pri) then
    addunary(expr,un,true,upos,info);
    end if;

  -- přeložit zbytek výrazu 
  -- %%TECH tohle by se možná dalo vyřešit nějak lépe tabulkou 
  case op
    -- operátor nebyl uveden 
    when op_none do { nic nedělat };

    -- přiřazení
    when op_assign do
        -- doplnit operátor
        getlexposall(opos,ll_curr);
        addoper(expr,op_assign,true,opos,info);

        -- výraz
        a_vyraz(curr,expr^.sub^.next,info);

    -- adiční operátory
    when op_add, op_sub, op_concat do
        a_jvyraz_chain(curr,expr,op,true,info);

    -- multiplikační operátory
    when op_mul, op_div, op_idiv, op_imod, op_shl, op_shr do
        a_clen_chain(curr,expr,op,true,info);

    -- relační operátory
    when op_eq, op_ne, op_lt, op_le, op_gt, op_ge do
        -- doplnit operátor
        getlexposall(opos,ll_curr);
        addoper(expr,op,true,opos,info);

        -- jednoduchý výraz
        a_jvyraz(curr,expr^.sub^.next,info);

    -- logické operátory
    -- AND THEN a OR ELSE zde nerozpoznávám, až v A_VYRAZ_CHAIN
    when op_and, op_or, op_xor {, op_andthen, op_orelse} do
        a_vyraz_chain(curr,expr,lex,true,info);

    -- různé další operátory
    when op_op1 do
        -- doplnit operátor
        getlexposall(opos,ll_curr);
        addoper(expr,op_op1,true,opos,info);

        -- člen
        a_clen(curr,expr^.sub^.next,info);

    when others do verify({VERIFY=}000013,true);
    end case;

  -- doplnit unární operátor s nižší prioritou
  if (un<>un_none) and ((op=op_none) or (expunaryinfo[un].pri<expoperinfo[op].pri)) then
    addunary(expr,un,true,upos,info);
    end if;
  end a_prikaz;



end cx_parse;
