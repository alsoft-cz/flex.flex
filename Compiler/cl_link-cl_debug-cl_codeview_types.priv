----------------------------------------------------------------------------------------------------
module private cl_codeview_types =
-- Překladač Flexu.
-- Generátor CodeView debug informací - modul pro typy.
----------------------------------------------------------------------------------------------------
-- Radek : 31.01.2003 : Prepsal z FIPu.
----------------------------------------------------------------------------------------------------

with
  standard,
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access,
  cc_def,
  cc_def.cc_unitype,
  cc_base,
  cc_base.cc_sym;

----------------------------------------------------------------------------------------------------
procedure entityident_to_name =
-- Převod identifikátoru entity na jméno v rámci CodeView informací.
----------------------------------------------------------------------------------------------------
with
  standard.characters,
  standard.characters.ascii;

begin
  for i in id:range loop
    result & ascii_char_to_lower(t_char8(id[i]));
    end loop;
  end entityident_to_name;



----------------------------------------------------------------------------------------------------
procedure filename_to_name =
-- Převod identifikátoru entity na jméno v rámci CodeView informací.
----------------------------------------------------------------------------------------------------
with
  standard.characters,
  standard.characters.ascii;

begin
  for i in id:range loop
    result & ascii_char_to_lower(t_char8(id[i]));
    end loop;
  end filename_to_name;



----------------------------------------------------------------------------------------------------
procedure trunc_file_name =
-- Převod identifikátoru entity na jméno v rámci CodeView informací.
----------------------------------------------------------------------------------------------------
with
  standard.characters,
  standard.characters.ascii;

var
  znak             : t_char8;

begin
  for i in reverse id:range loop
    znak:=id[i];
    if znak="\" then 
      break;
      end if;
    result:=znak & result;
    end loop;
  end trunc_file_name;



----------------------------------------------------------------------------------------------------
procedure unsigned_to_name =
-- Převod celého čísla bez znaménka na jméno v rámci CodeView informací.
----------------------------------------------------------------------------------------------------
with
  standard.conversions;

var
  s                : t_char32str;

begin
  s:=unsigned_to_string(x);
  for i in s:range loop
    result & t_char8(s[i]);
    end loop;
  end unsigned_to_name;



----------------------------------------------------------------------------------------------------
procedure register_codeview_dump (
  _base          : in out t_codeview_type_table;
  _dump          : in out p_codeview_type_dump
  ) return t_longint =
-- Zaregistruje dupnuta data a vrati index typu.
----------------------------------------------------------------------------------------------------
begin
  -- vytvorime popis recordu a inicializujeme
  new _dump;

  -- aktualizujeme informace v celkovem prehledu o typech a vratime cislo registrovaneho dumpu
  result:=_base.indextype+$1000;
  _base.indextype:=_base.indextype+1;

  -- zapojime do seznamu dumpnutych typu
  _dump^.prev:=_base.dump_last;
  if _base.dump_last<>nil then _base.dump_last^.next:=_dump; end if;
  if _base.dump_first=nil then _base.dump_first:=_dump; end if;
  _base.dump_last:=_dump;
  end register_codeview_dump;



----------------------------------------------------------------------------------------------------
procedure set_codeview_dump (
    _buffer        : in p_unsigned8array;        -- dumpnuta data
    _size          : in t_unsigned32;            -- velikost dumpnutych dat
    _dump          : in p_codeview_type_dump;    -- nastavovany dump
    _base          : in out t_codeview_type_table
    ) =
-- Zaregistruje dupnuta data a vrati index typu.
----------------------------------------------------------------------------------------------------
begin
  -- vyplnime informace o dumpu typy
  _dump^.buffer:=_buffer;
  _dump^.size:=_size;

  _base.size:=_base.size+_size;
  end set_codeview_dump;



----------------------------------------------------------------------------------------------------
procedure get_codeview_type_container =
-- K zadanenmu typu najde jeho reprezentaci v CodeView strukture.
----------------------------------------------------------------------------------------------------
var
  item             : p_codeview_type;            -- prvek seznamu codeview typu

begin
  -- inicializace
  _container:=nil;
  if _type=nil then
    return;
    end if;

  -- mame k dispozici informaci o debugu?
  if _type<>nil and then _type^.debuginfo<>nil then
    _container:=_type^.debuginfo;
    return;
    end if;

  -- prohledame seznam vsech typu
--  item:=_base.type_first;
--  while item<>nil loop
    -- nalezeno, koncime
--    if item^._type_=_type then
--      _container:=item;
--      result:=true;
--      return;
--      end if;

    -- dalsi typ v seznamu
--    item:=item^.next;
--    end loop;

  -- pokud jsme ho nenasli, musime ho vytvorit
  if _container=nil then
    new _container;
    _container^.status:=tcvs_init;
    _container^._type_:=_type;

    -- ulozime zpetny pointer na deebuginformace z typu
    if _type<>nil then
      _type^.debuginfo:=_container;
      end if;

    _container^.prev:=_base.type_last;
    if _base.type_last<>nil then _base.type_last^.next:=_container; end if;
    _base.type_last:=_container;
    if _base.type_first=nil then _base.type_first:=_container; end if;
    end if;
  end get_codeview_type_container;



----------------------------------------------------------------------------------------------------
procedure code_member_attribute (
    xattribute     : in t_codeview_type_member_attribute
    ) return t_mod_word =
-- Vytvori bitovou mapu attributu.
----------------------------------------------------------------------------------------------------
begin
  -- inicializace
  result:=0;

  -- access protection
  if tctma_noprotection in xattribute then result+$0000
  elsif tctma_private in xattribute then result+$0001
  elsif tctma_protected in xattribute then result+$0002
  elsif tctma_public in xattribute then result+$0003; 
  end if;

  -- method properties
  if tctma_vanillamethod in xattribute then result+$0000
  elsif tctma_virtualmethod in xattribute then result+$0004
  elsif tctma_staticmethod in xattribute then result+$0008
  elsif tctma_friendmethod in xattribute then result+$000C
  elsif tctma_introducingvirtualmethod in xattribute then result+$0010
  elsif tctma_purevirtualmethod in xattribute then result+$0014
  elsif tctma_pureintroducingvirtualmethod in xattribute then result+$0018; 
  end if;

  -- others
  if tctma_pseudo in xattribute then result+$0020; end if;
  if tctma_noinherit in xattribute then result+$0040; end if;
  if tctma_noconstruct in xattribute then result+$0080; end if;
  if tctma_compgenx  in xattribute then result+$0100; end if;
  end code_member_attribute;



----------------------------------------------------------------------------------------------------
procedure generate_st_signed (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_signed.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;

  -- zmena statusu
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- jedna se o primitivni reprezentaci ?
  case primitive_size
    when 1 do _leaf:=lf_t_char;
    when 2 do _leaf:=lf_t_short;
    when 4 do _leaf:=lf_t_long;
    when 8 do _leaf:=lf_t_quad;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000215);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_signed;



----------------------------------------------------------------------------------------------------
procedure generate_st_unsigned (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_unsigned.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- jedna se o primitivni reprezentaci ?
  case primitive_size
    when 1 do _leaf:=lf_t_uchar;
    when 2 do _leaf:=lf_t_ushort;
    when 4 do _leaf:=lf_t_ulong;
    when 8 do _leaf:=lf_t_uquad;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000216);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_unsigned;



----------------------------------------------------------------------------------------------------
procedure generate_st_float (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_float.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- podle velikosti datoveho typu urcime primitivni reprezentaci
  case primitive_size
    when 4  do _leaf:=lf_t_real32;
    when 6  do _leaf:=lf_t_real48;
    when 8  do _leaf:=lf_t_real64;
    when 10 do _leaf:=lf_t_real80;
    when 16 do _leaf:=lf_t_real128;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000217);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_float;



----------------------------------------------------------------------------------------------------
procedure generate_st_fixed (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_fixed.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- podle velikosti datoveho typu urcime primitivni reprezentaci
  case primitive_size
    when 4 do _leaf:=lf_t_long;
    when 8 do _leaf:=lf_t_quad;
--    when 16 do _leaf:=lf_t_???;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000248);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_fixed;



----------------------------------------------------------------------------------------------------
procedure generate_st_char (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_char.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- jedna se o primitivni reprezentaci ?
  case primitive_size
    when 1 do _leaf:=lf_t_rchar;
    when 2 do _leaf:=lf_t_wchar;
    when 4 do _leaf:=lf_t_wchar;
    when 8 do _leaf:=lf_t_uquad;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000219);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_char;



----------------------------------------------------------------------------------------------------
procedure generate_st_tag (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_tag.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- jedna se o primitivni reprezentaci ?
  case primitive_size
    when 1 do _leaf:=lf_t_uchar;
    when 2 do _leaf:=lf_t_ushort;
    when 4 do _leaf:=lf_t_ulong;
    when 8 do _leaf:=lf_t_uquad;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000220);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_tag;



----------------------------------------------------------------------------------------------------
procedure generate_st_logical (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_logical.
----------------------------------------------------------------------------------------------------
var
  primitive_size   : t_unsigned32;               -- velikost primitivniho typu

begin
  -- inicializace
  _primitive:=true;
  _desc:=nil;
  _my^.status:=tcvs_building;

  -- zjistime velikost typu
  primitive_size:=unidata_size_to_unsigned(_type^.size);

  -- jedna se o primitivni reprezentaci ?
  case primitive_size
    when 1 do _leaf:=lf_t_uchar;
    when 2 do _leaf:=lf_t_ushort;
    when 4 do _leaf:=lf_t_ulong;
    when 8 do _leaf:=lf_t_uquad;
    when others do
        -- nelze reprezentovat primitivnim datovym typem
        unimplemented({UNIMP=}000221);
    end case;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_logical;


#if #declared codeview_string; then;
----------------------------------------------------------------------------------------------------
procedure generate_st_string (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_string.
----------------------------------------------------------------------------------------------------
var
  typ              : pentity_type;               -- typ polozky
  cv_typ           : p_codeview_type;            -- typ polozky c codeview reprezentaci
  member           : p_codeview_type_member;     -- popis polozky recordu
  record_field     : p_codeview_type_fieldlist;  -- polozka recordu
  string_array     : p_codeview_type_array;      -- pole reprezentujici string

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_structure;
  _my^.status:=tcvs_building;


  
  -- naalokujeme pamet na popisu delky retezce
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  member^.offset:=uda_0;
  member^.name:='length';
  member^.status:=tcvs_build;

  -- popis velikosti retezce
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.first_field:=record_field;



  -- naalokujeme pamet pro vlastni retezec = pole znaku
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  if _type^.srange.getutype=nil then member^.offset:=uda_0 else member^.offset:=_type^.srange.getctype^.size; end if;
  member^.name:='string';
  member^.status:=tcvs_build;

  -- vytvorime popis stringu a inicializujeme
  new string_array;
  string_array^.status:=tcvs_build;

  -- typ prvku
  typ:=_type^.base.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_elemtype:=cv_typ;

  -- typ indexu
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_idxtype:=cv_typ;

  -- velikost pole
  if _type^.srange.getutype=nil then
    string_array^.length:=_type^.size;
  else
    string_array^.length:=_type^.size-_type^.srange.getctype^.size;
    end if;

  -- zapouzdrime pole celym typem
  new cv_typ;
  cv_typ^.status:=tcvs_build;
  cv_typ^.typ:=lf_array;
  cv_typ^.primitive:=false;
  cv_typ^.desc:=p_codeview_type0(string_array);

  -- a udelame z neho druhou polozku recordu
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.last_field:=record_field;



  -- zretezeni navzajem
  p_codeview_type_record(_desc)^.last_field^.prev:=p_codeview_type_record(_desc)^.first_field;
  p_codeview_type_record(_desc)^.first_field^.next:=p_codeview_type_record(_desc)^.last_field;

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  p_codeview_type_record(_desc)^.name:='';

  -- zmena statusu
  p_codeview_type_record(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_string;

#else;

----------------------------------------------------------------------------------------------------
procedure generate_st_string (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_string.
----------------------------------------------------------------------------------------------------
var
  typ              : pentity_type;               -- typ polozky
  cv_typ           : p_codeview_type;            -- typ polozky c codeview reprezentaci
  member           : p_codeview_type_member;     -- popis polozky recordu
  record_field     : p_codeview_type_fieldlist;  -- polozka recordu
  string_array     : p_codeview_type_array;      -- pole reprezentujici string

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_structure;
  _my^.status:=tcvs_building;



  -- naalokujeme pamet na popisu delky retezce
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  member^.offset:=uda_0;
  member^.name:='length';
  member^.status:=tcvs_build;

  -- popis velikosti retezce
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.first_field:=record_field;



  -- naalokujeme pamet pro vlastni retezec = pole znaku
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  if _type^.srange.getutype=nil 
    then member^.offset:=uda_0 
    else member^.offset:=unidata_size_to_addr(_type^.srange.getctype^.size); 
    end if;
  member^.name:='string';
  member^.status:=tcvs_build;

  -- vytvorime popis stringu a inicializujeme
  new string_array;
  string_array^.status:=tcvs_build;

  -- typ prvku
  typ:=_type^.base.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_elemtype:=cv_typ;

  -- typ indexu
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_idxtype:=cv_typ;

  -- velikost pole
  if _type^.srange.getutype=nil then
    string_array^.length:=_type^.size;
  else
    string_array^.length:=_type^.size-_type^.srange.getutype^.size;
    end if;                     

  -- zapouzdrime pole celym typem
  new cv_typ;
  cv_typ^.status:=tcvs_build;
  cv_typ^.typ:=lf_array;
  cv_typ^.primitive:=false;
  cv_typ^.desc:=p_codeview_type0(string_array);

  -- a udelame z neho druhou polozku recordu
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.last_field:=record_field;



  -- zretezeni navzajem
  p_codeview_type_record(_desc)^.last_field^.prev:=p_codeview_type_record(_desc)^.first_field;
  p_codeview_type_record(_desc)^.first_field^.next:=p_codeview_type_record(_desc)^.last_field;

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  p_codeview_type_record(_desc)^.name:='';

  -- zmena statusu
  p_codeview_type_record(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_string;
#end if;


----------------------------------------------------------------------------------------------------
procedure generate_st_ustring (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_ustring.
----------------------------------------------------------------------------------------------------
var
  typ              : pentity_type;               -- typ polozky
  cv_typ           : p_codeview_type;            -- typ polozky c codeview reprezentaci
  member           : p_codeview_type_member;     -- popis polozky recordu
  record_field     : p_codeview_type_fieldlist;  -- polozka recordu
  string_array     : p_codeview_type_array;      -- pole reprezentujici string

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_structure;
  _my^.status:=tcvs_building;



  -- naalokujeme pamet na popisu delky retezce
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  member^.offset:=uda_0;
  member^.name:='length';
  member^.status:=tcvs_build;

  -- popis velikosti retezce
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.first_field:=record_field;



  -- naalokujeme pamet pro vlastni retezec = pole znaku
  new member;
  member^.attr:=t_codeview_type_member_attribute:[tctma_public];
  if _type^.srange.getutype=nil 
    then member^.offset:=uda_0 
    else member^.offset:=unidata_size_to_addr(_type^.srange.getctype^.size); 
    end if;
  member^.name:='string';
  member^.status:=tcvs_build;

  -- vytvorime popis stringu a inicializujeme
  new string_array;
  string_array^.status:=tcvs_build;

  -- typ prvku
  typ:=_type^.base.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_elemtype:=cv_typ;

  -- typ indexu
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  string_array^.cv_idxtype:=cv_typ;

  -- velikost pole
  if _type^.srange.getutype=nil then
    string_array^.length:=_type^.size;
  else
    string_array^.length:=_type^.size-_type^.srange.getctype^.size;
    end if;

  -- zapouzdrime pole celym typem
  new cv_typ;
  cv_typ^.status:=tcvs_build;
  cv_typ^.typ:=lf_array;
  cv_typ^.primitive:=false;
  cv_typ^.desc:=p_codeview_type0(string_array);

  -- a udelame z neho druhou polozku recordu
  member^.typ:=cv_typ;

  -- vytvorime pro polozku misto
  new record_field;

  -- vyplnime zname veci
  record_field^.status:=tcvs_build;
  record_field^.fieldtype:=lf_member;
  record_field^.fielddesc:=member;

  -- jelikoz bude mit record jen dve polozky zjednodusime si jejich retezeni
  p_codeview_type_record(_desc)^.last_field:=record_field;



  -- zretezeni navzajem
  p_codeview_type_record(_desc)^.last_field^.prev:=p_codeview_type_record(_desc)^.first_field;
  p_codeview_type_record(_desc)^.first_field^.next:=p_codeview_type_record(_desc)^.last_field;

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  p_codeview_type_record(_desc)^.name:='';

  -- zmena statusu
  p_codeview_type_record(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_ustring;



----------------------------------------------------------------------------------------------------
procedure generate_st_array (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_array.
----------------------------------------------------------------------------------------------------
var
  typ              : pentity_type;               -- typ prvku a indexu
  cv_typ           : p_codeview_type;            -- typ v codeview reprezentaci

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_array(_desc);
  p_codeview_type_array(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_array;
  _my^.status:=tcvs_building;

  -- typ prvku
  typ:=_type^.base.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  p_codeview_type_array(_desc)^.cv_elemtype:=cv_typ;

  -- typ indexu
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  p_codeview_type_array(_desc)^.cv_idxtype:=cv_typ;

  -- velikost pole
  p_codeview_type_array(_desc)^.length:=_type^.size;

  -- jmeno pole
  if _type^.id=nil 
    then p_codeview_type_array(_desc)^.name:='' 
    else p_codeview_type_array(_desc)^.name:=entityident_to_name(_type^.id^); 
    end if;

  -- zmena konecneho statusu
  p_codeview_type_array(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_array;



----------------------------------------------------------------------------------------------------
procedure generate_st_uarray (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_uarray.
----------------------------------------------------------------------------------------------------
var
  typ              : pentity_type;               -- typ prvku a indexu
  cv_typ           : p_codeview_type;            -- typ v codeview reprezentaci

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_array(_desc);
  p_codeview_type_array(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_array;
  _my^.status:=tcvs_building;

  -- typ prvku
  typ:=_type^.base.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  p_codeview_type_array(_desc)^.cv_elemtype:=cv_typ;

  -- typ indexu
  typ:=_type^.srange.getutype;
  get_codeview_type_container(typ,_base,cv_typ);
  p_codeview_type_array(_desc)^.cv_idxtype:=cv_typ;

  -- velikost pole
  p_codeview_type_array(_desc)^.length:=unsigned_to_unidata_size($7FFF); {=_type.size;}

  -- jmeno pole
  if _type^.id=nil 
    then p_codeview_type_array(_desc)^.name:='' 
    else p_codeview_type_array(_desc)^.name:=entityident_to_name(_type^.id^); 
    end if;

  -- zmena konecneho statusu
  p_codeview_type_array(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_uarray;



----------------------------------------------------------------------------------------------------
procedure generate_st_record (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_record.
----------------------------------------------------------------------------------------------------
var
  item             : pentity;                    -- deti
  item_type        : pentity_type;               -- typ ditete
  cv_item          : p_codeview_type;            -- dite v codeview
  ancestor         : pentity;                    -- tata a mama
  cv_ancestor      : p_codeview_type;            -- tata a mama v codeview podani
  ri1              : p_codeview_type_fieldlist;  -- polozka recordu



    ------------------------------------------------------------------------------------------------
    procedure create_recorditem (
        _item      : in pentity;                 -- polozka reprezentovana prekladacem
        _itemtype  : in p_codeview_type;         -- codeview typ polozky
        _isvar     : in t_logical;               -- jedna se o skutecnou polozku ?
        _recorditem: out p_codeview_type_fieldlist -- codeview polozka recordu
        ) =
    -- Vytvori polozku recordu.
    ------------------------------------------------------------------------------------------------
    var
      member       : p_codeview_type_member;     -- popis polozky recordu

    begin
      -- naalokujeme pamet na popis polozky
      new member;

      -- nastavime priznak viditelnosti prvku
      case _item^.visible
        when etv_public     do member^.attr:=t_codeview_type_member_attribute:[tctma_public];
        when etv_protected  do member^.attr:=t_codeview_type_member_attribute:[tctma_protected];
        when etv_supervised do member^.attr:=t_codeview_type_member_attribute:[tctma_protected];
        when etv_private    do member^.attr:=t_codeview_type_member_attribute:[tctma_private];
        end case;

      -- typ polozky, jeji offset v recordu, jmeno a status
      member^.typ:=_itemtype;
      if _isvar then member^.offset:=pentity_var(item)^.addr else member^.offset:=uda_0; end if;
      if item^.id=nil then member^.name:='' else member^.name:=entityident_to_name(item^.id^); end if;
      member^.status:=tcvs_build;

      -- vytvorime pro polozku misto
      new _recorditem;

      -- vyplnime zname veci
      _recorditem^.status:=tcvs_build;
      _recorditem^.fieldtype:=lf_member;
      _recorditem^.fielddesc:=member;
      end create_recorditem;

var
  srch             : tentitysearch;

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_structure;
  _my^.status:=tcvs_building;

  -- vytvorime popis polozek
  srch.find_et_first(_type,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- pro zjednodušení
    item:=srch.psym;
    item_type:=pentity_var(item)^.typ.getutype;

    -- a mame u ni definovany typ ?
    get_codeview_type_container(item_type,_base,cv_item);
    if (cv_item<>nil) then
      -- vygenerujeme popis typu polozky
      generate_codeview_type(item_type,cv_item^.typ,cv_item^.primitive,cv_item^.desc,cv_item,_base);

      -- vytvorime polozku
      create_recorditem(item,cv_item,true,ri1);

      -- zaradime ji do seznamu
      ri1^.prev:=p_codeview_type_record(_desc)^.last_field;
      if p_codeview_type_record(_desc)^.last_field<>nil then p_codeview_type_record(_desc)^.last_field^.next:=ri1; end if;
      p_codeview_type_record(_desc)^.last_field:=ri1;
      if p_codeview_type_record(_desc)^.first_field=nil then p_codeview_type_record(_desc)^.first_field:=ri1; end if;
      end if;

    -- dalsi polozka v seznamu
    srch.find_et_next;
    end loop;

  -- zjistime zda jsme neco nezdedili
  ancestor:=_type^.ancestor.getuentity;
  if (ancestor<>nil) and (ancestor^.etype=et_type) then
    -- dohledame si jeho reprezentaci v codeview seznamu
    get_codeview_type_container(pentity_type(ancestor),_base,cv_ancestor);
    if cv_ancestor<>nil then
      -- zpracujeme typ recordu
      generate_codeview_type(pentity_type(ancestor),cv_ancestor^.typ,cv_ancestor^.primitive,
                             cv_ancestor^.desc,cv_ancestor,_base);

      -- bud je predek record, pak navazeme se na jeho polozky...
      if pentity_type(ancestor)^.stype=dt_record then
        -- vlastni record nema zadne polozky, vsechny jsou jen zdedene
        if p_codeview_type_record(_desc)^.first_field=nil then
          p_codeview_type_record(_desc)^.first_field:=p_codeview_type_record(cv_ancestor^.desc)^.last_field;

        -- mame vlastni polozky a navazeme zdedene do retezu pred ne
        else 
          p_codeview_type_record(_desc)^.first_field^.prev:=p_codeview_type_record(cv_ancestor^.desc)^.last_field;
          end if;

      -- ... nebo neco jinyho, coz prohlasime za polozku recordu
      else
        -- vutvorime misto pro dalsi polozku
        create_recorditem(ancestor,cv_ancestor,false,ri1);

        -- a zaradime ji na zacatek seznamu
        ri1^.next:=p_codeview_type_record(_desc)^.first_field;
        if  p_codeview_type_record(_desc)^.first_field<>nil then p_codeview_type_record(_desc)^.first_field^.prev:=ri1; end if;
        p_codeview_type_record(_desc)^.first_field:=ri1;
        if p_codeview_type_record(_desc)^.last_field=nil then p_codeview_type_record(_desc)^.last_field:=ri1; end if;
        end if;

    -- hmm, nenasli - co s tim ?
    else
      {!!!}
      end if;
    end if;

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  if _type^.id=nil 
    then p_codeview_type_record(_desc)^.name:=''
    else p_codeview_type_record(_desc)^.name:=entityident_to_name(_type^.id^);
    end if;
  p_codeview_type_record(_desc)^.status:=tcvs_build;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_record;



----------------------------------------------------------------------------------------------------
procedure generate_st_class (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_class.
----------------------------------------------------------------------------------------------------
var
  item             : pentity;                    -- deti
  item_type        : pentity_type;               -- typ ditete
  cv_item          : p_codeview_type;            -- dite v codeview
  ancestor         : pentity;                    -- tata a mama
  cv_ancestor      : p_codeview_type;            -- tata a mama v codeview podani
  ri1              : p_codeview_type_fieldlist;  -- polozka recordu



    ------------------------------------------------------------------------------------------------
    procedure create_recorditem (
        _item        : in pentity;               -- polozka reprezentovana prekladacem
        _itemtype    : in p_codeview_type;       -- codeview typ polozky
        _isvar       : in t_logical;             -- jedna se o skutecnou polozku ?
        _recorditem  : out p_codeview_type_fieldlist -- codeview polozka recordu
        ) =
    -- Vytvori polozku recordu.
    ------------------------------------------------------------------------------------------------
    var
      member       : p_codeview_type_member;     -- popis polozky recordu

    begin
      -- naalokujeme pamet na popis polozky
      new member;

      -- nastavime priznak viditelnosti prvku
      case _item^.visible
        when etv_public     do member^.attr:=t_codeview_type_member_attribute:[tctma_public];
        when etv_protected  do member^.attr:=t_codeview_type_member_attribute:[tctma_protected];
        when etv_supervised do member^.attr:=t_codeview_type_member_attribute:[tctma_protected];
        when etv_private    do member^.attr:=t_codeview_type_member_attribute:[tctma_private];
        end case;

      -- typ polozky, jeji offset v recordu, jmeno a status
      member^.typ:=_itemtype;
      if _isvar then member^.offset:=pentity_var(item)^.addr else member^.offset:=uda_0; end if;
      if item^.id=nil then member^.name:='' else member^.name:=entityident_to_name(item^.id^); end if;
      member^.status:=tcvs_build;

      -- vytvorime pro polozku misto
      new _recorditem;

      -- vyplnime zname veci
      _recorditem^.status:=tcvs_build;
      _recorditem^.fieldtype:=lf_member;
      _recorditem^.fielddesc:=member;
      end create_recorditem;

var
  srch             : tentitysearch;

begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_class;
  _my^.status:=tcvs_building;

  -- vytvorime popis polozek
  srch.find_et_first(_type,rc_primary,et_var,[]);
  while srch.psym<>nil loop
    -- pro zjednodušení
    item:=srch.psym;
    item_type:=pentity_var(item)^.typ.getutype;

    -- a mame u ni definovany typ ?
    get_codeview_type_container(item_type,_base,cv_item);
    if cv_item<>nil then
      -- zjistit, zda se jedná o metodu
      if item^.etype in tentitytypeset:[et_special,et_static,et_virtual,et_override] then
        -- předat informace specifické pro metodu
        p_codeview_type_proc(cv_item^.desc)^.method:=true;
        p_codeview_type_proc(cv_item^.desc)^.enclosing_class:=_my;
        end if;

      -- vygenerujeme popis typu polozky
      generate_codeview_type(item_type,cv_item^.typ,cv_item^.primitive,cv_item^.desc,cv_item,_base);

      -- vytvorime polozku
      create_recorditem(item,cv_item,true,ri1);

      -- zaradime ji do seznamu
      ri1^.prev:=p_codeview_type_record(_desc)^.last_field;
      if p_codeview_type_record(_desc)^.last_field<>nil then p_codeview_type_record(_desc)^.last_field^.next:=ri1; end if;
      p_codeview_type_record(_desc)^.last_field:=ri1;
      if p_codeview_type_record(_desc)^.first_field=nil then p_codeview_type_record(_desc)^.first_field:=ri1; end if;
      end if;

    -- dalsi polozka v seznamu
    srch.find_et_next;
    end loop;

  -- zjistime zda jsme neco nezdedili
  ancestor:=_type^.ancestor.getuentity;
  if (ancestor<>nil) and (ancestor^.etype in tentitytypeset:[et_type,et_class]) then
    -- dohledame si jeho reprezentaci v codeview seznamu
    get_codeview_type_container(pentity_type(ancestor),_base,cv_ancestor);
    if cv_ancestor<>nil then
      -- zpracujeme typ recordu
      generate_codeview_type(pentity_type(ancestor),cv_ancestor^.typ,cv_ancestor^.primitive,
                             cv_ancestor^.desc,cv_ancestor,_base);

      -- bud je predek record, pak navazeme se na jeho polozky...
      if pentity_type(ancestor)^.stype in tdatatypeset:[dt_class,dt_record] then
        -- vlastni record nema zadne polozky, vsechny jsou jen zdedene
        if p_codeview_type_record(_desc)^.first_field=nil then
          p_codeview_type_record(_desc)^.first_field:=p_codeview_type_record(cv_ancestor^.desc)^.last_field;

        -- mame vlastni polozky a navazeme zdedene do retezu pred ne
        else
          p_codeview_type_record(_desc)^.first_field^.prev:=p_codeview_type_record(cv_ancestor^.desc)^.last_field;
          end if;

      -- ... nebo neco jinyho, coz prohlasime za polozku recordu
      else
        -- vutvorime misto pro dalsi polozku
        create_recorditem(ancestor,cv_ancestor,false,ri1);

        -- a zaradime ji na zacatek seznamu
        ri1^.next:=p_codeview_type_record(_desc)^.first_field;
        if  p_codeview_type_record(_desc)^.first_field<>nil then p_codeview_type_record(_desc)^.first_field^.prev:=ri1; end if;
        p_codeview_type_record(_desc)^.first_field:=ri1;
        if p_codeview_type_record(_desc)^.last_field=nil then p_codeview_type_record(_desc)^.last_field:=ri1; end if;
        end if;

    -- hmm, nenasli - co s tim ?
    else
      {!!!}
      end if;
    end if;

  -- !!! Nejsou dodelany metody !!!

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  if _type^.id=nil 
    then p_codeview_type_record(_desc)^.name:=''
    else p_codeview_type_record(_desc)^.name:=entityident_to_name(_type^.id^);
    end if;
  p_codeview_type_record(_desc)^.status:=tcvs_build;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_class;



----------------------------------------------------------------------------------------------------
procedure generate_st_enum (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_enum.
----------------------------------------------------------------------------------------------------
var
  item             : pentity;                    -- prvek vyctu
  enumname         : p_codeview_type_enum_name;  -- popis prvku
  enumsize         : t_unsigned32;               -- velikost enumu
  ri1              : p_codeview_type_fieldlist;  -- polozka vyctu
  srch             : tentitysearch;

begin
  -- vytvorime popis enumu a inicializujeme
  new p_codeview_type_enum(_desc);
  p_codeview_type_enum(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_enum;
  _my^.status:=tcvs_building;

  -- predzjistime si velikost enumu
  enumsize:=unidata_size_to_unsigned(_type^.size);

  -- vytvorime popis polozek
  srch.find_et_first(_type,rc_primary,et_enum,[]);
  while srch.psym<>nil loop
    -- pro zjednodušení
    item:=srch.psym;

    -- naalokujeme pamet na popis polozky
    new enumname;

    -- nastavime priznak viditelnosti prvku
    case item^.visible
      when etv_public     do enumname^.attr:=t_codeview_type_member_attribute:[tctma_public];
      when etv_protected  do enumname^.attr:=t_codeview_type_member_attribute:[tctma_protected];
      when etv_supervised do enumname^.attr:=t_codeview_type_member_attribute:[tctma_protected];
      when etv_private    do enumname^.attr:=t_codeview_type_member_attribute:[tctma_private];
      end case;

    -- typ hodnoty prvku
    case enumsize
      when 1 do enumname^.typ:=lf_numeric;
      when 2 do enumname^.typ:=lf_ushort;
      when 4 do enumname^.typ:=lf_ulong;
      when others do unimplemented({UNIMP=}000222);
      end case;

    -- vyplnime hodnotu prvku, jmeno a status
    enumname^.value:=uniint_to_signed(pentity_enum(item)^.ordinal);
    if item^.id=nil then enumname^.name:='' else enumname^.name:=entityident_to_name(item^.id^); end if;
    enumname^.status:=tcvs_build;

    -- vytvorime pro polozku misto
    new ri1;

    -- vyplnime zname veci
    ri1^.status:=tcvs_build;
    ri1^.fieldtype:=lf_enumerate;
    ri1^.fielddesc:=enumname;

    -- zaradime ji do seznamu
    ri1^.prev:=p_codeview_type_enum(_desc)^.last_field;
    if p_codeview_type_enum(_desc)^.last_field<>nil then p_codeview_type_enum(_desc)^.last_field^.next:=ri1; end if;
    p_codeview_type_enum(_desc)^.last_field:=ri1;
    if p_codeview_type_enum(_desc)^.first_field=nil then p_codeview_type_enum(_desc)^.first_field:=ri1; end if;

    -- dalsi polozka v seznamu
    srch.find_et_next;
    end loop;

  -- vyplnime zbyle informace o vyctu
  case enumsize
    when 1 do p_codeview_type_enum(_desc)^.typ:=lf_t_uchar;
    when 2 do p_codeview_type_enum(_desc)^.typ:=lf_t_ushort;
    when 4 do p_codeview_type_enum(_desc)^.typ:=lf_t_ulong;
    when others do verify({VERIFY=}001267);
    end case;

  if _type^.id=nil 
    then p_codeview_type_enum(_desc)^.name:=''
    else p_codeview_type_enum(_desc)^.name:=entityident_to_name(_type^.id^);
    end if;

  -- zmena statusu
  p_codeview_type_enum(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_enum;



----------------------------------------------------------------------------------------------------
procedure generate_st_set (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_set.
----------------------------------------------------------------------------------------------------
var
  fields           : t_unsigned32;               -- pocet prvku mnoziny
  bit              : t_unsigned32;               -- bit urcujici pozici prvku
  bajt             : t_unsigned32;               -- byte urcujici pozici prvku
  precorditem      : p_codeview_type_fieldlist;  -- předcházející polozka recordu
  recorditem       : p_codeview_type_fieldlist;  -- polozka recordu
  member           : p_codeview_type_member;     -- typ polozka recordu
  bitfield         : p_codeview_type_bitfield;   -- popis prvku mnoziny
  cv_item          : p_codeview_type;            -- typ prvku v codeview reprezentaci

begin
  -- vytvoříme popis nosiče množiny jako pole

  -- vytvorime popis mnoziny jako record a inicializujeme
  new p_codeview_type_record(_desc);
  p_codeview_type_record(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_structure;
  _my^.status:=tcvs_building;

  -- zjistime pocet prvku mnoziny
  fields:=unidata_size_to_unsigned(_type^.size);

  -- udelame omezeneni na 256 polozek, at debug informace nejsou neumerne velke
  if fields>(256 div 8{bits}) then fields:=256 div 8{bits}; end if;

  -- počet bitů
  fields:=fields*8;

  -- zalozime popis vsech prvku mnoziny
  precorditem:=nil;
  for i in 0..fields-1 loop
    -- vypocteme offset prvku
    bit:=i mod 8;
    bajt:=i div 8;

    -- naalokujeme pamet na popis prvku
    new bitfield;

    bitfield^.length:=1;
    bitfield^.position:=bit;
    bitfield^.status:=tcvs_build;

    -- zjistime popis prvku v reprezetaci prekladace
    get_codeview_type_container(_type^.base.getctype,_base,cv_item);
    bitfield^.cv_typ:=cv_item;

    -- zapouzdrime prvek celym typem
    new cv_item;
    cv_item^.status:=tcvs_build;
    cv_item^.typ:=lf_bit;
    cv_item^.primitive:=false;
    cv_item^.desc:=bitfield;

    -- naalokujeme pamet na popis polozky
    new member;

    -- vyplnime co vime
    member^.attr:=t_codeview_type_member_attribute:[tctma_public];
    member^.offset:=unsigned_to_unidata_addr(bajt);
    member^.name:=unsigned_to_name(i);
    member^.status:=tcvs_build;
    member^.typ:=cv_item;

    -- vytvorime pro polozku misto
    new recorditem;

    -- vyplnime zname veci
    recorditem^.status:=tcvs_build;
    recorditem^.fieldtype:=lf_member;
    recorditem^.fielddesc:=member;

    -- zařadit položku do seznamu
    recorditem^.prev:=precorditem;
    recorditem^.next:=nil;
    if precorditem=nil
      then p_codeview_type_record(_desc)^.first_field:=recorditem;
      else precorditem^.next:=recorditem;
      end if;
    precorditem:=recorditem;
    end loop;

  -- vyplnime zbyle informace o recordu
  p_codeview_type_record(_desc)^.last_field:=recorditem;
  p_codeview_type_record(_desc)^.proper:=[];
  p_codeview_type_record(_desc)^.length:=_type^.size;
  if _type^.id=nil 
    then p_codeview_type_record(_desc)^.name:='';
    else p_codeview_type_record(_desc)^.name:=entityident_to_name(_type^.id^);
    end if;
  p_codeview_type_record(_desc)^.status:=tcvs_build;

  -- zmena statusu
  _my^.status:=tcvs_build;
  end generate_st_set;



----------------------------------------------------------------------------------------------------
procedure generate_st_pointer (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_pointer.
----------------------------------------------------------------------------------------------------
var
  basetype         : pentity_type;               -- bazovy typ pointeru
  cv_basetype      : p_codeview_type;            -- bazovy typ v codeview reprezentaci

begin
  -- vytvorime popis pointeru a inicializujeme
  new p_codeview_type_pointer(_desc);
  p_codeview_type_pointer(_desc)^.status:=tcvs_building;
  _primitive:=false;
  _leaf:=lf_pointer;
  _my^.status:=tcvs_building;

  -- zjistime info o objektu, na ktery pointer ukazuje
  basetype:=_type^.base.getutype;
  get_codeview_type_container(basetype,_base,cv_basetype);

  -- vyplnime zname veci
  p_codeview_type_pointer(_desc)^.typ:=cv_basetype;
  p_codeview_type_pointer(_desc)^.ptrtype:=cpp_near32bit;
  p_codeview_type_pointer(_desc)^.ptrmode:=cpm_pointer; {!!! prozatimni zjednoduseni !!!           }
  p_codeview_type_pointer(_desc)^.isflat32:=true;
  p_codeview_type_pointer(_desc)^.volatile:=false;
  p_codeview_type_pointer(_desc)^.ptrconst:=(_type^.paccess=va_const);
  p_codeview_type_pointer(_desc)^.unaligned:=true;
  p_codeview_type_pointer(_desc)^.restrict:=false;

  -- obsahuje pointer nejake atributy ?
  if _type^.pattrib<>rtattribset:[] then
    {!!! predelat t_pointer na record !!!}
    end if;

  -- zmena statusu
  p_codeview_type_pointer(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_pointer;



----------------------------------------------------------------------------------------------------
procedure generate_st_message (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_message.
----------------------------------------------------------------------------------------------------
begin
  end generate_st_message;



----------------------------------------------------------------------------------------------------
procedure generate_st_procedure (
    _type          : in pentity_type;
    _leaf          : out t_codeview_type_type;
    _primitive     : out t_logical;
    _desc          : out p_codeview_type0;
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Vygeneruje popis typu st_procedure.
----------------------------------------------------------------------------------------------------
with
  cp_cpu.cp_ia32.ci_abi,
  cg_gen.cg_ia32.ci_def;

var
  item             : pentity;                    -- vstupni parametr
  param            : p_codeview_type_argitem;    -- vstupni parametr v reprezentaci codeview
  cv_paramtype     : p_codeview_type;            -- typ parametru v codeview reprezentaci
  cv_paramtypeb    : p_codeview_type;            -- typ odkazovaneho parametru v cv reprezentaci
  paramtype        : pentity_type;               -- typ parametru
  srch             : tentitysearch;

    ------------------------------------------------------------------------------------------------
    procedure generate_st_this (
        _c_cv_type : in out p_codeview_type;     -- codeview typ třídy
        _desc      : out p_codeview_type0) =
    -- Vygeneruje popis skrytého [this] parametru metody jako referenci na třídu metody.
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud jeste neni reference, musime ji vytvorit -
      if _c_cv_type^.reference=nil then
        -- alokujeme pamet pro popis typu
        new cv_paramtype;
        cv_paramtype^.status:=tcvs_build;
        cv_paramtype^.typ:=lf_pointer;
        cv_paramtype^.primitive:=false;

        -- vytvorime popis pointeru a inicializujeme
        new p_codeview_type_pointer(cv_paramtype^.desc);
        p_codeview_type_pointer(cv_paramtype^.desc)^.status:=tcvs_build;

        -- poznamenáme si na třídu již existující referenci
        _c_cv_type^.reference:=cv_paramtype;

        -- vyplnime zname veci
        p_codeview_type_pointer(cv_paramtype^.desc)^.typ:=_c_cv_type;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrtype:=cpp_near32bit;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrmode:=cpm_reference;
        p_codeview_type_pointer(cv_paramtype^.desc)^.isflat32:=true;
        p_codeview_type_pointer(cv_paramtype^.desc)^.volatile:=false;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrconst:=false;
        p_codeview_type_pointer(cv_paramtype^.desc)^.unaligned:=true;
        p_codeview_type_pointer(cv_paramtype^.desc)^.restrict:=false;

      else
        -- reference na typ jiz existuje
        cv_paramtype:=_c_cv_type^.reference;
        end if;

      -- alokujeme pamet pro popis argumentu [this]
      new param;

      -- vyplnime co vime
      param^.typ:=cv_paramtype;

      -- zaradime [this] argument do seznamu na začátek
      param^.next:=p_codeview_type_proc(_desc)^.first_argument;
      if p_codeview_type_proc(_desc)^.first_argument<>nil then p_codeview_type_proc(_desc)^.first_argument^.prev:=param; end if;
      p_codeview_type_proc(_desc)^.first_argument:=param;
      if p_codeview_type_proc(_desc)^.last_argument=nil then p_codeview_type_proc(_desc)^.last_argument:=param; end if;
      end generate_st_this;


begin
  -- vytvorime popis recordu a inicializujeme
  new p_codeview_type_proc(_desc);
  p_codeview_type_proc(_desc)^.status:=tcvs_building;
  _primitive:=false;

  if p_codeview_type_proc(_desc)^.method
    then _leaf:=lf_mfunction;
    else _leaf:=lf_procedure;
    end if;

  _my^.status:=tcvs_building;

  -- projdeme seznam parametru
  -- !!! nutno brat ohled na poradi parametru !!!
  srch.find_et_first(_type,rc_primary,et_param,[]);
  while srch.psym<>nil loop
    -- pro zjednodušení
    item:=srch.psym;

    -- parametry predavane hodnotou zaregistrujeme primo...
    if pentity_param(item)^.pass=pp_value then
      -- zjistime info o typu parametru
      paramtype:=pentity_param(item)^.typ.getutype;
      get_codeview_type_container(paramtype,_base,cv_paramtype);
      if cv_paramtype=nil then
        -- Mame nejakej parametr predavanej hodnotou, ale nemame jeho popis ? To by se size vubec
        -- stat nemelo, ale kdyz uz, tak zvolime nejakej 4 bytovej typ, kterej tam flakneme

        -- alokujeme pamet pro popis typu
        new cv_paramtype;
        cv_paramtype^.status:=tcvs_build;
        cv_paramtype^.typ:=lf_t_ulong;
        cv_paramtype^.primitive:=true;
        end if;

    -- ... pro parametry predavane odkazem vytvorime pomocny t_pointer
    else
      -- otestujeme, zda jiz neexstuje reference na tento typ
      -- zjistime info o typu paramteru
      paramtype:=pentity_param(item)^.typ.getutype;
      get_codeview_type_container(paramtype,_base,cv_paramtypeb);

      -- pokud typ neexistuje nebo pokud pro nej jeste neni reference, musime ji vytvorit -
      if (cv_paramtypeb=nil) or (cv_paramtypeb^.reference=nil) then
        -- alokujeme pamet pro popis typu
        new cv_paramtype;
        cv_paramtype^.status:=tcvs_build;
        cv_paramtype^.typ:=lf_pointer;
        cv_paramtype^.primitive:=false;

        -- vytvorime popis pointeru a inicializujeme
        new p_codeview_type_pointer(cv_paramtype^.desc);
        p_codeview_type_pointer(cv_paramtype^.desc)^.status:=tcvs_build;

        -- pokud jsme typ nasli, poznamename se na nej jiz existujici reerenci
        if cv_paramtypeb<>nil then
          cv_paramtypeb^.reference:=cv_paramtype;
          end if;

        -- vyplnime zname veci
        p_codeview_type_pointer(cv_paramtype^.desc)^.typ:=cv_paramtypeb;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrtype:=cpp_near32bit;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrmode:=cpm_reference; {!!! zjednoduseni !!!  }
        p_codeview_type_pointer(cv_paramtype^.desc)^.isflat32:=true;
        p_codeview_type_pointer(cv_paramtype^.desc)^.volatile:=false;
        p_codeview_type_pointer(cv_paramtype^.desc)^.ptrconst:=false;
        p_codeview_type_pointer(cv_paramtype^.desc)^.unaligned:=true;
        p_codeview_type_pointer(cv_paramtype^.desc)^.restrict:=false;
      else
        -- reference na typ jiz existuje
        cv_paramtype:=cv_paramtypeb^.reference;
        end if;

      end if;

    -- alokujeme pamet pro popis argumentu
    new param;

    -- vyplnime co vime
    param^.typ:=cv_paramtype;

    -- zaradime argument do seznamu
    param^.prev:=p_codeview_type_proc(_desc)^.last_argument;
    if p_codeview_type_proc(_desc)^.last_argument<>nil then p_codeview_type_proc(_desc)^.last_argument^.next:=param; end if;
    p_codeview_type_proc(_desc)^.last_argument:=param;
    if p_codeview_type_proc(_desc)^.first_argument=nil then p_codeview_type_proc(_desc)^.first_argument:=param; end if;

    -- dalsi polozka v seznamu
    srch.find_et_next;
    end loop;

  -- jedná se o metodu
  if p_codeview_type_proc(_desc)^.method then
    -- vygenerovat popis typu skrytého [this] parametru
    generate_st_this(p_codeview_type_proc(_desc)^.enclosing_class,_desc);
    end if;

  -- vyplnime jeste co vime - typ volani...
  case get_call_conv(_type^)
    when icc_default do p_codeview_type_proc(_desc)^.cv_call:=cpc_nearpascal;
    when icc_flex    do p_codeview_type_proc(_desc)^.cv_call:=cpc_nearpascal;
    when icc_system  do p_codeview_type_proc(_desc)^.cv_call:=cpc_nearstdcall;
    when icc_cdecl   do p_codeview_type_proc(_desc)^.cv_call:=cpc_nearc;
    when icc_pascal  do p_codeview_type_proc(_desc)^.cv_call:=cpc_nearpascal;
    end case;

  if (_type^.result<>nil) and (_type^.result^.etype=et_param) then
    -- zjistime info o typu parametru
    paramtype:=_type^.result^.typ.getutype;
    get_codeview_type_container(paramtype,_base,cv_paramtype);

  else
    -- neukazujeme nikam
    cv_paramtype:=nil;
    end if;

  -- ... a navratovou hodnotu
  p_codeview_type_proc(_desc)^.cv_result:=cv_paramtype;

  -- a zmenime status na hotovo
  p_codeview_type_proc(_desc)^.status:=tcvs_build;
  _my^.status:=tcvs_build;
  end generate_st_procedure;



----------------------------------------------------------------------------------------------------
procedure dump_primitive (
    _my            : in p_codeview_type;
    _base          : in t_codeview_type_table
    ) =
-- Dump recordu.
----------------------------------------------------------------------------------------------------
begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  _my^.indextype:=t_longint(codeview_type_type_code[_my^.typ]);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;
  end dump_primitive;



----------------------------------------------------------------------------------------------------
procedure dump_lf_structure (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump recordu.
----------------------------------------------------------------------------------------------------
var
  ri               : p_codeview_type_fieldlist;  -- polozka recordu
  member           : p_codeview_type_member;     -- popis polozky recordu
  fieldlistindex   : t_longint;                  -- index fieldlistu
  memberindex      : t_longint;                  -- index typu v polozce recordu
  itemtype         : p_codeview_type;
  mydump           : p_codeview_type_dump;
  fielddump        : p_codeview_type_dump;
  buffer           : p_unsigned8array;           -- buffer na data
  buffer_size      : t_unsigned;                 -- velikost bufferu
  size             : t_word;                     -- velikost dumpu
  temp_size        : t_word;
  record_size      : t_unsigned32;               -- velikost structury recordu
  item_offset      : t_unsigned32;               -- offset polozky od zacatku recordu
  attr             : t_mod_word;
  b3               : t_unsigned8;


    ------------------------------------------------------------------------------------------------
    procedure dump_lf_method (
        _my        : in p_codeview_type;
        _base      : in out t_codeview_type_table) =
    -- Dump metody.
    ------------------------------------------------------------------------------------------------
    var
      arglistdump      : p_codeview_type_dump;
      arglistindex     : t_longint;
      arg              : p_codeview_type_argitem;-- paramater metody
      attrib           : t_longint;              -- atribut pointeru (pro parametry předávané odkazem)

    begin                                                                                                           
      -- abysme ho nahodou nedumpnuli rekurzivne                                                                    
      _my^.status:=tcvs_dumping;                                                                                    
      arglistindex:=register_codeview_dump(_base,arglistdump);                                                      
      _my^.indextype:=register_codeview_dump(_base,mydump);                                                         
      _my^.leaf:=codeview_type_type_code[_my^.typ];                                                                 
                                                                                                                    
      -- projedeme vsechny paramatery, spocitame je a nechame vygenerovat                                           
      p_codeview_type_proc(_my^.desc)^.parms:=0;                                                                    
      arg:=p_codeview_type_proc(_my^.desc)^.first_argument;                                                         

      -- první parametr je skrytý parametr [this], přeskočit (?)
      arg:=arg^.next;
      
      while arg<>nil loop                                                                                           
        -- udelame dump typu indexu                                                                                 
        dump_codeview_type(arg^.typ,_base);                                                                         
        if arg^.typ^.status<tcvs_dumping then                                                                       
          -- co ted s tim ?                                                                                         
          unimplemented({UNIMP=}000261);                                                                            
          end if;                                                                                                   
                                                                                                                    
        -- dalsi paramater                                                                                          
        p_codeview_type_proc(_my^.desc)^.parms:=p_codeview_type_proc(_my^.desc)^.parms+1;                           
        arg:=arg^.next;                                                                                             
        end loop;                                                                                                   
                                                                                                                    
      -- alokace mista                                                                                              
      buffer_size:=8+(p_codeview_type_proc(_my^.desc)^.parms*4);                                                    
      new buffer range buffer_size;                                                                                 
                                                                                                                    
      size:=buffer_size-2;                                                                                          
      memory_copy(size,buffer^[0],2);                                                                               
      memory_copy(codeview_type_type_code[lf_arglist],buffer^[2],2);                                                
      memory_copy(p_codeview_type_proc(_my^.desc)^.parms,buffer^[4],4);                                             
      size:=8;                                                                                                      
                                                                                                                    
      -- projedeme vsechny paramatery, spocitame je a nechame vygenerovat                                           
      arg:=p_codeview_type_proc(_my^.desc)^.first_argument;                                                         

      -- první parametr je skrytý parametr [this], dumpneme ho jako referenci
      buffer_size:=12;
      size:=buffer_size;

      -- zakodujeme attributy - !!! mama na to nadefinovany konstanty !!!
      attrib:=0;
      case p_codeview_type_pointer(arg^.typ^.desc)^.ptrtype
        when cpp_near           do attrib:=attrib;
        when cpp_far            do attrib:=attrib+1;
        when cpp_huge           do attrib:=attrib+2;
        when cpp_basedonsegment do attrib:=attrib+3;
        when cpp_basedonvalue   do attrib:=attrib+4;
        when cpp_basedonsegmentofvalue  do attrib:=attrib+5;
        when cpp_basedonaddress do attrib:=attrib+6;
        when cpp_basedonsegmentofaddress do attrib:=attrib+7;
        when cpp_basedontype    do attrib:=attrib+8;
        when cpp_basedonself    do attrib:=attrib+9;
        when cpp_near32bit      do attrib:=attrib+10;
        when cpp_far32bit       do attrib:=attrib+11;
        when cpp_64bit          do attrib:=attrib+12;
        end case;

      case p_codeview_type_pointer(arg^.typ^.desc)^.ptrmode
        when cpm_pointer             do attrib:=attrib+$00000000;
        when cpm_reference           do attrib:=attrib+$00000020;
        when cpm_pointertodatamember do attrib:=attrib+$00000040;
        when cpm_pointertomethod     do attrib:=attrib+$00000060;
        end case;

      if p_codeview_type_pointer(arg^.typ^.desc)^.isflat32 then attrib:=attrib+$00000100; end if;
      if p_codeview_type_pointer(arg^.typ^.desc)^.volatile then attrib:=attrib+$00000200; end if;
      if p_codeview_type_pointer(arg^.typ^.desc)^.ptrconst then attrib:=attrib+$00000400; end if;
      if p_codeview_type_pointer(arg^.typ^.desc)^.unaligned then attrib:=attrib+$00000800; end if;
      if p_codeview_type_pointer(arg^.typ^.desc)^.restrict then attrib:=attrib+$00001000; end if;
      p_codeview_type_pointer(arg^.typ^.desc)^.attr:=attrib;

      -- alokace mista
      new buffer range buffer_size;

      -- vlastni dump
      size:=size-2;
      memory_copy(size,buffer^[0],2);
      memory_copy(arg^.typ^.leaf,buffer^[2],2);
      memory_copy(arg^.typ^.indextype,buffer^[4],4);
      memory_copy(p_codeview_type_pointer(arg^.typ^.desc)^.attr,buffer^[8],4);

      -- aktualizujeme hodnoty dump informaci
      set_codeview_dump(buffer,buffer_size,mydump,_base);

      -- znena statusu na finalni
      arg^.status:=tcvs_dump;

      -- následující argument
      arg:=arg^.next;

      while arg<>nil loop                                                                                           
        memory_copy(arg^.typ^.indextype,buffer^[size],4);                                                           
        size:=size+4;                                                                                               
                                                                                                                    
        -- dalsi paramater                                                                                          
        arg:=arg^.next;                                                                                             
        end loop;                                                                                                   
                                                                                                                    
      -- aktualizujeme hodnoty dump informaci                                                                       
      set_codeview_dump(buffer,buffer_size,arglistdump,_base);                                                      
                                                                                                                    
      -- dump typu vysledku                                                                                         
      if p_codeview_type_proc(_my^.desc)^.cv_result<>nil then                                                       
        dump_codeview_type(p_codeview_type_proc(_my^.desc)^.cv_result,_base);                                       
        if p_codeview_type_proc(_my^.desc)^.cv_result^.status<tcvs_dumping then                                     
          -- co ted s tim ?                                                                                         
          unimplemented({UNIMP=}000262);                                                                            
          end if;                                                                                                   
        p_codeview_type_proc(_my^.desc)^.rvtype:=p_codeview_type_proc(_my^.desc)^.cv_result^.indextype;             
      else                                                                                                          
        -- procedura bez navratoveho typu vraci void                                                                
        p_codeview_type_proc(_my^.desc)^.rvtype:=t_longint(codeview_type_type_code[lf_t_void]);                     
        end if;                                                                                                     

      -- dump attributu                                                                                             
      p_codeview_type_proc(_my^.desc)^.call:=codeview_type_proc_call[p_codeview_type_proc(_my^.desc)^.cv_call];     
                                                                                                                    
      -- dump informaci o procedure                                                                                 
      buffer_size:=28;                                                                                              
      size:=buffer_size-2;                                                                                          
      new buffer range buffer_size;                                                                                 
                                                                                                                    
      memory_copy(size,buffer^[0],2);                                                                               
      memory_copy(_my^.leaf,buffer^[2],2);                                                                          
      memory_copy(p_codeview_type_proc(_my^.desc)^.rvtype,buffer^[4],4);                                            
      memory_copy(p_codeview_type_proc(_my^.desc)^.enclosing_class^.leaf,buffer^[8],4);
--      memory_copy( ,buffer^[12],4);
      memory_copy(p_codeview_type_proc(_my^.desc)^.call,buffer^[16],1);                                              
      memory_copy(p_codeview_type_proc(_my^.desc)^.parms,buffer^[18],2);                                            
      memory_copy(arglistindex,buffer^[12],4);                                                                      
      -- thisadjust, 4B. Co to je a k cemu?
                                                                                                                    
      -- aktualizujeme hodnoty dump informaci                                                                       
      set_codeview_dump(buffer,buffer_size,mydump,_base);                                                           

      -- znena statusu na finalni                                                                                   
      _my^.status:=tcvs_dump;                                                                                       
      end dump_lf_method;                                                                                        


begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  fieldlistindex:=register_codeview_dump(_base,fielddump);
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- udelame dump vsech polozek
  buffer_size:=4; -- size + leaf
  size:=buffer_size;

  -- zapocteme zdedene polozky, ktere uz by mely byt dumpnute
  ri:=p_codeview_type_record(_my^.desc)^.first_field;
  if ri<>nil then ri:=ri^.prev; end if;
  while ri<>nil loop
    -- zjistime informace o polozce recordu
    member:=p_codeview_type_member(ri^.fielddesc);

-- není to metoda
if member^.typ^.typ<>lf_procedure then

    -- udelame jeji dump, aby dostala prideleny index
    dump_codeview_type(member^.typ,_base);
    if member^.typ^.status<tcvs_dumping then
      -- co ted s tim ?
      unimplemented({UNIMP=}000223);
      end if;

    -- cislo dupnutyho typu polozky
    member^.memberindex:=member^.typ^.indextype;


    -- zjistime jakym zpusobem lze popsat offset
    item_offset:=unidata_addr_to_unsigned(member^.offset);
    if item_offset<$8000 then buffer_size:=buffer_size+2 else buffer_size:=buffer_size+6; end if;

    -- celkova potrebna velikost zarovnana na nasobek 4
    buffer_size:=buffer_size+9+member^.name:length;
    size:=buffer_size;
    buffer_size:=((buffer_size+3) div 4) * 4;
end if;
    -- dalsi polozka v recordu
    ri:=ri^.prev;
    end loop;

  ri:=p_codeview_type_record(_my^.desc)^.first_field;
  while ri<>nil loop
    -- zjistime informace o polozce recordu
    member:=p_codeview_type_member(ri^.fielddesc);
    -- member^.name:=lowcasestr(member^.name);

-- není to metoda
if member^.typ^.typ<>lf_procedure then

    -- udelame jeji dump, aby dostala prideleny index
    dump_codeview_type(member^.typ,_base);
    if member^.typ^.status<tcvs_dumping then
      -- co ted s tim ?
      unimplemented({UNIMP=}000224);
      end if;

    -- cislo dupnutyho typu polozky
    member^.memberindex:=member^.typ^.indextype;

    -- zjistime jakym zpusobem lze popsat offset
    item_offset:=unidata_addr_to_unsigned(member^.offset);
    if item_offset<$8000 then buffer_size:=buffer_size+2 else buffer_size:=buffer_size+6; end if;

    -- celkova potrebna velikost zarovnana na nasobek 4
    buffer_size:=buffer_size+9+member^.name:length;
    size:=buffer_size;
    buffer_size:=((buffer_size+3) div 4) * 4;
end if;

    -- dalsi polozka v recordu
    ri:=ri^.next;
    end loop;


  -- udelame dump seznamu polozek
  -- alokace mista
  new buffer range buffer_size;
  if size>=2 then size:=size-2; end if;
  memory_copy(size,buffer^[0],2);
  memory_copy(codeview_type_type_code[lf_fieldlist],buffer^[2],2);
  size:=4;

  p_codeview_type_record(_my^.desc)^.count:=0;

  -- dump zdedenych prvku
  ri:=p_codeview_type_record(_my^.desc)^.first_field;
  --ri:=nil; --!!!--

  -- podedili jsme neco ?
  if (ri<>nil) and (ri^.prev<>nil) then

    -- najdeme zacatek
--A    while ri^.prev<>nil loop
--A      {!!! zaplata !!! }
--A      ri^.prev^.next:=ri;

--A      ri:=ri^.prev;
--A      end loop;

    ri:=ri^.prev; --A

    -- a delame dump az na prvni vlastni polozku
--A    while ri<>p_codeview_type_record(_my^.desc)^.first_field loop
    while ri<>nil loop --A

-- není to metoda
if member^.typ^.typ<>lf_procedure then

      -- dump informaci o polozce
      memory_copy(codeview_type_type_code[lf_member],buffer^[size],2);
      size:=size+2;

      -- zjistime informace o polozce recordu
      member:=p_codeview_type_member(ri^.fielddesc);

      -- attributy, typ polozky
      attr:=code_member_attribute(member^.attr);
      memory_copy(attr,buffer^[size],2);
      memory_copy(member^.memberindex,buffer^[size+2],4);
      size:=size+6;

      -- zjistime jakym zpusobem lze popsat offset
      item_offset:=unidata_addr_to_unsigned(member^.offset);
      if item_offset<$8000 then
        memory_copy(item_offset,buffer^[size],2);
        size:=size+2
      else
        memory_copy(codeview_type_type_code[lf_t_ulong],buffer^[size],2);
        memory_copy(item_offset,buffer^[size+2],4);
        size:=size+6;
        end if;

      -- jmeno polozky recordu
      b3:=member^.name:length;
      memory_copy(b3,buffer^[size],1);
      memory_copy(member^.name[1],buffer^[size+1],member^.name:length);
      temp_size:=member^.name:length;
      size:=size+temp_size+1;

      -- pad byte
      item_offset:=((size+3) div 4) * 4;
      item_offset:=item_offset-size;
      for pad in reverse $f1..item_offset+$f0 loop
        memory_copy(pad,buffer^[size],1);
        size:=size+1;
        end loop;

      -- dalsi polozka v recordu
      p_codeview_type_record(_my^.desc)^.count:=p_codeview_type_record(_my^.desc)^.count+1;
--A      ri:=ri^.next;
end if;

      ri:=ri^.prev; --A
      end loop;
    end if;

  ri:=p_codeview_type_record(_my^.desc)^.first_field;
  while ri<>nil loop

-- není to metoda
if member^.typ^.typ<>lf_procedure then

    -- dump informaci o polozce
    memory_copy(codeview_type_type_code[lf_member],buffer^[size],2);
    size:=size+2;

    -- zjistime informace o polozce recordu
    member:=p_codeview_type_member(ri^.fielddesc);

    -- attributy, typ polozky
    attr:=code_member_attribute(member^.attr);
    memory_copy(attr,buffer^[size],2);
    memory_copy(member^.memberindex,buffer^[size+2],4);
    size:=size+6;

    -- zjistime jakym zpusobem lze popsat offset
    item_offset:=unidata_addr_to_unsigned(member^.offset);
    if item_offset<$8000 then
      memory_copy(item_offset,buffer^[size],2);
      size:=size+2
    else
      memory_copy(codeview_type_type_code[lf_t_ulong],buffer^[size],2);
      memory_copy(item_offset,buffer^[size+2],4);
      size:=size+6;
      end if;

    -- jmeno polozky recordu
    b3:=member^.name:length;
    memory_copy(b3,buffer^[size],1);
    memory_copy(member^.name[1],buffer^[size+1],member^.name:length);
    temp_size:=member^.name:length;
    size:=size+temp_size+1;

    -- pad byte
    item_offset:=((size+3) div 4) * 4;
    item_offset:=item_offset-size;
    for pad in reverse $f1..item_offset+$f0 loop
      memory_copy(pad,buffer^[size],1);
      size:=size+1;
      end loop;

    -- dalsi polozka v recordu
    p_codeview_type_record(_my^.desc)^.count:=p_codeview_type_record(_my^.desc)^.count+1;
end if;

    ri:=ri^.next;
    end loop;

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,fielddump,_base);

  -- dump popisu recordu
  -- vypocet potrebne velikosti bufferu
  record_size:=unidata_size_to_unsigned(p_codeview_type_record(_my^.desc)^.length);
  if record_size<$8000 then size:=2 else size:=6; end if;
  size:=size+19+p_codeview_type_record(_my^.desc)^.name:length;
  buffer_size:=((size+5) div 4) * 4;

  -- vytvoreni bitove mapy attributu
  attr:=0;
  if tctrp_packed   in p_codeview_type_record(_my^.desc)^.proper then attr or $0001; end if;
  if tctrp_ctor     in p_codeview_type_record(_my^.desc)^.proper then attr or $0002; end if;
  if tctrp_overops  in p_codeview_type_record(_my^.desc)^.proper then attr or $0004; end if;
  if tctrp_isnested in p_codeview_type_record(_my^.desc)^.proper then attr or $0008; end if;
  if tctrp_cnested  in p_codeview_type_record(_my^.desc)^.proper then attr or $0010; end if;
  if tctrp_opassign in p_codeview_type_record(_my^.desc)^.proper then attr or $0020; end if;
  if tctrp_opcast   in p_codeview_type_record(_my^.desc)^.proper then attr or $0040; end if;
  p_codeview_type_record(_my^.desc)^.prop:=attr;

  -- alokace mista
  new buffer range buffer_size;

  size:=size-2;
  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(p_codeview_type_record(_my^.desc)^.count,buffer^[4],2);
  memory_copy(p_codeview_type_record(_my^.desc)^.prop,buffer^[6],2);
  memory_copy(fieldlistindex,buffer^[8],4);
  if record_size<$8000 then
    memory_copy(record_size,buffer^[20],2);
    b3:=p_codeview_type_record(_my^.desc)^.name:length;
    memory_copy(b3,buffer^[22],1);
    memory_copy(p_codeview_type_record(_my^.desc)^.name[1],buffer^[23],p_codeview_type_record(_my^.desc)^.name:length);
  else
    memory_copy(codeview_type_type_code[lf_t_ulong],buffer^[20],2);
    memory_copy(record_size,buffer^[22],4);
    b3:=p_codeview_type_record(_my^.desc)^.name:length;
    memory_copy(b3,buffer^[26],1);
    memory_copy(p_codeview_type_record(_my^.desc)^.name[1],buffer^[27],p_codeview_type_record(_my^.desc)^.name:length);
    end if;

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;

-- máme už cv index typu; pro třídy provést dump metod
ri:=p_codeview_type_record(_my^.desc)^.first_field;
while ri<>nil loop
-- je to metoda
if member^.typ^.typ=lf_procedure then
  -- dumpnout metodu
  dump_lf_method(member^.typ,_base);
  end if;
  ri:=ri^.next;
  end loop;

  end dump_lf_structure;



----------------------------------------------------------------------------------------------------
procedure dump_lf_array (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump pole.
----------------------------------------------------------------------------------------------------
var
  mydump           : p_codeview_type_dump;
  buffer           : p_unsigned8array;           -- buffer na data
  buffer_size      : t_unsigned;                 -- velikost bufferu
  size             : t_word;                     -- velikost dumpu
  lengtha          : t_unsigned32;               -- velikost pole v bytech
  b3               : t_unsigned8;

begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- udelame dump typu prvku
  dump_codeview_type(p_codeview_type_array(_my^.desc)^.cv_elemtype,_base);
  if p_codeview_type_array(_my^.desc)^.cv_elemtype^.status<tcvs_dumping then
    -- co ted s tim ?
    unimplemented({UNIMP=}000225);
    end if;

  -- cislo dupnutyho typu prvku
  p_codeview_type_array(_my^.desc)^.elemtype:=p_codeview_type_array(_my^.desc)^.cv_elemtype^.indextype;

  -- udelame dump typu indexu
  dump_codeview_type(p_codeview_type_array(_my^.desc)^.cv_idxtype,_base);
  if p_codeview_type_array(_my^.desc)^.cv_idxtype^.status<tcvs_dumping then
    -- co ted s tim ?
    unimplemented({UNIMP=}000226);
    end if;

  -- cislo dupnutyho typu indexu
  p_codeview_type_array(_my^.desc)^.idxtype:=p_codeview_type_array(_my^.desc)^.cv_idxtype^.indextype;

  -- vypocteme potrebnou velikost a alokujeme pamet
  buffer_size:=13+p_codeview_type_array(_my^.desc)^.name:length;

  -- podel velikosti pole urcime jak tuto velikost popiseme
  lengtha:=unidata_size_to_unsigned(p_codeview_type_array(_my^.desc)^.length);
  if lengtha<$8000 then buffer_size:=buffer_size+2 else buffer_size:=buffer_size+6; end if;

  -- zarovname na delitelnost 4
  size:=buffer_size;
  buffer_size:=((buffer_size+3) div 4) * 4;

  -- alokace mista
  new buffer range buffer_size;

  -- dump
  if size>=2 then size-2; end if;
  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(p_codeview_type_array(_my^.desc)^.elemtype,buffer^[4],4);
  memory_copy(p_codeview_type_array(_my^.desc)^.idxtype,buffer^[8],4);
  if lengtha<$8000 then
    memory_copy(lengtha,buffer^[12],2);
    b3:=p_codeview_type_array(_my^.desc)^.name:length;
    memory_copy(b3,buffer^[14],1);
    memory_copy(p_codeview_type_array(_my^.desc)^.name[1],buffer^[15],p_codeview_type_array(_my^.desc)^.name:length);
  else
    memory_copy(codeview_type_type_code[lf_t_ulong],buffer^[12],2);
    memory_copy(lengtha,buffer^[14],4);
    b3:=p_codeview_type_array(_my^.desc)^.name:length;
    memory_copy(b3,buffer^[18],1);
    memory_copy(p_codeview_type_array(_my^.desc)^.name[1],buffer^[19],p_codeview_type_array(_my^.desc)^.name:length);
    end if;

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;
  end dump_lf_array;



----------------------------------------------------------------------------------------------------
procedure dump_lf_pointer (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump pole.
----------------------------------------------------------------------------------------------------
var
  mydump           : p_codeview_type_dump;
  buffer           : p_unsigned8array;           -- buffer na data
  buffer_size      : t_unsigned;                 -- velikost bufferu
  size             : t_word;                     -- velikost dumpu
  attr             : t_longint;
  basetype         : t_longint;

begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- dump typu, na ktery pointer ukazuje
  -- udelame dump typu prvku, nezname prvky prohlasime za void
  if (p_codeview_type_pointer(_my^.desc)^.typ<>nil) then
    dump_codeview_type(p_codeview_type_pointer(_my^.desc)^.typ,_base);
    if p_codeview_type_pointer(_my^.desc)^.typ^.status<tcvs_dumping then
      -- co ted s tim ?
      unimplemented({UNIMP=}000227);
      end if;
    basetype:=p_codeview_type_pointer(_my^.desc)^.typ^.indextype;
  else
    basetype:=t_longint(codeview_type_type_code[lf_t_void]);
    end if;

  -- !!! nepocita se s variant zaznamem !!!
  buffer_size:=12;
  size:=buffer_size;

  -- zakodujeme attributy - !!! mama na to nadefinovany konstanty !!!
  attr:=0;
  case p_codeview_type_pointer(_my^.desc)^.ptrtype
    when cpp_near           do attr:=attr;
    when cpp_far            do attr:=attr+1;
    when cpp_huge           do attr:=attr+2;
    when cpp_basedonsegment do attr:=attr+3;
    when cpp_basedonvalue   do attr:=attr+4;
    when cpp_basedonsegmentofvalue  do attr:=attr+5;
    when cpp_basedonaddress do attr:=attr+6;
    when cpp_basedonsegmentofaddress do attr:=attr+7;
    when cpp_basedontype    do attr:=attr+8;
    when cpp_basedonself    do attr:=attr+9;
    when cpp_near32bit      do attr:=attr+10;
    when cpp_far32bit       do attr:=attr+11;
    when cpp_64bit          do attr:=attr+12;
    end case;

  case p_codeview_type_pointer(_my^.desc)^.ptrmode
    when cpm_pointer             do attr:=attr+$00000000;
    when cpm_reference           do attr:=attr+$00000020;
    when cpm_pointertodatamember do attr:=attr+$00000040;
    when cpm_pointertomethod     do attr:=attr+$00000060;
    end case;

  if p_codeview_type_pointer(_my^.desc)^.isflat32 then attr:=attr+$00000100; end if;
  if p_codeview_type_pointer(_my^.desc)^.volatile then attr:=attr+$00000200; end if;
  if p_codeview_type_pointer(_my^.desc)^.ptrconst then attr:=attr+$00000400; end if;
  if p_codeview_type_pointer(_my^.desc)^.unaligned then attr:=attr+$00000800; end if;
  if p_codeview_type_pointer(_my^.desc)^.restrict then attr:=attr+$00001000; end if;
  p_codeview_type_pointer(_my^.desc)^.attr:=attr;

  -- alokace mista
  new buffer range buffer_size;

  -- vlastni dump
  size:=size-2;
  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(basetype,buffer^[4],4);

  memory_copy(p_codeview_type_pointer(_my^.desc)^.attr,buffer^[8],4);

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;
  end dump_lf_pointer;



----------------------------------------------------------------------------------------------------
procedure dump_lf_enum (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump enum.
----------------------------------------------------------------------------------------------------
var
  mydump           : p_codeview_type_dump;
  fielddump        : p_codeview_type_dump;
  buffer           : p_unsigned8array;           -- buffer na data
  buffer_size      : t_unsigned;                 -- velikost bufferu
  size             : t_word;                     -- velikost dumpu
  temp_size        : t_word;
  fieldlistindex   : t_longint;                  -- cislo popisu typu seznamu polozek
  ri               : p_codeview_type_fieldlist;  -- polozka recordu
  enum_item        : p_codeview_type_enum_name;  -- popis polozky enumu
  attr             : t_mod_word;
  roundsize        : t_word;                     -- zarovnana velikost
  b3               : t_unsigned8;

begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  fieldlistindex:=register_codeview_dump(_base,fielddump);
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];


  -- udelame dump vsech polozek
  buffer_size:=4; -- size + leaf
  size:=buffer_size;
  ri:=p_codeview_type_enum(_my^.desc)^.first_field;
  while ri<>nil loop
    -- zjistime informace o polozce recordu
    enum_item:=p_codeview_type_enum_name(ri^.fielddesc);
    enum_item^.memberindex:=t_longint(codeview_type_type_code[enum_item^.typ]);

    -- celkova potrebna velikost zarovnana na nasobek 4
    if enum_item^.value<$8000 then buffer_size:=buffer_size+2 else buffer_size:=buffer_size+6; end if;
    buffer_size:=buffer_size+5+enum_item^.name:length;
    size:=buffer_size;
    buffer_size:=((buffer_size+3) div 4) * 4;

    -- dalsi polozka v recordu
    ri:=ri^.next;
    end loop;

  -- udelame dump seznamu polozek
  -- alokace mista
  new buffer range buffer_size;
  if size>=2 then size-2; end if;
  memory_copy(size,buffer^[0],2);
  memory_copy(codeview_type_type_code[lf_fieldlist],buffer^[2],2);
  size:=4;

  p_codeview_type_enum(_my^.desc)^.count:=0;
  ri:=p_codeview_type_enum(_my^.desc)^.first_field;
  while ri<>nil loop
    -- dump informaci o polozce
    memory_copy(codeview_type_type_code[lf_enum],buffer^[size],2);
    size:=size+2;

    -- zjistime informace o polozce vyctu
    enum_item:=p_codeview_type_enum_name(ri^.fielddesc);

    -- attributy
    attr:=code_member_attribute(enum_item^.attr);
    memory_copy(attr,buffer^[size],2);
    size:=size+2;

    -- zjistime jakym zpusobem lze popsat hodnotu
    if enum_item^.value<$8000 then
      memory_copy(enum_item^.value,buffer^[size],2);
      size:=size+2
    else
      memory_copy(codeview_type_type_code[lf_t_ulong],buffer^[size],2);
      memory_copy(enum_item^.value,buffer^[size+2],4);
      size:=size+6;
      end if;

    -- jmeno polozky recordu
    b3:=enum_item^.name:length;
    memory_copy(b3,buffer^[size],1);
    memory_copy(enum_item^.name[1],buffer^[size+1],enum_item^.name:length);
    temp_size:=enum_item^.name:length;
    size:=size+temp_size+1;

    -- pad byte
    roundsize:=((size+3) div 4) * 4;
    roundsize:=roundsize-size;
    for pad in reverse $f1..roundsize+$f0 loop
      memory_copy(pad,buffer^[size],1);
      size:=size+1;
      end loop;

    -- dalsi polozka v recordu
    p_codeview_type_enum(_my^.desc)^.count:=p_codeview_type_enum(_my^.desc)^.count+1;
    ri:=ri^.next;
    end loop;

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,fielddump,_base);

  -- dump enumu
  size:=17+p_codeview_type_enum(_my^.desc)^.name:length;
  buffer_size:=((size+5) div 4) * 4;

  -- alokace mista
  new buffer range buffer_size;
  p_codeview_type_enum(_my^.desc)^.typx:=t_longint(codeview_type_type_code[p_codeview_type_enum(_my^.desc)^.typ]);

  -- dump dat
  if size >=2 then size-2; end if;
  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(p_codeview_type_enum(_my^.desc)^.count,buffer^[4],2);
  memory_copy(p_codeview_type_enum(_my^.desc)^.prop,buffer^[6],2);
  memory_copy(p_codeview_type_enum(_my^.desc)^.typx,buffer^[8],4);
  memory_copy(fieldlistindex,buffer^[12],4);
  b3:=p_codeview_type_enum(_my^.desc)^.name:length;
  memory_copy(b3,buffer^[16],1);
  memory_copy(p_codeview_type_enum(_my^.desc)^.name[1],buffer^[17],p_codeview_type_enum(_my^.desc)^.name:length);

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;
  end dump_lf_enum;



----------------------------------------------------------------------------------------------------
procedure dump_lf_bit (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump bitu množiny.
----------------------------------------------------------------------------------------------------
const
  buffer_size      : t_unsigned = 10;            -- délka bufferu v bytech

var
  mydump           : p_codeview_type_dump;       -- dump
  buffer           : p_unsigned8array;           -- buffer na data
  size             : t_word;

begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- co tady má být? S tímhle to nefunguje.
  --p_codeview_type_bitfield(_my^.desc)^.typ:=p_codeview_type_bitfield(_my^.desc)^.cv_typ^.indextype;

  -- alokace bufferu
  new buffer range buffer_size;

  -- nastavení dat dumpu
  size:=buffer_size-2;
  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(p_codeview_type_bitfield(_my^.desc)^.typ,buffer^[4],4);
  buffer^[8]:=p_codeview_type_bitfield(_my^.desc)^.length;
  buffer^[9]:=p_codeview_type_bitfield(_my^.desc)^.position;

  -- dump
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- změna stavu na finální
  _my^.status:=tcvs_dump;
  end dump_lf_bit;



----------------------------------------------------------------------------------------------------
procedure dump_lf_procedure (
    _my            : in p_codeview_type;
    _base          : in out t_codeview_type_table
    ) =
-- Dump procedure.
----------------------------------------------------------------------------------------------------
var
  mydump           : p_codeview_type_dump;
  arglistdump      : p_codeview_type_dump;
  arglistindex     : t_longint;
  buffer           : p_unsigned8array;           -- buffer na data
  buffer_size      : t_unsigned;                 -- velikost bufferu
  size             : t_word;                     -- velikost dumpu
  arg              : p_codeview_type_argitem;    -- paramater procedury

begin
  -- abysme ho nahodou nedumpnuli rekurzivne
  _my^.status:=tcvs_dumping;
  arglistindex:=register_codeview_dump(_base,arglistdump);
  _my^.indextype:=register_codeview_dump(_base,mydump);
  _my^.leaf:=codeview_type_type_code[_my^.typ];

  -- projedeme vsechny paramatery, spocitame je a nechame vygenerovat
  p_codeview_type_proc(_my^.desc)^.parms:=0;
  arg:=p_codeview_type_proc(_my^.desc)^.first_argument;
  while arg<>nil loop
    -- udelame dump typu indexu
    dump_codeview_type(arg^.typ,_base);
    if arg^.typ^.status<tcvs_dumping then
      -- co ted s tim ?
      unimplemented({UNIMP=}000228);
      end if;

    -- dalsi paramater
    p_codeview_type_proc(_my^.desc)^.parms:=p_codeview_type_proc(_my^.desc)^.parms+1;
    arg:=arg^.next;
    end loop;

  -- alokace mista
  buffer_size:=8+(p_codeview_type_proc(_my^.desc)^.parms*4);
  new buffer range buffer_size;

  size:=buffer_size-2;
  memory_copy(size,buffer^[0],2);
  memory_copy(codeview_type_type_code[lf_arglist],buffer^[2],2);
  memory_copy(p_codeview_type_proc(_my^.desc)^.parms,buffer^[4],4);
  size:=8;

  -- projedeme vsechny paramatery, spocitame je a nechame vygenerovat
  arg:=p_codeview_type_proc(_my^.desc)^.first_argument;
  while arg<>nil loop
    memory_copy(arg^.typ^.indextype,buffer^[size],4);
    size:=size+4;

    -- dalsi paramater
    arg:=arg^.next;
    end loop;

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,arglistdump,_base);

  -- dump typu vysledku
  if p_codeview_type_proc(_my^.desc)^.cv_result<>nil then
    dump_codeview_type(p_codeview_type_proc(_my^.desc)^.cv_result,_base);
    if p_codeview_type_proc(_my^.desc)^.cv_result^.status<tcvs_dumping then
      -- co ted s tim ?
      unimplemented({UNIMP=}000229);
      end if;
    p_codeview_type_proc(_my^.desc)^.rvtype:=p_codeview_type_proc(_my^.desc)^.cv_result^.indextype;
  else
    -- procedura bez navratoveho typu vraci void
    p_codeview_type_proc(_my^.desc)^.rvtype:=t_longint(codeview_type_type_code[lf_t_void]);
    end if;

  -- dump attributu
  p_codeview_type_proc(_my^.desc)^.call:=codeview_type_proc_call[p_codeview_type_proc(_my^.desc)^.cv_call];

  -- dump informaci o procedure
  buffer_size:=16;
  size:=buffer_size-2;
  new buffer range buffer_size;

  memory_copy(size,buffer^[0],2);
  memory_copy(_my^.leaf,buffer^[2],2);
  memory_copy(p_codeview_type_proc(_my^.desc)^.rvtype,buffer^[4],4);
  memory_copy(p_codeview_type_proc(_my^.desc)^.call,buffer^[8],1);
  memory_copy(p_codeview_type_proc(_my^.desc)^.parms,buffer^[10],2);
  memory_copy(arglistindex,buffer^[12],4);

  -- aktualizujeme hodnoty dump informaci
  set_codeview_dump(buffer,buffer_size,mydump,_base);

  -- znena statusu na finalni
  _my^.status:=tcvs_dump;
  end dump_lf_procedure;



----------------------------------------------------------------------------------------------------
procedure generate_codeview_type =
-- Vygeneruje popis typu.
----------------------------------------------------------------------------------------------------
begin
  -- osetreni opetovneho zpracovani
  if _my^.status>tcvs_init then return; end if;

  -- podle typy typu...
  case _type^.stype
    -- univerzální typy - ignorovat
    when dt_uniint     do -- nic nedělat
    when dt_unireal    do -- nic nedělat
    when dt_unilogical do -- nic nedělat
    when dt_unichar    do -- nic nedělat
    when dt_uniarray   do -- nic nedělat
    when dt_uninil     do -- nic nedělat

    -- regulární typy
    when dt_signed     do generate_st_signed(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_unsigned   do generate_st_unsigned(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_float      do generate_st_float(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_fixed      do generate_st_fixed(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_char       do generate_st_char(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_tag        do generate_st_tag(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_logical    do generate_st_logical(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_string     do generate_st_string(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_ustring    do generate_st_ustring(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_array      do generate_st_array(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_uarray     do generate_st_uarray(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_record     do generate_st_record(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_class      do generate_st_class(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_enum       do generate_st_enum(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_set        do generate_st_set(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_pointer    do generate_st_pointer(_type,_leaf,_primitive,_desc,_my,_base);

    --  singulární typy
    when dt_message    do {!!! dodelat !!!} generate_st_message(_type,_leaf,_primitive,_desc,_my,_base);
    when dt_procedure  do generate_st_procedure(_type,_leaf,_primitive,_desc,_my,_base);
    when others        do verify({VERIFY=}001268);
    end case;
  end generate_codeview_type;



----------------------------------------------------------------------------------------------------
procedure dump_codeview_type =
-- Dump popisu typu.
----------------------------------------------------------------------------------------------------
begin
  -- osetreni opetovneho zpracovani a zpracovani nepipraveneho popisu
  if _my^.status<>tcvs_build then return; end if;

  -- podle typy typu...
  case _my^.typ
    when lf_structure, lf_class do dump_lf_structure(_my,_base);
    when lf_array               do dump_lf_array(_my,_base);
    when lf_pointer             do dump_lf_pointer(_my,_base);
    when lf_enum                do dump_lf_enum(_my,_base);
    when lf_procedure           do dump_lf_procedure(_my,_base);
    when lf_bit                 do dump_lf_bit(_my,_base);
    when others do
        if _my^.primitive then        -- dump primitivnich typu
          dump_primitive(_my,_base);
          end if;
    end case;
  end dump_codeview_type;



end cl_codeview_types;
