----------------------------------------------------------------------------------------------------
module private cc_type =
-- Překladač Flexu.
-- Operace s typy.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.06.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_sym,cc_def.cc_codes;

----------------------------------------------------------------------------------------------------
procedure vset111 (
    oclass         : in toperclass;              -- třída operace
    v1             : in ttypeview;               -- pohled na typ
    v2             : in ttypeview;               -- pohled na typ
    check          : in t_view_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- VIEWCHECK[OCLASS,V1,V2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  viewcheck[oclass,v1,v2].c:=check;
  viewcheck[oclass,v1,v2].r:=result;
  end vset111;



----------------------------------------------------------------------------------------------------
procedure vset11s (
    oclass         : in toperclass;              -- třída operace
    v1             : in ttypeview;               -- pohled na typ
    v2             : in ttypeviewset;            -- pohled na typ
    check          : in t_view_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- VIEWCHECK[OCLASS,V1,V2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in ttypeview loop
    if i in v2 then
      viewcheck[oclass,v1,i].c:=check;
      viewcheck[oclass,v1,i].r:=result;
      end if;
    end loop;
  end vset11s;



----------------------------------------------------------------------------------------------------
procedure set111 (
    oclass         : in toperclass;              -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatype;               -- datové typy
    t2             : in tdatatype;               -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[OCLASS,T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  typecheck[oclass,t1,t2].c:=check;
  typecheck[oclass,t1,t2].r:=result;
  typecheck[oclass,t1,t2].a:=assign;
  end set111;



----------------------------------------------------------------------------------------------------
procedure set1s1 (
    oclass         : in toperclass;              -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatypeset;            -- datové typy
    t2             : in tdatatype;               -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t1 then
      typecheck[oclass,i,t2].c:=check;
      typecheck[oclass,i,t2].r:=result;
      typecheck[oclass,i,t2].a:=assign;
      end if;
    end loop;
  end set1s1;



----------------------------------------------------------------------------------------------------
procedure set11s (
    oclass         : in toperclass;              -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatype;               -- datové typy
    t2             : in tdatatypeset;            -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t2 then
      typecheck[oclass,t1,i].c:=check;
      typecheck[oclass,t1,i].r:=result;
      typecheck[oclass,t1,i].a:=assign;
      end if;
    end loop;
  end set11s;



----------------------------------------------------------------------------------------------------
procedure set1ss (
    oclass         : in toperclass;              -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatypeset;            -- datové typy
    t2             : in tdatatypeset;            -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t1 then
      for j in tdatatype loop
        if j in t2 then
          typecheck[oclass,i,j].c:=check;
          typecheck[oclass,i,j].r:=result;
          typecheck[oclass,i,j].a:=assign;
          end if;
        end loop;
      end if;  
    end loop;
  end set1ss;



----------------------------------------------------------------------------------------------------
procedure sets11 (
    oclass         : in toperclassset;           -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatype;               -- datové typy
    t2             : in tdatatype;               -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      typecheck[o,t1,t2].c:=check;
      typecheck[o,t1,t2].r:=result;
      typecheck[o,t1,t2].a:=assign;
      end if;
    end loop;
  end sets11;



----------------------------------------------------------------------------------------------------
procedure setss1 (
    oclass         : in toperclassset;           -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatypeset;            -- datové typy
    t2             : in tdatatype;               -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t1 then
          typecheck[o,i,t2].c:=check;
          typecheck[o,i,t2].r:=result;
          typecheck[o,i,t2].a:=assign;
          end if;
        end loop;
      end if;
    end loop;
  end setss1;



----------------------------------------------------------------------------------------------------
procedure sets1s (
    oclass         : in toperclassset;           -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatype;               -- datové typy
    t2             : in tdatatypeset;            -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t2 then
          typecheck[o,t1,i].c:=check;
          typecheck[o,t1,i].r:=result;
          typecheck[o,t1,i].a:=assign;
          end if;
        end loop;
      end if;
    end loop;
  end sets1s;



----------------------------------------------------------------------------------------------------
procedure setsss (
    oclass         : in toperclassset;           -- třída operace
    assign         : in t_logical;               -- T-povoleno zkrácené přiřazení
    t1             : in tdatatypeset;            -- datové typy
    t2             : in tdatatypeset;            -- datové typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ výsledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t1 then
          for j in tdatatype loop
            if j in t2 then
              typecheck[o,i,j].c:=check;
              typecheck[o,i,j].r:=result;
              typecheck[o,i,j].a:=assign;
              end if;
            end loop;
          end if;
        end loop;
      end if;
    end loop;
  end setsss;



----------------------------------------------------------------------------------------------------
procedure setcopy (
    from           : in toperclass;              -- třída operace
    _to            : in toperclass;              -- třída operace
    retain_assign  : in t_logical) =             -- ponechat nastavení příznaku assign
-- TYPECHECK[TO]:=TYPECHECK[FROM].
----------------------------------------------------------------------------------------------------
begin
  typecheck[_to]:=typecheck[from];
  if not retain_assign then
    for i in tdatatype loop
      for j in tdatatype loop
        typecheck[_to,i,j].a:=false;
        end loop;
      end loop;
    end if;
  end setcopy;



----------------------------------------------------------------------------------------------------
procedure init_type_compatibility_table =
-- Inicializace tabulky typové kompatibility.
----------------------------------------------------------------------------------------------------
begin
  --------------------------------------------------------------------------------------------------
  -- (4) Transformace a přiřazení (předsunuto, aby bylo možné kopírovat nastavení)
  --------------------------------------------------------------------------------------------------

  ----- Přiřazení ----------------------------------------------------------------------------------
  ----- celočíselný := celočíselný -----
  set111(toc_assign     ,true ,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_left);
  set1s1(toc_assign     ,true ,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- floating-point : = numerický -----
  set111(toc_assign     ,true ,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- fixed-point := numerický -----
  set111(toc_assign     ,true ,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- znakový := znakový -----
  set111(toc_assign     ,true ,dt_char      ,dt_char      ,ttc_simple_check     ,trt_left);
  set111(toc_assign     ,true ,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- logický := logický -----
  set111(toc_assign     ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_left);
  set111(toc_assign     ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);

  ----- výčtový := výčtový -----
  set111(toc_assign     ,true ,dt_enum      ,dt_enum      ,ttc_derived          ,trt_left);

  ----- řetězec := řetězec -----
  set1ss(toc_assign     ,true ,dts_string   ,dts_string   ,ttc_string           ,trt_left); {ttc_string_string}
  set1s1(toc_assign     ,true ,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_string_uniarray}

  ----- pole := pole -----
  set111(toc_assign     ,true ,dt_array     ,dt_array     ,ttc_array            ,trt_left); {ttc_array_array}
  set111(toc_assign     ,true ,dt_array     ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_array_uarray}
  set111(toc_assign     ,true ,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_left); {ttc_uarray_array}
  set111(toc_assign     ,true ,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_uarray_uarray}
  set1s1(toc_assign     ,true ,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_array_uniarray}

  ----- record := record -----
  set111(toc_assign     ,true ,dt_record    ,dt_record    ,ttc_identical{!!}    ,trt_left);

  ----- třída := třída -----
  set111(toc_assign     ,true ,dt_class     ,dt_class     ,ttc_identical{!!}    ,trt_left);

  ----- množina := množina -----
  set111(toc_assign     ,true ,dt_set       ,dt_set       ,ttc_set              ,trt_left);

  ----- pointer := pointer -----
  set111(toc_assign     ,true ,dt_pointer   ,dt_pointer   ,ttc_pointer_assign   ,trt_left);

  ----- tag := tag -----
  set111(toc_assign     ,true ,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_left);

  ----- regulární := NIL -----
  set1s1(toc_assign     ,true ,dts_regular  ,dt_uninil    ,ttc_nil              ,trt_left);


  ----- Transformace hodnoty -----------------------------------------------------------------------
  -- základ je stejný jako přiřazení 
  setcopy(toc_assign,toc_transform,false);

  ----- record <-- record -----
  set111(toc_transform  ,false,dt_record    ,dt_record    ,ttc_derived          ,trt_left);

  ----- třída <-- třída -----
  set111(toc_transform  ,false,dt_class     ,dt_class     ,ttc_derived          ,trt_left);

  -- uniint <-- uniint 
  set111(toc_transform  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  -- unireal <-- uniint,unireal 
  set111(toc_transform  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);

  -- unichar <-- unichar 
  set111(toc_transform  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);

  -- unilogical <-- unilogical
  set111(toc_transform  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);

  -- uniarray <-- uniarray 
  set111(toc_transform  ,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (1) Operátory
  --------------------------------------------------------------------------------------------------

  ----- Aritmetické operace ------------------------------------------------------------------------
  ----- celočíselný + celočíselný -----
  sets11(tocs_iaritm    ,true ,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_resolve);
  sets11(tocs_iaritm    ,true ,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_resolve);
  setss1(tocs_iaritm    ,true ,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  sets1s(tocs_iaritm    ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_right);
  sets11(tocs_iaritm    ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- floating-point + floating-point -----
  sets11(tocs_raritm    ,true ,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_resolve);
  sets11(tocs_raritm    ,true ,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_right);

  ----- fixed-point + fixed-point -----
  sets11(tocs_raritm    ,true ,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_resolve);
  sets11(tocs_raritm    ,true ,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_right);

  ----- reálný + reálný -----
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);


  ----- Množinové operace --------------------------------------------------------------------------
  ----- množina + množina -----
  set111(toc_set        ,true ,dt_set       ,dt_set       ,ttc_set              ,trt_left);


  ----- Spojování řetězců --------------------------------------------------------------------------
  ----- string & string -----
  set111(toc_concat     ,true ,dt_string      ,dt_string      ,ttc_string             ,trt_resolve); {ttc_string_string}
  set111(toc_concat     ,true ,dt_string      ,dt_ustring     ,ttc_string             ,trt_right);   {ttc_string_string}
  set11s(toc_concat     ,true ,dt_ustring     ,dts_string     ,ttc_string             ,trt_left);    {ttc_string_string}
  set1s1(toc_concat     ,true ,dts_string     ,dt_uniarray    ,ttc_uniarray           ,trt_left);    {ttc_string_uniarray}
  set11s(toc_concat     ,false,dt_uniarray    ,dts_string     ,ttc_uniarray           ,trt_right);   {ttc_uniarray_string}
  set111(toc_concat     ,false,dt_uniarray    ,dt_uniarray    ,ttc_uniarray           ,trt_left);    {ttc_uniarray}

  ----- univerzální string & component -----
  set11s(toc_concat     ,false,dt_uniarray    ,dts_u_unindexed,ttc_indexed_component  ,trt_left);
  set1s1(toc_concat     ,false,dts_u_unindexed,dt_uniarray    ,ttc_component_indexed  ,trt_right);

  ----- string & component (kromě případu component=string) -----
  set1ss(toc_concat     ,true ,dts_string     ,dts_u_unindexed,ttc_indexed_component  ,trt_left);
  set1ss(toc_concat     ,false,dts_u_unindexed,dts_string     ,ttc_component_indexed  ,trt_right);

  ----- component & component -----
  set1ss(toc_concat     ,false,dts_u_unindexed,dts_u_unindexed,ttc_component_component,trt_uniarray_el);
{!!
  dt_string, dt_array    --> a) trt_left + dt_array:length ???, b) dt_ustring
  dt_ustring, dt_array   --> trt_left
  dt_array, dt_string    --> a) trt_right + dt_array:length ???, b) dt_ustring
  dt_array, dt_ustring   --> trt_right
}

  ----- Logické operace ----------------------------------------------------------------------------
  ----- logický AND logický -----
  set111(toc_logical    ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_resolve);
  set111(toc_logical    ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_logical    ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_right);
  set111(toc_logical    ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);


  ----- Shifty -------------------------------------------------------------------------------------
  ----- celočíselný SHL unsigned -----
  set111(toc_shift      ,true ,dt_signed    ,dt_unsigned  ,ttc_modaritm_left_check,trt_resolve);
  set111(toc_shift      ,true ,dt_unsigned  ,dt_unsigned  ,ttc_modaritm_left_check,trt_resolve);
  set1s1(toc_shift      ,true ,dts_integer  ,dt_uniint    ,ttc_modaritm_left_check,trt_left);
  set111(toc_shift      ,false,dt_uniint    ,dt_unsigned  ,ttc_convertible        ,trt_right);
  set111(toc_shift      ,false,dt_uniint    ,dt_uniint    ,ttc_convertible        ,trt_left);


  ----- Bitové operace -----------------------------------------------------------------------------
  ----- celočíselný BIT_AND celočíselný -----
  set111(toc_bit        ,true ,dt_signed    ,dt_signed    ,ttc_modaritm_check   ,trt_resolve);
  set111(toc_bit        ,true ,dt_unsigned  ,dt_unsigned  ,ttc_modaritm_check   ,trt_resolve);
  set1s1(toc_bit        ,true ,dts_integer  ,dt_uniint    ,ttc_modaritm_check   ,trt_left);
  set11s(toc_bit        ,false,dt_uniint    ,dts_integer  ,ttc_modaritm_check   ,trt_right);
  set111(toc_bit        ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);


  ----- Relační porovnávací operace ----------------------------------------------------------------
  ----- celočíselný = celočíselný -----
  set111(toc_rel_compare,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_unilogical);
  set1s1(toc_rel_compare,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_unilogical);

  ----- floating-point = floating-point -----
  set111(toc_rel_compare,false,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_unilogical);

  ----- fixed-point = fixed-point -----
  set111(toc_rel_compare,false,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_unilogical);

  ----- reálný = reálný -----
  set111(toc_rel_compare,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_unilogical);

  ----- znakový = znakový -----
  set111(toc_rel_compare,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_unilogical);

  ----- logický = logický -----
  set111(toc_rel_compare,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_compare,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_unilogical);

  ----- enum = enum -----
  set111(toc_rel_compare,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_unilogical);

  ----- řetězec = řetězec -----
  set1ss(toc_rel_compare,false,dts_string   ,dts_string   ,ttc_string           ,trt_unilogical); {ttc_string_string}
  set11s(toc_rel_compare,false,dt_uniarray  ,dts_string   ,ttc_uniarray         ,trt_unilogical); {ttc_uniarray_string}
  set1s1(toc_rel_compare,false,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical); {ttc_string_uniarray}
  set111(toc_rel_compare,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical); {ttc_uniarray}

  ----- pole = pole -----
  set111(toc_rel_compare,false,dt_array     ,dt_array     ,ttc_array            ,trt_unilogical);
  set111(toc_rel_compare,false,dt_array     ,dt_uarray    ,ttc_uarray           ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uniarray  ,dts_array    ,ttc_uniarray         ,trt_unilogical);
  set1s1(toc_rel_compare,false,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical);

  ----- record = record -----
  set111(toc_rel_compare,false,dt_record    ,dt_record    ,ttc_identical        ,trt_unilogical);
  
  ----- třída = třída -----
  -- pro třídy není porovnání definováno

  ----- množina = množina -----
  set1ss(toc_rel_compare,false,dts_u_set    ,dts_u_set    ,ttc_set              ,trt_unilogical);

  ----- pointer = pointer -----
  set111(toc_rel_compare,false,dt_pointer   ,dt_pointer   ,ttc_pointer_rel      ,trt_unilogical);

  ----- tag = tag -----
  set111(toc_rel_compare,false,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_unilogical);

  ----- regulární = NIL -----
  set1s1(toc_rel_compare,false,dts_regular  ,dt_uninil    ,ttc_NIL              ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uninil    ,dts_regular  ,ttc_NIL              ,trt_unilogical);


  ----- Relační uspořádávací operace ---------------------------------------------------------------
  ----- numerický < numerický -----
  set111(toc_rel_order  ,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_unilogical);
  set1s1(toc_rel_order  ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_unilogical);
  set11s(toc_rel_order  ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_unilogical);

  ----- floating-point < floating-point -----
  set111(toc_rel_order  ,false,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_unilogical);

  ----- fixed-point < fixed-point -----
  set111(toc_rel_order  ,false,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_unilogical);

  ----- reálný < reálný -----
  set111(toc_rel_order  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
                        
  ----- znakový < znakový -----
  set111(toc_rel_order  ,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_unilogical);

  ----- logický < logický -----
  set111(toc_rel_order  ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_order  ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_unilogical);

  ----- enum < enum -----
  set111(toc_rel_order  ,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_unilogical);

  ----- řetězcový < řetězcový -----
  set1ss(toc_rel_order  ,false,dts_string   ,dts_string   ,ttc_order_string     ,trt_unilogical); {ttc_order_string_string}
  set11s(toc_rel_order  ,false,dt_uniarray  ,dts_string   ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_uniarray_string}
  set1s1(toc_rel_order  ,false,dts_string   ,dt_uniarray  ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_string_uniarray}
  set111(toc_rel_order  ,false,dt_uniarray  ,dt_uniarray  ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_uniarray}

  ----- pole < pole -----
  {!!}

  ----- množina < množina -----
  set1ss(toc_rel_order  ,false,dts_u_set    ,dts_u_set    ,ttc_set              ,trt_unilogical);

  ----- tag < tag -----
  set111(toc_rel_order  ,false,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_unilogical);


  ----- Test náležení ------------------------------------------------------------------------------
  ----- diskrétní IN množina -----
  set1ss(toc_rel_member ,false,dts_u_ordinal,dts_u_set    ,ttc_in_set           ,trt_unilogical);



  --------------------------------------------------------------------------------------------------
  -- (2) Přetypování
  --------------------------------------------------------------------------------------------------

  ----- Přetypování --------------------------------------------------------------------------------
  -- základ je stejný jako transformace hodnoty 
  setcopy(toc_transform,toc_typecast,false);

  ----- numerické konverze -----
  -- signed(signed) a unsigned(unsigned) se musí redefinovat, 
  -- protože nepožadujeme kontrolu shodnosti aritmetik 
  set111(toc_typecast   ,false,dt_signed    ,dt_signed    ,ttc_simple_check     ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unsigned  ,ttc_simple_check     ,trt_left);
  set111(toc_typecast   ,false,dt_signed    ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_signed    ,ttc_convertible      ,trt_left);
  set11s(toc_typecast   ,false,dt_float     ,dts_u_integer,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_float     ,dt_fixed     ,ttc_convertible      ,trt_left);
  set11s(toc_typecast   ,false,dt_fixed     ,dts_u_integer,ttc_convertible      ,trt_left);

  ----- konverze čísla na znak -----
  set111(toc_typecast   ,false,dt_char      ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_char      ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze znaku na číslo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_char      ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- konverze čísla na logical -----
  set111(toc_typecast   ,false,dt_logical   ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_logical   ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze logicalu na číslo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_logical   ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unilogical,ttc_convertible      ,trt_left);

  ----- konverze čísla na enum -----
  set111(toc_typecast   ,false,dt_enum      ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_enum      ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze enumu na číslo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_enum      ,ttc_convertible      ,trt_left);


  ----- Interface cast -----------------------------------------------------------------------------
  ----- třída -- třída -----
  set111(toc_interface_cast,false,dt_class  ,dt_class     ,ttc_icast_class      ,trt_left);

  ----- pointer na třídu -- pointer na třídu -----
  set111(toc_interface_cast,false,dt_pointer,dt_pointer   ,ttc_icast_pointer    ,trt_left);


  ----- Symetrická konverze ------------------------------------------------------------------------
  ----- univerzální integer -----
  set111(toc_symmetric  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);
  set11s(toc_symmetric  ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_left);
  set1s1(toc_symmetric  ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- univerzální real -----
  set111(toc_symmetric  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- univerzální znak -----
  set111(toc_symmetric  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- univerzální logical -----
  set111(toc_symmetric  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (3) Předávání parametrů
  --------------------------------------------------------------------------------------------------

  ----- Parametr: obyčejný IN parametr -------------------------------------------------------------
  -- základ je stejný jako přiřazení 
  setcopy(toc_assign,toc_param_in,false);


  ----- Parametr: obyčejný OUT parametr ------------------------------------------------------------
  ----- typ - typ  -----
  set111(toc_param_out  ,false,dt_signed    ,dt_signed    ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_unsigned  ,dt_unsigned  ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_float     ,dt_float     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_fixed     ,dt_fixed     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_char      ,dt_char      ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_logical   ,dt_logical   ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_enum      ,dt_enum      ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_string    ,dt_string    ,ttc_identical        ,trt_left);
  set11s(toc_param_out  ,false,dt_ustring   ,dts_string   ,ttc_string           ,trt_left); {ttc_string_string}
  set111(toc_param_out  ,false,dt_array     ,dt_array     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_left); {ttc_uarray_array}
  set111(toc_param_out  ,false,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_uarray_uarray}
  set111(toc_param_out  ,false,dt_record    ,dt_record    ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_class     ,dt_class     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_set       ,dt_set       ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_pointer   ,dt_pointer   ,ttc_pointer_out      ,trt_left);
  set111(toc_param_out  ,false,dt_tag       ,dt_tag       ,ttc_identical        ,trt_left);


  ----- Parametr: Modifikátory CLASS nebo VIRTUAL --------------------------------------------------
  ----- typ - typ  -----
  set111(toc_param_class,false,dt_signed    ,dt_signed    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_unsigned  ,dt_unsigned  ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_float     ,dt_float     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_fixed     ,dt_fixed     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_char      ,dt_char      ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_logical   ,dt_logical   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_string    ,dt_string    ,ttc_derived          ,trt_left);
  set11s(toc_param_class,false,dt_ustring   ,dts_string   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_array     ,dt_array     ,ttc_derived          ,trt_left);
  set11s(toc_param_class,false,dt_uarray    ,dts_array    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_record    ,dt_record    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_class     ,dt_class     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_set       ,dt_set       ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_pointer   ,dt_pointer   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_tag       ,dt_tag       ,ttc_derived          ,trt_left);
  ----- typ - univerzální typ -----
  set1s1(toc_param_class,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  set111(toc_param_class,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_param_class,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set1s1(toc_param_class,false,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_string_uniarray}
  set1s1(toc_param_class,false,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_array_uniarray}
  set1s1(toc_param_class,false,dts_regular  ,dt_uninil    ,ttc_nil              ,trt_left);


  ----- Parametr: Modifikátor UNCHECKED ------------------------------------------------------------
  -- nic nelze nastavit, nemá Full view



  --------------------------------------------------------------------------------------------------
  -- (5) Ostatní operace
  --------------------------------------------------------------------------------------------------

  ----- Konstruktor rozsahu ------------------------------------------------------------------------
  ----- celočíselný .. celočíselný -----
  set111(toc_range      ,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_resolve);
  set111(toc_range      ,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_resolve);
  set1s1(toc_range      ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  set11s(toc_range      ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- znakový .. znakový -----
  set111(toc_range      ,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_resolve);
  set111(toc_range      ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_range      ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- logický .. logický -----
  set111(toc_range      ,false,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_resolve);
  set111(toc_range      ,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_range      ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);

  ----- výčtový .. výčtový -----
  set111(toc_range      ,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_resolve);
  end init_type_compatibility_table;



----------------------------------------------------------------------------------------------------
procedure init_view_compatibility_table =
-- Inicializace tabulky typové kompatibility.
----------------------------------------------------------------------------------------------------
begin
  --------------------------------------------------------------------------------------------------
  -- (1) Operátory
  --------------------------------------------------------------------------------------------------

  ----- Relační porovnávací operace ----------------------------------------------------------------
  vset111(toc_rel_compare,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_unilogical);
  vset111(toc_rel_compare,tview_aggregate ,tview_full      ,tvc_aggregate ,trt_unilogical);
  vset111(toc_rel_compare,tview_partial   ,tview_partial   ,tvc_partial   ,trt_unilogical);



  --------------------------------------------------------------------------------------------------
  -- (2) Přetypování
  --------------------------------------------------------------------------------------------------

  ----- Přetypování --------------------------------------------------------------------------------
  vset111(toc_typecast   ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_typecast   ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_typecast   ,tview_incomplete,tview_unchecked ,tvc_unchecked ,trt_left);

  ----- Interface cast -----------------------------------------------------------------------------
  ----- třída -- třída -----
  vset111(toc_interface_cast,tview_incomplete,tview_full      ,tvc_interface,trt_left);
  vset111(toc_interface_cast,tview_incomplete,tview_incomplete,tvc_interface,trt_left);
  vset111(toc_interface_cast,tview_full      ,tview_incomplete,tvc_interface,trt_left);


  --------------------------------------------------------------------------------------------------
  -- (3) Předávání parametrů
  --------------------------------------------------------------------------------------------------

  ----- Parametr: obyčejný IN parametr -------------------------------------------------------------
  vset111(toc_param_in   ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_param_in   ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_param_in   ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);

  ----- Parametr: obyčejný OUT parametr ------------------------------------------------------------
  vset111(toc_param_out  ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_param_out  ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);

  ----- Parametr: Modifikátory CLASS nebo VIRTUAL --------------------------------------------------
  vset111(toc_param_class,tview_full      ,tview_aggregate ,tvc_aggregate         ,trt_left);
  vset111(toc_param_class,tview_full      ,tview_incomplete,tvc_partial_descendant,trt_left);
  vset111(toc_param_class,tview_partial   ,tview_full      ,tvc_partial_descendant,trt_left);
  vset111(toc_param_class,tview_partial   ,tview_partial   ,tvc_partial_descendant,trt_left);
--vset111(toc_param_class,tview_incomplete,tview_incomplete,tvc_partial_descendant,trt_left);

  ----- Parametr: Modifikátor UNCHECKED ------------------------------------------------------------
  vset111(toc_param_unchecked,tview_unchecked,tview_unchecked ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_full      ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_partial   ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_incomplete,tvc_unchecked      ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (4) Transformace a přiřazení (předsunuto, aby bylo možné kopírovat nastavení)
  --------------------------------------------------------------------------------------------------

  ----- Přiřazení ----------------------------------------------------------------------------------
  vset111(toc_assign     ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_assign     ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_assign     ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_full      ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_partial   ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_incomplete,tvc_unchecked ,trt_left);

  ----- Transformace hodnoty -----------------------------------------------------------------------
--vset111(toc_transform  ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_transform  ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
--vset111(toc_transform  ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_full      ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_partial   ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_incomplete,tvc_unchecked ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (5) Ostatní operace
  --------------------------------------------------------------------------------------------------

  end init_view_compatibility_table;
  


----------------------------------------------------------------------------------------------------
procedure t_gettypeview =
-- Typ pohledu na typ.                                                        
----------------------------------------------------------------------------------------------------
begin
  -- typ nemáme
  if ptyp=nil then result:=tview_null

  -- máme jen Incomplete declaration => Incomplete view 
  elsif ptyp^.evaluated<>etd_full then result:=tview_incomplete

  -- na třídu je vždy Full view 
  elsif ptyp^.evaluated=etd_full and ptyp^.stype=dt_class then result:=tview_full

  -- viditelnost dopředné deklarace a dokončení deklarace se liší 
  elsif ptyp^.visible<>ptyp^.full then
    if sym_is_fully_visible(ptyp,context{^curr})
      -- Full view 
      then result:=tview_full
      -- Partial view 
      else result:=tview_partial;
      end if;

{
  -- Full view pouze v nadřazeném deklarativním regionu
  elsif (ptyp^.visible in [sv_public,sv_protected]) and (ptyp^.full=sv_private) then
    if isincluded(@curr,ptyp^.context)
      -- v nadřazeném deklarativním regionu => Full view 
      then result:=tview_full
      -- jinde => Partial view 
      else result:=tview_partial;
    end

  -- Full view pouze v nadřazeném deklarativním regionu nebo v potomkovi 
  elsif (ptyp^.visible=sv_public) and (ptyp^.full=sv_protected) then
    if isincluded(@curr,ptyp^.context) or isdescendant(@curr,ptyp^.context)
      -- v potomkovi nebo v nadřazeném deklarativním regionu => Full view 
      then result:=tview_full
      -- jinde => Partial view 
      else result:=tview_partial;
    end
}
{
  -- typ by mohl mít utajenou strukturu 
  elsif tf_hidden in ptyp^.tflags then
    psym:=@curr;
    while (psym<>nil) and (psym<>ptyp^.context) do psym:=psym^.context;
    if psym=nil
      then result:=tview_partial
      else result:=tview_full;
    end
}
  -- typ určitě nemá utajenou strukturu 
  else
    result:=tview_full;
    end if;
  end t_gettypeview;



----------------------------------------------------------------------------------------------------
procedure t_gettypefullview =
-- Typ pohledu na typ. Preferuje Full view, nikdy nevrátí Partial view.
----------------------------------------------------------------------------------------------------
begin
  -- typ nemáme
  if ptyp=nil then 
    result:=tview_null

  -- máme jen Incomplete declaration => Incomplete view
  elsif ptyp^.evaluated<>etd_full then 
    result:=tview_incomplete

  -- ve všech ostatních případech se budeme chovat jako Full view
  else 
    result:=tview_full;
    end if;
  end t_gettypefullview;



----------------------------------------------------------------------------------------------------
procedure t_equal =
-- True, jsou-li typy shodné.                                                 
----------------------------------------------------------------------------------------------------
begin
  result:=t1.getctype=t2.getctype;
  end t_equal;



----------------------------------------------------------------------------------------------------
procedure t_equal_view =
-- True, jsou-li to shodné pohledy na shodné typy.                            
----------------------------------------------------------------------------------------------------
begin
  result:=t1.tview=t2.tview and t1.getctype=t2.getctype;
  end t_equal_view;



----------------------------------------------------------------------------------------------------
module cc_unchecked_compatibility =
-- Procedury pro kontrolu pravidel unchecked kompatibility.
----------------------------------------------------------------------------------------------------

    type
      -- režim "unchecked velikosti"
      t_unchecked_size_mode = enum
          us_dynamic;                            -- úplně dynamická velikost
          us_combined;                           -- kombinovaná: fixní základ + násobek báze
          us_fixed;                              -- fixní velikost
          end enum;

      -- "unchecked velikost" objektu
      t_unchecked_size = record
          mode         : t_unchecked_size_mode;  -- režim "unchecked velikost" objektu
          fixed_part   : tunidata_size;          -- fixní složka velikosti objektu
          base_part    : tunidata_size;          -- proměnná složka velikosti objektu
          end record;

    ------------------------------------------------------------------------------------------------
    procedure get_unchecked_size (
        t1         : pentity_type)               -- zkoumaný typ
        return t_unchecked_size;
    -- Sestaví popis "unchecked velikosti" typu [t1].
    ------------------------------------------------------------------------------------------------
    procedure test_unchecked_size (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical;                        -- True, jsou-li typy unchecked kompatibilní
    -- Kontrola unchecked kompatibility dvou typů.
    ------------------------------------------------------------------------------------------------

  private

    ------------------------------------------------------------------------------------------------
    procedure get_unchecked_size =
    -- Sestaví popis "unchecked velikosti" typu [t1].
    ------------------------------------------------------------------------------------------------
    begin
      -- typ není vůbec známý => dynamická velikost
      if t1=nil then 
        result.mode:=us_dynamic;

      -- je to nějaký unconstrained typ => kombinovaná velikost
      elsif t1^.stype in dts_unconstrained then
        result.mode:=us_combined;
        result.fixed_part:=t1^.size;
        result.base_part:=t1^.base.getctype^.size;

      -- všechno ostatní vede na fixní velikost
      else
        result.mode:=us_fixed;
        result.fixed_part:=t1^.size;
        end if;
      end get_unchecked_size;



    ------------------------------------------------------------------------------------------------
    procedure test_combined_combined (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical =
    -- Kontrola případu combined -- combined.
    ------------------------------------------------------------------------------------------------
    begin
      -- %%TODO(SLICE) Dodělat, až budou k dispozici řezy pole. Bez nich se totiž
      -- toto pravidlo kompatibility nedá rozumně aplikovat, protože je silně omezující
      -- a typicky se využívá ve spojistoti právě s řezy pole.
      result:=true;
    {
      F1 + N*B1 = F2 + M*B2

      => N*B1 = F2-F1 + M*B2

      => N = F2-F2/B1 + M*(B2/B1)
    }
    {
      -- fixní velikost levé strany je menší než pravé
      if s1.fixed_part>s2.fixed_part then

      -- fixní velikost pravé strany je menší než levé
      elsif s1.fixed_part<s2.fixed_part then
    }
      end test_combined_combined;



    ------------------------------------------------------------------------------------------------
    procedure test_fixed_combined (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical =
    -- Kontrola případu fixed -- combined.
    ------------------------------------------------------------------------------------------------
    begin
      result:=true;
    {
      -- %%TODO(SLICE) Dodělat, až budou k dispozici řezy pole. Bez nich se totiž
      -- toto pravidlo kompatibility nedá rozumně aplikovat, protože je silně omezující
      -- a typicky se využívá ve spojistoti právě s řezy pole.
    
      -- fixní složka levé strany musí být alespoň tak velká, jako fixní složka pravé strany
      result:=s1.fixed_part>=s2.fixed_part
      -- test kongruence zbytku fixní složky s velikostí báze proměnné složky pravé strany
      and then ((s1.fixed_part-s2.fixed_part) mod s2.base_part)=uds_0;
    }
      end test_fixed_combined;



    ------------------------------------------------------------------------------------------------
    procedure test_unchecked_size =
    -- Kontrola unchecked kompatibility dvou typů.
    ------------------------------------------------------------------------------------------------
    begin
      -- alespoň jedna z velikostí je dynamická => OK
      if s1.mode=us_dynamic or s2.mode=us_dynamic then
        result:=true;

      -- fixed -- fixed => velikosti se musí shodovat
      elsif s1.mode=us_fixed and s2.mode=us_fixed then
      {
        -- %%TODO(SLICE) Dodělat, až budou k dispozici řezy pole. Bez nich se totiž
        -- toto pravidlo kompatibility nedá rozumně aplikovat, protože je silně omezující
        -- a typicky se využívá ve spojistoti právě s řezy pole.
        result:=s1.fixed_part=s2.fixed_part;
      }
        result:=true;

      -- combined -- combined => velikosti musí
      elsif s1.mode=us_combined and s2.mode=us_combined then
        result:=test_combined_combined(s1,s2);

      -- combined -- fixed
      elsif s1.mode=us_combined and s2.mode=us_fixed then
        result:=test_fixed_combined(s2,s1);

      -- fixed -- combined
      elsif s1.mode=us_fixed and s2.mode=us_combined then
        result:=test_fixed_combined(s1,s2);

      -- jiný případ nemůže nastat
      else
        verify({VERIFY=}000755,true);
        end if;
      end test_unchecked_size;

    end cc_unchecked_compatibility;



----------------------------------------------------------------------------------------------------
procedure t_compatible_unchecked_pointers =
-- True, jsou-li typy kompatibilní z hlediska determinace kompatibility. 
-- Oba typy musí být pointery, z nichž alespoň jeden musí být unchecked.
----------------------------------------------------------------------------------------------------
with
  cc_unchecked_compatibility;

begin
  verify({VERIFY=}000756,not t_is_stype(t1,dt_pointer) or else not t_is_stype(t1,dt_pointer) or else (t1.getpbase<>pb_unchecked and t2.getpbase<>pb_unchecked));

  -- vypočítat "unchecked velikosti" obou typů a zkontrolovat kompatibilitu
  result:=test_unchecked_size(get_unchecked_size(t1.getctype^.base.getutype),get_unchecked_size(t2.getctype^.base.getutype));
  end t_compatible_unchecked_pointers;



----------------------------------------------------------------------------------------------------
procedure t_compatible_varaccesses =
-- True, jsou-li typy kompatibilní z hlediska determinace přístupu.
-- Oba typy musí být pointery. T1 musí být cílový typ operace (přiřazuje se do instance T1), T2 musí
-- být zdrojový typ (přiřazuje se z instance T2).
----------------------------------------------------------------------------------------------------
var
  t1a              : varaccess;                  -- determinace přístupu pointeru 1
  t2a              : varaccess;                  -- determinace přístupu pointeru 2

begin
  verify({VERIFY=}000757,not t_is_stype(t1,dt_pointer) or not t_is_stype(t1,dt_pointer));

  -- restrikce T1 > restrikce T2 => ok
  if t1a>t2a then result:=true

  -- normální <- normální
  elsif t1a=va_norm and t2a=va_norm then result:=true;

  -- const <- const
  elsif t1a=va_const and t2a=va_const then result:=true;

  -- protected <- protected
  elsif t1a=va_protected and t2a=va_protected then
    declare var
      s1           : pentity;                    -- kontejner, ve kterém je deklarován T1
      s2           : pentity;                    -- kontejner, ve kterém je deklarován T2

    begin
      -- zjistit kontejnery, ve kterých jsou T1 a T2 deklarovány
      s1:=sym_get_container(t1.getctype);
      s2:=sym_get_container(t2.getctype);

      -- S1 je vnořen v S2 nebo S1 je potomek S2 => ok
      result:=sym_is_included(s1,s2) or sym_is_descendant(s1,s2);
      end declare;

  -- ostatní případy nejsou kompatibilní
  else result:=false;
  end if;
  end t_compatible_varaccesses;



----------------------------------------------------------------------------------------------------
procedure t_compatible_determinations =
-- True, jsou-li typy kompatibilní z hlediska determinace kompatibility.      
----------------------------------------------------------------------------------------------------
begin
  result:=not (
  -- je-li jeden z typů protected, musí být druhý identický nebo univerzální 
     ((t1.compat=tc_protected) and (not t_equal(t1,t2) and t2.stype not in dts_unitype))
  or ((t2.compat=tc_protected) and (not t_equal(t1,t2) and t1.stype not in dts_unitype))
  -- je-li jeden z typů private, musí být druhý identický
  or ((t1.compat=tc_private) and not t_equal(t1,t2))
  or ((t2.compat=tc_private) and not t_equal(t1,t2))
  );
  end t_compatible_determinations;



----------------------------------------------------------------------------------------------------
procedure t_typecheck =
-- Typová kontrola.                                                           
----------------------------------------------------------------------------------------------------

      ----------------------------------------------------------------------------------------------
      procedure test_interface (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Abstraktní třída -- třída.
      ----------------------------------------------------------------------------------------------
      begin
        if t1.isclass and t2.isclass and t1.is_abstract
          -- kompatibilní
          then level:=tcl_convertible
          -- nekompatibilní
          else level:=tcl_incompatible;
          end if;
        end test_interface;

begin
  restype:=trt_none;


  ----- jeden z typů není určen --------------------------------------------------------------------
  if t1.tview=tview_null or t2.tview=tview_null then level:=tcl_incompatible


  ----- jeden z typů není Full view ----------------------------------------------------------------
  elsif t1.tview<>tview_full or t2.tview<>tview_full then
    declare

      ----------------------------------------------------------------------------------------------
      procedure test_partial (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Partial view <--> Partial view
      ----------------------------------------------------------------------------------------------
      begin
        -- identické typy
        if t_equal(t1,t2) then level:=tcl_identical
        -- jinak nekompatibilní
        else level:=tcl_incompatible;
        end if;
        end test_partial;



      ----------------------------------------------------------------------------------------------
      procedure test_partial_descendant (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Partial view <--> Partial view
      ----------------------------------------------------------------------------------------------
      begin
        -- identické typy
        if t_equal(t1,t2) then level:=tcl_identical
        -- je T1 předek T2 -> staticky binárně shodné
        elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
        -- jinak nekompatibilní
        else level:=tcl_incompatible;
        end if;
        end test_partial_descendant;



      ----------------------------------------------------------------------------------------------
      procedure test_unchecked (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Unchecked view := / <-- cokoliv
      ----------------------------------------------------------------------------------------------
      with
        cc_unchecked_compatibility;

      begin
        -- vypočítat "unchecked velikosti" obou typů a zkontrolovat kompatibilitu
        if test_unchecked_size(get_unchecked_size(t1.getutype),get_unchecked_size(t2.getutype))
          then level:=tcl_static_identical;
          else level:=tcl_incompatible;
          end if;
        end test_unchecked;



      ----------------------------------------------------------------------------------------------
      procedure test_aggregate (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Full view <--> Aggregate view.                                    
      ----------------------------------------------------------------------------------------------
      begin
        -- agregát -- agregátní typ
        if t1.tview=tview_aggregate and t_is_sts(t2,dts_aggregate) then level:=tcl_identical
        -- agregátní typ -- agregát
        elsif t2.tview=tview_aggregate and t_is_sts(t1,dts_aggregate) then level:=tcl_identical
        -- jinak nekompatibilní
        else level:=tcl_incompatible;
        end if;
        end test_aggregate;

    begin    
      -- zvolit typ výsledku
      restype:=viewcheck[oclass,t1.tview,t2.tview].r;

      -- typová kontrola
      case viewcheck[oclass,t1.tview,t2.tview].c

        -- nekompatibilní pohledy
        when tvc_incompatible       do level:=tcl_incompatible;

        -- kontrola parciálních pohledů
        when tvc_partial            do test_partial(t1,t2);
        
        -- kontrola parciálních pohledů, T1 předek T2
        when tvc_partial_descendant do test_partial_descendant(t1,t2);
        
        -- kontrola unchecked pohledů
        when tvc_unchecked          do test_unchecked(t1,t2);
        
        -- kontrola kombinace Full view a Aggregate view
        when tvc_aggregate          do test_aggregate(t1,t2);

        -- kontrola interface cast
        when tvc_interface          do test_interface(t1,t2);
        end case;

      -- %%X A co kontrola determinace kompatibility ? Má se provádět ?
      end declare;


  ----- zkoumat dál (oba jsou určitě Full view) ----------------------------------------------------
  else 
    declare

      ----------------------------------------------------------------------------------------------
      procedure test_determinations_base (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test determinací kompatibility T1 a T2:base.
      ----------------------------------------------------------------------------------------------
      begin
        -- podařilo-li se, pak ještě zkontrolovat determinaci kompatibility s bází množiny
        if level<>tcl_incompatible then
          if not t_compatible_determinations(t1,t2.getbase(context)) then
            level:=tcl_incompatible;
            end if;
          end if;
        end test_determinations_base;



      ----------------------------------------------------------------------------------------------
      procedure test_indexed_component (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_INDEXED_COMPONENT a TTC_COMPONENT_INDEXED.
      ----------------------------------------------------------------------------------------------
      begin
        -- není typ komponenty univerzální ? 
        if t2.stype in dts_unitype

          -- ano => musí být kompatibilní s bází řetězce 
          then
            if not t_compatible(context,toc_symmetric,false,t1.getbase(context),t2) then
              level:=tcl_incompatible;
              return;
              end if;

          -- ne => musí být identický s bází řetězce
          else
            if not t_equal(t1.getbase(context),t2) then
              level:=tcl_incompatible;
              return;
              end if;
            end if;

        level:=tcl_convertible;
        end test_indexed_component;



      ----------------------------------------------------------------------------------------------
      procedure test_string (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_STRING a TTC_ORDER_STRING.
      ----------------------------------------------------------------------------------------------
      begin
        -- identické typy 
        if t_equal(t1,t2) then level:=tcl_identical;
        -- identické báze
        elsif t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
        -- nekompatibilní
        else level:=tcl_incompatible;
        end if;
        end test_string;



      ----------------------------------------------------------------------------------------------
      procedure test_array (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_ARRAY a TTC_ORDER_ARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        if t_equal(t1,t2)
          -- identické typy
          then level:=tcl_identical
          -- pole musí být stejná
          else level:=tcl_incompatible;
          end if ;
        end test_array;



      ----------------------------------------------------------------------------------------------
      procedure test_uarray (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_UARRAY a TTC_ORDER_UARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        -- no, jistě nebudou stejné

        -- musí mít stejné báze
        if t_equal(t1.getbase(context),t2.getbase(context))
          then level:=tcl_static_identical
          else level:=tcl_incompatible;
          end if;
        end test_uarray;



      ----------------------------------------------------------------------------------------------
      procedure test_uniarray (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_(ORDER_)STRING/(UNI)ARRAY_STRING/(UNI)ARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        -- no, jistě nebudou stejné 

        -- jedna z bází je univerzální 
        if t_is_sts(t1.getbase(context),dts_unitype) or t_is_sts(t2.getbase(context),dts_unitype)

          -- musí mít kompatibilní báze 
          then
            if not t_compatible(context,toc_symmetric,false,t1.getbase(context),t2.getbase(context)) then
              level:=tcl_incompatible;
              return;
              end if;

          -- jinak musí mít identické báze 
          else
            if not t_equal(t1.getbase(context),t2.getbase(context)) then
              level:=tcl_incompatible;
              return;
              end if;
            end if;

        level:=tcl_convertible;
        end test_uniarray;



      ----------------------------------------------------------------------------------------------
      procedure test_convertible (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test konvertibility typů. 
      -- Určeno pro jednoduché případy, kdy alespoň jeden z typů je univerzální.
      ----------------------------------------------------------------------------------------------
      begin
        if t_equal(t1,t2)
          -- identické
          then level:=tcl_identical
          -- aspoň konvertibilní
          else level:=tcl_convertible;
          end if;
        end test_convertible;



      ----------------------------------------------------------------------------------------------
      procedure test_iaritm (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celočíselných typů. 
      -- Žádný z typů nesmí být univerzální.
      ----------------------------------------------------------------------------------------------
      begin
        -- identické typpy
        if t_equal(t1,t2) then level:=tcl_identical
        -- T1 je předek T2 --> staticky binárně shodné
        elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
        -- T1 je potomek T2 --> dynamicky binárně shodné (kontrola mezí)
        elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
        -- shodné aritmetiky --> konvertibilní
        elsif t1.getintaritm=t2.getintaritm then level:=tcl_convertible
        -- nekompatibilní typy
        else level:=tcl_incompatible;
        end if;
        end test_iaritm;



      ----------------------------------------------------------------------------------------------
      #template test_modular (t);
      ----------------------------------------------------------------------------------------------
        if not t_is_sts(t,dts_unitype) and then t.getintaritm<>tia_modular then
          level:=tcl_incompatible;
          return;
          end if;
        #end test_modular;



      ----------------------------------------------------------------------------------------------
      procedure test_modaritm (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celočíselných typů s modulární aritmetikou.
      -- Jeden z typů může být univerzální.
      ----------------------------------------------------------------------------------------------
      begin
        -- typ vlevo musí mít modulární aritmetiku
        test_modular(t1);

        -- typ vpravo musí mít modulární aritmetiku
        test_modular(t2);
     
        -- jeden z typů je univerzální 
        if t_is_sts(t1,dts_unitype) or t_is_sts(t2,dts_unitype)

          -- stačí test konvertibility
          then test_convertible(t1,t2);

          -- jinak úplný test celočíselné aritmetiky
          else test_iaritm(t1,t2);
          end if;
        end test_modaritm;



      ----------------------------------------------------------------------------------------------
      procedure test_modaritm_left (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celočíselných typů s modulární aritmetikou u levého operandu.
      -- Jeden z typů může být univerzální.
      ----------------------------------------------------------------------------------------------
      begin
        -- typ vlevo musí mít modulární aritmetiku
        test_modular(t1);
     
        -- jinak jsou typy určitě konvertibilní
        level:=tcl_convertible;
        end test_modaritm_left;

    begin
      -- kontrola na přiřazení
      if assign>typecheck[oclass,t1.stype,t2.stype].a then
        level:=tcl_incompatible;
        return;
        end if;

      -- typ výsledku
      if assign
        -- pro přiřazení vždy typ levého operandu
        then restype:=trt_left
        -- jinak podle tabulky
        else restype:=typecheck[oclass,t1.stype,t2.stype].r;
        end if;

      case typecheck[oclass,t1.stype,t2.stype].c
        -- nekompatibilní, není co řešit 
        when ttc_incompatible   do level:=tcl_incompatible;

        -- konvertibilní
        when ttc_convertible    do test_convertible(t1,t2);

        -- kontrola kompatibility celočíselných typů
        when ttc_iaritm_check   do test_iaritm(t1,t2);

        -- kontrola kompatibility celočíselných typů s modulární aritmetikou
        when ttc_modaritm_check do test_modaritm(t1,t2);

        -- kontrola kompatibility celočíselných typů s modulární aritmetikou u levého operandu
        when ttc_modaritm_left_check do test_modaritm_left(t1,t2);

        -- kontrola kompatibility reálných typů
        when ttc_raritm_check do
            -- identické typpy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je předek T2 --> staticky binárně shodné
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky binárně shodné (kontrola mezí)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- konvertibilní typy
            else level:=tcl_convertible;
            end if;

        -- jednoduchá kontrola dědičnosti
        when ttc_simple_check do
            -- identické typpy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je předek T2 --> staticky binárně shodné
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky binárně shodné (kontrola mezí)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- T1 a T2 nejsou v žádném vztahu --> konvertovatelné
            else level:=tcl_convertible;
            end if;

        -- jeden typ odvozen od druhého
        when ttc_derived do
            -- identické typy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je předek T2 --> staticky binárně shodné
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky binárně shodné
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- nekompatibilní
            else level:=tcl_incompatible;
            end if;

        -- typy musí být shodné
        when ttc_identical do
            if t_equal(t1,t2)
              then level:=tcl_identical
              else level:=tcl_incompatible;
              end if;

        -- pole -- pole
        when ttc_array  do test_array(t1,t2);

        -- (neomezené) pole -- (neomezené) pole
        when ttc_uarray do test_uarray(t1,t2);

        -- pole -- pole
        when ttc_order_array do
            -- musí mít diskrétní báze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- mají => zkoumat dál
              then test_array(t1,t2);
              -- nemají => nekompatibilní
              else level:=tcl_incompatible;
              end if;

        -- (neomezené) pole -- (neomezené) pole
        when ttc_order_uarray do
            -- musí mít diskrétní báze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- mají => zkoumat dál
              then test_uarray(t1,t2);
              -- nemají => nekompatibilní
              else level:=tcl_incompatible;
              end if;

        -- (neomezený) string -- (neomezený) string
        when ttc_string do test_string(t1,t2);

        -- (neomezený) string -- (neomezený) string
        when ttc_order_string do
            -- musí mít diskrétní báze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- mají => zkoumat dál
              then test_string(t1,t2);
              -- nemají => nekompatibilní
              else level:=tcl_incompatible;
              end if;

        -- univerzální pole/pole/string -- univerzální pole/pole/string
        when ttc_uniarray do test_uniarray(t1,t2);

        -- univerzální pole/pole/string -- univerzální pole/pole/string
        when ttc_order_uniarray do
            -- musí mít diskrétní báze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- mají => zkoumat dál
              then test_uniarray(t1,t2);
              -- nemají => nekompatibilní
              else level:=tcl_incompatible;
              end if;

        -- (u)string/(u)array  -- komponenta
        when ttc_indexed_component do 
            -- vlastní test kompatibility
            test_indexed_component(t1,t2);

            -- ještě zkontrolovat determinaci kompatibility s bází řetězce/pole
            test_determinations_base(t2,t1);

        -- komponenta -- (u)string/(u)array
        when ttc_component_indexed do 
            -- vlastní test kompatibility
            test_indexed_component(t2,t1);

            -- ještě zkontrolovat determinaci kompatibility s bází řetězce/pole
            test_determinations_base(t1,t2);

        -- komponenta -- komponenta
        when ttc_component_component do
            -- typy jsou ekvivalentní => ok
            if t_equal(t1,t2) then level:=tcl_convertible
            -- typy jsou symetricky kompatibilní => ok
            elsif t_compatible(context,toc_symmetric,false,t1,t2) then level:=tcl_convertible
            -- typy jsou různé => nekompatibilní
            else level:=tcl_incompatible;
            end if;

        -- množina -- množina
        when ttc_set do
            -- identické typy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je předek T2 --> staticky binárně shodné
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky binárně shodné (kontrola mezí)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- identické báze
            elsif t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
            -- jinak nekompatibilní
            else level:=tcl_incompatible;
            end if;

        -- diskrétní IN množina
        when ttc_in_set do
            -- T1 musí být stejný jako báze T2, nebo alespoň odvozený
            if t_descendant(context,t1,t2.getbase(context))
              then level:=tcl_convertible
              else level:=tcl_incompatible;
              end if;

            -- ještě zkontrolovat determinaci kompatibility s bází množiny
            test_determinations_base(t1,t2);

        -- předání pointeru jako OUT parametru
        when ttc_pointer_out do
            if t_equal(t1,t2)

              -- identické typy
              then level:=tcl_identical

              -- zkoumat dál
              else
                ---- (1) kontrola tříd ----
                -- musí to být pointery stejné třídy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola bází ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita bází dvou pointerů
                  t2b : ptrbase;                   -- kompatibilita bází dvou pointerů

                begin
                  -- pro zjednodušení si dopředu zjistit kompatibilitu bází
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- class -- class
                  if t1b=pb_class and t2b=pb_class then
                    -- T1:base předek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- T1:base potomek T2:base
                    elsif t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- unchecked -- unchecked 
                  elsif t1b=pb_unchecked and t2b=pb_unchecked then
                    -- jsou to kompatibilní unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_static_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- jiné kombinace jsou nepovolené
                  else
                    level:=tcl_incompatible;
                    end if;
                  end declare;


                ---- (3) kontrola determinace přístupu ----
                if not t_compatible_varaccesses(t1,t2) then
                  level:=tcl_incompatible;
                  end if;


                -- kompatibilní pointery mají i stejný fyzický layout
                verify({VERIFY=}000758,level<>tcl_incompatible and then t1.getpattrib<>t2.getpattrib);
                end if;

        -- přiřazení pointerů
        when ttc_pointer_assign do
            if t_equal(t1,t2)

              -- identické typy
              then level:=tcl_identical

              -- zkoumat dál
              else
                ---- (1) kontrola tříd ----
                -- musí to být pointery stejné třídy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola bází ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita bází dvou pointerů
                  t2b : ptrbase;                   -- kompatibilita bází dvou pointerů

                begin
                  -- pro zjednodušení si dopředu zjistit kompatibilitu bází
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- strict := strict
                  if t1b=pb_strict and t2b=pb_strict then
                    -- identické báze => kompatibilní
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- ^unconstrained array
                    elsif t_is_stype(t1.getbase(context),dt_uarray) then test_uarray(t1.getbase(context),t2.getbase(context))
                    -- ^unconstrained string
                    elsif t_is_stype(t1.getbase(context),dt_ustring) then test_string(t1.getbase(context),t2.getbase(context))
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- class := class
                  elsif t1b=pb_class and t2b=pb_class then
                    -- T1:base předek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- T1:base potomek T2:base
                    elsif t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- class := strict
                  elsif t1b=pb_class and t2b=pb_strict then
                    -- T1:base předek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- strict := class
                  elsif t1b=pb_strict and t2b=pb_class then
                    -- T1:base potomek T2:base
                    if t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- alespoň jeden z pointerů je unchecked
                  elsif t1b=pb_unchecked or t2b=pb_unchecked then
                    -- jsou to kompatibilní unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_convertible
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- jiné případy by neměly nastat
                  else
                    verify({VERIFY=}000209,true);
                    end if;
                  end declare;


                ---- (3) kontrola determinace přístupu ----
                if not t_compatible_varaccesses(t1,t2) then
                  level:=tcl_incompatible;
                  end if;
                end if;

        -- porovnání pointerů
        when ttc_pointer_rel do
            if t_equal(t1,t2)

              -- identické typy
              then level:=tcl_identical

              -- zkoumat dál
              else 
                ---- (1) kontrola tříd ----
                -- musí to být pointery stejné třídy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola bází ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita bází dvou pointerů
                  t2b : ptrbase;                   -- kompatibilita bází dvou pointerů

                begin
                  -- pro zjednodušení si dopředu zjistit kompatibilitu bází
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- strict -- strict
                  if t1b=pb_strict and t2b=pb_strict then
                    -- identické báze => kompatibilní
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- ^unconstrained array
                    elsif t_is_stype(t1.getbase(context),dt_uarray) 
                       or t_is_stype(t2.getbase(context),dt_uarray) then test_uarray(t1.getbase(context),t2.getbase(context))
                    -- ^unconstrained string
                    elsif t_is_stype(t1.getbase(context),dt_ustring) 
                       or t_is_stype(t2.getbase(context),dt_ustring) then test_string(t1.getbase(context),t2.getbase(context))
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- class -- class
                  elsif t1b=pb_class and t2b=pb_class then
                    -- identické báze
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- jedna odvozená od druhé
                    elsif t_derived(context,t1.getbase(context),t2.getbase(context)) then level:={%%X}tcl_dynamic_identical
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- class -- strict
                  elsif t1b=pb_class and t2b=pb_strict then
                    -- báze T2 musí být odvozena od báze T1
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context))
                      then level:=tcl_dynamic_identical
                      else level:=tcl_incompatible;
                      end if;

                  -- strict -- class
                  elsif t1b=pb_strict and t2b=pb_class then
                    -- báze T1 musí být odvozena od báze T2
                    if t_ancestor(context,t2.getbase(context),t1.getbase(context))
                      then level:=tcl_dynamic_identical
                      else level:=tcl_incompatible;
                      end if;

                  -- alespoň jeden z pointerů je unchecked
                  elsif t1b=pb_unchecked or t2b=pb_unchecked then
                    -- jsou to kompatibilní unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_convertible
                    -- jinak nekompatibilní
                    else level:=tcl_incompatible;
                    end if;

                  -- jiné případy by neměly nastat
                  else
                    verify({VERIFY=}000210,true);
                    end if;
                  end declare;


                ---- (3) kontrola determinace přístupu ----
                -- při porovnávání nás determinace přístupu nezajímá
                end if;  

        -- interface cast: třída -- třída
        when ttc_icast_class do test_interface(t1,t2);

        -- interface cast: pointer -- pointer
        when ttc_icast_pointer do 
            ---- (1) kontrola tříd ----
            -- musí to být pointery na data
            if t1.getpclass<>pc_data or t2.getpclass<>pc_data then
              level:=tcl_incompatible;
              return;
              end if;


            ---- (2) kontrola bází ----
            -- nesmí být unchecked
            if t1.getpbase=pb_unchecked or t2.getpbase=pb_unchecked then
              level:=tcl_incompatible;
              return;
              end if;


            ---- (3) báze musí být icast-kompatibilní třídy ----
            test_interface(t1.getbase(context),t2.getbase(context));

        -- NIL
        when ttc_nil do level:=tcl_static_identical;

        when others do verify({VERIFY=}000073,true);
        end case;

      -- na závěr ještě kontrola determinace kompatibility
      if level<>tcl_incompatible 
      -- má-li pro tento druh kontroly smysl
      and then typecheck[oclass,t1.stype,t2.stype].c not in ttcs_no_determination_check then
        -- provést kontrolu
        if not t_compatible_determinations(t1,t2) then
          level:=tcl_incompatible;
          end if;
        end if;
      end declare;
    end if;
  end t_typecheck;



----------------------------------------------------------------------------------------------------
procedure t_compatible =
-- True, jsou-li typy kompatibilní.                                           
-- Kromě testu determinace kompatibility provádí i test konvertibility        
-- hodnoty typu T2 na typ T1.                                                 
----------------------------------------------------------------------------------------------------
var
  level            : tcomplevel;                 -- úroveň kompatibility                        
  restype          : tresulttype;                -- typ výsledku                                

begin
  t_typecheck(context,oclass,assign,t1,t2,level,restype);
  result:=level<>tcl_incompatible;
  end t_compatible;



----------------------------------------------------------------------------------------------------
procedure t_get_compatibility_level =
-- Úroveň kompatibility typů vůči přiřazení var(T1):=value(T2).               
----------------------------------------------------------------------------------------------------
var
  restype          : tresulttype;                -- typ výsledku                                

begin
  t_typecheck(context,oclass,assign,t1,t2,result,restype);
  end t_get_compatibility_level;



----------------------------------------------------------------------------------------------------
procedure t_binary_identical =
-- True, jsou-li typy binárně identické.                                      
----------------------------------------------------------------------------------------------------
begin
  result:=t_get_compatibility_level(context,toc_assign,true,t1,t2) in tcomplevelset:[tcl_identical,tcl_static_identical];
  end t_binary_identical;



----------------------------------------------------------------------------------------------------
procedure t_descendant =
-- True, je-li T1 potomek T2.                                                 
----------------------------------------------------------------------------------------------------
var
  t                : typeview;

begin
  -- Poznámka: Podobná procedura je i v CC_SYM, ale pro symboly (ISDESCENDANT) 
  t:=t1;
  while (t.tview<>tview_null) and not t_equal(t,t2) loop t:=t.getancestor(context) end loop;
  result:=t.tview<>tview_null;
  end t_descendant;



----------------------------------------------------------------------------------------------------
procedure t_ancestor =
-- True, je-li T1 předek T2.                                                  
----------------------------------------------------------------------------------------------------
var
  t                : typeview;

begin
  -- Poznámka: Podobná procedura je i v CC_SYM, ale pro symboly (ISANCESTOR) 
  t:=t2;
  while (t.tview<>tview_null) and not t_equal(t1,t) loop t:=t.getancestor(context) end loop;
  result:=t.tview<>tview_null;
  end t_ancestor;



----------------------------------------------------------------------------------------------------
procedure t_derived =
-- True, je-li T1 předek nebo potomek T2.                                     
----------------------------------------------------------------------------------------------------
begin
  result:=t_ancestor(context,t1,t2) or t_ancestor(context,t2,t1);
  end t_derived;



----------------------------------------------------------------------------------------------------
procedure t_get_pointer_rtattrib =
-- Ze zadaných údajů vypočítá množinu volitelných atributů pointeru.          
-- Pozor: Očekává, že množina PATTRIB je již inicializovaná.
----------------------------------------------------------------------------------------------------
begin
  -- báze je class => :tag 
  if pbase=pb_class and then base^.stype<>dt_class then
    pattrib+rtattribset:[rta_tag];

  -- báze je unchecked => :size
  {%%TODO(RTATTRIB) Sakra, :size není potřeba v unchecked pointeru s constrained bází, ne? }
  elsif pbase=pb_unchecked then
    pattrib+rtattribset:[rta_size]

  -- báze je unconstrained string/array => :tag (:size nebo :last je vždy vypočitatelné na základě tagu)
  elsif base<>nil and base^.stype in dts_unconstrained then 
    pattrib+rtattribset:[rta_tag]
    end if;  

{
  -- Ondra 06.12.2001 : Musíme se rozhodnout mezi :size a :last
  -- unchecked => :size
  if pbase=pb_unchecked then 
    pattrib+rtattribset:[rta_size]
  -- báze je unconstrained string/array => :last
  elsif base<>nil and base^.stype in dts_unconstrained then 
    pattrib+rtattribset:[rta_last]
  -- class => :size
  elsif (pbase=pb_class and pclass=pc_data) and then base^.stype<>dt_class then 
    pattrib+rtattribset:[rta_size]; 
    end if;
}
  -- Poznámka: Nemůže se stát, že by bázový typ měl utajenou strukturu a já
  -- zde přitom zjistil, že je unconstrained. Je to tím, že typ s
  -- potenciálně utajenou strukturou nesmí být unconstrained.

  -- ^instance
  if pclass=pc_subprogram then
    pattrib+rtattribset:[rta_instance];
    end if;
  end t_get_pointer_rtattrib;



----------------------------------------------------------------------------------------------------
procedure t_is_string_of_char =
-- True, je-li typ unistr/string/ustring of char/unichar.                     
----------------------------------------------------------------------------------------------------
var
  b                : typeview;

begin
  if t.tview=tview_full and t.stype in dts_u_string

    -- je to string, zkoumat bázi
    then
      b:=t.getbase(context);
      result:=b.tview=tview_full and b.stype in dts_u_char;

    -- je to něco jiného
    else
      result:=false;
      end if;
  end t_is_string_of_char;



----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_object =
-- True, je-li typ pointer na objekt.
----------------------------------------------------------------------------------------------------
begin
  result:=t.tview=tview_full and t.stype=dt_pointer and t.getpclass=pc_data;
  end t_is_pointer_to_object;



----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_unconstrained =
-- True, je-li typ pointer na unconstrained array/string.
----------------------------------------------------------------------------------------------------
begin
  result:=t.tview=tview_full and t.stype=dt_pointer and t.getpclass=pc_data
          and t.getbase(context).stype in dts_unconstrained;
  end t_is_pointer_to_unconstrained;



----------------------------------------------------------------------------------------------------
procedure t_is_sts =
-- True, je-li typ z množiny STS.                                             
----------------------------------------------------------------------------------------------------
begin
  result:=(t.tview=tview_full or t.isclass) and t.stype in sts;
  end t_is_sts;



----------------------------------------------------------------------------------------------------
procedure t_is_nonmod_ordinal =
-- Vrací T, pokud je [typ] s plným pohledem, ordinální a případně celoč. bez modulární aritmetiky.
----------------------------------------------------------------------------------------------------
begin
  result:=t_is_sts(typ,dts_ordinal);
  if result and then t_is_sts(typ,dts_integer) then
    result and typ.getintaritm<>tia_modular;
    end if;
  end t_is_nonmod_ordinal;



----------------------------------------------------------------------------------------------------
procedure t_is_range_inclusive =
-- Vrací T, pokud je rozsah [srct] inkluzivně podrozsahem [destt].
----------------------------------------------------------------------------------------------------
var
  rrd              : t_relative_range_disposition;

begin
  -- zjistit vzájemnou polohu mezí cílového a zdrojového typu
  rrd:=t_get_relative_range_disposition(srct,destt);
        
  -- rozsah zdrojového ani stejný ani podmnožinou cílového typu?
  result:=rrd=rrd_equalset or rrd=rrd_subset;
  end t_is_range_inclusive;



----------------------------------------------------------------------------------------------------
procedure t_is_stype =
-- True, je-li typ roven STYPE.
----------------------------------------------------------------------------------------------------
begin
  result:=(t.tview=tview_full or t.isclass) and t.stype=stype;
  end t_is_stype;



----------------------------------------------------------------------------------------------------
procedure t_is_composite =
-- True, je-li typ kompozitní.
----------------------------------------------------------------------------------------------------
begin
  -- typ je v daném kontextu kompozitní <=> 
  result:=t.tview<>tview_full or else t.stype in dts_composite;
  end t_is_composite;



----------------------------------------------------------------------------------------------------
procedure t_contains_class =
-- True, pokud zadaný typ obsahuje instanci třídy jako subkomponentu.
-- (Nebo je sám třída.) Kašle se na viditelnost struktury typu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hledátko

begin
  -- nepočítali jsme to už jednou ?
  if typ.cclass=tcc_unknown then
    case typ.stype
      -- přímo třída
      when dt_class     do typ.cclass:=tcc_yes;

      -- pole/řetězec
      when dt_array,dt_uarray,dt_string,dt_ustring do
          -- předpoklad
          typ.cclass:=tcc_no;

          -- zjistit, jak je na tom báze
          result:=t_contains_class(typ.base.getctype^);
          if result then
            typ.cclass:=tcc_yes;
            return;
            end if;

      -- record
      when dt_record do
          -- předpoklad
          typ.cclass:=tcc_no;

          -- co předek ?
          if typ.ancestor.isset then
            result:=t_contains_class(pentity_type(typ.ancestor.getcentity)^);
            if result then
              typ.cclass:=tcc_yes;
              return;
              end if;
            end if;

          -- co komponenty ?
          srch.find_et_first(^typ,rc_primary,et_var,[]);
          while srch.psym<>nil loop
            -- zkontrolovat
            result:=t_contains_class(pentity_var(srch.psym)^.typ.getctype^);
            if result then
              typ.cclass:=tcc_yes;
              return;
              end if;

            -- další symbol
            srch.find_et_next;
            end loop;

      -- nic jiného nemá komponenty ani není třída
      when others do typ.cclass:=tcc_no;
      end case;
    end if;

  -- pokud se to ještě nezjistilo, tak zjistit teď
  result:=typ.cclass=tcc_yes;
  end t_contains_class;



----------------------------------------------------------------------------------------------------
procedure t_get_relative_range_disposition =
-- vrati relativni rozlozeni mezi typu t1 vzhledem k typu t2
-- rrd_emptyset:      (t1:low<t2:low  and t1:high<t2:low)  or (t1:low>t2:high and t1:high>t2:high)
-- rrd_equalset:       t1:low=t2:low  and t1:high=t2:high
-- rrd_superset:      (t1:low<=t2:low and t1:high>t2:high) or (t1:low<t2:low and t1:high>=t2:high)
-- rrd_subset:        (t1:low>=t2:low and t1:high<t2:high) or (t1:low>t2:low and t1:high<=t2:high)
-- rrd_overlap_left:   t1:low<t2:low  and t1:high<=t2:high and t1:high>=t2:low
-- rrd_overlap_right:  t1:low>=t2:low and t1:low<=t2:high  and t1:high>t2:high
----------------------------------------------------------------------------------------------------
var
  t1_lo : tuniint;
  t1_hi : tuniint;
  t2_lo : tuniint;
  t2_hi : tuniint;

begin
  -- zjisti jednotlive meze
  t1_lo:=t1.getlval;
  t1_hi:=t1.gethval;
  t2_lo:=t2.getlval;
  t2_hi:=t2.gethval;

  -- t1:range a t2:range se neprotinaji
  if (t1_lo<t2_lo and t1_hi<t2_lo) or (t1_lo>t2_hi and t1_hi>t2_hi) then
    result:=rrd_emptyset;
  
  -- t1:range a t2:range jsou stejne
  elsif t1_lo=t2_lo  and t1_hi=t2_hi then
    result:=rrd_equalset;
  
  -- t1:range je nadmnozinou t2:range
  elsif (t1_lo<=t2_lo and t1_hi>t2_hi) or (t1_lo<t2_lo and t1_hi>=t2_hi) then
    result:=rrd_superset;
  
  -- t1:range he podmnozinou t2:range
  elsif (t1_lo>=t2_lo and t1_hi<t2_hi) or (t1_lo>t2_lo and t1_hi<=t2_hi) then
    result:=rrd_subset;
  
  -- t1:range nalevo presahuje t2:range
  elsif t1_lo<t2_lo  and t1_hi<=t2_hi and t1_hi>=t2_lo then
    result:=rrd_overlap_left;
  
  -- t1:range napravo presahuje t2:range
  elsif t1_lo>=t2_lo and t1_lo<=t2_hi  and t1_hi>t2_hi then
    result:=rrd_overlap_right;
  
  -- ostatni pripady
  else
    -- chyba v algoritmu - musi byt vykryty vsechny pripady
    verify({VERIFY=}000759,true);
    end if;

  end t_get_relative_range_disposition;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  init_type_compatibility_table;
  init_view_compatibility_table;
  end entry;



end cc_type;
