----------------------------------------------------------------------------------------------------
module private cc_type =
-- P©eklada‡ Flexu.
-- Operace s typy.
----------------------------------------------------------------------------------------------------
-- Ondra : 20.06.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_sym,cc_def.cc_codes;

type
  -- akce pro ur‡en¡ kompatibility podle porovn n¡ datov˜ch typ–
  t_type_check     = enum
      ---- jednoduch‚ kontroly ----
      ttc_incompatible;                          -- T1 nekompatibiln¡ T2
      ttc_convertible;                           -- T1 identick‚/konvertibiln¡ T2
                                                 -- Pozn mka: pouze pro zjednodu¨en¡, byl by 
                                                 -- nahraditeln˜ akcemi [ttc_simple_check], 
                                                 -- [ttc_iaritm_check], a [ttc_raritm_check], ale 
                                                 -- minim lnˆ posledn¡ dvˆ by se musely zab˜vat 
                                                 -- rozpozn n¡m univerz ln¡ch typ–
      ttc_iaritm_check;                          -- T1 p©edek/potomek/identick‚/stejn‚ aritmetiky/nekompatibiln¡ T2
      ttc_modaritm_check;                        -- T1 p©edek/potomek/identick‚/nekompatibiln¡ T2, pouze modul rn¡ aritmetika
      ttc_modaritm_left_check;                   -- T1 m  modul rn¡ aritmetiku, T2 se ignoruje
      ttc_raritm_check;                          -- T1 p©edek/potomek/identick‚/stejn‚ aritmetiky/nekompatibiln¡ T2
      ttc_simple_check;                          -- T1 p©edek/potomek/identick‚/konvertibiln¡ T2
      ttc_derived;                               -- T1 p©edek/potomek/identick‚/nekompatibiln¡ T2
      ttc_identical;                             -- T1 identick‚/nekompatibiln¡ T2
      ---- pole ----
      ttc_array;                                 -- T1 i T2 jsou pole
      ttc_uarray;                                -- T1 nebo T2 je unconstrained pole, zb˜vaj¡c¡ pole
      ttc_order_array;                           -- jako [ttc_array] pro £‡ely uspo© d n¡
      ttc_order_uarray;                          -- jako [ttc_uarray] pro £‡ely uspo© d n¡
      ---- ©etˆzce ----
      ttc_string;                                -- T1 i T2 jsou string nebo unconstrained string
      ttc_order_string;
      ---- univerz ln¡ pole ----
      ttc_uniarray;                              -- alespo¤ jeden z T1, T2 je univerz ln¡ pole, 
                                                 -- zb˜vaj¡c¡ je (unconstrained) pole nebo 
                                                 -- (unconstrained) string
      ttc_order_uniarray;                        -- jako [ttc_uniarray] pro £‡ely uspo© d n¡
      ---- speciality pro z©etˆzen¡ ----
      ttc_indexed_component;                     -- (u)string/(u)array  -- komponenta
      ttc_component_indexed;                     -- komponenta -- (u)string/(u)array
      ttc_component_component;                   -- komponenta -- komponenta
      ---- mno‘iny ----
      ttc_set;                                   -- mno‘ina -- mno‘ina
      ttc_in_set;                                -- diskr‚tn¡ IN mno‘ina
      ---- pointery ----
      ttc_pointer_assign;                        -- p©i©azen¡ pointeru
      ttc_pointer_rel;                           -- porovn n¡ pointeru
      ttc_pointer_out;                           -- p©ed n¡ pointeru jako OUT parametru
      ---- interface cast ----
      ttc_icast_class;                           -- t©¡da -- t©¡da
      ttc_icast_pointer;                         -- pointer na t©¡du -- pointer na t©¡du
      ---- NIL ----
      ttc_nil;                                   -- univerz lnˆ kompatibiln¡ NIL
      end enum;
  t_type_check_set = set of t_type_check;

const
{
  -- operace, u kter˜ch nem  smysl prov dˆt test determinace kompatibility nebo se prov d¡ jinak
  tocs_no_determination_check = toperclassset:[
      -- pro membership test se prov d¡ nad dvojic¡ <el:type,er:base>
      toc_rel_member,
      -- pro p©etypov n¡ a interface cast nem  smysl
      toc_typecast,
      toc_interface_cast];
}
  -- akce, u kter˜ch nem  smysl prov dˆt test determinace kompatibility nebo se prov d¡ jinak
  ttcs_no_determination_check = t_type_check_set:[
      -- pro z©etˆzen¡ ©etˆzce s komponentou se prov d¡ nad dvojic¡ <string:base,component:type>
      ttc_indexed_component,
      ttc_component_indexed,
      -- pro membership test se prov d¡ nad dvojic¡ <el:type,er:base> 
      ttc_in_set,
      -- pro p©etypov n¡ a interface cast nem  smysl
      ttc_icast_class,
      ttc_icast_pointer];

  -- %%TECH Pozn mka: Charakter test– TTC_SIMPLE_CHECK a TTC_STRICT_SIMPLE
  -- zaji¨Ÿuje automatickou kontrolu shodnosti aritmetik celo‡¡seln˜ch typ–.
  -- D–kaz: Aritmetiky nelze zmˆnit derivac¡ typu.

type
  -- tabulka pro kontrolu kompatibility
  t_type_check_tab = array toperclass,tdatatype,tdatatype of record
      c            : t_type_check;               -- kompatibilita/dal¨¡ kontrola
      r            : tresulttype;                -- typ v˜sledku
      a            : t_logical;                  -- T-povoleno zkr cen‚ p©i©azen¡
      end record;

var
  typecheck        : t_type_check_tab;

type
  -- akce pro ur‡en¡ kompatibility podle porovn n¡ pohled–
  t_view_check     = enum
      tvc_incompatible;                          -- nekompatibiln¡ pohledy
      tvc_partial;                               -- kontrola parci ln¡ch pohled–
      tvc_partial_descendant;                    -- kontrola parci ln¡ch pohled–, T1 p©edek T2
      tvc_unchecked;                             -- kontrola unchecked pohled–
      tvc_aggregate;                             -- kontrola kombinace Full view a Aggregate view
      tvc_interface;                             -- kontrola interface cast
      end enum;

  -- tabulka pro kontrolu kompatibility
  t_view_check_tab = array toperclass,ttypeview,ttypeview of record
      c            : t_view_check;               -- kompatibilita/dal¨¡ kontrola
      r            : tresulttype;                -- typ v˜sledku
      end record;

var
  viewcheck        : t_view_check_tab;

----------------------------------------------------------------------------------------------------
procedure vset111 (
    oclass         : in toperclass;              -- t©¡da operace
    v1             : in ttypeview;               -- pohled na typ
    v2             : in ttypeview;               -- pohled na typ
    check          : in t_view_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- VIEWCHECK[OCLASS,V1,V2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  viewcheck[oclass,v1,v2].c:=check;
  viewcheck[oclass,v1,v2].r:=result;
  end vset111;



----------------------------------------------------------------------------------------------------
procedure vset11s (
    oclass         : in toperclass;              -- t©¡da operace
    v1             : in ttypeview;               -- pohled na typ
    v2             : in ttypeviewset;            -- pohled na typ
    check          : in t_view_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- VIEWCHECK[OCLASS,V1,V2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in ttypeview loop
    if i in v2 then
      viewcheck[oclass,v1,i].c:=check;
      viewcheck[oclass,v1,i].r:=result;
      end if;
    end loop;
  end vset11s;



----------------------------------------------------------------------------------------------------
procedure set111 (
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatype;               -- datov‚ typy
    t2             : in tdatatype;               -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[OCLASS,T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  typecheck[oclass,t1,t2].c:=check;
  typecheck[oclass,t1,t2].r:=result;
  typecheck[oclass,t1,t2].a:=assign;
  end set111;



----------------------------------------------------------------------------------------------------
procedure set1s1 (
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatypeset;            -- datov‚ typy
    t2             : in tdatatype;               -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t1 then
      typecheck[oclass,i,t2].c:=check;
      typecheck[oclass,i,t2].r:=result;
      typecheck[oclass,i,t2].a:=assign;
      end if;
    end loop;
  end set1s1;



----------------------------------------------------------------------------------------------------
procedure set11s (
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatype;               -- datov‚ typy
    t2             : in tdatatypeset;            -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t2 then
      typecheck[oclass,t1,i].c:=check;
      typecheck[oclass,t1,i].r:=result;
      typecheck[oclass,t1,i].a:=assign;
      end if;
    end loop;
  end set11s;



----------------------------------------------------------------------------------------------------
procedure set1ss (
    oclass         : in toperclass;              -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatypeset;            -- datov‚ typy
    t2             : in tdatatypeset;            -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for i in tdatatype loop
    if i in t1 then
      for j in tdatatype loop
        if j in t2 then
          typecheck[oclass,i,j].c:=check;
          typecheck[oclass,i,j].r:=result;
          typecheck[oclass,i,j].a:=assign;
          end if;
        end loop;
      end if;  
    end loop;
  end set1ss;



----------------------------------------------------------------------------------------------------
procedure sets11 (
    oclass         : in toperclassset;           -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatype;               -- datov‚ typy
    t2             : in tdatatype;               -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      typecheck[o,t1,t2].c:=check;
      typecheck[o,t1,t2].r:=result;
      typecheck[o,t1,t2].a:=assign;
      end if;
    end loop;
  end sets11;



----------------------------------------------------------------------------------------------------
procedure setss1 (
    oclass         : in toperclassset;           -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatypeset;            -- datov‚ typy
    t2             : in tdatatype;               -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t1 then
          typecheck[o,i,t2].c:=check;
          typecheck[o,i,t2].r:=result;
          typecheck[o,i,t2].a:=assign;
          end if;
        end loop;
      end if;
    end loop;
  end setss1;



----------------------------------------------------------------------------------------------------
procedure sets1s (
    oclass         : in toperclassset;           -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatype;               -- datov‚ typy
    t2             : in tdatatypeset;            -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t2 then
          typecheck[o,t1,i].c:=check;
          typecheck[o,t1,i].r:=result;
          typecheck[o,t1,i].a:=assign;
          end if;
        end loop;
      end if;
    end loop;
  end sets1s;



----------------------------------------------------------------------------------------------------
procedure setsss (
    oclass         : in toperclassset;           -- t©¡da operace
    assign         : in t_logical;               -- T-povoleno zkr cen‚ p©i©azen¡
    t1             : in tdatatypeset;            -- datov‚ typy
    t2             : in tdatatypeset;            -- datov‚ typy
    check          : in t_type_check;            -- kontrola
    result         : in tresulttype) =           -- typ v˜sledku
-- TYPECHECK[T1,T2]:=CHECK.
----------------------------------------------------------------------------------------------------
begin
  for o in toperclass loop
    if o in oclass then
      for i in tdatatype loop
        if i in t1 then
          for j in tdatatype loop
            if j in t2 then
              typecheck[o,i,j].c:=check;
              typecheck[o,i,j].r:=result;
              typecheck[o,i,j].a:=assign;
              end if;
            end loop;
          end if;
        end loop;
      end if;
    end loop;
  end setsss;



----------------------------------------------------------------------------------------------------
procedure setcopy (
    from           : in toperclass;              -- t©¡da operace
    _to            : in toperclass;              -- t©¡da operace
    retain_assign  : in t_logical) =             -- ponechat nastaven¡ p©¡znaku assign
-- TYPECHECK[TO]:=TYPECHECK[FROM].
----------------------------------------------------------------------------------------------------
begin
  typecheck[_to]:=typecheck[from];
  if not retain_assign then
    for i in tdatatype loop
      for j in tdatatype loop
        typecheck[_to,i,j].a:=false;
        end loop;
      end loop;
    end if;
  end setcopy;



----------------------------------------------------------------------------------------------------
procedure init_type_compatibility_table =
-- Inicializace tabulky typov‚ kompatibility.
----------------------------------------------------------------------------------------------------
begin
  --------------------------------------------------------------------------------------------------
  -- (4) Transformace a p©i©azen¡ (p©edsunuto, aby bylo mo‘n‚ kop¡rovat nastaven¡)
  --------------------------------------------------------------------------------------------------

  ----- P©i©azen¡ ----------------------------------------------------------------------------------
  ----- celo‡¡seln˜ := celo‡¡seln˜ -----
  set111(toc_assign     ,true ,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_left);
  set1s1(toc_assign     ,true ,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- floating-point : = numerick˜ -----
  set111(toc_assign     ,true ,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- fixed-point : = numerick˜ -----
  set111(toc_assign     ,true ,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_left);
  set111(toc_assign     ,true ,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- znakov˜ := znakov˜ -----
  set111(toc_assign     ,true ,dt_char      ,dt_char      ,ttc_simple_check     ,trt_left);
  set111(toc_assign     ,true ,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- logick˜ := logick˜ -----
  set111(toc_assign     ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_left);
  set111(toc_assign     ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);

  ----- v˜‡tov˜ := v˜‡tov˜ -----
  set111(toc_assign     ,true ,dt_enum      ,dt_enum      ,ttc_derived          ,trt_left);

  ----- ©etˆzec := ©etˆzec -----
  set1ss(toc_assign     ,true ,dts_string   ,dts_string   ,ttc_string           ,trt_left); {ttc_string_string}
  set1s1(toc_assign     ,true ,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_string_uniarray}

  ----- pole := pole -----
  set111(toc_assign     ,true ,dt_array     ,dt_array     ,ttc_array            ,trt_left); {ttc_array_array}
  set111(toc_assign     ,true ,dt_array     ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_array_uarray}
  set111(toc_assign     ,true ,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_left); {ttc_uarray_array}
  set111(toc_assign     ,true ,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_uarray_uarray}
  set1s1(toc_assign     ,true ,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_array_uniarray}

  ----- record := record -----
  set111(toc_assign     ,true ,dt_record    ,dt_record    ,ttc_identical{!!}    ,trt_left);

  ----- t©¡da := t©¡da -----
  set111(toc_assign     ,true ,dt_class     ,dt_class     ,ttc_identical{!!}    ,trt_left);

  ----- mno‘ina := mno‘ina -----
  set111(toc_assign     ,true ,dt_set       ,dt_set       ,ttc_set              ,trt_left);

  ----- pointer := pointer -----
  set111(toc_assign     ,true ,dt_pointer   ,dt_pointer   ,ttc_pointer_assign   ,trt_left);

  ----- tag := tag -----
  set111(toc_assign     ,true ,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_left);

  ----- regul rn¡ := NIL -----
  set1s1(toc_assign     ,true ,dts_regular  ,dt_uninil    ,ttc_nil              ,trt_left);


  ----- Transformace hodnoty -----------------------------------------------------------------------
  -- z klad je stejn˜ jako p©i©azen¡ 
  setcopy(toc_assign,toc_transform,false);

  ----- record <-- record -----
  set111(toc_transform  ,false,dt_record    ,dt_record    ,ttc_derived          ,trt_left);

  ----- t©¡da <-- t©¡da -----
  set111(toc_transform  ,false,dt_class     ,dt_class     ,ttc_derived          ,trt_left);

  -- uniint <-- uniint 
  set111(toc_transform  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  -- unireal <-- uniint,unireal 
  set111(toc_transform  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);

  -- unichar <-- unichar 
  set111(toc_transform  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);

  -- unilogical <-- unilogical
  set111(toc_transform  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);

  -- uniarray <-- uniarray 
  set111(toc_transform  ,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (1) Oper tory
  --------------------------------------------------------------------------------------------------

  ----- Aritmetick‚ operace ------------------------------------------------------------------------
  ----- celo‡¡seln˜ + celo‡¡seln˜ -----
  sets11(tocs_iaritm    ,true ,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_resolve);
  sets11(tocs_iaritm    ,true ,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_resolve);
  setss1(tocs_iaritm    ,true ,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  sets1s(tocs_iaritm    ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_right);
  sets11(tocs_iaritm    ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- floating-point + floating-point -----
  sets11(tocs_raritm    ,true ,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_resolve);
  sets11(tocs_raritm    ,true ,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_right);

  ----- fixed-point + fixed-point -----
  sets11(tocs_raritm    ,true ,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_resolve);
  sets11(tocs_raritm    ,true ,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_right);

  ----- re ln˜ + re ln˜ -----
  sets11(tocs_raritm    ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);


  ----- Mno‘inov‚ operace --------------------------------------------------------------------------
  ----- mno‘ina + mno‘ina -----
  set111(toc_set        ,true ,dt_set       ,dt_set       ,ttc_set              ,trt_left);


  ----- Spojov n¡ ©etˆzc– --------------------------------------------------------------------------
  ----- string & string -----
  set111(toc_concat     ,true ,dt_string      ,dt_string      ,ttc_string             ,trt_resolve); {ttc_string_string}
  set111(toc_concat     ,true ,dt_string      ,dt_ustring     ,ttc_string             ,trt_right);   {ttc_string_string}
  set11s(toc_concat     ,true ,dt_ustring     ,dts_string     ,ttc_string             ,trt_left);    {ttc_string_string}
  set1s1(toc_concat     ,true ,dts_string     ,dt_uniarray    ,ttc_uniarray           ,trt_left);    {ttc_string_uniarray}
  set11s(toc_concat     ,false,dt_uniarray    ,dts_string     ,ttc_uniarray           ,trt_right);   {ttc_uniarray_string}
  set111(toc_concat     ,false,dt_uniarray    ,dt_uniarray    ,ttc_uniarray           ,trt_left);    {ttc_uniarray}

  ----- univerz ln¡ string & component -----
  set11s(toc_concat     ,false,dt_uniarray    ,dts_u_unindexed,ttc_indexed_component  ,trt_left);
  set1s1(toc_concat     ,false,dts_u_unindexed,dt_uniarray    ,ttc_component_indexed  ,trt_right);

  ----- string & component (kromˆ p©¡padu component=string) -----
  set1ss(toc_concat     ,true ,dts_string     ,dts_u_unindexed,ttc_indexed_component  ,trt_left);
  set1ss(toc_concat     ,false,dts_u_unindexed,dts_string     ,ttc_component_indexed  ,trt_right);

  ----- component & component -----
  set1ss(toc_concat     ,false,dts_u_unindexed,dts_u_unindexed,ttc_component_component,trt_uniarray_el);
{!!
  dt_string, dt_array    --> a) trt_left + dt_array:length ???, b) dt_ustring
  dt_ustring, dt_array   --> trt_left
  dt_array, dt_string    --> a) trt_right + dt_array:length ???, b) dt_ustring
  dt_array, dt_ustring   --> trt_right
}

  ----- Logick‚ operace ----------------------------------------------------------------------------
  ----- logick˜ AND logick˜ -----
  set111(toc_logical    ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_resolve);
  set111(toc_logical    ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_logical    ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_right);
  set111(toc_logical    ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);


  ----- Shifty -------------------------------------------------------------------------------------
  ----- celo‡¡seln˜ SHL unsigned -----
  set111(toc_shift      ,true ,dt_signed    ,dt_unsigned  ,ttc_modaritm_left_check,trt_resolve);
  set111(toc_shift      ,true ,dt_unsigned  ,dt_unsigned  ,ttc_modaritm_left_check,trt_resolve);
  set1s1(toc_shift      ,true ,dts_integer  ,dt_uniint    ,ttc_modaritm_left_check,trt_left);
  set111(toc_shift      ,false,dt_uniint    ,dt_unsigned  ,ttc_convertible        ,trt_right);
  set111(toc_shift      ,false,dt_uniint    ,dt_uniint    ,ttc_convertible        ,trt_left);


  ----- Bitov‚ operace -----------------------------------------------------------------------------
  ----- celo‡¡seln˜ BIT_AND celo‡¡seln˜ -----
  set111(toc_bit        ,true ,dt_signed    ,dt_signed    ,ttc_modaritm_check   ,trt_resolve);
  set111(toc_bit        ,true ,dt_unsigned  ,dt_unsigned  ,ttc_modaritm_check   ,trt_resolve);
  set1s1(toc_bit        ,true ,dts_integer  ,dt_uniint    ,ttc_modaritm_check   ,trt_left);
  set11s(toc_bit        ,false,dt_uniint    ,dts_integer  ,ttc_modaritm_check   ,trt_right);
  set111(toc_bit        ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);


  ----- Rela‡n¡ porovn vac¡ operace ----------------------------------------------------------------
  ----- celo‡¡seln˜ = celo‡¡seln˜ -----
  set111(toc_rel_compare,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_unilogical);
  set1s1(toc_rel_compare,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_unilogical);

  ----- floating-point = floating-point -----
  set111(toc_rel_compare,false,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_unilogical);

  ----- fixed-point = fixed-point -----
  set111(toc_rel_compare,false,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_unilogical);

  ----- re ln˜ = re ln˜ -----
  set111(toc_rel_compare,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_unilogical);

  ----- znakov˜ = znakov˜ -----
  set111(toc_rel_compare,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_compare,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_unilogical);

  ----- logick˜ = logick˜ -----
  set111(toc_rel_compare,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_compare,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_compare,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_unilogical);

  ----- enum = enum -----
  set111(toc_rel_compare,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_unilogical);

  ----- ©etˆzec = ©etˆzec -----
  set1ss(toc_rel_compare,false,dts_string   ,dts_string   ,ttc_string           ,trt_unilogical); {ttc_string_string}
  set11s(toc_rel_compare,false,dt_uniarray  ,dts_string   ,ttc_uniarray         ,trt_unilogical); {ttc_uniarray_string}
  set1s1(toc_rel_compare,false,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical); {ttc_string_uniarray}
  set111(toc_rel_compare,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical); {ttc_uniarray}

  ----- pole = pole -----
  set111(toc_rel_compare,false,dt_array     ,dt_array     ,ttc_array            ,trt_unilogical);
  set111(toc_rel_compare,false,dt_array     ,dt_uarray    ,ttc_uarray           ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uniarray  ,dts_array    ,ttc_uniarray         ,trt_unilogical);
  set1s1(toc_rel_compare,false,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical);
  set111(toc_rel_compare,false,dt_uniarray  ,dt_uniarray  ,ttc_uniarray         ,trt_unilogical);

  ----- record = record -----
  set111(toc_rel_compare,false,dt_record    ,dt_record    ,ttc_identical        ,trt_unilogical);
  
  ----- t©¡da = t©¡da -----
  -- pro t©¡dy nen¡ porovn n¡ definov no

  ----- mno‘ina = mno‘ina -----
  set1ss(toc_rel_compare,false,dts_u_set    ,dts_u_set    ,ttc_set              ,trt_unilogical);

  ----- pointer = pointer -----
  set111(toc_rel_compare,false,dt_pointer   ,dt_pointer   ,ttc_pointer_rel      ,trt_unilogical);

  ----- tag = tag -----
  set111(toc_rel_compare,false,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_unilogical);

  ----- regul rn¡ = NIL -----
  set1s1(toc_rel_compare,false,dts_regular  ,dt_uninil    ,ttc_NIL              ,trt_unilogical);
  set11s(toc_rel_compare,false,dt_uninil    ,dts_regular  ,ttc_NIL              ,trt_unilogical);


  ----- Rela‡n¡ uspo© d vac¡ operace ---------------------------------------------------------------
  ----- numerick˜ < numerick˜ -----
  set111(toc_rel_order  ,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_unilogical);
  set1s1(toc_rel_order  ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_unilogical);
  set11s(toc_rel_order  ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_unilogical);

  ----- floating-point < floating-point -----
  set111(toc_rel_order  ,false,dt_float     ,dt_float     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_unilogical);

  ----- fixed-point < fixed-point -----
  set111(toc_rel_order  ,false,dt_fixed     ,dt_fixed     ,ttc_raritm_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_unilogical);

  ----- re ln˜ < re ln˜ -----
  set111(toc_rel_order  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_unilogical);
                        
  ----- znakov˜ < znakov˜ -----
  set111(toc_rel_order  ,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_unilogical);

  ----- logick˜ < logick˜ -----
  set111(toc_rel_order  ,true ,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_unilogical);
  set111(toc_rel_order  ,true ,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_unilogical);
  set111(toc_rel_order  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_unilogical);

  ----- enum < enum -----
  set111(toc_rel_order  ,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_unilogical);

  ----- ©etˆzcov˜ < ©etˆzcov˜ -----
  set1ss(toc_rel_order  ,false,dts_string   ,dts_string   ,ttc_order_string     ,trt_unilogical); {ttc_order_string_string}
  set11s(toc_rel_order  ,false,dt_uniarray  ,dts_string   ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_uniarray_string}
  set1s1(toc_rel_order  ,false,dts_string   ,dt_uniarray  ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_string_uniarray}
  set111(toc_rel_order  ,false,dt_uniarray  ,dt_uniarray  ,ttc_order_uniarray   ,trt_unilogical); {ttc_order_uniarray}

  ----- pole < pole -----
  {!!}

  ----- mno‘ina < mno‘ina -----
  set1ss(toc_rel_order  ,false,dts_u_set    ,dts_u_set    ,ttc_set              ,trt_unilogical);

  ----- tag < tag -----
  set111(toc_rel_compare,false,dt_tag       ,dt_tag       ,ttc_simple_check     ,trt_unilogical);


  ----- Test n le‘en¡ ------------------------------------------------------------------------------
  ----- diskr‚tn¡ IN mno‘ina -----
  set1ss(toc_rel_member ,false,dts_u_ordinal,dts_u_set    ,ttc_in_set           ,trt_unilogical);



  --------------------------------------------------------------------------------------------------
  -- (2) P©etypov n¡
  --------------------------------------------------------------------------------------------------

  ----- P©etypov n¡ --------------------------------------------------------------------------------
  -- z klad je stejn˜ jako transformace hodnoty 
  setcopy(toc_transform,toc_typecast,false);

  ----- numerick‚ konverze -----
  -- signed(signed) a unsigned(unsigned) se mus¡ redefinovat, 
  -- proto‘e nepo‘adujeme kontrolu shodnosti aritmetik 
  set111(toc_typecast   ,false,dt_signed    ,dt_signed    ,ttc_simple_check     ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unsigned  ,ttc_simple_check     ,trt_left);
  set111(toc_typecast   ,false,dt_signed    ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_signed    ,ttc_convertible      ,trt_left);
  set11s(toc_typecast   ,false,dt_float     ,dts_u_integer,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_float     ,dt_fixed     ,ttc_convertible      ,trt_left);
  set11s(toc_typecast   ,false,dt_fixed     ,dts_u_integer,ttc_convertible      ,trt_left);

  ----- konverze ‡¡sla na znak -----
  set111(toc_typecast   ,false,dt_char      ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_char      ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze znaku na ‡¡slo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_char      ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- konverze ‡¡sla na logical -----
  set111(toc_typecast   ,false,dt_logical   ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_logical   ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze logicalu na ‡¡slo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_logical   ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_unsigned  ,dt_unilogical,ttc_convertible      ,trt_left);

  ----- konverze ‡¡sla na enum -----
  set111(toc_typecast   ,false,dt_enum      ,dt_unsigned  ,ttc_convertible      ,trt_left);
  set111(toc_typecast   ,false,dt_enum      ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- konverze enumu na ‡¡slo -----
  set111(toc_typecast   ,false,dt_unsigned  ,dt_enum      ,ttc_convertible      ,trt_left);


  ----- Interface cast -----------------------------------------------------------------------------
  ----- t©¡da -- t©¡da -----
  set111(toc_interface_cast,false,dt_class  ,dt_class     ,ttc_icast_class      ,trt_left);

  ----- pointer na t©¡du -- pointer na t©¡du -----
  set111(toc_interface_cast,false,dt_pointer,dt_pointer   ,ttc_icast_pointer    ,trt_left);


  ----- Symetrick  konverze ------------------------------------------------------------------------
  ----- univerz ln¡ integer -----
  set111(toc_symmetric  ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);
  set11s(toc_symmetric  ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_left);
  set1s1(toc_symmetric  ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- univerz ln¡ real -----
  set111(toc_symmetric  ,false,dt_unireal   ,dt_unireal   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unireal   ,dt_float     ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_float     ,dt_unireal   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unireal   ,dt_fixed     ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_fixed     ,dt_unireal   ,ttc_convertible      ,trt_left);

  ----- univerz ln¡ znak -----
  set111(toc_symmetric  ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- univerz ln¡ logical -----
  set111(toc_symmetric  ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_left);
  set111(toc_symmetric  ,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (3) P©ed v n¡ parametr–
  --------------------------------------------------------------------------------------------------

  ----- Parametr: oby‡ejn˜ IN parametr -------------------------------------------------------------
  -- z klad je stejn˜ jako p©i©azen¡ 
  setcopy(toc_assign,toc_param_in,false);


  ----- Parametr: oby‡ejn˜ OUT parametr ------------------------------------------------------------
  ----- typ - typ  -----
  set111(toc_param_out  ,false,dt_signed    ,dt_signed    ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_unsigned  ,dt_unsigned  ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_float     ,dt_float     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_fixed     ,dt_fixed     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_char      ,dt_char      ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_logical   ,dt_logical   ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_enum      ,dt_enum      ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_string    ,dt_string    ,ttc_identical        ,trt_left);
  set11s(toc_param_out  ,false,dt_ustring   ,dts_string   ,ttc_string           ,trt_left); {ttc_string_string}
  set111(toc_param_out  ,false,dt_array     ,dt_array     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_uarray    ,dt_array     ,ttc_uarray           ,trt_left); {ttc_uarray_array}
  set111(toc_param_out  ,false,dt_uarray    ,dt_uarray    ,ttc_uarray           ,trt_left); {ttc_uarray_uarray}
  set111(toc_param_out  ,false,dt_record    ,dt_record    ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_class     ,dt_class     ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_set       ,dt_set       ,ttc_identical        ,trt_left);
  set111(toc_param_out  ,false,dt_pointer   ,dt_pointer   ,ttc_pointer_out      ,trt_left);
  set111(toc_param_out  ,false,dt_tag       ,dt_tag       ,ttc_identical        ,trt_left);


  ----- Parametr: Modifik tory CLASS nebo VIRTUAL --------------------------------------------------
  ----- typ - typ  -----
  set111(toc_param_class,false,dt_signed    ,dt_signed    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_unsigned  ,dt_unsigned  ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_float     ,dt_float     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_fixed     ,dt_fixed     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_char      ,dt_char      ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_logical   ,dt_logical   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_string    ,dt_string    ,ttc_derived          ,trt_left);
  set11s(toc_param_class,false,dt_ustring   ,dts_string   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_array     ,dt_array     ,ttc_derived          ,trt_left);
  set11s(toc_param_class,false,dt_uarray    ,dts_array    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_record    ,dt_record    ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_class     ,dt_class     ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_set       ,dt_set       ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_pointer   ,dt_pointer   ,ttc_derived          ,trt_left);
  set111(toc_param_class,false,dt_tag       ,dt_tag       ,ttc_derived          ,trt_left);
  ----- typ - univerz ln¡ typ -----
  set1s1(toc_param_class,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  set111(toc_param_class,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_param_class,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set1s1(toc_param_class,false,dts_string   ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_string_uniarray}
  set1s1(toc_param_class,false,dts_array    ,dt_uniarray  ,ttc_uniarray         ,trt_left); {ttc_array_uniarray}
  set1s1(toc_param_class,false,dts_regular  ,dt_uninil    ,ttc_nil              ,trt_left);


  ----- Parametr: Modifik tor UNCHECKED ------------------------------------------------------------
  -- nic nelze nastavit, nem  Full view



  --------------------------------------------------------------------------------------------------
  -- (5) Ostatn¡ operace
  --------------------------------------------------------------------------------------------------

  ----- Konstruktor rozsahu ------------------------------------------------------------------------
  ----- celo‡¡seln˜ .. celo‡¡seln˜ -----
  set111(toc_range      ,false,dt_signed    ,dt_signed    ,ttc_iaritm_check     ,trt_resolve);
  set111(toc_range      ,false,dt_unsigned  ,dt_unsigned  ,ttc_iaritm_check     ,trt_resolve);
  set1s1(toc_range      ,false,dts_integer  ,dt_uniint    ,ttc_convertible      ,trt_left);
  set11s(toc_range      ,false,dt_uniint    ,dts_integer  ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_uniint    ,dt_uniint    ,ttc_convertible      ,trt_left);

  ----- znakov˜ .. znakov˜ -----
  set111(toc_range      ,false,dt_char      ,dt_char      ,ttc_simple_check     ,trt_resolve);
  set111(toc_range      ,false,dt_char      ,dt_unichar   ,ttc_convertible      ,trt_left);
  set111(toc_range      ,false,dt_unichar   ,dt_char      ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_unichar   ,dt_unichar   ,ttc_convertible      ,trt_left);

  ----- logick˜ .. logick˜ -----
  set111(toc_range      ,false,dt_logical   ,dt_logical   ,ttc_simple_check     ,trt_resolve);
  set111(toc_range      ,false,dt_logical   ,dt_unilogical,ttc_convertible      ,trt_left);
  set111(toc_range      ,false,dt_unilogical,dt_logical   ,ttc_convertible      ,trt_right);
  set111(toc_range      ,false,dt_unilogical,dt_unilogical,ttc_convertible      ,trt_left);

  ----- v˜‡tov˜ .. v˜‡tov˜ -----
  set111(toc_range      ,false,dt_enum      ,dt_enum      ,ttc_derived          ,trt_resolve);
  end init_type_compatibility_table;



----------------------------------------------------------------------------------------------------
procedure init_view_compatibility_table =
-- Inicializace tabulky typov‚ kompatibility.
----------------------------------------------------------------------------------------------------
begin
  --------------------------------------------------------------------------------------------------
  -- (1) Oper tory
  --------------------------------------------------------------------------------------------------

  ----- Rela‡n¡ porovn vac¡ operace ----------------------------------------------------------------
  vset111(toc_rel_compare,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_unilogical);
  vset111(toc_rel_compare,tview_aggregate ,tview_full      ,tvc_aggregate ,trt_unilogical);
  vset111(toc_rel_compare,tview_partial   ,tview_partial   ,tvc_partial   ,trt_unilogical);



  --------------------------------------------------------------------------------------------------
  -- (2) P©etypov n¡
  --------------------------------------------------------------------------------------------------

  ----- P©etypov n¡ --------------------------------------------------------------------------------
  vset111(toc_typecast   ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_typecast   ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_typecast   ,tview_incomplete,tview_unchecked ,tvc_unchecked ,trt_left);

  ----- Interface cast -----------------------------------------------------------------------------
  ----- t©¡da -- t©¡da -----
  vset111(toc_interface_cast,tview_incomplete,tview_full      ,tvc_interface,trt_left);
  vset111(toc_interface_cast,tview_incomplete,tview_incomplete,tvc_interface,trt_left);
  vset111(toc_interface_cast,tview_full      ,tview_incomplete,tvc_interface,trt_left);


  --------------------------------------------------------------------------------------------------
  -- (3) P©ed v n¡ parametr–
  --------------------------------------------------------------------------------------------------

  ----- Parametr: oby‡ejn˜ IN parametr -------------------------------------------------------------
  vset111(toc_param_in   ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_param_in   ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_param_in   ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);

  ----- Parametr: oby‡ejn˜ OUT parametr ------------------------------------------------------------
  vset111(toc_param_out  ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_param_out  ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);

  ----- Parametr: Modifik tory CLASS nebo VIRTUAL --------------------------------------------------
  vset111(toc_param_class,tview_full      ,tview_aggregate ,tvc_aggregate         ,trt_left);
  vset111(toc_param_class,tview_partial   ,tview_full      ,tvc_partial_descendant,trt_left);
  vset111(toc_param_class,tview_partial   ,tview_partial   ,tvc_partial_descendant,trt_left);
  vset111(toc_param_class,tview_incomplete,tview_incomplete,tvc_partial_descendant,trt_left);

  ----- Parametr: Modifik tor UNCHECKED ------------------------------------------------------------
  vset111(toc_param_unchecked,tview_unchecked,tview_unchecked ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_full      ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_partial   ,tvc_unchecked      ,trt_left);
  vset111(toc_param_unchecked,tview_unchecked,tview_incomplete,tvc_unchecked      ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (4) Transformace a p©i©azen¡ (p©edsunuto, aby bylo mo‘n‚ kop¡rovat nastaven¡)
  --------------------------------------------------------------------------------------------------

  ----- P©i©azen¡ ----------------------------------------------------------------------------------
  vset111(toc_assign     ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_assign     ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
  vset111(toc_assign     ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_full      ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_partial   ,tvc_unchecked ,trt_left);
  vset111(toc_assign     ,tview_unchecked ,tview_incomplete,tvc_unchecked ,trt_left);

  ----- Transformace hodnoty -----------------------------------------------------------------------
--vset111(toc_transform  ,tview_full      ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_full      ,tview_aggregate ,tvc_aggregate ,trt_left);
  vset111(toc_transform  ,tview_partial   ,tview_partial   ,tvc_partial   ,trt_left);
--vset111(toc_transform  ,tview_partial   ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_incomplete,tview_incomplete,tvc_partial   ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_unchecked ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_full      ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_partial   ,tvc_unchecked ,trt_left);
  vset111(toc_transform  ,tview_unchecked ,tview_incomplete,tvc_unchecked ,trt_left);



  --------------------------------------------------------------------------------------------------
  -- (5) Ostatn¡ operace
  --------------------------------------------------------------------------------------------------

  end init_view_compatibility_table;
  


----------------------------------------------------------------------------------------------------
procedure t_gettypeview =
-- Typ pohledu na typ.                                                        
----------------------------------------------------------------------------------------------------
begin
  -- typ nem me
  if ptyp=nil then result:=tview_null

  -- m me jen Incomplete declaration => Incomplete view 
  elsif ptyp^.evaluated<>etd_full then result:=tview_incomplete

  -- na t©¡du je v‘dy Full view 
  elsif ptyp^.evaluated=etd_full and ptyp^.stype=dt_class then result:=tview_full

  -- viditelnost dop©edn‚ deklarace a dokon‡en¡ deklarace se li¨¡ 
  elsif ptyp^.visible<>ptyp^.full then
    if sym_is_fully_visible(ptyp,context{^curr})
      -- Full view 
      then result:=tview_full
      -- Partial view 
      else result:=tview_partial;
      end if;

{
  -- Full view pouze v nad©azen‚m deklarativn¡m regionu
  elsif (ptyp^.visible in [sv_public,sv_protected]) and (ptyp^.full=sv_private) then
    if isincluded(@curr,ptyp^.context)
      -- v nad©azen‚m deklarativn¡m regionu => Full view 
      then result:=tview_full
      -- jinde => Partial view 
      else result:=tview_partial;
    end

  -- Full view pouze v nad©azen‚m deklarativn¡m regionu nebo v potomkovi 
  elsif (ptyp^.visible=sv_public) and (ptyp^.full=sv_protected) then
    if isincluded(@curr,ptyp^.context) or isdescendant(@curr,ptyp^.context)
      -- v potomkovi nebo v nad©azen‚m deklarativn¡m regionu => Full view 
      then result:=tview_full
      -- jinde => Partial view 
      else result:=tview_partial;
    end
}
{
  -- typ by mohl m¡t utajenou strukturu 
  elsif tf_hidden in ptyp^.tflags then
    psym:=@curr;
    while (psym<>nil) and (psym<>ptyp^.context) do psym:=psym^.context;
    if psym=nil
      then result:=tview_partial
      else result:=tview_full;
    end
}
  -- typ ur‡itˆ nem  utajenou strukturu 
  else
    result:=tview_full;
    end if;
  end t_gettypeview;



----------------------------------------------------------------------------------------------------
procedure t_gettypefullview =
-- Typ pohledu na typ. Preferuje Full view, nikdy nevr t¡ Partial view.
----------------------------------------------------------------------------------------------------
begin
  -- typ nem me
  if ptyp=nil then 
    result:=tview_null

  -- m me jen Incomplete declaration => Incomplete view
  elsif ptyp^.evaluated<>etd_full then 
    result:=tview_incomplete

  -- ve v¨ech ostatn¡ch p©¡padech se budeme chovat jako Full view
  else 
    result:=tview_full;
    end if;
  end t_gettypefullview;



----------------------------------------------------------------------------------------------------
procedure t_equal =
-- True, jsou-li typy shodn‚.                                                 
----------------------------------------------------------------------------------------------------
begin
  result:=t1.getctype=t2.getctype;
  end t_equal;



----------------------------------------------------------------------------------------------------
procedure t_equal_view =
-- True, jsou-li to shodn‚ pohledy na shodn‚ typy.                            
----------------------------------------------------------------------------------------------------
begin
  result:=t1.tview=t2.tview and t1.getctype=t2.getctype;
  end t_equal_view;



----------------------------------------------------------------------------------------------------
module cc_unchecked_compatibility =
-- Procedury pro kontrolu pravidel unchecked kompatibility.
----------------------------------------------------------------------------------------------------

    type
      -- re‘im "unchecked velikosti"
      t_unchecked_size_mode = enum
          us_dynamic;                            -- £plnˆ dynamick  velikost
          us_combined;                           -- kombinovan : fixn¡ z klad + n sobek b ze
          us_fixed;                              -- fixn¡ velikost
          end enum;

      -- "unchecked velikost" objektu
      t_unchecked_size = record
          mode         : t_unchecked_size_mode;  -- re‘im "unchecked velikost" objektu
          fixed_part   : tunidata_size;          -- fixn¡ slo‘ka velikosti objektu
          base_part    : tunidata_size;          -- promˆnn  slo‘ka velikosti objektu
          end record;

    ------------------------------------------------------------------------------------------------
    procedure get_unchecked_size (
        t1         : pentity_type)               -- zkouman˜ typ
        return t_unchecked_size;
    -- Sestav¡ popis "unchecked velikosti" typu [t1].
    ------------------------------------------------------------------------------------------------
    procedure test_unchecked_size (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical;                        -- True, jsou-li typy unchecked kompatibiln¡
    -- Kontrola unchecked kompatibility dvou typ–.
    ------------------------------------------------------------------------------------------------

  private

    ------------------------------------------------------------------------------------------------
    procedure get_unchecked_size =
    -- Sestav¡ popis "unchecked velikosti" typu [t1].
    ------------------------------------------------------------------------------------------------
    begin
      -- typ nen¡ v–bec zn m˜ => dynamick  velikost
      if t1=nil then 
        result.mode:=us_dynamic;

      -- je to nˆjak˜ unconstrained typ => kombinovan  velikost
      elsif t1^.stype in dts_unconstrained then
        result.mode:=us_combined;
        result.fixed_part:=t1^.size;
        result.base_part:=t1^.base.getctype^.size;

      -- v¨echno ostatn¡ vede na fixn¡ velikost
      else
        result.mode:=us_fixed;
        result.fixed_part:=t1^.size;
        end if;
      end get_unchecked_size;



    ------------------------------------------------------------------------------------------------
    procedure test_combined_combined (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical =
    -- Kontrola p©¡padu combined -- combined.
    ------------------------------------------------------------------------------------------------
    begin
      -- %%TODO(SLICE) Dodˆlat, a‘ budou k dispozici ©ezy pole. Bez nich se toti‘
      -- toto pravidlo kompatibility ned  rozumnˆ aplikovat, proto‘e je silnˆ omezuj¡c¡
      -- a typicky se vyu‘¡v  ve spojistoti pr vˆ s ©ezy pole.
      result:=true;
    {
      F1 + N*B1 = F2 + M*B2

      => N*B1 = F2-F1 + M*B2

      => N = F2-F2/B1 + M*(B2/B1)
    }
    {
      -- fixn¡ velikost lev‚ strany je men¨¡ ne‘ prav‚
      if s1.fixed_part>s2.fixed_part then

      -- fixn¡ velikost prav‚ strany je men¨¡ ne‘ lev‚
      elsif s1.fixed_part<s2.fixed_part then
    }
      end test_combined_combined;



    ------------------------------------------------------------------------------------------------
    procedure test_fixed_combined (
        s1         : in t_unchecked_size;        -- "unchecked velikost" typu 1
        s2         : in t_unchecked_size)        -- "unchecked velikost" typu 2
        return t_logical =
    -- Kontrola p©¡padu fixed -- combined.
    ------------------------------------------------------------------------------------------------
    begin
      result:=true;
    {
      -- %%TODO(SLICE) Dodˆlat, a‘ budou k dispozici ©ezy pole. Bez nich se toti‘
      -- toto pravidlo kompatibility ned  rozumnˆ aplikovat, proto‘e je silnˆ omezuj¡c¡
      -- a typicky se vyu‘¡v  ve spojistoti pr vˆ s ©ezy pole.
    
      -- fixn¡ slo‘ka lev‚ strany mus¡ b˜t alespo¤ tak velk , jako fixn¡ slo‘ka prav‚ strany
      result:=s1.fixed_part>=s2.fixed_part
      -- test kongruence zbytku fixn¡ slo‘ky s velikost¡ b ze promˆnn‚ slo‘ky prav‚ strany
      and then ((s1.fixed_part-s2.fixed_part) mod s2.base_part)=uds_0;
    }
      end test_fixed_combined;



    ------------------------------------------------------------------------------------------------
    procedure test_unchecked_size =
    -- Kontrola unchecked kompatibility dvou typ–.
    ------------------------------------------------------------------------------------------------
    begin
      -- alespo¤ jedna z velikost¡ je dynamick  => OK
      if s1.mode=us_dynamic or s2.mode=us_dynamic then
        result:=true;

      -- fixed -- fixed => velikosti se mus¡ shodovat
      elsif s1.mode=us_fixed and s2.mode=us_fixed then
      {
        -- %%TODO(SLICE) Dodˆlat, a‘ budou k dispozici ©ezy pole. Bez nich se toti‘
        -- toto pravidlo kompatibility ned  rozumnˆ aplikovat, proto‘e je silnˆ omezuj¡c¡
        -- a typicky se vyu‘¡v  ve spojistoti pr vˆ s ©ezy pole.
        result:=s1.fixed_part=s2.fixed_part;
      }
        result:=true;

      -- combined -- combined => velikosti mus¡
      elsif s1.mode=us_combined and s2.mode=us_combined then
        result:=test_combined_combined(s1,s2);

      -- combined -- fixed
      elsif s1.mode=us_combined and s2.mode=us_fixed then
        result:=test_fixed_combined(s2,s1);

      -- fixed -- combined
      elsif s1.mode=us_fixed and s2.mode=us_combined then
        result:=test_fixed_combined(s1,s2);

      -- jin˜ p©¡pad nem–‘e nastat
      else
        verify(677,true);
        end if;
      end test_unchecked_size;

    end cc_unchecked_compatibility;



----------------------------------------------------------------------------------------------------
procedure t_compatible_unchecked_pointers =
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility. 
-- Oba typy mus¡ b˜t pointery, z nich‘ alespo¤ jeden mus¡ b˜t unchecked.
----------------------------------------------------------------------------------------------------
with
  cc_unchecked_compatibility;

begin
  verify(675,not t_is_stype(t1,dt_pointer) or else not t_is_stype(t1,dt_pointer) or else (t1.getpbase<>pb_unchecked and t2.getpbase<>pb_unchecked));

  -- vypo‡¡tat "unchecked velikosti" obou typ– a zkontrolovat kompatibilitu
  result:=test_unchecked_size(get_unchecked_size(t1.getctype^.base.getutype),get_unchecked_size(t2.getctype^.base.getutype));
  end t_compatible_unchecked_pointers;



----------------------------------------------------------------------------------------------------
procedure t_compatible_varaccesses =
-- True, jsou-li typy kompatibiln¡ z hlediska determinace p©¡stupu.
-- Oba typy mus¡ b˜t pointery. T1 mus¡ b˜t c¡lov˜ typ operace (p©i©azuje se do instance T1), T2 mus¡
-- b˜t zdrojov˜ typ (p©i©azuje se z instance T2).
----------------------------------------------------------------------------------------------------
var
  t1a              : varaccess;                  -- determinace p©¡stupu pointeru 1
  t2a              : varaccess;                  -- determinace p©¡stupu pointeru 2

begin
  verify(676,not t_is_stype(t1,dt_pointer) or not t_is_stype(t1,dt_pointer));

  -- restrikce T1 > restrikce T2 => ok
  if t1a>t2a then result:=true

  -- norm ln¡ <- norm ln¡
  elsif t1a=va_norm and t2a=va_norm then result:=true;

  -- const <- const
  elsif t1a=va_const and t2a=va_const then result:=true;

  -- protected <- protected
  elsif t1a=va_protected and t2a=va_protected then
    declare var
      s1           : pentity;                    -- kontejner, ve kter‚m je deklarov n T1
      s2           : pentity;                    -- kontejner, ve kter‚m je deklarov n T2

    begin
      -- zjistit kontejnery, ve kter˜ch jsou T1 a T2 deklarov ny
      s1:=sym_get_container(t1.getctype);
      s2:=sym_get_container(t2.getctype);

      -- S1 je vno©en v S2 nebo S1 je potomek S2 => ok
      result:=sym_is_included(s1,s2) or sym_is_descendant(s1,s2);
      end declare;

  -- ostatn¡ p©¡pady nejsou kompatibiln¡
  else result:=false;
  end if;
  end t_compatible_varaccesses;



----------------------------------------------------------------------------------------------------
procedure t_compatible_determinations =
-- True, jsou-li typy kompatibiln¡ z hlediska determinace kompatibility.      
----------------------------------------------------------------------------------------------------
begin
  result:=not (
  -- je-li jeden z typ– protected, mus¡ b˜t druh˜ identick˜ nebo univerz ln¡ 
     ((t1.compat=tc_protected) and (not t_equal(t1,t2) and t2.stype not in dts_unitype))
  or ((t2.compat=tc_protected) and (not t_equal(t1,t2) and t1.stype not in dts_unitype))
  -- je-li jeden z typ– private, mus¡ b˜t druh˜ identick˜
  or ((t1.compat=tc_private) and not t_equal(t1,t2))
  or ((t2.compat=tc_private) and not t_equal(t1,t2))
  );
  end t_compatible_determinations;



----------------------------------------------------------------------------------------------------
procedure t_typecheck =
-- Typov  kontrola.                                                           
----------------------------------------------------------------------------------------------------

      ----------------------------------------------------------------------------------------------
      procedure test_interface (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Abstraktn¡ t©¡da -- t©¡da.
      ----------------------------------------------------------------------------------------------
      begin
        if t1.isclass and t2.isclass and t1.is_abstract
          -- kompatibiln¡
          then level:=tcl_convertible
          -- nekompatibiln¡
          else level:=tcl_incompatible;
          end if;
        end test_interface;

begin
  restype:=trt_none;


  ----- jeden z typ– nen¡ ur‡en --------------------------------------------------------------------
  if t1.tview=tview_null or t2.tview=tview_null then level:=tcl_incompatible


  ----- jeden z typ– nen¡ Full view ----------------------------------------------------------------
  elsif t1.tview<>tview_full or t2.tview<>tview_full then
    declare

      ----------------------------------------------------------------------------------------------
      procedure test_partial (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Partial view <--> Partial view
      ----------------------------------------------------------------------------------------------
      begin
        -- identick‚ typy
        if t_equal(t1,t2) then level:=tcl_identical
        -- jinak nekompatibiln¡
        else level:=tcl_incompatible;
        end if;
        end test_partial;



      ----------------------------------------------------------------------------------------------
      procedure test_partial_descendant (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Partial view <--> Partial view
      ----------------------------------------------------------------------------------------------
      begin
        -- identick‚ typy
        if t_equal(t1,t2) then level:=tcl_identical
        -- je T1 p©edek T2 -> staticky bin rnˆ shodn‚
        elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
        -- jinak nekompatibiln¡
        else level:=tcl_incompatible;
        end if;
        end test_partial_descendant;



      ----------------------------------------------------------------------------------------------
      procedure test_unchecked (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Unchecked view := / <-- cokoliv
      ----------------------------------------------------------------------------------------------
      with
        cc_unchecked_compatibility;

      begin
        -- vypo‡¡tat "unchecked velikosti" obou typ– a zkontrolovat kompatibilitu
        if test_unchecked_size(get_unchecked_size(t1.getutype),get_unchecked_size(t2.getutype))
          then level:=tcl_static_identical;
          else level:=tcl_incompatible;
          end if;
        end test_unchecked;



      ----------------------------------------------------------------------------------------------
      procedure test_aggregate (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test Full view <--> Aggregate view.                                    
      ----------------------------------------------------------------------------------------------
      begin
        -- agreg t -- agreg tn¡ typ
        if t1.tview=tview_aggregate and t_is_sts(t2,dts_aggregate) then level:=tcl_identical
        -- agreg tn¡ typ -- agreg t
        elsif t2.tview=tview_aggregate and t_is_sts(t1,dts_aggregate) then level:=tcl_identical
        -- jinak nekompatibiln¡
        else level:=tcl_incompatible;
        end if;
        end test_aggregate;

    begin    
      -- zvolit typ v˜sledku
      restype:=viewcheck[oclass,t1.tview,t2.tview].r;

      -- typov  kontrola
      case viewcheck[oclass,t1.tview,t2.tview].c

        -- nekompatibiln¡ pohledy
        when tvc_incompatible       do level:=tcl_incompatible;

        -- kontrola parci ln¡ch pohled–
        when tvc_partial            do test_partial(t1,t2);
        
        -- kontrola parci ln¡ch pohled–, T1 p©edek T2
        when tvc_partial_descendant do test_partial_descendant(t1,t2);
        
        -- kontrola unchecked pohled–
        when tvc_unchecked          do test_unchecked(t1,t2);
        
        -- kontrola kombinace Full view a Aggregate view
        when tvc_aggregate          do test_aggregate(t1,t2);

        -- kontrola interface cast
        when tvc_interface          do test_interface(t1,t2);
        end case;

      -- %%X A co kontrola determinace kompatibility ? M  se prov dˆt ?
      end declare;


  ----- zkoumat d l (oba jsou ur‡itˆ Full view) ----------------------------------------------------
  else 
    declare

      ----------------------------------------------------------------------------------------------
      procedure test_determinations_base (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test determinac¡ kompatibility T1 a T2:base.
      ----------------------------------------------------------------------------------------------
      begin
        -- poda©ilo-li se, pak je¨tˆ zkontrolovat determinaci kompatibility s b z¡ mno‘iny
        if level<>tcl_incompatible then
          if not t_compatible_determinations(t1,t2.getbase(context)) then
            level:=tcl_incompatible;
            end if;
          end if;
        end test_determinations_base;



      ----------------------------------------------------------------------------------------------
      procedure test_indexed_component (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_INDEXED_COMPONENT a TTC_COMPONENT_INDEXED.
      ----------------------------------------------------------------------------------------------
      begin
        -- nen¡ typ komponenty univerz ln¡ ? 
        if t2.stype in dts_unitype

          -- ano => mus¡ b˜t kompatibiln¡ s b z¡ ©etˆzce 
          then
            if not t_compatible(context,toc_symmetric,false,t1.getbase(context),t2) then
              level:=tcl_incompatible;
              return;
              end if;

          -- ne => mus¡ b˜t identick˜ s b z¡ ©etˆzce
          else
            if not t_equal(t1.getbase(context),t2) then
              level:=tcl_incompatible;
              return;
              end if;
            end if;

        level:=tcl_convertible;
        end test_indexed_component;



      ----------------------------------------------------------------------------------------------
      procedure test_string (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_STRING a TTC_ORDER_STRING.
      ----------------------------------------------------------------------------------------------
      begin
        -- identick‚ typy 
        if t_equal(t1,t2) then level:=tcl_identical;
        -- identick‚ b ze
        elsif t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
        -- nekompatibiln¡
        else level:=tcl_incompatible;
        end if;
        end test_string;



      ----------------------------------------------------------------------------------------------
      procedure test_array (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_ARRAY a TTC_ORDER_ARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        if t_equal(t1,t2)
          -- identick‚ typy
          then level:=tcl_identical
          -- pole mus¡ b˜t stejn 
          else level:=tcl_incompatible;
          end if ;
        end test_array;



      ----------------------------------------------------------------------------------------------
      procedure test_uarray (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_UARRAY a TTC_ORDER_UARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        -- no, jistˆ nebudou stejn‚

        -- mus¡ m¡t stejn‚ b ze
        if t_equal(t1.getbase(context),t2.getbase(context))
          then level:=tcl_static_identical
          else level:=tcl_incompatible;
          end if;
        end test_uarray;



      ----------------------------------------------------------------------------------------------
      procedure test_uniarray (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test TTC_(ORDER_)STRING/(UNI)ARRAY_STRING/(UNI)ARRAY.
      ----------------------------------------------------------------------------------------------
      begin
        -- no, jistˆ nebudou stejn‚ 

        -- jedna z b z¡ je univerz ln¡ 
        if t_is_sts(t1.getbase(context),dts_unitype) or t_is_sts(t2.getbase(context),dts_unitype)

          -- mus¡ m¡t kompatibiln¡ b ze 
          then
            if not t_compatible(context,toc_symmetric,false,t1.getbase(context),t2.getbase(context)) then
              level:=tcl_incompatible;
              return;
              end if;

          -- jinak mus¡ m¡t identick‚ b ze 
          else
            if not t_equal(t1.getbase(context),t2.getbase(context)) then
              level:=tcl_incompatible;
              return;
              end if;
            end if;

        level:=tcl_convertible;
        end test_uniarray;



      ----------------------------------------------------------------------------------------------
      procedure test_convertible (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test konvertibility typ–. 
      -- Ur‡eno pro jednoduch‚ p©¡pady, kdy alespo¤ jeden z typ– je univerz ln¡.
      ----------------------------------------------------------------------------------------------
      begin
        if t_equal(t1,t2)
          -- identick‚
          then level:=tcl_identical
          -- aspo¤ konvertibiln¡
          else level:=tcl_convertible;
          end if;
        end test_convertible;



      ----------------------------------------------------------------------------------------------
      procedure test_iaritm (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celo‡¡seln˜ch typ–. 
      -- ’ dn˜ z typ– nesm¡ b˜t univerz ln¡.
      ----------------------------------------------------------------------------------------------
      begin
        -- identick‚ typpy
        if t_equal(t1,t2) then level:=tcl_identical
        -- T1 je p©edek T2 --> staticky bin rnˆ shodn‚
        elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
        -- T1 je potomek T2 --> dynamicky bin rnˆ shodn‚ (kontrola mez¡)
        elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
        -- shodn‚ aritmetiky --> konvertibiln¡
        elsif t1.getintaritm=t2.getintaritm then level:=tcl_convertible
        -- nekompatibiln¡ typy
        else level:=tcl_incompatible;
        end if;
        end test_iaritm;



      ----------------------------------------------------------------------------------------------
      #template test_modular (t);
      ----------------------------------------------------------------------------------------------
        if not t_is_sts(t,dts_unitype) and then t.getintaritm<>tia_modular then
          level:=tcl_incompatible;
          return;
          end if;
        #end test_modular;



      ----------------------------------------------------------------------------------------------
      procedure test_modaritm (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celo‡¡seln˜ch typ– s modul rn¡ aritmetikou.
      -- Jeden z typ– m–‘e b˜t univerz ln¡.
      ----------------------------------------------------------------------------------------------
      begin
        -- typ vlevo mus¡ m¡t modul rn¡ aritmetiku
        test_modular(t1);

        -- typ vpravo mus¡ m¡t modul rn¡ aritmetiku
        test_modular(t2);
     
        -- jeden z typ– je univerz ln¡ 
        if t_is_sts(t1,dts_unitype) or t_is_sts(t2,dts_unitype)

          -- sta‡¡ test konvertibility
          then test_convertible(t1,t2);

          -- jinak £pln˜ test celo‡¡seln‚ aritmetiky
          else test_iaritm(t1,t2);
          end if;
        end test_modaritm;



      ----------------------------------------------------------------------------------------------
      procedure test_modaritm_left (
          t1       : in typeview;
          t2       : in typeview) =
      -- Test kompatibility celo‡¡seln˜ch typ– s modul rn¡ aritmetikou u lev‚ho operandu.
      -- Jeden z typ– m–‘e b˜t univerz ln¡.
      ----------------------------------------------------------------------------------------------
      begin
        -- typ vlevo mus¡ m¡t modul rn¡ aritmetiku
        test_modular(t1);
     
        -- jinak jsou typy ur‡itˆ konvertibiln¡
        level:=tcl_convertible;
        end test_modaritm_left;

    begin
      -- kontrola na p©i©azen¡
      if assign>typecheck[oclass,t1.stype,t2.stype].a then
        level:=tcl_incompatible;
        return;
        end if;

      -- typ v˜sledku
      if assign
        -- pro p©i©azen¡ v‘dy typ lev‚ho operandu
        then restype:=trt_left
        -- jinak podle tabulky
        else restype:=typecheck[oclass,t1.stype,t2.stype].r;
        end if;

      case typecheck[oclass,t1.stype,t2.stype].c
        -- nekompatibiln¡, nen¡ co ©e¨it 
        when ttc_incompatible   do level:=tcl_incompatible;

        -- konvertibiln¡
        when ttc_convertible    do test_convertible(t1,t2);

        -- kontrola kompatibility celo‡¡seln˜ch typ–
        when ttc_iaritm_check   do test_iaritm(t1,t2);

        -- kontrola kompatibility celo‡¡seln˜ch typ– s modul rn¡ aritmetikou
        when ttc_modaritm_check do test_modaritm(t1,t2);

        -- kontrola kompatibility celo‡¡seln˜ch typ– s modul rn¡ aritmetikou u lev‚ho operandu
        when ttc_modaritm_left_check do test_modaritm_left(t1,t2);

        -- kontrola kompatibility re ln˜ch typ–
        when ttc_raritm_check do
            -- identick‚ typpy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je p©edek T2 --> staticky bin rnˆ shodn‚
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky bin rnˆ shodn‚ (kontrola mez¡)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- konvertibiln¡ typy
            else level:=tcl_convertible;
            end if;

        -- jednoduch  kontrola dˆdi‡nosti
        when ttc_simple_check do
            -- identick‚ typpy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je p©edek T2 --> staticky bin rnˆ shodn‚
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky bin rnˆ shodn‚ (kontrola mez¡)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- T1 a T2 nejsou v ‘ dn‚m vztahu --> konvertovateln‚
            else level:=tcl_convertible;
            end if;

        -- jeden typ odvozen od druh‚ho
        when ttc_derived do
            -- identick‚ typy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je p©edek T2 --> staticky bin rnˆ shodn‚
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky bin rnˆ shodn‚
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- nekompatibiln¡
            else level:=tcl_incompatible;
            end if;

        -- typy mus¡ b˜t shodn‚
        when ttc_identical do
            if t_equal(t1,t2)
              then level:=tcl_identical
              else level:=tcl_incompatible;
              end if;

        -- pole -- pole
        when ttc_array  do test_array(t1,t2);

        -- (neomezen‚) pole -- (neomezen‚) pole
        when ttc_uarray do test_uarray(t1,t2);

        -- pole -- pole
        when ttc_order_array do
            -- mus¡ m¡t diskr‚tn¡ b ze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- maj¡ => zkoumat d l
              then test_array(t1,t2);
              -- nemaj¡ => nekompatibiln¡
              else level:=tcl_incompatible;
              end if;

        -- (neomezen‚) pole -- (neomezen‚) pole
        when ttc_order_uarray do
            -- mus¡ m¡t diskr‚tn¡ b ze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- maj¡ => zkoumat d l
              then test_uarray(t1,t2);
              -- nemaj¡ => nekompatibiln¡
              else level:=tcl_incompatible;
              end if;

        -- (neomezen˜) string -- (neomezen˜) string
        when ttc_string do test_string(t1,t2);

        -- (neomezen˜) string -- (neomezen˜) string
        when ttc_order_string do
            -- mus¡ m¡t diskr‚tn¡ b ze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- maj¡ => zkoumat d l
              then test_string(t1,t2);
              -- nemaj¡ => nekompatibiln¡
              else level:=tcl_incompatible;
              end if;

        -- univerz ln¡ pole/pole/string -- univerz ln¡ pole/pole/string
        when ttc_uniarray do test_uniarray(t1,t2);

        -- univerz ln¡ pole/pole/string -- univerz ln¡ pole/pole/string
        when ttc_order_uniarray do
            -- mus¡ m¡t diskr‚tn¡ b ze
            if t_is_sts(t1.getbase(context),dts_u_ordinal) and t_is_sts(t2.getbase(context),dts_u_ordinal)
              -- maj¡ => zkoumat d l
              then test_uniarray(t1,t2);
              -- nemaj¡ => nekompatibiln¡
              else level:=tcl_incompatible;
              end if;

        -- (u)string/(u)array  -- komponenta
        when ttc_indexed_component do 
            -- vlastn¡ test kompatibility
            test_indexed_component(t1,t2);

            -- je¨tˆ zkontrolovat determinaci kompatibility s b z¡ ©etˆzce/pole
            test_determinations_base(t2,t1);

        -- komponenta -- (u)string/(u)array
        when ttc_component_indexed do 
            -- vlastn¡ test kompatibility
            test_indexed_component(t2,t1);

            -- je¨tˆ zkontrolovat determinaci kompatibility s b z¡ ©etˆzce/pole
            test_determinations_base(t1,t2);

        -- komponenta -- komponenta
        when ttc_component_component do
            -- typy jsou ekvivalentn¡ => ok
            if t_equal(t1,t2) then level:=tcl_convertible
            -- typy jsou symetricky kompatibiln¡ => ok
            elsif t_compatible(context,toc_symmetric,false,t1,t2) then level:=tcl_convertible
            -- typy jsou r–zn‚ => nekompatibiln¡
            else level:=tcl_incompatible;
            end if;

        -- mno‘ina -- mno‘ina
        when ttc_set do
            -- identick‚ typy
            if t_equal(t1,t2) then level:=tcl_identical
            -- T1 je p©edek T2 --> staticky bin rnˆ shodn‚
            elsif t_ancestor(context,t1,t2) then level:=tcl_static_identical
            -- T1 je potomek T2 --> dynamicky bin rnˆ shodn‚ (kontrola mez¡)
            elsif t_descendant(context,t1,t2) then level:=tcl_dynamic_identical
            -- identick‚ b ze
            elsif t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
            -- jinak nekompatibiln¡
            else level:=tcl_incompatible;
            end if;

        -- diskr‚tn¡ IN mno‘ina
        when ttc_in_set do
            -- T1 mus¡ b˜t stejn˜ jako b ze T2, nebo alespo¤ odvozen˜
            if t_descendant(context,t1,t2.getbase(context))
              then level:=tcl_convertible
              else level:=tcl_incompatible;
              end if;

            -- je¨tˆ zkontrolovat determinaci kompatibility s b z¡ mno‘iny
            test_determinations_base(t1,t2);

        -- p©ed n¡ pointeru jako OUT parametru
        when ttc_pointer_out do
            if t_equal(t1,t2)

              -- identick‚ typy
              then level:=tcl_identical

              -- zkoumat d l
              else
                ---- (1) kontrola t©¡d ----
                -- mus¡ to b˜t pointery stejn‚ t©¡dy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola b z¡ ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–
                  t2b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–

                begin
                  -- pro zjednodu¨en¡ si dop©edu zjistit kompatibilitu b z¡
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- class -- class
                  if t1b=pb_class and t2b=pb_class then
                    -- T1:base p©edek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- T1:base potomek T2:base
                    elsif t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- unchecked -- unchecked 
                  elsif t1b=pb_unchecked and t2b=pb_unchecked then
                    -- jsou to kompatibiln¡ unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_static_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- jin‚ kombinace jsou nepovolen‚
                  else
                    level:=tcl_incompatible;
                    end if;
                  end declare;


                ---- (3) kontrola determinace p©¡stupu ----
                if not t_compatible_varaccesses(t1,t2) then
                  level:=tcl_incompatible;
                  end if;


                -- kompatibiln¡ pointery maj¡ i stejn˜ fyzick˜ layout
                verify(674,level<>tcl_incompatible and then t1.getpattrib<>t2.getpattrib);
                end if;

        -- p©i©azen¡ pointer–
        when ttc_pointer_assign do
            if t_equal(t1,t2)

              -- identick‚ typy
              then level:=tcl_identical

              -- zkoumat d l
              else
                ---- (1) kontrola t©¡d ----
                -- mus¡ to b˜t pointery stejn‚ t©¡dy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola b z¡ ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–
                  t2b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–

                begin
                  -- pro zjednodu¨en¡ si dop©edu zjistit kompatibilitu b z¡
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- strict := strict
                  if t1b=pb_strict and t2b=pb_strict then
                    -- identick‚ b ze => kompatibiln¡
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- ^unconstrained array
                    elsif t_is_stype(t1.getbase(context),dt_uarray) then test_uarray(t1.getbase(context),t2.getbase(context))
                    -- ^unconstrained string
                    elsif t_is_stype(t1.getbase(context),dt_ustring) then test_string(t1.getbase(context),t2.getbase(context))
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- class := class
                  elsif t1b=pb_class and t2b=pb_class then
                    -- T1:base p©edek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- T1:base potomek T2:base
                    elsif t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- class := strict
                  elsif t1b=pb_class and t2b=pb_strict then
                    -- T1:base p©edek T2:base
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- strict := class
                  elsif t1b=pb_strict and t2b=pb_class then
                    -- T1:base potomek T2:base
                    if t_descendant(context,t1.getbase(context),t2.getbase(context)) then level:=tcl_dynamic_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- alespo¤ jeden z pointer– je unchecked
                  elsif t1b=pb_unchecked or t2b=pb_unchecked then
                    -- jsou to kompatibiln¡ unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_convertible
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- jin‚ p©¡pady by nemˆly nastat
                  else
                    verify(209,true);
                    end if;
                  end declare;


                ---- (3) kontrola determinace p©¡stupu ----
                if not t_compatible_varaccesses(t1,t2) then
                  level:=tcl_incompatible;
                  end if;
                end if;

        -- porovn n¡ pointer–
        when ttc_pointer_rel do
            if t_equal(t1,t2)

              -- identick‚ typy
              then level:=tcl_identical

              -- zkoumat d l
              else 
                ---- (1) kontrola t©¡d ----
                -- mus¡ to b˜t pointery stejn‚ t©¡dy
                if t1.getpclass<>t2.getpclass then
                  level:=tcl_incompatible;
                  return;
                  end if;


                ---- (2) kontrola b z¡ ----
                declare var
                  t1b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–
                  t2b : ptrbase;                   -- kompatibilita b z¡ dvou pointer–

                begin
                  -- pro zjednodu¨en¡ si dop©edu zjistit kompatibilitu b z¡
                  t1b:=t1.getpbase;
                  t2b:=t2.getpbase;

                  -- strict -- strict
                  if t1b=pb_strict and t2b=pb_strict then
                    -- identick‚ b ze => kompatibiln¡
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- ^unconstrained array
                    elsif t_is_stype(t1.getbase(context),dt_uarray) 
                       or t_is_stype(t2.getbase(context),dt_uarray) then test_uarray(t1.getbase(context),t2.getbase(context))
                    -- ^unconstrained string
                    elsif t_is_stype(t1.getbase(context),dt_ustring) 
                       or t_is_stype(t2.getbase(context),dt_ustring) then test_string(t1.getbase(context),t2.getbase(context))
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- class -- class
                  elsif t1b=pb_class and t2b=pb_class then
                    -- identick‚ b ze
                    if t_equal(t1.getbase(context),t2.getbase(context)) then level:=tcl_static_identical
                    -- jedna odvozen  od druh‚
                    elsif t_derived(context,t1.getbase(context),t2.getbase(context)) then level:={%%X}tcl_dynamic_identical
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- class -- strict
                  elsif t1b=pb_class and t2b=pb_strict then
                    -- b ze T2 mus¡ b˜t odvozena od b ze T1
                    if t_ancestor(context,t1.getbase(context),t2.getbase(context))
                      then level:=tcl_dynamic_identical
                      else level:=tcl_incompatible;
                      end if;

                  -- strict -- class
                  elsif t1b=pb_strict and t2b=pb_class then
                    -- b ze T1 mus¡ b˜t odvozena od b ze T2
                    if t_ancestor(context,t2.getbase(context),t1.getbase(context))
                      then level:=tcl_dynamic_identical
                      else level:=tcl_incompatible;
                      end if;

                  -- alespo¤ jeden z pointer– je unchecked
                  elsif t1b=pb_unchecked or t2b=pb_unchecked then
                    -- jsou to kompatibiln¡ unchecked pointery ?
                    if t_compatible_unchecked_pointers(t1,t2) then level:=tcl_convertible
                    -- jinak nekompatibiln¡
                    else level:=tcl_incompatible;
                    end if;

                  -- jin‚ p©¡pady by nemˆly nastat
                  else
                    verify(210,true);
                    end if;
                  end declare;


                ---- (3) kontrola determinace p©¡stupu ----
                -- p©i porovn v n¡ n s determinace p©¡stupu nezaj¡m 
                end if;  

        -- interface cast: t©¡da -- t©¡da
        when ttc_icast_class do test_interface(t1,t2);

        -- interface cast: pointer -- pointer
        when ttc_icast_pointer do 
            ---- (1) kontrola t©¡d ----
            -- mus¡ to b˜t pointery na data
            if t1.getpclass<>pc_data or t2.getpclass<>pc_data then
              level:=tcl_incompatible;
              return;
              end if;


            ---- (2) kontrola b z¡ ----
            -- nesm¡ b˜t unchecked
            if t1.getpbase=pb_unchecked or t2.getpbase=pb_unchecked then
              level:=tcl_incompatible;
              return;
              end if;


            ---- (3) b ze mus¡ b˜t icast-kompatibiln¡ t©¡dy ----
            test_interface(t1.getbase(context),t2.getbase(context));

        -- NIL
        when ttc_nil do level:=tcl_static_identical;

        when others do verify(73,true);
        end case;

      -- na z vˆr je¨tˆ kontrola determinace kompatibility
      if level<>tcl_incompatible 
      -- m -li pro tento druh kontroly smysl
      and then typecheck[oclass,t1.stype,t2.stype].c not in ttcs_no_determination_check then
        -- prov‚st kontrolu
        if not t_compatible_determinations(t1,t2) then
          level:=tcl_incompatible;
          end if;
        end if;
      end declare;
    end if;
  end t_typecheck;



----------------------------------------------------------------------------------------------------
procedure t_compatible =
-- True, jsou-li typy kompatibiln¡.                                           
-- Kromˆ testu determinace kompatibility prov d¡ i test konvertibility        
-- hodnoty typu T2 na typ T1.                                                 
----------------------------------------------------------------------------------------------------
var
  level            : tcomplevel;                 -- £rove¤ kompatibility                        
  restype          : tresulttype;                -- typ v˜sledku                                

begin
  t_typecheck(context,oclass,assign,t1,t2,level,restype);
  result:=level<>tcl_incompatible;
  end t_compatible;



----------------------------------------------------------------------------------------------------
procedure t_get_compatibility_level =
-- —rove¤ kompatibility typ– v–‡i p©i©azen¡ var(T1):=value(T2).               
----------------------------------------------------------------------------------------------------
var
  restype          : tresulttype;                -- typ v˜sledku                                

begin
  t_typecheck(context,oclass,assign,t1,t2,result,restype);
  end t_get_compatibility_level;



----------------------------------------------------------------------------------------------------
procedure t_binary_identical =
-- True, jsou-li typy bin rnˆ identick‚.                                      
----------------------------------------------------------------------------------------------------
begin
  result:=t_get_compatibility_level(context,toc_assign,true,t1,t2) in tcomplevelset:[tcl_identical,tcl_static_identical];
  end t_binary_identical;



----------------------------------------------------------------------------------------------------
procedure t_descendant =
-- True, je-li T1 potomek T2.                                                 
----------------------------------------------------------------------------------------------------
var
  t                : typeview;

begin
  -- Pozn mka: Podobn  procedura je i v CC_SYM, ale pro symboly (ISDESCENDANT) 
  t:=t1;
  while (t.tview<>tview_null) and not t_equal(t,t2) loop t:=t.getancestor(context) end loop;
  result:=t.tview<>tview_null;
  end t_descendant;



----------------------------------------------------------------------------------------------------
procedure t_ancestor =
-- True, je-li T1 p©edek T2.                                                  
----------------------------------------------------------------------------------------------------
var
  t                : typeview;

begin
  -- Pozn mka: Podobn  procedura je i v CC_SYM, ale pro symboly (ISANCESTOR) 
  t:=t2;
  while (t.tview<>tview_null) and not t_equal(t1,t) loop t:=t.getancestor(context) end loop;
  result:=t.tview<>tview_null;
  end t_ancestor;



----------------------------------------------------------------------------------------------------
procedure t_derived =
-- True, je-li T1 p©edek nebo potomek T2.                                     
----------------------------------------------------------------------------------------------------
begin
  result:=t_ancestor(context,t1,t2) or t_ancestor(context,t2,t1);
  end t_derived;



----------------------------------------------------------------------------------------------------
procedure t_checktype =
-- Dodate‡n  kontrola typu - zejm‚na z vislost¡ na jin˜ch typech.             
-- Nap©¡klad pro typ procedura kontroluje £plnost deklarace typ– parametr–.   
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko

begin
  case ptyp^.stype
    -- procedura
    when dt_procedure do
        -- projet v¨echny parametry
        srch.find_et_first(ptyp,rc_primary,et_param,tesearchflagset:[]);
        while srch.psym<>nil loop
          {%%X}

          -- dal¨¡ parametr
          srch.find_et_next;
          end loop;

        {%%X}

    -- pro jin‚ typy mˆ nic nenapad 
    when others do verify(230,true);
    end case;
  end t_checktype;



----------------------------------------------------------------------------------------------------
procedure t_get_pointer_rtattrib =
-- Ze zadan˜ch £daj– vypo‡¡t  mno‘inu voliteln˜ch atribut– pointeru.          
-- Pozor: O‡ek v , ‘e mno‘ina PATTRIB je ji‘ inicializovan .
----------------------------------------------------------------------------------------------------
begin
  -- :tag 
  if pbase=pb_class and then base^.stype<>dt_class then
    pattrib+rtattribset:[rta_tag];
    end if;

  -- Ondra 06.12.2001 : Mus¡me se rozhodnout mezi :size a :last
  -- unchecked => :size
  if pbase=pb_unchecked then 
    pattrib+rtattribset:[rta_size]
  -- b ze je unconstrained string/array => :last
  elsif base<>nil and base^.stype in dts_unconstrained then 
    pattrib+rtattribset:[rta_last]
  -- class => :size
  elsif (pbase=pb_class and pclass=pc_data) and then base^.stype<>dt_class then 
    pattrib+rtattribset:[rta_size]; 
    end if;

  -- Pozn mka: Nem–‘e se st t, ‘e by b zov˜ typ mˆl utajenou strukturu a j 
  -- zde p©itom zjistil, ‘e je unconstrained. Je to t¡m, ‘e typ s
  -- potenci lnˆ utajenou strukturou nesm¡ b˜t unconstrained.

  -- ^instance
  if pclass=pc_subprogram then
    pattrib+rtattribset:[rta_instance];
    end if;
  end t_get_pointer_rtattrib;



----------------------------------------------------------------------------------------------------
procedure t_derive_string =
-- Odvod¡ typ constrained string o d‚lce HVAL a b zi BASE.
-- Pokud je HVAL vˆt¨¡ ne‘ maxim ln¡ dovolen , ohl s¡ varov n¡ CW_CONCAT_STRLENGTH a d‚lku o©¡zne na 
-- maxim ln¡ dovolenou.
----------------------------------------------------------------------------------------------------
with
  cc_var,
  cd_decl,
  cd_decl.cd_create;

var
  hval             : tuniint;                    -- zvolen  horn¡ mez                           
  maxhval          : tuniint;                    -- maxim ln¡ horn¡ mez s ohledem na b zi       
  size             : tunidata_size;              -- velikost ©etˆzce                            
  isize            : tunidata_size;              -- velikost intern¡ ‡ sti                      
  bsize            : tunidata_size;              -- velikost b ze                               
  ptyp_context     : tcontext;                   -- kontext novˆ zalo‘en‚ho ©etˆzcov‚ho typu

begin
  -- zjistit velikost b ze 
  bsize:=base.getsize;

  -- ovˆ©it, zda je velikost p©¡pustn  
  cpu^.getstrmaxhval(bsize,maxhval);
  if hval0>maxhval

    -- je to moc, ohl sit varov n¡ 
    then
      ce^.setwarning({CCERR=}000313,cw_concat_strlength);
      {%%POS}
      hval:=maxhval;

    -- nen¡ to moc
    else
      hval:=hval0;
      end if;

  -- vypo‡¡tat parametry ©etˆzce 
  cpu^.getstrparams(dt_string,size,isize,bsize,hval);

  -- zalo‘it typ string
  d_create_temporary_type(context,ptyp,ptyp_context,dt_string,size);

  -- dosadit b zov˜ typ 
  ptyp^.base.settype(base.getctype);

  -- konec deklarace
  d_end_temporary_type(ptyp^);

  -- odvodit typ rozsahu 
  t_derive_string_range(ptyp^,isize,hval);

{
  verify(343,(t1.stype<>dt_string) or (t2.stype<>dt_string));

  -- zjistit velikost b ze
  bsize:=t1.getbase(curr).getsize;

  -- vypo‡¡tat po‡et prvk– ©etˆzce
  hval:=t1.getrange(curr).gethval;
  uiadd(hval,t2.getrange(curr).gethval);

  -- ovˆ©it, zda je velikost p©¡pustn  
  cpu^.getstrmaxhval(bsize,maxhval);
  if uicmpg(hval,maxhval) then
    ce^.setwarning({CCERR=}000314,cw_concat_strlength);
    {%%POS}
    hval:=maxhval;
    end if;

  -- vypo‡¡tat parametry ©etˆzce 
  cpu^.getstrparams(dt_string,size,isize,bsize,hval);

  -- zalo‘it typ string 
  newtmp(curr,ptyp,dt_string,size);

  -- dosadit b zov˜ typ 
  ptyp^.base.settype(t1.getbase(curr).getctype);

  -- odvodit typ rozsahu 
  t_derive_string_range(ptyp^,isize,hval);
}
  end t_derive_string;



----------------------------------------------------------------------------------------------------
procedure t_derive_string_range =
-- Pro zadan˜ typ ©ˆtˆzce odvod¡ rozsah ©etˆzce.
----------------------------------------------------------------------------------------------------
with
  cc_var,cd_decl,cd_decl.cd_create;

var
  rtype            : pentity_type;               -- typ rozsahu ©etˆzce
  rtype_context    : tcontext;                   -- kontext typu rozsahu ©etˆzce

begin
  -- vytvo©it typ rozsahu
  d_create_at_position(sym_primary_context(typ),pentity(rtype),rtype_context,et_type,nil,{%%TODO(nullpos)}nil);
  rtype^.tkind:=tk_regular;
  rtype^.stype:=dt_unsigned;
  rtype^.size:=isize;
  rtype^.lval:=ui_1;
  rtype^.hval:=hval;
  cpu^.bytestobits(isize,rtype^.bits);
  d_end_at_position(rtype^,{%%TODO(nullpos)}nil,false);

  -- nastavit jako typ rozsahu uveden‚ho stringu
  typ.srange.settype(rtype);
  end t_derive_string_range;



----------------------------------------------------------------------------------------------------
procedure t_is_string_of_char =
-- True, je-li typ unistr/string/ustring of char/unichar.                     
----------------------------------------------------------------------------------------------------
var
  b                : typeview;

begin
  if t.tview=tview_full and t.stype in dts_u_string

    -- je to string, zkoumat b zi
    then
      b:=t.getbase(context);
      result:=b.tview=tview_full and b.stype in dts_u_char;

    -- je to nˆco jin‚ho
    else
      result:=false;
      end if;
  end t_is_string_of_char;



----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_object =
-- True, je-li typ pointer na objekt.
----------------------------------------------------------------------------------------------------
begin
  result:=t.tview=tview_full and t.stype=dt_pointer and t.getpclass=pc_data;
  end t_is_pointer_to_object;



----------------------------------------------------------------------------------------------------
procedure t_is_pointer_to_unconstrained =
-- True, je-li typ pointer na unconstrained array/string.
----------------------------------------------------------------------------------------------------
begin
  result:=t.tview=tview_full and t.stype=dt_pointer and t.getpclass=pc_data
          and t.getbase(context).stype in dts_unconstrained;
  end t_is_pointer_to_unconstrained;



----------------------------------------------------------------------------------------------------
procedure t_is_sts =
-- True, je-li typ z mno‘iny STS.                                             
----------------------------------------------------------------------------------------------------
begin
  result:=(t.tview=tview_full or t.isclass) and t.stype in sts;
  end t_is_sts;



----------------------------------------------------------------------------------------------------
procedure t_is_stype =
-- True, je-li typ roven STYPE.
----------------------------------------------------------------------------------------------------
begin
  result:=(t.tview=tview_full or t.isclass) and t.stype=stype;
  end t_is_stype;



----------------------------------------------------------------------------------------------------
procedure t_is_composite =
-- True, je-li typ kompozitn¡.
----------------------------------------------------------------------------------------------------
begin
  -- typ je v dan‚m kontextu kompozitn¡ <=> 
  result:=t.tview<>tview_full or else t.stype in dts_composite;
  end t_is_composite;



----------------------------------------------------------------------------------------------------
procedure t_contains_class =
-- True, pokud zadan˜ typ obsahuje instanci t©¡dy jako subkomponentu.
-- (Nebo je s m t©¡da.) Ka¨le se na viditelnost struktury typu.
----------------------------------------------------------------------------------------------------
var
  srch             : tentitysearch;              -- hled tko

begin
  -- nepo‡¡tali jsme to u‘ jednou ?
  if typ.cclass=tcc_unknown then
    case typ.stype
      -- p©¡mo t©¡da
      when dt_class     do typ.cclass:=tcc_yes;

      -- pole/©etˆzec
      when dt_array,dt_uarray,dt_string,dt_ustring do
          -- p©edpoklad
          typ.cclass:=tcc_no;

          -- zjistit, jak je na tom b ze
          result:=t_contains_class(typ.base.getctype^);
          if result then
            typ.cclass:=tcc_yes;
            return;
            end if;

      -- record
      when dt_record do
          -- p©edpoklad
          typ.cclass:=tcc_no;

          -- co p©edek ?
          if typ.ancestor.isset then
            result:=t_contains_class(pentity_type(typ.ancestor.getcentity)^);
            if result then
              typ.cclass:=tcc_yes;
              return;
              end if;
            end if;

          -- co komponenty ?
          srch.find_et_first(^typ,rc_primary,et_var,[]);
          while srch.psym<>nil loop
            -- zkontrolovat
            result:=t_contains_class(pentity_var(srch.psym)^.typ.getctype^);
            if result then
              typ.cclass:=tcc_yes;
              return;
              end if;

            -- dal¨¡ symbol
            srch.find_et_next;
            end loop;

      -- nic jin‚ho nem  komponenty ani nen¡ t©¡da
      when others do typ.cclass:=tcc_no;
      end case;
    end if;

  -- pokud se to je¨tˆ nezjistilo, tak zjistit teƒ
  result:=typ.cclass=tcc_yes;
  end t_contains_class;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  init_type_compatibility_table;
  init_view_compatibility_table;
  end entry;



end cc_type;