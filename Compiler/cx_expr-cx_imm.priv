----------------------------------------------------------------------------------------------------
module private cx_imm =
-- Překladač Flexu.
-- Operace s přímou hodnotou.
----------------------------------------------------------------------------------------------------
-- Ondra : 24.07.2001 : Vytvořil.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
#separate private cx_array;
-- Práce s agregátem pole.
----------------------------------------------------------------------------------------------------
#separate private cx_set;
-- Práce s agregátem množiny.        
----------------------------------------------------------------------------------------------------

const
  -- alokace paměti
  immitemsinit     = 10;
  immitemsdelta    = 20;


----------------------------------------------------------------------------------------------------
procedure imm_convord (
     oldval        : in unchecked;               -- původní hodnota
     newval        : out unchecked;              -- nová hodnota
     oldsize       : in t_unsigned32;            -- velikost původní hodnoty
     oldsign       : in t_logical;               -- T-signed, F-unsigned
     newsize       : in t_unsigned32;            -- velikost nové hodnoty
     newsign       : in t_logical) =             -- T-signed, F-unsigned
-- Konvertuje ordinální hodnotu.
----------------------------------------------------------------------------------------------------
var
  ui               : tuniint;

begin
  uniint_load(ui,oldval,oldsize,oldsign);
  if uniint_test_shrink(ui,newsize,newsign) then
    ce^.seterror({CCERR=}000468,ce_numrange);
    {%%POS}
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  uniint_store(ui,newval,newsize);
  end imm_convord;



----------------------------------------------------------------------------------------------------
procedure store_ordinal =
-- Uloží do přímé hodnoty univerzální integer.                                
----------------------------------------------------------------------------------------------------
begin
  imm.ic:=ic_ordinal;
  imm.ui:=ui;
  end store_ordinal;



----------------------------------------------------------------------------------------------------
procedure store_real =
-- Uloží do přímé hodnoty univerzální real.                                
----------------------------------------------------------------------------------------------------
begin
  imm.ic:=ic_real;
  imm.ur:=ur;
  end store_real;



----------------------------------------------------------------------------------------------------
procedure store_nil =
-- Uloží do přímé hodnoty NIL.                                                
----------------------------------------------------------------------------------------------------
begin
  imm.ic:=ic_nil;
  end store_nil;



----------------------------------------------------------------------------------------------------
procedure store_string =
-- Uloží do přímé hodnoty znakový agregát.
-- (Nealokuje paměť, jen převezme pointer).
----------------------------------------------------------------------------------------------------
type
  tmpointer        = ^unchecked for machine_pointer use true;
  tupointer        = record
      ptr          : tmpointer;
    #if #environment compiler_version;='4.0.3.14' then;
      rta_last     : unsigned 32;
    #else;
      rta_tag      : tag;
    #end if;
      end record;

  --%%TODO(SLICE) krutobrutální záplata
  paliasedlexaggregate = ^string of aliased plexaggregate^:base;

begin
  imm.ic:=ic_condensed;
  imm.citems.len:=str^:length;
  imm.citems.isize:=str^:base:size;

  --%%TODO(SLICE) krutobrutální záplata
  tupointer(imm.citems.items:unchecked).ptr     :=^paliasedlexaggregate(str)^[1]:unchecked;
#if #environment compiler_version;='4.0.3.14' then;
  tupointer(imm.citems.items:unchecked).rta_last:=str^:length;
#else;
  tupointer(imm.citems.items:unchecked).rta_tag :=str^:tag;
#end if;
  --imm.citems.items:=^str^[1..str^:length]:unchecked;
  end store_string;



----------------------------------------------------------------------------------------------------
procedure store_sysstr =
-- Uloží do přímé hodnoty systémový řetězec.
----------------------------------------------------------------------------------------------------
type
  p_aliased_unsigned8array = ^array of aliased t_unsigned8; {%%TODO(SLICE) záplata pro záplatu níže }

begin
  -- základní údaje
  imm.ic:=ic_condensed;
  imm.citems.len:=s:length;
  imm.citems.isize:=tunichar:size;

  -- alokovat paměť
  new imm.citems.items range imm.citems.len*imm.citems.isize;

  -- zkopírovat řetězec 
  for i in s:range loop
    tunichar({%%TODO(SLICE)}t_pointer(^p_aliased_unsigned8array(imm.citems.items)^[(i-1)*tunichar:size])^):=char_to_unichar(s[i]);
    end loop;
  end store_sysstr;



----------------------------------------------------------------------------------------------------
procedure store_imm =
-- Zkopíruje do přímé hodnoty jinou přímou hodnotu.                           
-- (vytváří fyzickou kopii).                                                  
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

begin
  imm.ic:=from.ic;
  case from.ic
    -- ordinální hodnota 
    when ic_ordinal   do imm.ui:=from.ui;

    -- reálné číslo
    when ic_real      do imm.ur:=from.ur;

    -- kondenzované pole
    when ic_condensed do
        new imm.citems.items range from.citems.len*from.citems.isize;
        imm.citems.len  :=from.citems.len;
        imm.citems.isize:=from.citems.isize;
        advanced.low_level.unchecked_memory_access.memory_copy(from.citems.items^,imm.citems.items^,imm.citems.len*imm.citems.isize);

    -- agregát pole
    when ic_array     do
        -- alokovat paměť pro agregát
        new imm.aitems;

        -- zkopírovat prvky, je-li co kopírovat
        if from.aitems^.list<>nil then
          -- alokovat paměť pro prvky
          new imm.aitems^.list range from.aitems^.list^:length;

          -- zkopírovat prvky
          for i in from.aitems^.list^:range loop
            succ imm.aitems^.list^:length;
            imm.aitems^.list^[i].lval:=from.aitems^.list^[i].lval;
            imm.aitems^.list^[i].hval:=from.aitems^.list^[i].hval;
            store_imm(imm.aitems^.list^[i].val,from.aitems^.list^[i].val);
            end loop;
          end if;

        -- zkopírovat OTHERS
        store_imm(imm.aitems^.othersval,from.aitems^.othersval);

    -- agregát recordu
    when ic_record    do
        -- alokovat paměť pro agregát
        new imm.ritems;

        -- zkopírovat prvky, je-li co kopírovat
        if from.ritems^.list<>nil then
          -- alokovat paměť pro prvky
          new imm.ritems^.list range from.ritems^.list^:last;

          -- zkopírovat prvky
          for i in from.ritems^.list^:range loop
            succ imm.ritems^.list^:length;
            imm.ritems^.list^[i].item:=from.ritems^.list^[i].item;
            store_imm(imm.ritems^.list^[i].val,from.ritems^.list^[i].val);
            end loop;
          end if;

        -- zkopírovat OTHERS
        store_imm(imm.ritems^.othersval,from.ritems^.othersval);
        --u_nimplemented(450);

    -- agregát množiny
    when ic_set       do
        -- alokovat paměť pro agregát
        new imm.sitems;

        -- zkopírovat prvky, je-li co kopírovat
        if from.sitems^.list<>nil then
          -- alokovat paměř pro prvky
          new imm.sitems^.list range from.sitems^.list^:length;

          -- zkopírovat prvky (žádné deep copy není potřeba)
          imm.sitems^.list^:=from.sitems^.list^;
          end if;
        --u_nimplemented(136);

    -- NIL
    when ic_nil       do ;

--  when ic_bin       do                 -- specifikováno nadřazeným typem
--      c_store(imm.val,from.vsize);
--      imm.vsize:=from.vsize;
--      movef(from.val^,imm.val^,imm.vsize);

--  -- relokabilní symol
--  when ic_relo      do imm.sym:=from.sym;

    when others       do verify({VERIFY=}000250,true);
    end case;
  end store_imm;



----------------------------------------------------------------------------------------------------
procedure store_array =
-- Vytvoří přímou hodnotu typu agregát pole.                                  
----------------------------------------------------------------------------------------------------
begin
  -- základní údaje 
  imm.ic:=ic_array;

  -- alokovat paměť pro agregát 
  new imm.aitems;

  -- předalokovat požadovaný počet položek
  if items<>0 then
    cx_array.choice_extend(imm.aitems^,items);
    end if;

  -- OTHERS je implicitně NIL 
  store_nil(imm.aitems^.othersval);
  end store_array;



----------------------------------------------------------------------------------------------------
procedure store_array_item =
-- Uloží do přímé hodnoty (agregátu pole) hodnotu položek v určitém rozsahu.  
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000438,(imm.ic<>ic_array) or (imm.aitems=nil));

  cx_array.choice_add_single(context,imm.aitems^,val,item,choice);
  end store_array_item;



----------------------------------------------------------------------------------------------------
procedure store_array_items_range =
-- Uloží do přímé hodnoty (agregátu pole) hodnotu položek v určitém rozsahu.  
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000251,(imm.ic<>ic_array) or (imm.aitems=nil));

  cx_array.choice_add_range(context,imm.aitems^,lval,hval,item,choice);
  end store_array_items_range;



----------------------------------------------------------------------------------------------------
procedure store_array_others =
-- Uloží do přímé hodnoty (agregátu pole) hodnotu OTHERS.                     
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000252,(imm.ic<>ic_array) or (imm.aitems=nil));

  -- uložit 
  store_imm(imm.aitems^.othersval,item);
  end store_array_others;



----------------------------------------------------------------------------------------------------
procedure store_record =
-- Vytvoří přímou hodnotu typu agregát řetězce.                               
----------------------------------------------------------------------------------------------------
begin
  -- základní údaje 
  imm.ic:=ic_record;

  -- alokovat paměť pro agregát 
  new imm.ritems;

  -- OTHERS je implicitně NIL 
  store_nil(imm.ritems^.othersval);
  end store_record;



----------------------------------------------------------------------------------------------------
procedure store_record_item =
-- Uloží do přímé hodnoty (agregátu recordu) hodnotu jedné položky.           
----------------------------------------------------------------------------------------------------
var
  i                : t_unsigned;
  _list            : imm.ritems^.list:type;
  _x               : imm.ritems^.list^:base;

begin;
  verify({VERIFY=}000436,(imm.ic<>ic_record) or (imm.ritems=nil));

  -- není už hodnota složky definována ? 
  i:=1;
  if imm.ritems^.list<>nil then
    while i<=imm.ritems^.list^:length and then imm.ritems^.list^[i].item<>pitem loop 
      succ i; 
      end loop;
    end if;
  if imm.ritems^.list<>nil and then i<=imm.ritems^.list^:length

    -- ano je => varování + změnit hodnotu 
    then
      -- varování 
      ce^.setwarning(context,{CCERR=}000469,cw_duplicate_association);
      {%%POS}

      -- změnit hodnotu 
      imm.ritems^.list^[i].val:=item;

    -- ne není => přidat novou hodnotu 
    else
      -- realokovat paměť
      if imm.ritems^.list=nil then
        new imm.ritems^.list range immitemsinit;
      elsif imm.ritems^.list^:length+1>imm.ritems^.list^:last then
        --%%TODO(ADJUST) adjust imm.ritems^.list range imm.ritems^.list^:last+immitemsdelta;
        new _list range imm.ritems^.list^:last+immitemsdelta;
        _list^:=imm.ritems^.list^;
        discard imm.ritems^.list;
        imm.ritems^.list:=_list;
        end if;

      -- přidat na konec %%TODO(AGGREGATE)
      _x.item:=pitem;
      _x.val :=item;
      imm.ritems^.list^ & _x;
      --u_nimplemented(89);
      end if;

  end store_record_item;



----------------------------------------------------------------------------------------------------
procedure store_record_others =
-- Uloží do přímé hodnoty (agregátu recordu) hodnotu OTHERS.                  
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000254,(imm.ic<>ic_record) or (imm.ritems=nil));

  -- uložit 
  store_imm(imm.ritems^.othersval,item);
  end store_record_others;



----------------------------------------------------------------------------------------------------
procedure store_set =
-- Vytvoří přímou hodnotu typu agregát množiny.                               
----------------------------------------------------------------------------------------------------
begin
  -- základní údaje 
  imm.ic:=ic_set;

  -- alokovat paměť pro agregát 
  new imm.sitems;
  end store_set;



----------------------------------------------------------------------------------------------------
procedure store_set_item =
-- Uloží do přímé hodnoty (agregátu množiny) položku.                         
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000440,(imm.ic<>ic_set) or (imm.sitems=nil));

  cx_set.choice_add_single(context,imm.sitems^,val,warn_duplicates,choice);
  end store_set_item;



----------------------------------------------------------------------------------------------------
procedure store_set_items_range =
-- Uloží do přímé hodnoty (agregátu množiny) položky v určitém rozsahu.       
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000441,(imm.ic<>ic_set) or (imm.sitems=nil));

  cx_set.choice_add_range(context,imm.sitems^,lval,hval,warn_duplicates,choice);
  end store_set_items_range;



----------------------------------------------------------------------------------------------------
procedure load_uniint =
-- Z přímé hodnoty načte celé číslo.                                          
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_ordinal     do ui:=imm.ui;
    when ic_nil         do ui:=ui_nil;
    when others         do verify({VERIFY=}000008,true{imm.ic<>ic_ordinal});
    end case;
  end load_uniint;



----------------------------------------------------------------------------------------------------
procedure load_unireal =
-- Z přímé hodnoty načte univerzální reálné číslo
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_ordinal     do ur:=uniint_to_unireal(imm.ui);
    when ic_real        do ur:=imm.ur;
    when ic_nil         do ur:=ur_nil;
    when others         do verify({VERIFY=}000236,true);
    end case;
  end load_unireal;



----------------------------------------------------------------------------------------------------
procedure load_unilogical =
-- Z přímé hodnoty načte univerzální logickou hodnotu.
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_ordinal     do ul:=uniint_to_unilogical(imm.ui);{imm.ui;}
    when ic_nil         do ul:=ul_nil;
    when others         do verify({VERIFY=}000094,true{imm.ic<>ic_ordinal});
    end case;
  end load_unilogical;



----------------------------------------------------------------------------------------------------
procedure load_sysstr =
-- Z přímé hodnoty načte systémový řetězec.
----------------------------------------------------------------------------------------------------
with
  standard.numerics;
  
var
  i                : t_unsigned;
  j                : t_unsigned;

begin
{
  verify({VERIFY=}000844,(imm.ic<>ic_string) or (imm.pocet<>imm.delka{Dukaz: imm.pocet=imm.delka => prvek:size=1}));
  byte(s[0]):=imm.pocet;
  movef(imm.citems.items^,s[1],imm.pocet);
}
  case imm.ic
    when ic_condensed do
        s:length:=min_unsigned(s:last,imm.citems.len);
        i:=0;
        j:=1;
        for l in s:range loop
          imm_convord(imm.citems.items^[i],s[j],imm.citems.isize,false,s:base:size,false);
          i+imm.citems.isize;
          j+1;
          end loop;
    when ic_nil do s:={sysstr_nil}nil;
    when others do verify({VERIFY=}000845,true{imm.ic<>ic_string});
    end case;
  end load_sysstr;



----------------------------------------------------------------------------------------------------
procedure load_image =
-- Z přímé hodnoty načte její textovou reprezentaci.
----------------------------------------------------------------------------------------------------
with
  standard.conversions;

begin
  verify({VERIFY=}000179,t.tview<>tview_full);
  case imm.ic
    -- ordinální hodnota 
    when ic_ordinal     do
        case t{ptyp^}.stype
          -- číslo se znaménkem
          when dt_signed, dt_uniint do s:=signed_to_string(uniint_to_signed(imm.ui));--%%TODO(LIB) s:=linttostr(imm.ui,tuniint:size);

          -- číslo bez znaménka
          when dt_unsigned do s:=unsigned_to_string(uniint_to_unsigned(imm.ui));--%%TODO(LIB) s:=lnumtostr(imm.ui,tuniint:size);

          -- znak
          when dt_char, dt_unichar do unimplemented({UNIMP=}000046);

          -- boolean
          when dt_logical, dt_unilogical do unimplemented({UNIMP=}000047);

          -- enum
          when dt_enum do unimplemented({UNIMP=}000048);

          when others do verify({VERIFY=}000118,true);
          end case;

    -- reálné číslo
    when ic_real do
        case t{ptyp^}.stype
          -- univerzální real
          when dt_unireal do --%%TODO(LIB) s:=realtostr({%%X}extended(imm.ur),true,0);

          -- floating-point číslo
          when dt_float   do --%%TODO(LIB) s:=realtostr({%%X}extended(imm.ur),true,0);

          -- fixed-point číslo
           when dt_fixed  do --%%TODO(LIB) s:=realtostr({%%X}extended(imm.ur),true,0);

          when others do verify({VERIFY=}000119,true);
          end case;

    -- nil
    when ic_nil do s:=sysstr_nil_image;

    when others do verify({VERIFY=}000117,true);
    end case;
  end load_image;



----------------------------------------------------------------------------------------------------
procedure imm_convarray (
    curr           : in tcontext;                -- překládaný prvek
    imm            : in out timm_value;          -- přímá hodnota
    oldtype        : in typeview;                -- původní typ
    newtype        : in typeview;                -- nový typ
    change         : out t_logical) =            -- T-změnila se interní reprezentace
-- Konvertuje pole starého typu na nový typ.
----------------------------------------------------------------------------------------------------
var
  oldbase          : typeview;                   -- báze původního typu                         
  newbase          : typeview;                   -- báze nového typu                            
  oldrange         : typeview;                   -- rozsah původního typu                       
  newrange         : typeview;                   -- rozsah nového typu                          
  change0          : t_logical;                  -- vnořený příznak změny                       
  diff             : tuniint;                    -- rozdíl mezí                                 
  j                : t_unsigned;

begin
  -- pole je prázdné, není co řešit 
  if imm.ic=ic_nil then return; end if;

--verify({VERIFY=}000081,imm.ic<>ic_condensed);

  -- zjistit báze typů 
  oldbase:=oldtype.getbase(curr);
  newbase:=newtype.getbase(curr);

  -- typy jsou binárně stejné, není co řešit 
  --if t_binary_identical(t_defview(old^.base.getctype),t_defview(new^.base.getctype)) then exit; end if;
  if t_binary_identical(curr,oldbase,newbase) then return; end if;

  case imm.ic
    -- kondenzovaný tvar 
    when ic_condensed do
        -- nic se transformovat nebude 
{
        case oldtype.stype
          -- unichar --> 
          dt_unichar : case newtype.stype
              -- --> char 
              dt_char do
                  -- zkonvertovat 
                  if udcmpe(newtype.getsize,ud_lunichar) then
                    end if;

                  change:=true;
                  end;

              else verify({VERIFY=}000265,true);
              end case;

          else verify({VERIFY=}000266,true);
          end case;
}

    -- agregátní tvar
    when ic_array do
        -- konvertovat všechny prvky
        for i in imm.aitems^.list^:range loop
          imm_settype(curr,imm.aitems^.list^[i].val,oldbase,newbase,change0);
          change:=change or change0;
          end loop;

        -- konvertovat OTHERS
        imm_settype(curr,imm.aitems^.othersval,oldbase,newbase,change0);
        change:=change or change0;

        -- rozsahy
        oldrange:=oldtype.getrange(curr);
        newrange:=newtype.getrange(curr);

        -- rozdíl mezí (NEW:FIRST - OLD:FIRST)
        diff:=newrange.getlval-oldrange.getlval;

        -- přepočítat meze
        if diff<>ui_0 then
          for i in imm.aitems^.list^:range loop
            imm.aitems^.list^[i].lval+diff;
            imm.aitems^.list^[i].hval+diff;
            end loop;
          end if;

    when others do verify({VERIFY=}000260,true);
    end case;
  end imm_convarray;



----------------------------------------------------------------------------------------------------
procedure imm_settype =
-- Přizpůsobí přímou hodnotu novému typu.                                     
----------------------------------------------------------------------------------------------------
begin
  -- předpoklad : nic se nezmění
  change:=false;

  case oldtype.stype
    -- diskrétní typy -->
    when dt_signed,dt_unsigned,dt_char,dt_enum,dt_logical,dt_uniint,dt_unilogical,dt_unichar do case newtype.stype
        -- --> diskrétní typy
        when dt_signed,dt_unsigned,dt_char,dt_enum,dt_logical,dt_uniint,dt_unilogical,dt_unichar do { nic nedělat };

        -- --> reálné typy
        when dt_float,dt_fixed,dt_unireal do unimplemented({UNIMP=}000026);

        when others do verify({VERIFY=}000076,true);
        end case;

    -- floating-point typy -->
    when dt_float,dt_fixed,dt_unireal do case newtype.stype
        -- --> reálné typy
        when dt_float,dt_fixed,dt_unireal do { nic nedělat };

        when others do verify({VERIFY=}000077,true);
        end case;

    -- pole nebo řetězec -->
    when dt_array,dt_uarray,dt_string,dt_ustring,{dt_unistr,}dt_uniarray do case newtype.stype
        -- --> pole nebo řetězec
        when dt_array,dt_uarray,dt_string,dt_ustring,{dt_unistr,}dt_uniarray do imm_convarray(curr,imm,oldtype,newtype,change);

        when others do verify({VERIFY=}000259,true);
        end case;

    -- množina -->
    when dt_set do case newtype.stype
        -- --> množina
        when dt_set do { nic nedělat };

        when others do verify({VERIFY=}000439,true);
        end case;

    -- record -->
    when dt_record do case newtype.stype
        -- --> record
        when dt_record do { nic nedělat };

        when others do verify({VERIFY=}000449,true);
        end case;

    -- NIL -->
    when dt_uninil do
        case newtype.tview
          -- Full view
          when tview_full do case newtype.stype
              -- --> diskrétní typy
              when dt_signed,dt_unsigned,dt_char,dt_enum,dt_logical,dt_uniint do
                  imm.ic:=ic_ordinal;
                  imm.ui:=ui_nil;
                  change:=true;

              -- --> reálné typy
              when dt_float,dt_fixed,dt_unireal do
                  imm.ic:=ic_real;
                  imm.ur:=ur_nil;
                  change:=true;

              -- pro ostatní typy ponechat
              when others do ;
              end case;

          -- Unchecked view
          when tview_unchecked do -- nic nedělat

          when others do verify({VERIFY=}000471,true);
          end case;

    when others do verify({VERIFY=}000080,true);
    end case;
  end imm_settype;



----------------------------------------------------------------------------------------------------
procedure imm_check =
-- Kontrola správnosti přímé hodnoty.
----------------------------------------------------------------------------------------------------
var
  lval             : tuniint;                    -- dolní mez
  hval             : tuniint;                    -- horní mez
  sign             : t_logical;                  -- znaménko
  base             : typeview;                   -- bázový typ
  length           : tuniint;                    -- délka rozsahu
  ui               : tuniint;

begin
  case imm.ic
    -- ordinální hodnota
    when ic_ordinal do
        verify({VERIFY=}000268,not (t.stype in dts_u_ordinal));

        -- neprovádět pro univerzální typy
        if t.stype in dts_unitype then return; end if;

        -- kontrola mezí
        if imm.ui<t.getlval or imm.ui>t.gethval then
          ce^.seterror({CCERR=}000470,ce_numrange);
          {%%POS}
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
          end if;

    -- reálné číslo
    when ic_real do
        -- kontrola přesnosti
        {%%X dodělat až bude hotová vlastní reálná aritmetika }

    -- kondenzovaný řetězec
    when ic_condensed do
        -- neprovádět pro univerzální typy
        if t.stype in dts_unitype then return; end if;

        -- kontrola délky
        case t.stype
          -- řetězec
          when dt_string do
              imm_get_length(imm,length);
              if length>t.getrange(curr).getlength then
                ce^.seterror({CCERR=}000471,ce_toomanyitems);
                {%%POS}
                ce^.resumeerror;
                end if;

          -- neomezený řetězec
          when dt_ustring do { nic nedělat };

          -- pole
          when dt_array do
              imm_get_length(imm,length);
              if length<>t.getrange(curr).getlength then
                ce^.seterror({CCERR=}000472,ce_arraylength);
                --%%TODO(LIB) ce^.setinfo(formats2(hint_expr_arraylength,linttostr(length,tuniint:size),linttostr(t.getrange(curr).getlength,tuniint:size)));
                {%%POS}
                {%%RESUME ce^.raiseerror;}
                ce^.resumeerror;
                end if;

          -- neomezené pole
          when dt_uarray  do { nic nedělat };

          when others do verify({VERIFY=}000269,true);
          end case;

        -- typ báze 
        base:=t.getbase(curr);
        verify({VERIFY=}000270,not (base.stype in dts_ordinal));

        -- pro zjednodušení 
        sign:=base.stype=dt_signed;
        lval:=base.getlval;
        hval:=base.gethval;

        -- kontrola mezí prvků 
        if imm.citems.len>0 then
          for i in 0..imm.citems.len-1 loop
            -- načíst hodnotu prvku
            uniint_load(ui,imm.citems.items^[i*imm.citems.isize],imm.citems.isize,sign);

            -- kontrola mezí
            if ui<lval or ui>hval then
              ce^.seterror({CCERR=}000473,ce_numrange);
              {%%POS}
              {%%RESUME ce^.raiseerror;}
              ce^.resumeerror;
              end if;
            end loop;
          end if;

    -- agregát pole
    when ic_array do
        -- kontrola přetečení pole (stačí)
        imm_get_length(imm,length);
        if length>t.getrange(curr).getlength then
          ce^.seterror({VERIFY=}000888,ce_toomanyitems);
          ce^.resumeerror;
          end if;

        -- Tvrzení: Není třeba provádět žádné další kontroly
        -- Důkaz: Přímá hodnota typu agregát pole vznikne pouze překladem
        -- syntaktické kategorie Agregát.
        --   Je třeba kontrolovat ještě 2 podmínky:
        --     1) rozsah indexu ve vazbě položky,
        --     2) přípustnost konstantní hodnoty položky.
        -- Obě kontroly se provádějí během zpracování agregátu.

    -- agregát recordu
    when ic_record do
        -- Tvrzení: Není třeba provádět žádné kontroly
        -- Důkaz: analogicky jako pro agregát pole

    -- agregát množiny
    when ic_set do
        -- Tvrzení: Není třeba provádět žádné kontroly
        -- Důkaz: analogicky jako pro agregát pole

    -- NIL
    when ic_nil do { nic nedělat };

    when others do verify({VERIFY=}000267,true);
    end case;
  end imm_check;



----------------------------------------------------------------------------------------------------
procedure imm_get_length =
-- Délka znakového agregátu.
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_nil       do length:=ui_0;
    when ic_condensed do length:=unsigned_to_uniint(imm.citems.len);
    when ic_array     do
        if imm.aitems^.list=nil or else imm.aitems^.list^:length=0
          then length:=ui_0;
          else length:=imm.aitems^.list^[imm.aitems^.list^:length].hval-imm.aitems^.list^[1].lval+ui_1;
          end if;
    when others do verify({VERIFY=}000542,true);
    end case;
  end imm_get_length;


----------------------------------------------------------------------------------------------------
procedure imm_isnil =
-- True, je-li přímá hodnota NIL nebo NIL-ekvivalentní.
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_ordinal   do result:=imm.ui=ui_nil;
    when ic_real      do result:=imm.ur=ur_nil;
    when ic_nil       do result:=true;
    when ic_condensed do result:=imm.citems.len=0;
    when ic_array     do result:=(imm.aitems^.list=nil or else imm.aitems^.list^:length=0) and then imm_isnil(imm.aitems^.othersval);
    {%%X doplnit: LEN<>0 AND THEN imm_isnil(libovolna slozka) }
    when ic_record    do result:=(imm.ritems^.list=nil or else imm.ritems^.list^:length=0) and then imm_isnil(imm.ritems^.othersval);
    when ic_set       do result:=imm.sitems^.list=nil or else imm.sitems^.list^:length=0;
    {%%X doplnit: LEN<>0 AND THEN imm_isnil(libovolna slozka) }
--  when ic_relo      do result:=false;
    when others       do verify({VERIFY=}000261,true);
    end case;
  end imm_isnil;



----------------------------------------------------------------------------------------------------
procedure imm_isfullset =
-- True, je-li přímá hodnota ekvivalentní úplné množině.                      
----------------------------------------------------------------------------------------------------
begin
  case imm.ic
    when ic_set         do
        result:=imm.sitems^.list<>nil
                and then imm.sitems^.list^:length=1
                and then imm.sitems^.list^[1].lval=ptyp^.base.getctype()^.lval
                and then imm.sitems^.list^[1].hval=ptyp^.base.getctype()^.hval;
    when ic_nil         do result:=false;
    when others         do verify({VERIFY=}000454,true);
    end case;
  end imm_isfullset;



----------------------------------------------------------------------------------------------------
procedure imm_union =
-- Sjednocení dvou množin.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000455,A.ic not in timmclassset:[ic_set,ic_nil] or B.ic not in timmclassset:[ic_set,ic_nil]);

  -- vpravo je NIL => nic nedělat
  if imm_isnil(B) then return; end if;

  -- z NIL vlevo udělat množinu
  if A.ic=ic_nil then
    store_set(A);
    end if;

  -- prvky z B zahrnout do A
  for i in B.sitems^.list^:range loop
    if B.sitems^.list^[i].lval=B.sitems^.list^[i].hval
      then store_set_item(context,A,B.sitems^.list^[i].lval,false)
      else store_set_items_range(context,A,B.sitems^.list^[i].lval,B.sitems^.list^[i].hval,false);
      end if;
    end loop;
  end imm_union;



----------------------------------------------------------------------------------------------------
procedure imm_diff =
-- Rozdíl dvou množin.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000458,A.ic not in timmclassset:[ic_set,ic_nil] or B.ic not in timmclassset:[ic_set,ic_nil]);

  -- na jedné straně je NIL => nic nedělat
  if imm_isnil(A) or imm_isnil(B) then return; end if;

  -- prvky z B odstranit z A
  for i in B.sitems^.list^:range loop
    if B.sitems^.list^[i].lval=B.sitems^.list^[i].hval
      then cx_set.choice_remove_single(A.sitems^,B.sitems^.list^[i].lval)
      else cx_set.choice_remove_range(A.sitems^,B.sitems^.list^[i].lval,B.sitems^.list^[i].hval);
      end if;
    end loop;
  end imm_diff;



----------------------------------------------------------------------------------------------------
procedure imm_isect =
-- Průnik dvou množin.
----------------------------------------------------------------------------------------------------
var
    i              : t_unsigned;
    j              : t_unsigned;
    tmp            : tuniint;

begin
  verify({VERIFY=}001293,A.ic not in timmclassset:[ic_set,ic_nil] or B.ic not in timmclassset:[ic_set,ic_nil]);

  -- na jedné straně je NIL => výsledek je prázdná množina
  if imm_isnil(A) or imm_isnil(B) then
    store_set(A);
    return;
    end if;

  -- procházím oba seznamy intervalů a odřezávám z A ty části, které nejsou v B
  i:=1;
  j:=1;
  while i<=A.sitems^.list^:length loop
    -- najdi první podinterval z množiny B, který není před začátkem tohoto podintervalu
    while j<=B.sitems^.list^:length and then B.sitems^.list^[j].hval<A.sitems^.list^[i].lval loop
      succ j;
      end loop;

    -- Jaký je vzájemný vztah podintervalů?
    if j>B.sitems^.list^:length or else B.sitems^.list^[j].lval>A.sitems^.list^[i].hval
      then
        -- podinterval z A vůbec v B není => z A ho musíme odstranit
        if A.sitems^.list^[i].lval=A.sitems^.list^[i].hval
          then cx_set.choice_remove_single(A.sitems^,A.sitems^.list^[i].lval)
          else cx_set.choice_remove_range(A.sitems^,A.sitems^.list^[i].lval,A.sitems^.list^[i].hval);
          end if;

      else
        -- podintervaly se alespoň částečně překrývají => upravit?

        -- zkontrolovat levý okraj
        if B.sitems^.list^[j].lval>A.sitems^.list^[i].lval then
          -- interval v B začíná později => posunout levý okraj
          A.sitems^.list^[i].lval:=B.sitems^.list^[j].lval;
          end if;

        -- zkontrolovat pravý okraj
        if B.sitems^.list^[j].hval<A.sitems^.list^[i].hval then
          -- interval v B končí dřív => upravit pravý okraj
          -- pozor finta: abychom nemuseli řešit spoustu speciálních případů, prostě tenhle interval
          -- rozdělíme na dva -- ten shodný s B a zbytek. Shodný s B je OK, takže normálně pokračujeme
          -- zbytkem.
          tmp:=A.sitems^.list^[i].hval;
          A.sitems^.list^[i].hval:=B.sitems^.list^[j].hval;
          if A.sitems^.list^[i].hval+ui_2=tmp
            then store_set_item(context,A,tmp,false)
            else store_set_items_range(context,A,A.sitems^.list^[i].hval+ui_2,tmp,false);
            end if;
          end if;

        -- pokračovat dalším intervalem
        succ i;
        end if;
    end loop;
  end imm_isect;



----------------------------------------------------------------------------------------------------
procedure imm_cmp =
-- Porovnání dvou přímých hodnot.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_sym;

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        imm        : in timm_value) =            -- pravý operand
    -- Porovnání NIL = cokoliv.
    ------------------------------------------------------------------------------------------------
    begin
      case imm.ic
        when ic_ordinal   do cmp:=imm.ui=ui_nil;
        when ic_real      do cmp:=imm.ur=ur_nil;
        when ic_condensed do cmp:=imm.citems.len=0;
        when ic_array     do unimplemented({UNIMP=}000108);--cmp:=(imm2.aitems^.len=0) and (imm2.aitems^.othersval
        when ic_record    do unimplemented({UNIMP=}000109);--cmp:=imm2.ritems^.
        when ic_set       do unimplemented({UNIMP=}000137);
        when others       do verify({VERIFY=}000316,true);
        end case;
      case oper
        when cmp_eq     do { nic nedělat };
        when cmp_ne     do cmp:=not cmp;
        when others     do verify({VERIFY=}000317,true);
        end case;
      end cmpnil;



    ------------------------------------------------------------------------------------------------
    procedure array_step (
        paitems    : in pimm_array;              -- položky agregátu
        pval       : out pimm_value;             -- aktuální definiční hodnota položek
        bound      : in out tuniint;             -- pravá hranice aktuálního definičního rozsahu
        iter       : in out t_unsigned;          -- iterátor řetězce položkových definic
        at_end     : out t_logical) =            -- T-bylo dosaženo konce řetězce položkových def.
    -- Posunout hranici def. rozsahu v řetězci a určit aktuální definiční hodnotu položek.
    ------------------------------------------------------------------------------------------------
    begin
      -- nebylo dosaženo konce řetězce
      if paitems^.list<>nil and then iter<paitems^.list^:length
        -- přechod do položkové definice, či do mezery mezi nimi
        then
          -- další položka navazuje
          if bound=paitems^.list^[succ iter].lval-ui_1
        
            -- přejít na další položkovou definici
            then
              succ iter;
              pval:=^paitems^.list^[iter].val;
              bound:=paitems^.list^[iter].hval;

            -- přejít do mezery mezi položkovými definicemi
            else
              pval:=^paitems^.othersval;
              bound:=paitems^.list^[succ iter].lval-ui_1;
              end if;

        -- přechod na zarážku konce řetězce
        else
          pval:=^paitems^.othersval;
          at_end:=true;
          end if;
      end array_step;



    ------------------------------------------------------------------------------------------------
    procedure array_condensed_cmp (
        paitems    : in pimm_array;              -- definiční položky nekondenzovaného pole
        pcitems    : in pimm_condensed) =        -- prvky kondenzovaného pole
    -- Vyhodnotit porovnání =, <> nekondenzovaného a kondenzovaného pole.
    ------------------------------------------------------------------------------------------------
    var
      citer        : tuniint :=ui_0;             -- iterátor kondenzovaného pole
      cat_end      : t_logical := false;         -- příznak dosažení konce kondenzovaného. pole
      bound        : tuniint;                    -- hranice zkontrolovaných def. rozsahů nekond. pole
      iter         : t_unsigned := 0;            -- iterátor nekond. pole
      at_end       : t_logical := false;         -- příznak dosažení konce nekond. pole
      pval         : pimm_value;                 -- aktuální definiční hodnota položek nekond. pole
      leftmost     : tuniint;                    -- min. index polí
      rightmost    : tuniint;                    -- max. index polí
      a            : tuniint;                    -- hodnota položky kondenzovaného pole
      b            : tuniint;                    -- hodnota položky nekondenzovaného pole

    begin
      -- inicializovat hranice polí
      leftmost:=typ.getrange(context).getlval;
      rightmost:=typ.getrange(context).gethval;
      bound:=pred leftmost;

      -- porovnat prvky kondenzovaného pole
      -- se všemi odpovídajícími položkovými definicemi nek. pole
      loop
        -- v nekondenzovaném poli jsme pozadu
        if citer+leftmost>bound then
          -- posunout hranici nekond. pole, načíst hodnotu a z ní číslo
          array_step(paitems,pval,bound,iter,at_end);
          uniint_load(b,pval^.ui,pval^.ui:size,{%%X sign:}false);
          end if;

        -- zjistit hodnotu platnou pro index [i] kondenzovaného pole
        if citer<unsigned_to_uniint(pcitems^.len)

          -- nějaké prvky zbyly
          then
            -- načíst číslo z pole
            uniint_load(a,pcitems^.items^[uniint_to_unsigned(citer)*pcitems^.isize],pcitems^.isize,{%%X sign:}false);

          -- konec pole
          else
            -- zprava je kondenzované pole naplněno hodnotou [nil] => nastavit
            a:=ui_nil;
            cat_end:=true;

            -- přeskočit na poslední položku porovnávaného rozsahu
            citer:=bound-leftmost;
            end if;

        -- porovnat
        if a<>b then break; end if;

        -- další prvek
        succ citer;
        cmp:=(cat_end and at_end) or (citer+leftmost>rightmost);
        until cmp;

      -- požadován test na nerovnost => negovat [cmp]
      cmp xor (oper=cmp_ne);
      end array_condensed_cmp;



    ------------------------------------------------------------------------------------------------
    procedure set_inclusion (
        lop        : in timm_value;              -- levý operand
        rop        : in timm_value) =            -- pravý operand
    -- Vyhodnotit inkluzivní porovnávací operace <, <=.
    ------------------------------------------------------------------------------------------------
    var
      llen         : t_unsigned :=0;             -- délka seznamu rozsahů levého operandu
      li           : t_unsigned :=1;             -- iterátor seznamu rozsahů levého operandu
      rlen         : t_unsigned :=0;             -- délka seznamu rozsahů pravého operandu
      ri           : t_unsigned :=1;             -- iterátor seznamu rozsahů pravého operandu
      sharp        : t_logical :=false;          -- příznak ostré inkluze
      match        : t_logical;                  -- příznak inkluze aktuálního rozsahu
      ldiff        : tuniint;                    -- rozdíl levých hranic rozsahů
      rdiff        : tuniint;                    -- rozdíl pravých hranic rozsahů

    begin
      -- zjistit délky seznamů rozsahů operandů
      if lop.sitems^.list<>nil then
        llen:=lop.sitems^.list^:length;
        end if;

      if rop.sitems^.list<>nil then
        rlen:=rop.sitems^.list^:length;
        end if;

      -- pro každý rozsah levého operandu hledat rozsah v pravém op.,
      -- ve kterém je inkluzivně obsažen
      cmp:=true;
      while cmp and li<=llen loop
        match:=false;
        while ri<=rlen loop
          -- vypočítat rozdíly hranic aktuálních rozsahů
          ldiff:=lop.sitems^.list^[li].lval-rop.sitems^.list^[ri].lval;
          rdiff:=lop.sitems^.list^[li].hval-rop.sitems^.list^[ri].hval;

          -- aktuální rozsah levého operandu inkluzivně v aktuálním rozsahu pravého operandu
          match:=ldiff>=ui_0 and rdiff<=ui_0;
          if match then
            -- zaznamenat případnou ostrou inkluzi
            sharp or (ldiff<>ui_0 or rdiff<>ui_0);

            -- dosažen pravý okraj aktuálního rozsahu pravého operandu => posunout
            if rdiff=ui_0 then
              succ ri;
              end if;
                  
            -- přejít na další rozsah levého operandu
            break;
            end if;
                
          -- zaznamenat ostrou inkluzi
          sharp:=true;

          -- další rozsah pravého operandu
          succ ri;
          end loop;
              
        -- zaznamenat výsledek hledání inkluze aktuálního rozsahu levého operandu
        cmp and match;

        -- další rozsah levého operandu
        succ li;
        end loop;
            
      -- požadována ostrá inkluze => zkontrolovat
      cmp and (oper not in tcmpoperset:[cmp_gt,cmp_lt] or sharp);
      end set_inclusion;


var
  a                : tuniint;
  b                : tuniint; 
  i                : t_unsigned;

begin
  -- ordinální -- ordinální
  if (imm1.ic=ic_ordinal) and (imm2.ic=ic_ordinal) then
    case oper
      when cmp_eq do cmp:=imm1.ui=imm2.ui;
      when cmp_ne do cmp:=imm1.ui<>imm2.ui;
      when cmp_lt do cmp:=imm1.ui<imm2.ui;
      when cmp_le do cmp:=imm1.ui<=imm2.ui;
      when cmp_gt do cmp:=imm1.ui>imm2.ui;
      when cmp_ge do cmp:=imm1.ui>=imm2.ui;
      when others do verify({VERIFY=}000121,true);
      end case;

  -- reálné -- reálné
  elsif (imm1.ic=ic_real) and (imm2.ic=ic_real) then
    unimplemented({UNIMP=}000106);

  -- kondenzované pole -- kondenzované pole
  elsif (imm1.ic=ic_condensed) and (imm2.ic=ic_condensed) then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          if imm1.citems.len<>imm2.citems.len

            -- různé délky => je to jasné
            then cmp:=oper=cmp_ne

            -- stejné délky => zkoumat dál
            else
              -- porovnat
              i:=0;
              while i<imm1.citems.len loop
                -- načíst čísla
                uniint_load(a,imm1.citems.items^[i*imm1.citems.isize],imm1.citems.isize,{%%X sign:}false);
                uniint_load(b,imm2.citems.items^[i*imm2.citems.isize],imm2.citems.isize,{%%X sign:}false);

                -- porovnat
                if a<>b then break; end if;

                -- další prvek
                succ i;
                end loop;

              -- finta s xorem
              cmp:=(i=imm1.citems.len) xor (oper=cmp_ne);
              end if;

      -- <, <=, >, >=
      when cmp_lt,cmp_le,cmp_gt,cmp_ge do
          unimplemented({UNIMP=}000111);

      when others do verify({VERIFY=}000318,true);
      end case;

  -- nekondenzované pole -- nekondenzované pole
  elsif imm1.ic=ic_array and imm2.ic=ic_array then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          declare var
            bound1     : tuniint;                -- hranice zkontrolovaných def. rozsahů [imm1.aitems^.list]
            iter1      : t_unsigned :=0;         -- iterátor [imm1.aitems^.list]
            at_end1    : t_logical :=false;      -- příznak dosažení konce [imm1.aitems^.list]
            pval1      : pimm_value;             -- aktuální definiční hodnota položek [imm1]
            bound2     : tuniint;                -- obdobné sémantiky pro [imm2]
            iter2      : t_unsigned :=0;
            at_end2    : t_logical :=false;
            pval2      : pimm_value;
            rightmost  : tuniint;                -- max. index polí

          begin
            -- inicializovat hranice obou polí
            bound1:=pred typ.getrange(context).getlval;
            bound2:=bound1;
            rightmost:=typ.getrange(context).gethval;

            -- obě pole nebyla zkontrolována celá
            while not (bound1=rightmost and bound2=rightmost) loop
              -- v [imm1] jsme popředu => posunout hranici [imm2] a načíst hodnotu
              if bound1>bound2 then
                array_step(imm2.aitems,pval2,bound2,iter2,at_end2);

              -- v [imm2] jsme popředu => posunout hranici [imm1] a načíst hodnotu
              elsif bound2>bound1 then
                array_step(imm1.aitems,pval1,bound1,iter1,at_end1);

              -- v obou jsme zároveň => posunout hranice a načíst hodnoty obou
              else
                array_step(imm1.aitems,pval1,bound1,iter1,at_end1);
                array_step(imm2.aitems,pval2,bound2,iter2,at_end2);
                end if;
              
              -- konec [imm1] byl dosažen => nastavit hranici [imm1] na max.
              if at_end1 then
                bound1:=rightmost;
                end if;

              -- konec [imm2] byl dosažen => nastavit hranici [imm2] na max.
              if at_end2 then
                bound2:=rightmost;
                end if;

              -- testovat incidentní položky na nerovnost
              imm_cmp(pval1^,pval2^,cmp_ne,cmp,typ.getbase(context),context);

              -- agregáty si neodpovídají (alespoň v jedné položce)
              if cmp then
                break;
                end if;
              end loop;
            end declare;
    
          -- požadován test na rovnost => negovat [cmp]
          cmp xor oper=cmp_eq;

      -- <, <=, >, >=
      when cmp_lt,cmp_le,cmp_gt,cmp_ge do
          unimplemented({UNIMP=}000205);

      when others do verify({VERIFY=}000846,true);
      end case;

  -- pole -- kondenzované pole
  elsif (imm1.ic=ic_array) and (imm2.ic=ic_condensed) then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          array_condensed_cmp(imm1.aitems,^imm2.citems);

      -- <, <=, >, >=
      when cmp_lt,cmp_le,cmp_gt,cmp_ge do
          unimplemented({UNIMP=}000110);
      
      when others do verify({VERIFY=}000847,true);
      end case;

  -- kondenzované pole -- pole
  elsif (imm1.ic=ic_condensed) and (imm2.ic=ic_array) then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          array_condensed_cmp(imm2.aitems,^imm1.citems);

      -- <, <=, >, >=
      when cmp_lt,cmp_le,cmp_gt,cmp_ge do
          unimplemented({UNIMP=}000206);
      
      when others do verify({VERIFY=}000848,true);
      end case;

  -- record -- record
  elsif (imm1.ic=ic_record) and (imm2.ic=ic_record) then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          declare var
            srch   : tentitysearch;              -- hledátko
            len1   : t_unsigned :=0;             -- délka [imm1.ritems^.list]
            pval1  : pimm_value;                 -- hodnota položky v [imm1]
            len2   : t_unsigned :=0;             -- délka [imm2.ritems^.list]
            pval2  : pimm_value;                 -- hodnota položky v [imm2]
            ityp   : typeview;                   -- pohled na typ položky

          begin
            -- zjistit délky seznamů definic hodnot [imm1] a [imm2]
            if imm1.ritems^.list<>nil then
              len1:=imm1.ritems^.list^:length;
              end if;
            if imm2.ritems^.list<>nil then
              len2:=imm2.ritems^.list^:length;
              end if;

            -- hledat všechny položky záznamu v konstantách [imm1] a [imm2]
            srch.find_et_first(typ.getctype,rc_primary,et_var,tesearchflagset:[]);

            cmp:=true;
            while cmp and srch.psym<>nil loop
              -- vyhledat definici hodnoty položky v [imm1]
              i:=1;
              pval1:=^imm1.ritems^.othersval;
              while i<=len1 loop
                if imm1.ritems^.list^[i].item=srch.psym then
                  pval1:=^imm1.ritems^.list^[i].val;
                  break;
                  end if;
                succ i;
                end loop;

              -- vyhledat definici hodnoty položky v [imm2]
              i:=1;
              pval2:=^imm2.ritems^.othersval;
              while i<=len2 loop
                if imm2.ritems^.list^[i].item=srch.psym then
                  pval2:=^imm2.ritems^.list^[i].val;
                  break;
                  end if;
                succ i;
                end loop;

              -- sestavit pohled na typ položky
              ityp.init(context,pentity_var(srch.psym)^.typ.getctype);

              -- porovnat hodnoty odpovídající položkám
              imm_cmp(pval1^,pval2^,cmp_eq,cmp,ityp,context);

              -- najít další položku
              srch.find_et_next;
              end loop;
            end declare;

          --požadován test na nerovnost => negovat [cmp]
          cmp xor (oper=cmp_ne);

      -- <, <=, >, >=
      when cmp_lt,cmp_le,cmp_gt,cmp_ge do
          unimplemented({UNIMP=}000107);

      when others do verify({VERIFY=}000849,true);
      end case;

  -- množina -- množina
  elsif (imm1.ic=ic_set) and (imm2.ic=ic_set) then
    case oper
      -- =, <>
      when cmp_eq,cmp_ne do
          -- předpokládat různost
          cmp:=false;

          -- první množina neprázdná
          if imm1.sitems^.list<>nil then
            -- shodné délky seznamů rozsahů => je třeba porovnat
            if imm2.sitems^.list<>nil and then imm1.sitems^.list^:length=imm2.sitems^.list^:length then
              -- porovnat seznamy rozsahů
              cmp:=true;
              i:=1;
              while cmp and i<=imm1.sitems^.list^:length loop
                -- porovnat [i]-té rozsahy
                cmp:=imm1.sitems^.list^[i].lval=imm2.sitems^.list^[i].lval and imm1.sitems^.list^[i].hval=imm2.sitems^.list^[i].hval;
                succ i;
                end loop;
              end if;
          
          -- obě množiny jsou prázdné
          elsif imm2.sitems^.list=nil then
            cmp:=true;
            end if;
    
          -- požadován test na nerovnost => negovat [cmp]
          cmp xor (oper=cmp_ne);

      -- <, <=
      when cmp_lt,cmp_le do
          set_inclusion(imm1,imm2);

      -- >, >=
      when cmp_gt,cmp_ge do
          set_inclusion(imm2,imm1);

      when others do verify({VERIFY=}000850,true);
      end case;

  -- NIL -- NIL
  elsif (imm1.ic=ic_nil) and (imm2.ic=ic_nil) then
    case oper
      when cmp_eq do cmp:=true;
      when cmp_ne do cmp:=false;
      when others do verify({VERIFY=}000314,true);
      end case;

  -- NIL -- cokoliv
  elsif imm1.ic=ic_nil then cmpnil(imm2)

  -- cokoliv -- NIL
  elsif imm2.ic=ic_nil then cmpnil(imm1)

  else
    verify({VERIFY=}000315,true);
    end if;
  end imm_cmp;



----------------------------------------------------------------------------------------------------
procedure imm_concat_strings_assign =
-- Zřetězí konstantní řetězce. Neošetřuje případ aplikace operátoru & na komponentu,
-- tento případ je řešen zvlášť.
----------------------------------------------------------------------------------------------------
begin
  -- kondenzované -- kondenzované
  if imm1.ic=ic_condensed and imm2.ic=ic_condensed then
    -- levý operand ''
    if imm1.citems.len=0 then
      -- předat [imm1] hodnotu [imm2]
      imm1.citems.len:=imm2.citems.len;
      imm1.citems.items:=imm2.citems.items;

    -- pravý operand ''
    elsif imm2.citems.len=0 then
      -- nedělat nic

    -- je nutno alokovat nový buffer a kopírovat
    else
      declare var
        buffer     : p_unsigned8array;           -- nosič hodnoty kondenzovaného výsledku
        ui         : tuniint;                    -- pomocná proměnná
      begin
        -- alokovat nové nosné pole
        new buffer range (imm1.citems.len+imm2.citems.len)*imm1.citems.isize;

        -- konketenace
        verify({VERIFY=}000986,imm1.citems.isize<>imm2.citems.isize);
        for i in 0..imm1.citems.len-1 loop
          uniint_load(ui,imm1.citems.items^[i*imm1.citems.isize],imm1.citems.isize,false);
          uniint_store(ui,buffer^[i*imm1.citems.isize],imm1.citems.isize);
          end loop;
        for i in 0..imm2.citems.len-1 loop
          uniint_load(ui,imm2.citems.items^[i*imm1.citems.isize],imm1.citems.isize,false);
          uniint_store(ui,buffer^[(i+imm1.citems.len)*imm1.citems.isize],imm1.citems.isize);
          end loop;

        -- aktualizovat délku výsledku
        imm1.citems.len+imm2.citems.len;

        -- aktualizovat hodnotu výsledku
        imm1.citems.items:=buffer;
        end declare;
      end if;

  -- kondenzované -- nekondenzované
  elsif imm1.ic=ic_condensed and imm2.ic=ic_array then
    {%%TODO(CONCAT) dodělat}

  -- nekondenzované -- kondenzované
  elsif imm1.ic=ic_array and imm2.ic=ic_array then
    {%%TODO(CONCAT) dodělat}
  
  -- nekondenzované -- nekondenzované
  elsif imm1.ic=ic_array and imm2.ic=ic_array then
    {%%TODO(CONCAT) dodělat}

  -- cokoli jiného je chyba
  else
    verify({VERIFY=}000987,true);
    end if;
  end imm_concat_strings_assign;


{%%TODO(CONCAT)
----------------------------------------------------------------------------------------------------
procedure imm_concat_string_component_assign =
-- Zřetězí konstantní řetězec a komponentu.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(CONCAT) dodělat}
  end imm_concat_string_component_assign;



----------------------------------------------------------------------------------------------------
procedure imm_concat_components_assign =
-- Zřetězí konstantní komponenty do řetězce.
----------------------------------------------------------------------------------------------------
begin
  {%%TODO(CONCAT) dodělat}
  end imm_concat_components_assign;
}


end cx_imm;
