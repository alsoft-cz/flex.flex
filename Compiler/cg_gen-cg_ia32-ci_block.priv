----------------------------------------------------------------------------------------------------
module private ci_block =
-- Překladač Flexu.
-- Generování bloku příkazů.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_gc,
  cc_base,
  cc_base.cc_rtl,
  cc_base.cc_options,
  cc_attr,
  cx_expr,
  cx_expr.cx_def,
  cx_expr.cx_imm,
  cb_block,
  cb_block.cb_def,
  ci_code,
  ci_code.ci_rtl,
  ci_code.ci_instr,
  ci_code.ci_relo,
  ci_code.ci_operand,
  ci_code.ci_stack,
  ci_reg,
  ci_context,
  ci_expr,
  ci_fragment,
  cg_debug,
  cp_cpu.cp_32.cp_def,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_ia32.ci_instr;

type
  -- kontext příkazu
  iblcontext       = record
      xlevel       : t_unsigned;                 -- hloubka vnoření bloků begin..end
      end_loop     : itarget;                    -- návěští konce cyklu
      loop_level   : t_unsigned;                 -- hlobka vnoření cyklu
      end_block    : itarget;                    -- návěští konce bloku
      end_catch    : itarget;                    -- návěští konce catch bloku
      top_block    : itarget;                    -- návěští konce top-level bloku
      incatch      : t_logical;                  -- v části catch
      end record;

const
  -- nejvyšší blok begin..end
  xlevel_top       = 1;

----------------------------------------------------------------------------------------------------
procedure prepare_loop_context (
    context        : in iblcontext;              -- aktuální kontext příkazu
    newcontext     : out iblcontext;             -- kontext vnitřku cyklu
    end_loop       : in itarget) =               -- návěští konce cyklu
-- Připraví kontext pro generování vnitřku cyklu.
----------------------------------------------------------------------------------------------------
begin
  -- většinu údajů převzít
  newcontext:=context;

  -- zapamatovat si návěští konce cyklu
  newcontext.end_loop:=end_loop;

  -- zapamatovat si úroveň vnoření tohoto cyklu
  newcontext.loop_level:=newcontext.xlevel;
  end prepare_loop_context;



----------------------------------------------------------------------------------------------------
procedure assign_label_target (
    plabel         : in pentity_label;           -- zpracovávané návěští
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Pokud se tak již nestalo, tak do návěští doplní číslo návěští.
----------------------------------------------------------------------------------------------------
begin
  -- alokovat cíl skoku
  if plabel^.codegen=nil then
    -- alokovat paměť
    new picodegen_label(plabel^.codegen);
    c_garbage_collector.get_instance^.register_record(plabel^.codegen);

    -- doplnit návěští
    newtarget(info,picodegen_label(plabel^.codegen)^.target);
    end if;
  end assign_label_target;



----------------------------------------------------------------------------------------------------
procedure addjump (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o překladu
    cond           : in icond;                   -- podmínka skoku
    target         : in itarget;                 -- cíl skoku
    prediction     : in ijumpprediction := ijp_none) = -- predikce skoku
-- Přidá (ne)podmíněný relativní skok daný absolutní cílovou adresou.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addjump], která si sama připraví kontext výrazu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;

begin
  -- připravit prázdný kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skutečný [addjump]
  ci_instr.addjump(inst,info,context,cond,target,prediction);
  end addjump;



----------------------------------------------------------------------------------------------------
procedure addcallrtl (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o překladu
    rtl            : in t_rtl_entity;            -- volaný interní podprogram
    save_regs      : in t_logical:=false) =      -- ulozit nastaveni registru?
-- Přidá volání interního podprogramu.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addcallrtl], která si sama připraví kontext výrazu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;

begin
  -- připravit prázdný kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skutečný [addjump]
  ci_instr.addcallrtl(inst,info,context,rtl,save_regs);
  end addcallrtl;



----------------------------------------------------------------------------------------------------
procedure i_node (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblnode;                 -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo);           -- informace o průběhu generování
-- Generování kódu jednoho uzlu.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_sequence (
    curr           : in class tentity_code;      -- překládaný prvek
    list           : in bllist;                  -- první uzel sekvence
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu posloupnosti příkazů.
----------------------------------------------------------------------------------------------------
var
  bl               : pblnode;

begin
  bl:=list.first;
{
  -- doplnit záznam pro generování debug informací
  if bl<>nil then
    adddebuginfo(inst,dbt_sequence_,bl^.pos[bp_begin].b,nil);
    end if;
}
  while bl<>nil loop
    -- vygenerovat jeden uzel
    i_node(curr,bl,context,inst,info);

    -- další příkaz
    bl:=bl^.next;
    end loop;
  end i_sequence;



----------------------------------------------------------------------------------------------------
procedure i_cmd (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblcmd;                  -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu přiřazovacího příkazu.
----------------------------------------------------------------------------------------------------
begin
  -- vygenerovat příkaz
  i_gen_expr(inst,info,curr,bl^.expr);
  end i_cmd;



----------------------------------------------------------------------------------------------------
procedure i_break (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblbreak;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu BREAK.
----------------------------------------------------------------------------------------------------
begin
  -- není pro tuto entitu vyžadován složitější způsob návratu
  if (bl^.blevel>1) and (bl^.blevel>context.loop_level)

    -- ano => využít Return-control frame
    then
      -- vyplnit Return-control frame
      i_set_rcframe_action(inst,info,bl^.blevel-context.loop_level,context.end_loop);

      -- skok na koncové návěští bloku
      addjump(inst,info,ic_ucond,context.end_block{inst.rettarget});

    -- ne => přímo skok na konec cyklu
    else
     -- skok na návěští
     addjump(inst,info,ic_ucond,context.end_loop);
     end if;
  end i_break;



----------------------------------------------------------------------------------------------------
procedure i_return (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblreturn;               -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu RETURN.
----------------------------------------------------------------------------------------------------
begin
  -- není pro tuto entitu vyžadován složitější způsob návratu
  if bl^.blevel>1 then
    i_set_rcframe_action(inst,info,bl^.blevel-1,context.top_block);
    end if;

  -- skok na koncové návěští bloku
  addjump(inst,info,ic_ucond,context.end_block{inst.rettarget});
  end i_return;



----------------------------------------------------------------------------------------------------
procedure i_raise (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblraise;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu RAISE.
----------------------------------------------------------------------------------------------------
begin
  -- zaslání výjimky do jiného tasku
  if bl^.dest<>nil then
    unimplemented({UNIMP=}000103);

  -- zaslání nové výjimky do tohoto tasku
  elsif bl^.msg<>nil then
    -- zrušit starou výjimku
    if context.incatch then
      -- reset výjimky
      addcallrtl(inst,info,rtl_discard_exception);
      end if;

    -- sestavit informace o výjimce
    i_gen_expr(inst,info,curr,bl^.msg);

    if context.incatch

      -- je to náhrada právě ošetřované výjimky za jinou
      then
        -- nastavit novou výjimku
        addcallrtl(inst,info,rtl_set_exception);

        -- a udělat skok na konec bloku, tam už se to ošetří samo
        addjump(inst,info,ic_ucond,context.end_catch);

      -- je to normálně vyvolávaná výjimka
      else
        addcallrtl(inst,info,rtl_raise_exception);
        end if;

  -- re-raise existující výjimky v tomto tasku
  else
    -- stačí udělat skok na konec bloku, tam už se to ošetří samo
    addjump(inst,info,ic_ucond,context.end_catch);
    end if;
  end i_raise;



----------------------------------------------------------------------------------------------------
procedure i_send (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblsend;                 -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu SEND.
----------------------------------------------------------------------------------------------------
begin
  unimplemented({UNIMP=}000182);
  end i_send;



----------------------------------------------------------------------------------------------------
procedure i_goto (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblgoto;                 -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu GOTO.
----------------------------------------------------------------------------------------------------
begin
  -- doplnit číslo návěští
  assign_label_target(bl^.plabel,info);

  -- není pro tuto entitu vyžadován složitější způsob návratu
  if (bl^.blevel>1) and (bl^.blevel>bl^.plabel^.level)

    -- ano => využít Return-control frame
    then
      -- vyplnit Return-control frame
      i_set_rcframe_action(inst,info,bl^.blevel-bl^.plabel^.level,picodegen_label(bl^.plabel^.codegen)^.target);

      -- skok na koncové návěští bloku
      addjump(inst,info,ic_ucond,context.end_block);

    -- ne => přímo skok na konec cyklu
    else
     -- skok na návěští
     addjump(inst,info,ic_ucond,picodegen_label(bl^.plabel^.codegen)^.target);
     end if;
  end i_goto;



----------------------------------------------------------------------------------------------------
procedure i_new (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblnew;                  -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu NEW.
----------------------------------------------------------------------------------------------------
with
  cg_gen.cg_ia32.ci_fragment.ci_rta;

var
  ptyp             : pentity_type;               -- typ proměnné
  base             : pentity_type;               -- typ báze pointeru
  mastercontext    : iexprcontext;               -- kontext generování všech výrazů

    ------------------------------------------------------------------------------------------------
    procedure storertattrib (
        opvar      : in out c_operand;           -- proměnná
        rta        : in rtattrib;                -- ukládaný atribut
        oprtavalue : in c_operand) =             -- hodnota atributu
    -- Do pointeru uloží zadaný dynamický atribut (je-li to požadováno).
    ------------------------------------------------------------------------------------------------
    begin
      if rta in ptyp^.pattrib then
        declare var
          oprtaaddr: c_operand;                  -- adresa dynamického atributu
        begin
          -- obnovit registry
          opvar.refresh(inst,info,mastercontext);
          
          -- sestavit adresu atributu
          i_rta_load_address(inst,info,mastercontext,opvar,rta,oprtaaddr);

          -- přiřadit
          addii(inst,info,ii_mov,oprtaaddr,oprtavalue,op0);

          -- korekce pro :last - neomezené pole bázovat od nuly
          if rta=rta_last and then base<>nil and then base^.stype=dt_uarray then
            addii(inst,info,ii_dec,oprtaaddr,op0,op0);
            end if;

        leave
          -- uvolnit operand
          oprtaaddr.free(info,mastercontext);
          end declare;
        end if;
      end storertattrib;

var
  opvar            : c_operand;                  -- adresa proměnné

begin
  -- typ proměnné a báze pointeru
  ptyp:=bl^.xvar^.t.getctype;
  base:=ptyp^.base.getutype;

  -- pointer-to-object může obsahovat atributy :tag, :size a :last
  verify({VERIFY=}000444,ptyp^.pattrib-rtattribset:[rta_tag,rta_size,rta_last]<>rtattribset:[]);

  -- vytvořit kontext pro generování všech výrazů
  i_createcontext(mastercontext,lm_gen,nil);


  ---- (1) generování jména proměnné ----
  declare var
    subcontext     : iexprcontext;               -- kontext generování jednoho výrazu

  begin
    -- jak jsme na tom s atributy uloženými v pointeru ?
    if ptyp^.pattrib<>rtattribset:[]

      -- nějaké máme => při generování výrazu uložit adresu na stack a navíc vrátit
      then
        -- připravit kontext generování
        i_newcontext(mastercontext,subcontext,lm_push_and_load_addr,nil);

        -- jméno proměnné
        i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xvar,opvar);

        -- z registru odvodit adresní operand
        opvar.transform_imm_or_reg_to_mem(edt_pointer,unidata_size_to_unsigned(ptyp^.size));

        -- změnit módy načtení run-time atributů tak, aby popisovaly referencovaný objekt
        i_rta_set_modes_of_referenced_value(bl^.xvar,opvar);

      -- nemáme žádné => při generování výrazu jen uložit adresu na stack
      else
        declare var
          opnone   : c_operand;
          
        begin
          -- připravit kontext generování
          i_newcontext(mastercontext,subcontext,lm_push_addr,nil);

          -- jméno proměnné
          i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xvar,opnone);
          
        leave
          -- uvolnit nezajímavý výsledek
          opnone.free(info,mastercontext);
          end declare;
        end if;
    end declare;


  ---- (2) generování tagu ----
--  if rta_tag in ptyp^.pattrib then
  declare var
    oprtavalue     : c_operand;                  -- hodnota atributu

  begin
    -- máme k dispozici TAG ?
    if bl^.xtag<>nil

      -- ano => načíst dynamický tag
      then
        declare var
          subcontext : iexprcontext;             -- kontext generování jednoho výrazu

        begin
          -- načíst hodnotu
          i_newcontext(mastercontext,subcontext,lm_reg,nil);
          i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xtag,oprtavalue);
          end declare;

      -- ne => načíst statický tag (je-li k dispozici, jinak 0)
      else
        oprtavalue.create_imm(edt_unsigned,4,0);
        if base<>nil and then tf_tagged in base^.tflags then
          oprtavalue.set_relo_entity(base);
          end if;
        end if;

    -- uložit atribut :tag na stack
    addii(inst,info,ii_push,oprtavalue,op0,op0);

    -- uložit hodnotu atributu :tag do pointeru
    storertattrib(opvar,rta_tag,oprtavalue);

  leave
    -- uvolnit hodnotu atributu :tag
    oprtavalue.free(info,mastercontext);
    end declare;
--    end if;


  ---- (3) generování velikosti ----
  declare var
    oprtavalue     : c_operand;                  -- hodnota atributu

  begin
    -- máme k dispozici RANGE ?
    if bl^.xrange<>nil

      -- ano => vypočítat dynamickou velikost
      then
        declare var
          subcontext : iexprcontext;             -- kontext generování jednoho výrazu

        begin
          -- načíst hodnotu
          i_newcontext(mastercontext,subcontext,lm_reg_all,nil);
          i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xrange,oprtavalue);

          -- je to ^unconstrained array/string ?
          if base<>nil and then base^.stype in dts_unconstrained then
            -- uložit hodnotu atributu :last do pointeru
            storertattrib(opvar,rta_last,oprtavalue);

            -- vynásobit velikostí báze
            -- Ondra 16.5.2003 : Zde byl použit [subcontext]. Domnívám se, že to bylo špatně.
            i_gen_mul_reg(inst,info,mastercontext,oprtavalue,unidata_size_to_imm32(base^.base.getctype^.size));

            -- přičíst základní velikost objektu
            if base^.stype in dts_string then
              addopimm(inst,info,mastercontext,ii_add,oprtavalue,lstrisize32);
              end if;
            end if;
          end declare;

      -- ne => statická velikost
      else
        verify({VERIFY=}000445,base=nil or else base^.stype in dts_unconstrained);

        -- připravit velikost
        oprtavalue.create_imm(edt_unsigned,idefregsize,unidata_size_to_imm32(base^.size));
        end if;

    -- uložit atribut :size na stack
    addii(inst,info,ii_push,oprtavalue,op0,op0);

    -- uložit hodnotu atributu :size do pointeru
    storertattrib(opvar,rta_size,oprtavalue);

  leave
    -- uvolnit hodnotu atributu :size
    oprtavalue.free(info,mastercontext);
    end declare;


  ---- (4) vlastní alokace paměti ----

  -- %%TECH Nemusíme se vůbec zajímat o to, jestli to je či není třída, protože veškerou
  -- obsluhu případu alokace třídy již globální analýza rozvinula do sekvence pomocných
  -- příkazů umístěných v epilogu tohoto příkazu NEW.
{
  -- má počáteční hodnotu ?
  if base<>nil and then base^.init.isset and then not imm_is_nil(base^.init.getimm^)

    -- ano => alokovat a přiřadit
    then
}
      -- zavolat ALLOC
      addcallrtl(inst,info,rtl_alloc);
{
      -- přiřadit počáteční hodnotu
      unimplemented({UNIMP=}000191);

    -- ne => alokovat a inicializovat na NIL
    else
      -- zavolat ALLOC
      addcallrtl(inst,info,rtl_alloc{_and_fillz});
      end if;
}
leave
  -- uvolnit operand s proměnnou
  opvar.free(info,mastercontext);
  end i_new;



----------------------------------------------------------------------------------------------------
procedure i_adjust (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblnew;                  -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu ADJUST.
----------------------------------------------------------------------------------------------------
var
  ptyp             : pentity_type;               -- typ proměnné
  base             : pentity_type;               -- typ báze pointeru
  mastercontext    : iexprcontext;               -- kontext generování všech výrazů

    ------------------------------------------------------------------------------------------------
    procedure storertattrib (
        opvar      : in out c_operand;           -- proměnná
        rta        : in rtattrib;                -- ukládaný atribut
        oprtavalue : in c_operand) =             -- hodnota atributu
    -- Do pointeru uloží zadaný dynamický atribut (je-li to požadováno).
    ------------------------------------------------------------------------------------------------
    with
      cg_gen.cg_ia32.ci_fragment.ci_rta;

    begin
      if rta in ptyp^.pattrib then
        declare var
          oprtaaddr: c_operand;                  -- adresa dynamického atributu
        begin
          -- obnovit registry
          opvar.refresh(inst,info,mastercontext);

          -- sestavit adresu atributu
          i_rta_load_address(inst,info,mastercontext,opvar,rta,oprtaaddr);

          -- přiřadit
          addii(inst,info,ii_mov,oprtaaddr,oprtavalue,op0);

          -- korekce pro :last - neomezené pole bázovat od nuly
          if rta=rta_last and then base<>nil and then base^.stype=dt_uarray then
            addii(inst,info,ii_dec,oprtaaddr,op0,op0);
            end if;

        leave
          -- uvolnit operand
          oprtaaddr.free(info,mastercontext);
          end declare;
        end if;
      end storertattrib;

var
  opvar            : c_operand;                  -- adresa proměnné

begin
  -- typ proměnné a báze pointeru
  ptyp:=bl^.xvar^.t.getctype;
  base:=ptyp^.base.getutype;

  -- vytvořit kontext pro generování všech výrazů
  i_createcontext(mastercontext,lm_gen,nil);


  ---- (1) generování jména proměnné ----
  declare var
    subcontext     : iexprcontext;               -- kontext generování jednoho výrazu
    opnone   : c_operand;

  begin
    -- připravit kontext generování
    i_newcontext(mastercontext,subcontext,lm_push_addr,nil);

    -- jméno proměnné
    i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xvar,opnone);

  leave
    opnone.free(info,mastercontext);
    end declare;


  ---- (2) generování velikosti ----
  declare var
    oprtavalue     : c_operand;                  -- hodnota atributu

  begin
    -- vypočítat dynamickou velikost
    declare var
      subcontext : iexprcontext;                 -- kontext generování jednoho výrazu

    begin
      -- načíst hodnotu
      i_newcontext(mastercontext,subcontext,lm_reg_all,nil);
      i_load_subexpr(inst,info,subcontext,mastercontext,bl^.xrange,oprtavalue);

      -- uložit hodnotu atributu :last do pointeru
      storertattrib(opvar,rta_last,oprtavalue);

      -- je to ^unconstrained array/string ?
      if base<>nil then
        verify({VERIFY=}000788,base^.stype not in dts_index);

        -- vynásobit velikostí báze
        i_gen_mul_reg(inst,info,mastercontext,oprtavalue,unidata_size_to_imm32(base^.base.getctype^.size));

        -- přičíst základní velikost objektu
        if base^.stype in dts_string then
          addopimm(inst,info,mastercontext,ii_add,oprtavalue,lstrisize32);
          end if;
        end if;
      end declare;

    -- uložit hodnotu atributu :size do pointeru
    storertattrib(opvar,rta_size,oprtavalue);

    -- uložit atribut :size na stack
    addii(inst,info,ii_push,oprtavalue,op0,op0);

  leave
    -- uvolnit hodnotu atributu :size
    oprtavalue.free(info,mastercontext);
    end declare;


  ---- (3) vlastní realokace paměti ----
  -- zavolat ADJUST
  addcallrtl(inst,info,rtl_realloc);

leave
  -- uvolnit operand s proměnnou
  opvar.free(info,mastercontext);
  end i_adjust;



----------------------------------------------------------------------------------------------------
procedure i_discard (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pbldiscard;              -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu DISCARD.
----------------------------------------------------------------------------------------------------
var
  opnone           : c_operand;                  -- prázdný výsledek
  xcontext         : iexprcontext;               -- kontext výrazu

begin
  -- vytvořit kontext
  i_createcontext(xcontext,lm_push_addr,nil);

  -- jméno proměnné
  i_load_expr(inst,info,xcontext,bl^.xvar,opnone);

  -- zavolat FREE
  addcallrtl(inst,info,rtl_free);

leave
  -- uvolnit pomocný operand
  opnone.free(info,xcontext);
  end i_discard;



----------------------------------------------------------------------------------------------------
procedure i_delay (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pbldelay;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu DELAY.
----------------------------------------------------------------------------------------------------
begin
  unimplemented({UNIMP=}000183);
  end i_delay;



----------------------------------------------------------------------------------------------------
procedure i_if (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblif;                   -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu IF.
----------------------------------------------------------------------------------------------------
var
  sub              : pblif_cond;                 -- větev IF
  last             : itarget;                    -- cíl pro skok na konec
  next             : itarget;                    -- cíl pro skok na další variantu

begin
  -- alokovat návěští pro skok na konec skoku
  newtarget(info,last);

  -- vygenerovat všechny větve
  sub:=pblif_cond(bl^.sub.first);
  while sub<>nil loop
    verify({VERIFY=}000097,sub^.btype<>bt_if_cond);

    -- doplnit záznam pro generování debug informací
    adddebuginfo(inst.di,dbt_if,getaddr(inst),sub^.pos[bp_begin]{.b},nil);

    -- podmínka provedení
    if sub^.cond<>nil then
      -- alokovat návěští pro skok na konec větve
      newtarget(info,next);

      -- podmínka
      i_gen_cond(inst,info,curr,sub^.cond,tgfallthru,next);
      end if;

    -- sekvence příkazů
    i_sequence(curr,sub^.sub,context,inst,info);

    -- skok na konec
    if sub^.next<>nil then
      addjump(inst,info,ic_ucond,last);
      end if;

    -- dosadit cíl skoku na toto místo
    if sub^.cond<>nil then
      settarget(info,next,getaddr(inst));
      end if;

    -- další větev
    sub:=pblif_cond(sub^.next);
    end loop;

  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_end_if,getaddr(inst),bl^.pos[bp_end]{.b},nil);

  -- dosadit cíl skoku na toto místo
  settarget(info,last,getaddr(inst));
  end i_if;



----------------------------------------------------------------------------------------------------
procedure i_loop (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblloop;                 -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu LOOP.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iblcontext;                 -- nový kontext
  tgtop            : itarget;                    -- návěští: začátek cyklu
  tgbottom         : itarget;                    -- návěští: konec cyklu

begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_loop,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  -- alokovat návěští
  newtarget(info,tgtop);
  newtarget(info,tgbottom);
  settarget(info,tgtop,getaddr(inst));

  -- připravit nový kontext
  prepare_loop_context(context,newcontext,tgbottom);

  -- vygenerovat posloupnost příkazů
  i_sequence(curr,bl^.sub,newcontext,inst,info);

  if bl^.cond<>nil
    -- UNTIL
    then
      -- doplnit záznam pro generování debug informací
      adddebuginfo(inst.di,dbt_until,getaddr(inst),bl^.pos[bp_end]{.b},nil);

      -- vygenerovat podmínku
      i_gen_cond(inst,info,curr,bl^.cond,{cond=true=>}tgfallthru,{cond=false=>}tgtop);

    -- END LOOP
    else
      -- doplnit záznam pro generování debug informací
      adddebuginfo(inst.di,dbt_end_loop,getaddr(inst),bl^.pos[bp_end]{.b},nil);

      addjump(inst,info,ic_ucond,tgtop{addr});
      end if;

  -- dosadit cíl skoku na toto místo
  settarget(info,tgbottom,getaddr(inst));
  end i_loop;



----------------------------------------------------------------------------------------------------
procedure i_for (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblfor;                  -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu FOR.
----------------------------------------------------------------------------------------------------
var
  ophigh           : c_operand;                  -- horní mez
  opvar            : c_operand;                  -- proměnná
  tg_start         : itarget;                    -- návěští začátku cyklu
  tg_end           : itarget;                    -- návěští konce cyklu
  dynamicbound     : t_logical;                  -- jedna z mezí je dynamická
  highdynamic      : t_logical;                  -- horní mez je dynamická
  mastercontext    : iexprcontext;               -- top-level kontext generování výrazu
--xcontext         : iexprcontext;               -- kontext generování výrazu
--newcontext       : iblcontext;                 -- kontext pro generování těla cyklu
  bound_edtype     : t_elementary_data_type;     -- elementární typ meze rozsahu řídící proměnné

begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_for,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  -- %%X Režim CONCURRENT není implementován,
  -- generuje se stejný kód jako pro přímé pořadí

  -- připravit návěští
  newtarget(info,tg_start);
  newtarget(info,tg_end);

  -- vytvořit kontext pro generování všech výrazů
  i_createcontext(mastercontext,lm_gen,nil);

  -- určit elementární typ meze rozsahu řídící proměnné
  if bl^.for_var^.typ.getctype^.stype=dt_signed
    then bound_edtype:=edt_signed;
    else bound_edtype:=edt_unsigned;
    end if;

  declare var
    oplow          : c_operand;                  -- dolní mez

  begin
    -- implicitní meze
    if bl^.xrange=nil then
      -- dolní mez
      if bl^.order=bfo_reverse
        then oplow.create_imm(bound_edtype,0,uniint_to_imm32(bl^.for_var^.typ.getctype^.hval));
        else oplow.create_imm(bound_edtype,0,uniint_to_imm32(bl^.for_var^.typ.getctype^.lval));
        end if;

      -- horní mez
      if bl^.order=bfo_reverse
        then ophigh.create_imm(bound_edtype,0,uniint_to_imm32(bl^.for_var^.typ.getctype^.lval));
        else ophigh.create_imm(bound_edtype,0,uniint_to_imm32(bl^.for_var^.typ.getctype^.hval));
        end if;

      -- meze rozhodně nejsou dynamické
      dynamicbound:=false;
      highdynamic:=false;
      --u_nimplemented(129);

    -- konstruktor rozsahu
    elsif bl^.xrange^.ntype=nt_range then
      declare var
        xcontext   : iexprcontext;               -- kontext generování výrazu

      begin
        -- připravit kontext pro horní mez
        i_newcontext(mastercontext,xcontext,lm_temp_value,bl^.for_var^.typ.getctype);

        -- horní mez
        if bl^.order=bfo_reverse
          then i_load_subexpr(inst,info,xcontext,mastercontext,bl^.xrange^.sub,ophigh);
          else i_load_subexpr(inst,info,xcontext,mastercontext,bl^.xrange^.sub^.next,ophigh);
          end if;
        end declare;

      -- není horní mez dynamická ?
      highdynamic:=ophigh.optype<>io_imm;

      declare var
        xcontext   : iexprcontext;               -- kontext generování výrazu

      begin
        -- připravit kontext pro dolní mez
        i_newcontext(mastercontext,xcontext,lm_reg,bl^.for_var^.typ.getctype);

        -- dolní mez
        if bl^.order=bfo_reverse
          then i_load_subexpr(inst,info,xcontext,mastercontext,bl^.xrange^.sub^.next,oplow);
          else i_load_subexpr(inst,info,xcontext,mastercontext,bl^.xrange^.sub,oplow);
          end if;
        end declare;

      -- není jedna z mezí dynamická ?
      dynamicbound:=oplow.optype<>io_imm or ophigh.optype<>io_imm;

    -- typ
    elsif bl^.xrange^.nclass=nc_type then
      -- horní mez
      if bl^.order=bfo_reverse
        then ophigh.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.t.getctype^.lval));
        else ophigh.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.t.getctype^.hval));
        end if;

      -- dolní mez
      if bl^.order=bfo_reverse
        then oplow.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.t.getctype^.hval));
        else oplow.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.t.getctype^.lval));
        end if;

      -- meze rozhodně nejsou dynamické
      dynamicbound:=false;
      highdynamic:=false;
      --u_nimplemented(127);

    -- atribut (nepochybně dynamický)
    elsif bl^.xrange^.ntype=nt_attrib then
      verifyx({VERIFY=}000597,(pexpattrib(bl^.xrange)^.aclass<>atc_dynamic) or pexpattrib(bl^.xrange)^.ata not in tattractualset:[ata_string_range,ata_array_range],bl^.pos[bp_begin]);

      -- %%TECH Atribut nad dt_array (constrained pole) není ve skutečnosti dynamický, znamená to jenom,
      --        že toto pole bylo předáno pomocí class pointeru. Ale žádný potomek meze změnit nemůže,
      --        takže použijeme prostě konstanty.

      -- dolní mez
      case bl^.xrange^.sub^.t.stype
        when dt_string,dt_ustring do oplow.create_imm(bound_edtype,0,timm32(1));
        when dt_uarray            do oplow.create_imm(bound_edtype,0,timm32(0));
        when dt_array             do oplow.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.sub^.t.getctype^.srange.getctype^.lval));
        when others               do verifyx({VERIFY=}000598,true,bl^.pos[bp_begin]);
        end case;

      -- horní mez
      case bl^.xrange^.sub^.t.stype
        when dt_string,dt_ustring do i_load_subrtattrib(inst,info,mastercontext,curr,rta_length,bl^.xrange^.sub,bl^.order=bfo_reverse,ophigh);
        when dt_uarray            do i_load_subrtattrib(inst,info,mastercontext,curr,rta_last,  bl^.xrange^.sub,bl^.order=bfo_reverse,ophigh);
        when dt_array             do ophigh.create_imm(bound_edtype,0,uniint_to_imm32(bl^.xrange^.sub^.t.getctype^.srange.getctype^.hval));
        when others               do verifyx({VERIFY=}000599,true,bl^.pos[bp_begin]);
        end case;

      -- pro reverzní cyklus zaměnit operandy
      if bl^.order=bfo_reverse then
        -- zaměnit
        {%%TODO(ADJUST)}
        declare var
          optemp   : c_operand;
        begin
          optemp.clone(inst,info,mastercontext,oplow);
          oplow .replace(info,mastercontext,ophigh);
          ophigh.replace(info,mastercontext,optemp);
        leave
          optemp.free(info,mastercontext);
          end declare;

        -- patchnout velikost - v tomto případě se bude hodit i v konstantním operandu,
        -- jinako to při alokaci pomocného registru v NEWOPREG a pár řádků níže chcípne.
        ophigh.adjust_size(oplow.size);
        end if;

      -- horní mez je dynamická, pokud to není jenom constrained pole (viz výše)
      dynamicbound:=bl^.xrange^.sub^.t.stype<>dt_array;
      highdynamic:=dynamicbound and bl^.order<>bfo_reverse;

    -- nic jiného se zde nemůže objevit
    else
      verify({VERIFY=}000414,true)
      end if;

    declare var
      disp         : timm32;                     -- offset proměnné vzhledem k frame pointeru

    begin
      -- zjistit adresu proměnné
      getvaraddr(inst,info,bl^.for_var,disp);

      -- sestavit adresu proměnné (bude buď ve tvaru [EBP+ofs] nebo absolutní)
      opvar.create_memory_address_on_stack(inst,
            edtype_from_type(bl^.for_var^.typ.getctype),
            unidata_size_to_unsigned(bl^.for_var^.typ.getctype^.size),disp);
      end declare;

    -- nacpat dolní mez do proměnné
    addii(inst,info,ii_mov,opvar,oplow,op0);

  leave
    -- uvolnit dolní mez
    oplow.free(info,mastercontext);
    -- dolní mez už nebude potřeba
    -- %%X v tuto chvíli se to uvolní samo, do budoucna bude ale potřeba
    -- kontext generování výrazu udržovat globálně
    --i_free(info,xcontext,oplow);
    end declare;

  -- jedna z mezí je dynamická
  if dynamicbound then

    -- není dynamická právě horní mez ?
    if highdynamic

      -- horní mez je dynamická => přes registr
      then
        declare var
          optemp   : c_operand;                  -- pomocný operand
          xcontext : iexprcontext;               -- kontext generování výrazu

        begin
          -- připravit kontext pro generování FOR
          i_newcontext(mastercontext,xcontext,lm_gen,nil);

          -- pomocný registr
          optemp.create_new_register(inst,info,xcontext,bound_edtype,ophigh.size);

          -- načíst horní mez
          addii(inst,info,ii_mov,optemp,ophigh,op0);

          -- porovnat
          addii(inst,info,ii_cmp,opvar,optemp,op0);

        leave
          -- uvolnit pomocný registr
          optemp.free(info,xcontext);
          end declare;

      -- horní mez je statická => přímo
      else
        -- rovnou porovnat
        addii(inst,info,ii_cmp,opvar,ophigh,op0);
        end if;

    -- skok
    if bl^.order=bfo_reverse

      -- FOR s dekrementací
      then
        if bl^.for_var^.typ.getctype^.stype=dt_signed
          then addjump(inst,info,ic_l,tg_end{,ijp_not_taken});
          else addjump(inst,info,ic_b,tg_end{,ijp_not_taken});
          end if;

      -- FOR s inkrementací
      else
        if bl^.for_var^.typ.getctype^.stype=dt_signed
          then addjump(inst,info,ic_g,tg_end{,ijp_not_taken});
          else addjump(inst,info,ic_a,tg_end{,ijp_not_taken});
          end if;
        end if;
    end if;

  -- adresa začátku cyklu
  settarget(info,tg_start,getaddr(inst));

  -- vygenerovat tělo cyklu v samostatném kontextu
  declare var
    newcontext     : iblcontext;                 -- kontext pro generování těla cyklu

  begin
    -- připravit nový kontext
    prepare_loop_context(context,newcontext,tg_end);

    -- tělo cyklu
    i_sequence(curr,bl^.sub,newcontext,inst,info);
    end declare;

  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_end_loop,getaddr(inst),bl^.pos[bp_end]{.b},nil);

  -- porovnat řídící proměnnou s dynamickou horní mezí
  if highdynamic

    -- horní mez přes registr
    then
      declare var
        optemp     : c_operand;
        xcontext   : iexprcontext;               -- kontext generování výrazu

      begin
        -- připravit kontext pro porovnání s horní mezí
        i_newcontext(mastercontext,xcontext,lm_gen,nil);

        -- načíst hodnotu horní meze
        optemp.create_new_register(inst,info,xcontext,bound_edtype,ophigh.size);
        addii(inst,info,ii_mov,optemp,ophigh,op0);

        -- porovnat
        addii(inst,info,ii_cmp,opvar,optemp,op0);
      leave
        optemp.free(info,xcontext);
        end declare;

    -- přímo
    else
      addii(inst,info,ii_cmp,opvar,ophigh,op0)
      end if;

  -- skok ven z cyklu při dosažení horní meze
  addjump(inst,info,ic_e,tg_end{,ijp_not_taken});

  -- změnit řídící proměnnou
  if bl^.order=bfo_reverse
    -- dekrementovat
    then addii(inst,info,ii_dec,opvar,op0,op0)
    -- inkrementovat
    else addii(inst,info,ii_inc,opvar,op0,op0)
    end if;

  -- skok na začátek cyklu
  addjump(inst,info,ic_ucond,tg_start);

  -- adresa konce cyklu
  settarget(info,tg_end,getaddr(inst));

leave
  -- uvolnit všechny operandy
  ophigh.free(info,mastercontext);
  opvar.free(info,mastercontext);
  -- uvolnit operandy
  -- %%X Nevím, proř tady byly ty I_FREE, když XCONTEXT se každou chvíli vytváří nový
  --i_free(info,xcontext,ophigh);
  --i_free(info,xcontext,opvar);
  end i_for;



----------------------------------------------------------------------------------------------------
procedure i_while (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblwhile;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu WHILE.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iblcontext;                 -- nový kontext
  tgtop            : itarget;                    -- návěští: začátek cyklu
  tgbottom         : itarget;                    -- návěští: konec cyklu

begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_while,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  -- alokovat návěští
  newtarget(info,tgtop);
  newtarget(info,tgbottom);
  settarget(info,tgtop,getaddr(inst));

  -- připravit nový kontext
  prepare_loop_context(context,newcontext,tgbottom);

  -- vygenerovat podmínku
  i_gen_cond(inst,info,curr,bl^.cond,{cond=true=>}tgfallthru,{cond=false=>}tgbottom);

  -- vygenerovat posloupnost příkazů
  i_sequence(curr,bl^.sub,newcontext,inst,info);

  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_end_loop,getaddr(inst),bl^.pos[bp_end]{.b},nil);

  -- skok na začátek
  addjump(inst,info,ic_ucond,tgtop);

  -- dosadit cíl skoku na toto místo
  settarget(info,tgbottom,getaddr(inst));
  end i_while;



----------------------------------------------------------------------------------------------------
procedure i_case (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblcase;                 -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu CASE
----------------------------------------------------------------------------------------------------
type
  icasetglist      = array of record
      tg_jmp       : itarget;                    -- návěští skokové tabulky
      tg_do        : itarget;                    -- návěští obsluhy
      end record;

var
  blwhen           : pblwhen_c;                  -- větve CASE
  tg_end_case      : itarget;                    -- návěští pro skok na konec CASE
  tg_list          : ^icasetglist;               -- návěští jednotlivých větví
  tg_next          : itarget;                    -- návěští pro skok na další tabulku
  cnt              : t_unsigned;                 -- počet větví
  ptyp             : pentity_type;               -- typ řídícího výrazu

begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_case,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  -- bude potřeba typ řídícího výrazu
  ptyp:=bl^.expr^.t.getctype;

  ----- %%TECH Generování CASE ---------------------------------------------------------------------
  -- Používá se nejjednodušší možná metoda. Před začátkem CASE se vygeneruje
  -- kód pro rozskok na jednotlivé obsluhy. Předpokládá se, že výběry jsou
  -- v rámci jedné větve CASE vzestupně setříděny.
  -- Pro každou větev CASE jsou zapotřebí dvě návěští:
  --   -- skok na další skokové tabulky (pro první a poslední ne, ale...)
  --   -- skok na kód dané větve
  -- Pro celý case je navíc potřeba návěští na skok na konec.
  --------------------------------------------------------------------------------------------------

  ----- připravit návěští -----

  -- návěští pro skok na konec
  newtarget(info,tg_end_case);

  -- spočítat větve
  blwhen:=pblwhen_c(bl^.sub.first);
  cnt:=0;
  while blwhen<>nil loop
    succ cnt;
    blwhen:=pblwhen_c(blwhen^.next);
    end loop;
  verify({VERIFY=}000420,cnt=0);

  -- alokovat návěští
  new tg_list range cnt;
  for i in tg_list^:range loop
    newtarget(info,tg_list^[i].tg_jmp);
    newtarget(info,tg_list^[i].tg_do);
    end loop;

  ----- vypočítat řídící výraz -----
  declare var
    opexpr         : c_operand;                  -- hodnota řídícího výrazu
    xcontext       : iexprcontext;               -- kontext generování výrazu

  begin
    -- připravit kontext
    i_createcontext(xcontext,lm_reg_all,ptyp);

    -- načíst výraz do registru
    i_load_expr(inst,info,xcontext,bl^.expr,opexpr);

    ----- vygenerovat skokovou tabulku -----
    blwhen:=pblwhen_c(bl^.sub.first);
    for i in tg_list^:range loop
      -- doplnit záznam pro generování debug informací
      if o_is_option_by_entity(opt_extra_debug_information,info.entity^) then 
        adddebuginfo(inst.di,dbt_when,getaddr(inst),blwhen^.pos[bp_begin]{.b},nil);
        end if;

      -- návěští pro skok na tuto tabulku
      settarget(info,tg_list^[i].tg_jmp,getaddr(inst));

      case blwhen^.ctype

        -- seznam výběrů
        when bct_choice do
            -- zpracovat všechny optimalizované výběry
            for j in blwhen^.clist.list^:range loop
              if blwhen^.clist.list^[j].lval=blwhen^.clist.list^[j].hval

                -- jedna hodnota
                then
                  declare var
                    opchoice : c_operand;

                  begin
                    -- načíst hodnotu
                    opchoice.create_imm(opexpr.edtype,0,uniint_to_imm32(blwhen^.clist.list^[j].lval));

                    -- porovnat
                    addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                    -- při shodě skok na obsluhu
                    addjump(inst,info,ic_e,tg_list^[i].tg_do);

                    -- Ondra 12.9.2002 : Je-li to poslední větev, tak pro jistotu skok
                    -- na konec CASE. %%TODO(CASE) V takové situaci hlásit CONSTRAINT_ERROR.
                    if (i=tg_list^:last) and (j=blwhen^.clist.list^:length) then
                      addjump(inst,info,ic_ucond,tg_end_case);
                      end if;

                  leave
                    opchoice.free(info,xcontext);
                    end declare;

                -- rozsah hodnot
                else
                  declare var
                    opchoice : c_operand;

                  begin
                    -- načíst hodnotu dolní meze
                    opchoice.create_imm(opexpr.edtype,0,uniint_to_imm32(blwhen^.clist.list^[j].lval));

                    -- porovnat
                    addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                    -- je-li menší, tak skok na další skokovou tabulku
                    if i=tg_list^:last
                      -- z poslední větve se skáče na konec CASE (nemělo by nastat)
                      then tg_next:=tg_end_case
                      -- z ostatních na další
                      else tg_next:=tg_list^[i+1].tg_jmp;
                      end if;
                    if ptyp^.stype=dt_signed
                      then addjump(inst,info,ic_l,tg_next);
                      else addjump(inst,info,ic_b,tg_next);
                      end if;

                  leave
                    opchoice.free(info,xcontext);
                    end declare;

                  declare var
                    opchoice : c_operand;

                  begin
                    -- načíst hodnotu horní meze
                    opchoice.create_imm(opexpr.edtype,0,uniint_to_imm32(blwhen^.clist.list^[j].hval));

                    -- porovnat
                    addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                    -- je-li <=, skok na obsluhu
                    if ptyp^.stype=dt_signed
                      then addjump(inst,info,ic_le,tg_list^[i].tg_do);
                      else addjump(inst,info,ic_be,tg_list^[i].tg_do);
                      end if;

                  leave
                    opchoice.free(info,xcontext);
                    end declare;
                  end if;
              end loop;
  {
            -- připravit kontext
            i_createcontext(xcontext,lm_gen,ptyp);

            -- zpracovat všechny výběry
            for j in 1..blwhen^.list.lcount loop
              -- přímo jedna hodnota
              if blwhen^.list.list^[j]^.ntype=nt_imm then
                -- načíst hodnotu
                i_load_expr(inst,info,xcontext,blwhen^.list.list^[j],opchoice);

                -- porovnat
                addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                -- při shodě skok na obsluhu
                addjump(inst,info,ic_e,tg_list^[i].tg_do);

              -- konstantní rozsah
              elsif blwhen^.list.list^[j]^.ntype=nt_range then
                -- načíst hodnotu dolní meze
                i_load_expr(inst,info,xcontext,pexprange(blwhen^.list.list^[j])^.sub,opchoice);

                -- porovnat
                addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                -- je-li menší, tak skok na další skokovou tabulku
                if i=cnt
                  -- z poslední větve se skáče na konec CASE (nemělo by nastat)
                  then tg_next:=tg_end_case
                  -- z ostatních na další
                  else tg_next:=tg_list^[i+1].tg_jmp;
                if ptyp^.stype=dt_signed
                  then addjump(inst,info,ic_l,tg_next);
                  else addjump(inst,info,ic_b,tg_next);
                  end if;

                -- načíst hodnotu horní meze
                i_load_expr(inst,info,xcontext,pexprange(blwhen^.list.list^[j])^.sub^.next,opchoice);

                -- porovnat
                addii(inst,info,ii_cmp,opexpr,opchoice,op0);

                -- je-li <=, skok na obsluhu
                if ptyp^.stype=dt_signed
                  then addjump(inst,info,ic_le,tg_list^[i].tg_do);
                  else addjump(inst,info,ic_be,tg_list^[i].tg_do);
                  end if;

              -- jméno typu
              elsif blwhen^.list.list^[j]^.nclass=nc_type then
                unimplemented({UNIMP=}000130);

              else verify({VERIFY=}000789,true);
              end loop;
  }
        -- OTHERS
        when bct_others do
            -- přímo skok na obsluhu
            addjump(inst,info,ic_ucond,tg_list^[i].tg_do);

        when others do verify({VERIFY=}000421,true);
        end case;

      -- další větev
      blwhen:=pblwhen_c(blwhen^.next);
      end loop;

  leave
    -- uvolnit operand reprezentující výraz
    opexpr.free(info,xcontext);
    end declare;

  ----- vygenerovat obsluhy -----
  blwhen:=pblwhen_c(bl^.sub.first);
  for i in tg_list^:range loop
    -- návěští pro skok na tuto větev
    settarget(info,tg_list^[i].tg_do,getaddr(inst));

    -- kód
    i_sequence(curr,blwhen^.sub,context,inst,info);

    -- skok na konec CASE
    if i<tg_list^:last then addjump(inst,info,ic_ucond,tg_end_case); end if;

    -- další větev
    blwhen:=pblwhen_c(blwhen^.next);
    end loop;

  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_end_case,getaddr(inst),bl^.pos[bp_end]{.b},nil);

  -- cíl skoku na toto místo
  settarget(info,tg_end_case,getaddr(inst));

leave 
  -- uklid po sobe
  discard tg_list;
  end i_case;



----------------------------------------------------------------------------------------------------
procedure i_accept (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblaccept;               -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu ACCEPT
----------------------------------------------------------------------------------------------------
begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_accept,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  unimplemented({UNIMP=}000184);
  end i_accept;



----------------------------------------------------------------------------------------------------
procedure i_block (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblblock;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iblcontext;                 -- nový kontext

    ------------------------------------------------------------------------------------------------
    procedure set_end_target (
        target     : itarget) =
    -- Do NEWCONTEXT poznamená návěští pro skok na konec tohoto bloku.
    ------------------------------------------------------------------------------------------------
    begin
      -- přiřadit návěští pro skok na konec
      newcontext.end_block:=target;

      -- pokud jsme top-level blok, tak ještě nastavit návěští pro
      -- skok na náš konec, které se bude hodit v příkazech RETURN
      -- vnořených v dalších begin..end blocích
      if newcontext.xlevel=1 then
        newcontext.top_block:=target;
        end if;
      end set_end_target;

var
  xframe           : t_logical;                  -- T-je potřeba exceptionframe
  rcframe          : t_logical;                  -- T-je potřeba returun-control frame
--save_rcframe     : timm32;                     -- adresa nadřazeného return-control framu
  frame_handler    : timm32;                     -- offset položky HANDLER v exception-frame
  tg_catch         : itarget;                    -- návěští části CATCH
  tg_rollback      : itarget;                    -- návěští části ROLLBACK
  tg_commit        : itarget;                    -- návěští části COMMIT
  tg_leave         : itarget;                    -- návěští části LEAVE
  tg_final         : itarget;                    -- návěští END - finalizace
  tg_end           : itarget;                    -- návěští END - ret
  blwhen           : pblwhen_m;                  -- větev CATCH

begin
  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_block_begin,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

  -- připravit nový kontext
  newcontext:=context;
  succ newcontext.xlevel;
  newcontext.incatch:=false;

  -- zjistit, zda potřebujeme výjimky
  xframe:=bl^.bcatch.first<>nil or bl^.brollback.first<>nil or bl^.bcommit.first<>nil or bl^.bleave.first<>nil
          or ((newcontext.xlevel=xlevel_top or bl^.btype=bt_declare) and
          -- Ondra 2.7.2003 : Existence samotného inicializačního bloku není 
          -- postačující podmínkou pro vznik exception framu.
          ({bl^.binit.first<>nil or} bl^.bentry.first<>nil or bl^.bexit.first<>nil));
  verify({VERIFY=}000657,xframe and bl^.btype in bts_protected);

  -- zjistit, zda někdo uvnitř bude potřebovat return-control frame
  rcframe:={(newcontext.xlevel>xlevel_top) and} bl^.tra_outer or bl^.loc_outer {(bt_return in bl^.tra_cmd)};

  -- alokovat návěští
  newtarget(info,tg_catch);
  newtarget(info,tg_rollback);
  newtarget(info,tg_commit);
  newtarget(info,tg_leave);
  newtarget(info,tg_final);
  newtarget(info,tg_end);


  ---- Inicializace --------------------------------------------------------------------------------

  -- vytvořit exception frame
  if xframe then
    i_create_xframe(inst,info,frame_handler,tg_end);
    end if;

  -- vytvořit return-control frame (jen pro top-level blok)
  if rcframe and (newcontext.xlevel=xlevel_top) then
    i_create_rcframe(inst,info{,save_rcframe});
    end if;

  -- začátek bloku chráněného proti výjimkám z jiných tasků
  if bl^.btype in bts_protected then
    addcallrtl(inst,info,rtl_begin_sequential);
    end if;

  -- inicializace proměnných (volání entry)
  if newcontext.xlevel=xlevel_top or bl^.btype=bt_declare then
    -- v tuto chvíli je adresa obsluhy výjimky nastavena na RTL_END_XFRAME

    -- počáteční hodnoty proměnných
    i_sequence(curr,bl^.binit,context,inst,info);

    -- zavolat ENTRY
    if bl^.bentry.first<>nil then
      -- případná výjimka musí zavolat EXIT již inicializovaných tříd
      -- => změnit adresu obsluhy výjimky
      verify({VERIFY=}000399,not xframe);
      i_set_handler(inst,info,frame_handler,tg_final);

      -- vygenerovat
      i_sequence(curr,bl^.bentry,context,inst,info);
      end if;
    end if;



  ---- Příkazová část ------------------------------------------------------------------------------

  -- přiřadit návěští pro skok na konec tohoto bloku
  set_end_target(tg_commit);

  -- adresa obsluhy: CATCH
  if xframe then
    i_set_handler(inst,info,frame_handler,tg_catch);
    end if;

  -- příkazová část
  i_sequence(curr,bl^.sub,newcontext,inst,info);

  -- přeskočit CATCH a ROLLBACK
  if bl^.bcatch.first<>nil or bl^.brollback.first<>nil then
    addjump(inst,info,ic_ucond,tg_commit);
    end if;



  ---- Část CATCH ----------------------------------------------------------------------------------

  -- doplnit záznam pro generování debug informací
  if bl^.bcatch.first<>nil then
    adddebuginfo(inst.di,dbt_block_catch,getaddr(inst),bl^.bcatch_pos,nil);
    end if;

  -- adresa skoku na toto místo: CATCH
  settarget(info,tg_catch,getaddr(inst));

  -- část CATCH
  if bl^.bcatch.first<>nil then
    newcontext.incatch:=true;
    newcontext.end_catch:=tg_rollback;

    -- adresa obsluhy: ROLLBACK
    if xframe then
      i_set_handler(inst,info,frame_handler,tg_rollback);
      end if;

    declare var
      tg_catch_loop : itarget;                   -- návěští začátku cyklu obsluhy výjimek

    begin
      -- adresa skoku na toto místo: opakování catch
      newtarget(info,tg_catch_loop);
      settarget(info,tg_catch_loop,getaddr(inst));

      -- zpracovat všechny WHEN
      blwhen:=pblwhen_m(bl^.bcatch.first);
      while blwhen<>nil loop
        declare var
          tg_next_when : itarget;                  -- příští větev CATCH

        begin
          -- doplnit záznam pro generování debug informací
          if o_is_option_by_entity(opt_extra_debug_information,info.entity^) then 
            adddebuginfo(inst.di,dbt_when,getaddr(inst),blwhen^.pos[bp_begin]{.b},nil);
            end if;

          -- vygenerovat výběr
          case blwhen^.ctype
            -- výběr
            when bct_choice do
                declare var
                  tg_this_when : itarget;            -- tato větev CATCH

                begin
                  -- návěští pro přeskočení obsluhy
                  newtarget(info,tg_next_when);

                  -- návěští pro skok na tuto obsluhu
                  if blwhen^.list^:length>1 then 
                    newtarget(info,tg_this_when); 
                    end if;

                  -- testovat všechny výběry
                  for i in blwhen^.list^:range loop
                    -- vygenerovat číslo výjimky
                    i_load_message_code(inst,info,curr,blwhen^.list^[i]);

                    -- testovat
                    addcallrtl(inst,info,rtl_check_code);

                    -- neshoduje se => zkusit další obsluhu
                    if i<blwhen^.list^:length
                      then addjump(inst,info,ic_e,tg_this_when);
                      else addjump(inst,info,ic_ne,tg_next_when);
                      end if;
                    end loop;

                  -- cíl skoku na toto návěští
                  if blwhen^.list^:length>1 then 
                    settarget(info,tg_this_when,getaddr(inst)); 
                    end if;
                  end declare;

            -- OTHERS
            when bct_others do -- nic nedělat

            when others do verify({VERIFY=}000309,true);
            end case;

          declare var
            tg_end_when: itarget;                    -- návěští konce WHEN bloku

          begin
            -- alokovat návěští pro skok na konec tohoto WHEN bloku
            newtarget(info,tg_end_when);

            -- přiřadit návěští pro skok na konec tohoto bloku
            set_end_target(tg_end_when);

            -- vygenerovat obsluhu
            i_sequence(curr,blwhen^.sub,newcontext,inst,info);

            -- přiřadit návěští pro skok na konec tohoto WHEN bloku
            settarget(info,tg_end_when,getaddr(inst));
            end declare;

          -- reset výjimky
          addcallrtl(inst,info,rtl_discard_exception);

          -- je-li nahozená ještě nějaká výjimka, tak ji zpracovat
          addjump(inst,info,ic_ne,tg_catch_loop{,ijp_not_taken});

          -- skok na COMMIT
          addjump(inst,info,ic_ucond,tg_commit);

          -- skok na další větev CATCH nebo na ROLLBACK
          if blwhen^.ctype=bct_choice then
            settarget(info,tg_next_when,getaddr(inst));
            end if;
          end declare;

        -- další větev CATCH
        blwhen:=pblwhen_m(blwhen^.next);
        end loop;
      end declare;

    -- konec části CATCH
    newcontext.incatch:=false;
    newcontext.end_catch:=0;
    end if;



  ---- Část ROLLBACK -------------------------------------------------------------------------------

  -- doplnit záznam pro generování debug informací
  if bl^.brollback.first<>nil then
    adddebuginfo(inst.di,dbt_block_rollback,getaddr(inst),bl^.brollback_pos,nil);
    end if;

  -- adresa skoku na toto místo: ROLLBACK
  settarget(info,tg_rollback,getaddr(inst));

  -- část ROLLBACK
  if bl^.brollback.first<>nil then
    -- přiřadit návěští pro skok na konec tohoto bloku
    set_end_target(tg_leave);

    -- adresa obsluhy: LEAVE
    if xframe then
      i_set_handler(inst,info,frame_handler,tg_leave);
      end if;

    -- sekvence příkazů části ROLLBACK
    i_sequence(curr,bl^.brollback,newcontext,inst,info);

    -- přeskočit COMMIT
    if bl^.bcommit.first<>nil then
      addjump(inst,info,ic_ucond,tg_leave);
      end if;
    end if;



  ---- Část COMMIT -------------------------------------------------------------------------------

  -- doplnit záznam pro generování debug informací
  if bl^.bcommit.first<>nil then
    adddebuginfo(inst.di,dbt_block_commit,getaddr(inst),bl^.bcommit_pos,nil);
    end if;

  -- adresa skoku na toto místo: COMMIT
  settarget(info,tg_commit,getaddr(inst));

  -- část COMMIT
  if bl^.bcommit.first<>nil then
    -- přiřadit návěští pro skok na konec tohoto bloku
    set_end_target(tg_leave);

    -- adresa obsluhy: LEAVE
    if xframe then
      i_set_handler(inst,info,frame_handler,tg_leave);
      end if;

    -- sekvence příkazů části COMMIT
    i_sequence(curr,bl^.bcommit,newcontext,inst,info);
    end if;



  ---- Část LEAVE ----------------------------------------------------------------------------------

  -- doplnit záznam pro generování debug informací
  if bl^.bleave.first<>nil then
    adddebuginfo(inst.di,dbt_block_leave,getaddr(inst),bl^.bleave_pos,nil);
    end if;

  -- adresa skoku na toto místo: LEAVE
  settarget(info,tg_leave,getaddr(inst));

  -- část LEAVE
  if bl^.bleave.first<>nil then
    -- přiřadit návěští pro skok na konec tohoto bloku
    set_end_target(tg_final);

    -- adresa obsluhy: END - finalizace
    if xframe then
      i_set_handler(inst,info,frame_handler,tg_final);
      end if;

    -- sekvence příkazů části COMMIT
    i_sequence(curr,bl^.bleave,newcontext,inst,info);
    end if;



  ---- Finalizace ----------------------------------------------------------------------------------

  -- doplnit záznam pro generování debug informací
  adddebuginfo(inst.di,dbt_block_end,getaddr(inst),bl^.pos[bp_end],nil);

  -- adresa skoku na toto místo: END - finalizace
  settarget(info,tg_final,getaddr(inst));

  -- finalizace proměnných (volání exit)
  if (newcontext.xlevel=xlevel_top or bl^.btype=bt_declare) and bl^.bexit.first<>nil then
    -- doplnit záznam pro generování debug informací
    --adddebuginfo(inst.di,dbt_finalization_,getaddr(inst),bl^.pos[bp_begin].b,nil);

    -- adresa obsluhy: END - ret
    verify({VERIFY=}000398,not xframe);
    i_set_handler(inst,info,frame_handler,tg_end);

    -- zavolat EXIT
    i_sequence(curr,bl^.bexit,context,inst,info);
    end if;

  -- adresa skoku na toto místo: END - ret
  settarget(info,tg_end,getaddr(inst));

  -- konec bloku chráněného proti výjimkám z jiných tasků
  if bl^.btype in bts_protected then
    addcallrtl(inst,info,rtl_end_sequential);
    end if;

  -- zrušit exception-frame
  if xframe then
    -- zrušit exception-frame a šířit eventuální výjimku
    addcallrtl(inst,info,rtl_end_xframe);
    end if;

  -- provést akci podle return-control framu (kromě top-level bloku)
  if rcframe and (newcontext.xlevel>xlevel_top) then
    i_process_rcframe(inst,info,{save_rcframe,}context.end_block);
    end if;
  end i_block;



----------------------------------------------------------------------------------------------------
procedure i_label (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pbllabel;                -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu návěští.
----------------------------------------------------------------------------------------------------
begin
  -- doplnit záznam pro generování debug informací
  --adddebuginfo(inst.di,dbt_label_,getaddr(inst),bl^.pos[bp_begin].b,nil);

  -- doplnit číslo návěští
  assign_label_target(bl^.plabel,info);

  -- přidělit cíli skoku adresu
  settarget(info,picodegen_label(bl^.plabel^.codegen)^.target,getaddr(inst));
  end i_label;



----------------------------------------------------------------------------------------------------
procedure adjust_asm_op (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    oper           : in out c_operand) =         -- upravovaný operand instrukce
-- Upraví operand předaný inline assemblerem do použitelného tvaru.
----------------------------------------------------------------------------------------------------
with
  ci_asm;

begin
  case oper.optype
    -- nepoužitý operand -> konec
    when io_none do return;

    -- některé operandy jsou už dokončeny
    when io_reg, io_imm do return;

    -- adresa v paměti
    when io_mem  do case oper.relo_info.rtype
        -- nic
        when irt_none do -- nic nedělat

        -- symbol
        when irt_entity do
            case pentity(oper.relo_info.rentity)^.etype
              -- proměnná
              when et_var do
                  case pentity_var(oper.relo_info.rentity)^.mclass
                    -- automatická
                    when mc_auto do
                        -- %%X !! nebyl už bázový registr jednou uveden ?
                        -- (asi sotva, protože to mám v p_memory_address ošetřené parameterm no_base)
                        oper.shift_by_base_low_level(istackframereg[inst.frame]);

                        -- offset proměnné
                        declare var
                          disp : timm32;         -- offset proměnné vzhledem k frame pointeru
                        begin
                          getvaraddr(inst,info,pentity_var(oper.relo_info.rentity),disp);
                          oper.shift_displacement(imm32_to_signed{%%FLEX}(disp));
                          end declare;

                        -- operand je překonvertován -> změna typu
                        oper.clear_relo_low_level;

                    -- statická
                    when mc_static do
                        -- nic nedělat

                    when others do verify({VERIFY=}000198,true);
                    end case;

              when others do verify({VERIFY=}000197,true);
              end case;

        when others do verify({VERIFY=}000211,true);
        end case;

    -- cíl skoku
    when io_rel do case oper.relo_info.rtype
        -- nic
        when irt_none do -- nic nedělat

        -- symbol
        when irt_entity do
            case pentity(oper.relo_info.rentity)^.etype
              -- návěští
              when et_label do
                  -- doplnit číslo návěští
                  assign_label_target(pentity_label(oper.relo_info.rentity),info);

                  -- upravit operand
                  oper.set_target(picodegen_label(pentity_label(oper.relo_info.rentity)^.codegen)^.target);
                  oper.clear_relo_low_level;

              -- procedura
              when et_procedure, et_static do
                  -- nic nedělat

              when others do verify({VERIFY=}000627,true);
              end case;
        { % % FLEX
            -- pro OPER.LPOS musíme doplnit správný target
            oper.target:=piasmlabellist(oper.lpos)^.target^.iasml.target;
        }
        when others do verify({VERIFY=}000226,true);
        end case;

    when others do verify({VERIFY=}000195,true);
    end case;
  end adjust_asm_op;



----------------------------------------------------------------------------------------------------
procedure i_asm (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblasm;                  -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu inline assembleru.
----------------------------------------------------------------------------------------------------
with
  ci_asm;

var
  p                : piasmnode;                  -- položka seznamu instrukcí

begin
{
  -- všem návěštím přidělit cíl skoku
  p:=bl^.ifirst;
  while p<>nil loop
    -- je-li toto návěští, přiděl mu číslo cíle skoku
    if p^.ntype=ian_label then
      newtarget(info,piasmnode_label(p)^.target);
      end if;
    p:=p^.next;
    end loop;
}
  -- zpracovat všechny instrukce
  p:=bl^.ifirst;
  while p<>nil loop
    case p^.ntype
      -- návěští
      when ian_label do
          -- doplnit číslo návěští
          assign_label_target(piasmnode_label(p)^.plabel,info);

          -- cíli skoku přiřadit adresu
          settarget(info,picodegen_label(piasmnode_label(p)^.plabel^.codegen)^.target,getaddr(inst));

      -- instrukce assembleru
      when ian_instruction do
          -- doplnit záznam pro generování debug informací
          adddebuginfo(inst.di,dbt_asm,getaddr(inst),p^.pos{.b},nil);

          -- upravit operandy instrukce
          for i in piasmnode_instr(p)^.op:range loop
            adjust_asm_op(inst,info,piasmnode_instr(p)^.op[i]);
            end loop;

          -- pro skok na relativní adresu upravit první operand
          if iinstrinfo[piasmnode_instr(p)^.ii].kind=iik_jump and piasmnode_instr(p)^.op[1].optype=io_rel then
            -- pro skokové instrukce potřebujeme mít cíl skoku trochu jinde než je implicitně
            --piasmnode_instr(p)^.op[1].disptarget:=piasmnode_instr(p)^.op[1].target;

            -- upravit
            piasmnode_instr(p)^.op[1].adjust_relative_address_size(inst,info,iinstrinfo[piasmnode_instr(p)^.ii].cond);
            end if;

          -- prefix instrukce
          if piasmnode_instr(p)^.prefix<>ip_none then
            addip(inst,info,piasmnode_instr(p)^.prefix);
            end if;

          -- segmentový prefix
          if piasmnode_instr(p)^.segment<>ir_none then
            addip(inst,info,isegregtoprefix[piasmnode_instr(p)^.segment]);
            end if;

          -- přidat instrukci do kódu
          addii(inst,info,piasmnode_instr(p)^.ii,piasmnode_instr(p)^.op[1],piasmnode_instr(p)^.op[2],piasmnode_instr(p)^.op[3]);

      -- vložení sekvence bytů
      when ian_insert do
          -- doplnit záznam pro generování debug informací
          adddebuginfo(inst.di,dbt_asm,getaddr(inst),p^.pos{.b},nil);

          -- přidat do kódu sekvenci bytů
          addbytes(inst,info,piasmnode_insert(p)^.bytes^);

      -- cokoli ostatní je chyba
      when others do verify({VERIFY=}000224,true);
      end case;

    -- další instrukce
    p:=p^.next;
    end loop;
  end i_asm;



----------------------------------------------------------------------------------------------------
procedure i_simple (
    curr           : in class tentity_code;      -- překládaný prvek
    bl             : in pblsimple;               -- příkaz
    context        : in iblcontext;              -- aktuální kontext příkazu
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo) =          -- informace o průběhu generování
-- Generování kódu příkazu BREAK.
----------------------------------------------------------------------------------------------------
begin
  -- doplnit záznam pro generování debug informací
  case bl^.btype
    -- přiřazovací příkaz
    when bt_cmd         do adddebuginfo(inst.di,dbt_cmd,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz BREAK
    when bt_break       do adddebuginfo(inst.di,dbt_break,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz RETURN
    when bt_return      do adddebuginfo(inst.di,dbt_return,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz RAISE
    when bt_raise       do adddebuginfo(inst.di,dbt_raise,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz SEND
    when bt_send        do adddebuginfo(inst.di,dbt_send,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz GOTO
    when bt_goto        do adddebuginfo(inst.di,dbt_goto,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz NEW
    when bt_new         do adddebuginfo(inst.di,dbt_new,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz ADJUST
    when bt_adjust      do adddebuginfo(inst.di,dbt_adjust,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz DISCARD
    when bt_discard     do adddebuginfo(inst.di,dbt_discard,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- příkaz DELAY
    when bt_delay       do adddebuginfo(inst.di,dbt_delay,getaddr(inst),bl^.pos[bp_begin]{.b},nil);

    -- jiné příkazy tu nemají co dělat
    when others do verify({VERIFY=}000790,true);
    end case;

  -- vygenerovat prolog
  i_sequence(curr,bl^.bprolog,context,inst,info);

  -- vygenerovat kód
  case bl^.btype
    -- přiřazovací příkaz
    when bt_cmd         do i_cmd(curr,pblcmd(bl),context,inst,info);

    -- příkaz BREAK
    when bt_break       do i_break(curr,pblbreak(bl),context,inst,info);

    -- příkaz RETURN
    when bt_return      do i_return(curr,pblreturn(bl),context,inst,info);

    -- příkaz RAISE
    when bt_raise       do i_raise(curr,pblraise(bl),context,inst,info);

    -- příkaz SEND
    when bt_send        do i_send(curr,pblsend(bl),context,inst,info);

    -- příkaz GOTO
    when bt_goto        do i_goto(curr,pblgoto(bl),context,inst,info);

    -- příkaz NEW
    when bt_new         do i_new(curr,pblnew(bl),context,inst,info);

    -- příkaz ADJUST
    when bt_adjust      do i_adjust(curr,pblnew(bl),context,inst,info);

    -- příkaz DISCARD
    when bt_discard     do i_discard(curr,pbldiscard(bl),context,inst,info);

    -- příkaz DELAY
    when bt_delay       do i_delay(curr,pbldelay(bl),context,inst,info);

    -- jiné příkazy tu nemají co dělat
    when others do verify({VERIFY=}000791,true);
    end case;

  -- vygenerovat epilog
  i_sequence(curr,bl^.bepilog,context,inst,info);
  end i_simple;



----------------------------------------------------------------------------------------------------
procedure i_node =
-- Generování kódu jednoho uzlu.
----------------------------------------------------------------------------------------------------
label
  k1;

begin
  verifyx({VERIFY=}000025,(bl=nil) or (bl^.zprac<>bl^.zprac:last),bl^.pos[bp_begin]);

  -- vygenerovat kód
  case bl^.btype
    -- přiřazovací příkaz
    when bt_cmd         do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz BREAK
    when bt_break       do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz RETURN
    when bt_return      do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz RAISE
    when bt_raise       do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz SEND
    when bt_send        do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz GOTO
    when bt_goto        do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz NEW
    when bt_new         do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz ADJUST
    when bt_adjust      do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz DISCARD
    when bt_discard     do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz DELAY
    when bt_delay       do i_simple(curr,pblsimple(bl),context,inst,info);

    -- příkaz IF
    when bt_if          do i_if(curr,pblif(bl),context,inst,info);

    -- příkaz LOOP
    when bt_loop        do i_loop(curr,pblloop(bl),context,inst,info);

    -- příkaz FOR
    when bt_for         do i_for(curr,pblfor(bl),context,inst,info);

    -- příkaz WHILE
    when bt_while       do i_while(curr,pblwhile(bl),context,inst,info);

    -- příkaz CASE
    when bt_case        do i_case(curr,pblcase(bl),context,inst,info);

    -- příkaz ACCEPT
    when bt_accept      do i_accept(curr,pblaccept(bl),context,inst,info);

    -- blok příkazu
    when bt_block       do i_block(curr,pblblock(bl),context,inst,info);

    -- protected blok příkazu
    when bt_protected   do i_block(curr,pblblock(bl),context,inst,info);

    -- sekvenční blok příkazu
    when bt_sequential  do i_block(curr,pblblock(bl),context,inst,info);

    -- blok příkazů s lokálními deklaracemi
    when bt_declare     do i_block(curr,pbldeclare(bl),context,inst,info);

    -- návěští
    when bt_label       do i_label(curr,pbllabel(bl),context,inst,info);

    -- inline assembler
    when bt_asm         do i_asm(curr,pblasm(bl),context,inst,info);

    -- jiné symboly tu nemají co dělat
    when others do verify({VERIFY=}000026,true);
    end case;

k1:
  end i_node;



----------------------------------------------------------------------------------------------------
procedure i_gen_block =
-- Vygeneruje kód příkazové části symbolu.
----------------------------------------------------------------------------------------------------
with
  cc_binding,
  cg_gen.cg_ia32.ci_fragment.ci_frame;

var
  info             : igeninfo;                   -- informace o průběhu generování
  context          : iblcontext;                 -- kontext příkazu
  framehandler     : timm32;                     -- adresa položky HANDLER v exception-frame
  tg_endxframe     : itarget;                    -- návěští obsluhy neobsloužených výjimek

begin
  -- není co generovat
  -- %%X je tohle dobře ? a co inicializace lokálních proměnných ?
  if not curr.bl.isset then return; end if;

  -- připravit informace o generování
  initinfo(curr,info);

  -- připravit kontext
  context.xlevel:=0;

  -- doplnit záznam pro generování debug informací
  -- %%X k čemu je tahle debug informace ?
  if curr.bl.isset<>nil then
    adddebuginfo(inst.di,dbt_procedure,getaddr(inst),pblnode(curr.bl.getcblock)^.pos[bp_begin]{.b},nil);
    end if;

  -- entry sekvence
  i_gen_subprogram_prolog(curr,inst,info);

  -- prolog bootstrap kódu entrypointu z cizího světa
  if is_exported(^curr) and then inst.profile.call in iccs_entrypoint then
    declare var
      xcontext     : iexprcontext;               -- kontext výrazu
      
    begin  
      -- připravit prázdný kontext výrazu
      i_createcontext(xcontext,lm_gen,nil);
      
      -- vygenerovat vlastní prolog entrypointu
      i_gen_entrypoint_prolog(curr,inst,info,xcontext,framehandler,tg_endxframe,rtl_register_task_foreign,for do_initialize use false);
      end declare;
    end if;
  
  -- vygenerovat blok
  i_node(curr,curr.bl.getcblock,context,inst,info);

  -- epilog bootstrap kódu entrypointu z cizího světa
  if is_exported(^curr) and then inst.profile.call in iccs_entrypoint then
    i_gen_entrypoint_epilog(curr,inst,info,tg_endxframe,for do_finalize use false,for do_terminate use false);
    end if;

  -- exit sekvence
  i_gen_subprogram_epilog(curr,inst,info);

  -- vyhodnotit lokální relokace
  localresolve(curr,inst,info);
  end i_gen_block;



end ci_block;
