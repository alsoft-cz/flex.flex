----------------------------------------------------------------------------------------------------
module private ci_string =
-- Překladač Flexu.
-- Řetězcové operace.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.04.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  ci_expr.ci_rcheck;

----------------------------------------------------------------------------------------------------
procedure i_str_skip_length (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    expr           : in pexpnode;                -- související výraz
    op             : in c_operand) =             -- řetězec
-- Přeskočí atribut :length uložený v řetězci. [op] musí být [io_reg] nebo [io_mem].
----------------------------------------------------------------------------------------------------
begin
  -- pokud je operand konstanta typu univerzální pole, pak je uložena bez délky => nic neposouvat
  if expr^.ntype=nt_imm and t_is_stype(expr^.t,dt_uniarray) then
    return
    end if;

  -- posunout operand
  case op.optype
    when io_reg do addopimm(inst,info,context,ii_add,op,lstrisize32);
    when io_mem do op.shift_displacement(lstrisize32);
    when others do verify({VERIFY=}001024);
    end case;
  end i_str_skip_length;



type
  -- požadovaný tvar operandu s :length
  t_length_mode = enum
      lm_dont_care;                              -- je to fuk
      lm_direct_ecx;                             -- vždy načíst přímo do ECX
      lm_no_memory;                              -- vždy načíst libovolného registru
      lm_no_dependance;                          -- načíst jako adresu nezávislou na původním op.
      lm_address;                                -- načíst jako adresu obecně závislou na původním op.
      end enum;

----------------------------------------------------------------------------------------------------
procedure i_str_load_length (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    expr           : in pexpnode;                -- související podvýraz
    op             : in c_operand;               -- registr obsahující adresu řetězce
    oplength       : out c_operand;              -- :length řetězce
    length_mode    : in t_length_mode := lm_no_memory) = -- požadovaný tvar operandu s :length
-- Načte :length zadaného řetězce.
----------------------------------------------------------------------------------------------------
use
  supervised cx_expr,cx_expr.cx_rta;

begin
  -- %%X Úplně nejvíc by se mi líbilo, kdyby případ konstantního univerzálního pole uměl
  -- ošetřit přílo [i_rta_load], ale to by se do něj musel předávat související výraz, což
  -- představuje posun od současné koncepce.

  if expr^.ntype=nt_imm

    -- velikost konstantního stringu se odvodí z počtu prvků jeho hodnoty
    then
      declare var
        ui     : tuniint;

      begin
        -- zjistit délku konstantního agregátu
        imm_get_length(pexpimm(expr)^.imm,ui);

        -- sestavit operand
        case length_mode

          -- nacpat do ECX
          when lm_direct_ecx do
              -- alokovat ECX
              oplength.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

              -- uložit do něj konstantu
              addopimm(inst,info,context,ii_mov,oplength,uniint_to_imm32(ui));

          -- nacpat do nějakého registru
          when lm_no_memory do
              -- alokovat registr
              oplength.create_new_register(inst,info,context,edt_unsigned,4);

              -- uložit do něj konstantu
              addopimm(inst,info,context,ii_mov,oplength,uniint_to_imm32(ui));

          -- můžeme ponechat jako konstantu
          when others do
              oplength.create_imm(edt_unsigned,lstrisize32,uniint_to_imm32(ui));
          end case; 
        end declare;

    -- v ostatních případech si sáhneme pro dynamický atribut
    else
      declare var
        opmem  : c_operand;                  -- [<registr>]
        rta_modes : t_rtattrib_modes;        -- módy načtení run-time atributů

      begin
        -- připravit operand reprezentující hodnotu, který budeme moci modifikovat
        -- již reprezentuje hodnotu => stačí naklonovat
        if op.edtype in edts_value and op.optype=io_mem then 
          opmem.clone(inst,info,context,op);

        -- je to adresa v registru nebo přímá hodnota => změnit na paměťovou adresu
        elsif op.edtype=edt_address and op.optype in t_operand_type_set:[io_reg,io_imm] then 
          opmem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op);

        -- nic jiného neumíme
        else 
          verify({VERIFY=}001030);
          end if;

        -- nastavit správně módy run-time atributů
        cx_expr.cx_rta.x_rta_string_attributes(expr,rta_modes);
        opmem.set_rta_modes(rta_modes);

        -- načíst :length 
        case length_mode
          when lm_dont_care     do i_rta_load(inst,info,context,opmem,rta_length,oplength);
          when lm_direct_ecx    do i_rta_load(inst,info,context,opmem,rta_length,oplength,for no_memory use true,for pref_reg use in_ecx);
          when lm_no_memory     do i_rta_load(inst,info,context,opmem,rta_length,oplength,for no_memory use true);
          when lm_no_dependance do i_rta_load_address(inst,info,context,opmem,rta_length,oplength,for no_dependance use true);
          when lm_address       do i_rta_load_address(inst,info,context,opmem,rta_length,oplength);
          end case;

      leave
        -- uvolnit pracovní operand
        opmem.free(info,context);
        end declare;
      end if;
  end i_str_load_length;



----------------------------------------------------------------------------------------------------
procedure i_str_load_binary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    el             : in pexpnode;                -- levý podvýraz
    er             : in pexpnode;                -- pravý podvýraz
    op1            : out c_operand;              -- adresa levého řetězce v ESI
    op2            : out c_operand;              -- adresa pravého řetězce v EDI
    opecx          : in p_operand := nil;        -- volitelný operand pro rezervaci ECX
    op1length      : in p_operand := nil;        -- volitelný operand pro délku levého řetězce
    op2length      : in p_operand := nil;        -- volitelný operand pro délku pravého řetězce
    skip_length    : in t_logical := false;      -- T-upravit ESI a EDI tak, aby ukazovaly za :length
    direct_ecx     : in t_logical := false) =    -- T-pro délku levého operandu rovnou použít ECX
-- Načte adresy řetězců do ESI (levý operand) a EDI (pravý operand), popřípadě i jejich velikosti
-- do registrů. Jestliže je uveden parametr [opecx], rezervuje se před načtením délek registr ECX.
--   Je-li [direct_ecx] rovno True, pak se délka levého operandu uloží rovnou do ECX, délka pravého
-- operandu nemusí být nutně načtena do registru. Dále nesmí být nastaveno [opecx] a [skip_length].
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- načíst levý operand do ESI
  i_newcontext(context,newcontext,lm_addr,nil);
  i_setrpref(newcontext,in_esi,irm_addr);
  i_load(inst,info,newcontext,context,el,op1);

  -- načíst pravý operand do EDI
  i_newcontext(context,newcontext,lm_addr,nil);
  i_setrpref(newcontext,in_edi,irm_addr);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);

  -- redukovat počet registrů
  i_gen_reduceop(inst,info,context,op1);
  i_gen_reduceop(inst,info,context,op2);

  -- interní kontrola
  verify({VERIFY=}001022,op1.optype<>io_reg or else op1.reg.reg<>ir_esi);
  verify({VERIFY=}001023,op2.optype<>io_reg or else op2.reg.reg<>ir_edi);

  -- rezervovat ECX
  if opecx<>nil then
    verify({VERIFY=}001025,direct_ecx);
    opecx^.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
    end if;

  -- načíst délku levého řetězce do registru
  if op1length<>nil then
    if direct_ecx
      then i_str_load_length(inst,info,context,el,op1,op1length^,lm_direct_ecx);
      else i_str_load_length(inst,info,context,el,op1,op1length^);
      end if;
    end if;

  -- načíst délku pravého řetězce do registru
  if op2length<>nil then
    if direct_ecx
      then i_str_load_length(inst,info,context,er,op2,op2length^,for length_mode use lm_dont_care);
      else i_str_load_length(inst,info,context,er,op2,op2length^,for length_mode use lm_no_memory);
      end if;   
    end if;

  -- přeskočit :length uložené v řetězcích
  if skip_length then
    verify({VERIFY=}001027,direct_ecx);
    i_str_skip_length(inst,info,context,el,op1);
    i_str_skip_length(inst,info,context,er,op2);
    end if;
  end i_str_load_binary;



----------------------------------------------------------------------------------------------------
procedure i_str_load_single (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    expr           : in pexpnode;                -- levý podvýraz
    op             : out c_operand;              -- adresa řetězce
    pref_reg       : in iunireg := in_none;      -- preferovaný registr pro adresu řetězce
    oplast         : in p_operand := nil;        -- volitelný operand pro :last řetězce
    oplength       : in p_operand := nil;        -- volitelný operand pro délku řetězce
    skip_length    : in t_logical := false;      -- T-upravit adresu řetězce tak, aby ukazovala za :length
    length_mode    : in t_length_mode := lm_no_memory; -- požadovaný tvar operandu s :length
    preserve_ecx   : in t_logical := false) =    -- vyvarovat se použití ECX
-- Načte adresu řetězců, popřípadě i jeho :last a/nebo :length do registrů.
--   Je-li [direct_ecx] rovno True, pak se délka operandu uloží rovnou do ECX.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů
  opecx            : c_operand;                  -- rezervovaný registr ECX

    ------------------------------------------------------------------------------------------------
    procedure preserve_registers =
    -- Rezervuje registry, jejichž použití se máme vyvarovat.
    ------------------------------------------------------------------------------------------------
    begin
      -- není potřebat vyvarovat se použití ECX ?
      if preserve_ecx then
        verify({VERIFY=}001098,length_mode=lm_direct_ecx);
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
        end if;
      end preserve_registers;



    ------------------------------------------------------------------------------------------------
    procedure load_expr (
        mode       : iexprloadmode) =
    -- Načte operand.
    ------------------------------------------------------------------------------------------------
    begin
      -- načíst adresu levého operandu
      i_newcontext(context,newcontext,mode,nil);
      i_setrpref(newcontext,pref_reg,irm_addr);
      i_load(inst,info,newcontext,context,expr,op);

      -- obnovit registry
      op.refresh(inst,info,context);

      -- rezervovat registry, jejichž použití se máme vyvarovat
      preserve_registers;
      
      -- redukovat počet registrů
      i_gen_reduceop(inst,info,context,op);
      end load_expr;

begin
  -- způsob výpočtu adresy je do značné míry závislý na požadavku na atribut :last
  if oplast<>nil

    -- je požadován => zjištění adresy je dvoukrokové
    then
      -- načíst operand
      load_expr(i_get_load_mode_by_requested_rta(expr,rta_last,for addr_otherwise use true));

      -- načíst hodnotu :last
      i_rta_load(inst,info,context,op,rta_last,oplast^,for no_memory use true);

      -- donačíst adresu, je-li to potřeba
      i_gen_load_address_to_register_with_dereference(inst,info,context,op,for force_reg use pref_reg<>in_none,for pref_reg use pref_reg);

    -- není požadován => zjištění je jednoduché
    else 
      -- načíst operand
      load_expr(lm_addr);
      end if;

  -- interní kontrola
  if pref_reg<>in_none then 
    verify({VERIFY=}001029,op.optype<>io_reg or else iregtouni[op.reg.reg]<>pref_reg);
    end if;

  -- načíst atribut :length
  if oplength<>nil then
    i_str_load_length(inst,info,context,expr,op,oplength^,for length_mode use length_mode);
    end if;

  -- přeskočit :length uložené v řetězci
  if skip_length then
    verify({VERIFY=}001065,oplength<>nil and then op.depends_on(oplength^));
    i_str_skip_length(inst,info,context,expr,op);
    end if;

leave
  -- uvolnit případně rezervované registry
  opecx.free(info,context);
  end i_str_load_single;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_order_string =
-- Porovnávání řetězců (< <= > >=).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  rest             : typeview;                   -- společný typ operandů
  base             : pentity_type;               -- typ báze
  basesize         : t_unsigned32;               -- velikost báze řětězců
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000799,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost báze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- diskrétní báze -----
  if base^.stype in dts_ordinal then
    if basesize=1 or basesize=2 or basesize=4{%%TODO(SET) basesize in [1,2,4]}

      -- příznivá velikost báze => přes REPE CMPS
      then
        declare var
          el_uniarray : t_logical;               -- true, je-li levý operand konstanta typu univerzální pole
          er_uniarray : t_logical;               -- true, je-li pravý operand konstanta typu univerzální pole
          op1         : c_operand;               -- adresa levého řetězce v ESI
          op1length   : aliased c_operand;       -- počet prvků levého řetězce v registru
          op2         : c_operand;               -- adresa pravého řetězce v EDI
          op2length   : aliased c_operand;       -- počet prvků pravého řetězce v registru
          opecx       : aliased c_operand;       -- min(op1length,op2length) v ECX`

        begin
          -- není náhodou některý operand konstanta typu univerzální pole ?
          el_uniarray:=el^.ntype=nt_imm and t_is_stype(el^.t,dt_uniarray);
          er_uniarray:=er^.ntype=nt_imm and t_is_stype(er^.t,dt_uniarray);

          if el_uniarray or er_uniarray then
            -- %%X Pozor, součástí konstanty typu univerzální pole není informace o délce,
            -- což se musí zohlednit při zjišťování a porovnávání velikostí níže.
            -- Srovnej s procedurou I_GEN_OP_COMPARE_STRING.
            unimplemented({UNIMP=}000197);
            end if;

          -- načíst adresy obou operandů do ESI a EDI a provést nějaké další operace
          i_str_load_binary(inst,info,context,el,er,op1,op2,
              -- rezervovat ECX
              for opecx       use ^opecx,
              -- načíst velikost řetězce vlevo
              for op1length   use ^op1length,
              -- načíst velikost řetězce vpravo
              for op2length   use ^op2length,
              -- posunout pointery na řetězce, aby neukazovaly na :length
              for skip_length use true);

          -- do ECX dát přednostně velikost řetězce vlevo
          addii(inst,info,ii_mov,opecx,op1length,op0);

          -- porovnat velikosti řetězců
          addii(inst,info,ii_cmp,op1length,op2length,op0);

          -- el:length>er:length => ECX:=er:length
          addcmov(inst,info,context,ic_be,opecx,op2length);

          declare var
            tg_cmplength : itarget;              -- návěští pro skok na porovnání délek
            tg_end       : itarget;              -- návěští pro skok na konec porovnání
          begin
            -- alokovat návěští
            newtarget(info,tg_cmplength);
            newtarget(info,tg_end);

            -- ECX=0 => porovnání se redukuje na porovnání délek
            -- %%X neumím JECXZ
            addii(inst,info,ii_cmp,opecx,op_0,op0);
            addjump(inst,info,context,ic_e,tg_cmplength,{%%TODO(PREDICTION)}ijp_not_taken);

            -- shodit Direction Flag - porovnává se zdola nahoru
            addii(inst,info,ii_cld,op0,op0,op0);

            -- REPE CMPS
            addip(inst,info,ip_repe);
            case basesize
              when 1 do addii(inst,info,ii_cmpsb,op0,op0,op0);
              when 2 do addii(inst,info,ii_cmpsw,op0,op0,op0);
              when 4 do addii(inst,info,ii_cmpsd,op0,op0,op0);
              when others do verify({VERIFY=}000468,true);
              end case;

            -- je jednoznačně znám výsledek ? => skok na konec porovnání
            addjump(inst,info,context,ic_ne,tg_end);

            -- cíl skoku na toto místo
            settarget(info,tg_cmplength,getaddr(inst));

            -- porovnání se redukuje na porovnání délek řetězců
            addii(inst,info,ii_cmp,op1length,op2length,op0);

            -- cíl skoku na toto místo
            settarget(info,tg_end,getaddr(inst));
            end declare;

        leave
          -- uvolnit operandy
          op1.free(info,context);
          op1length.free(info,context);
          op2.free(info,context);
          op2length.free(info,context);
          opecx.free(info,context);
          end declare;

        -- výsledek
        vysl.create_condition(op2cc[expr^.oper,base^.stype=dt_signed]);

      -- nějaká nestandardní velikost báze
      else
        unimplemented({UNIMP=}000148);
        end if;

  ----- reálná báze -----
  elsif base^.stype in dts_float then
    unimplemented({UNIMP=}000149);

  -- jiné typy báze nelze porovnávat
  else 
    verify({VERIFY=}000467,true);
    end if;
  end i_gen_op_order_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_string =
-- Porovnávání řetězců (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : in pexpnode) =
    -- Porovná zadaný uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      op1          : c_operand;                  -- řetězec
      op1length    : aliased c_operand;          -- jeho :length
      newcontext   : iexprcontext;               -- kontext podvýrazů

    begin
      -- adresa levého operandu
      i_str_load_single(inst,info,context,x,op1,
          -- načíst délku řetězce
          for oplength    use ^op1length,
          -- tvar, v jaké délku dostaneme, nás vůbec nezajímá
          for length_mode use lm_dont_care);

      -- do :length nacpat nulu, tím se řetězec vyprázdní
      addii(inst,info,ii_cmp,op1length,op_0,op0);

      -- výsledek
      vysl.create_condition(op2cc[expr^.oper,false]);

    leave
      -- uvolnit operandy
      op1.free(info,context);
      op1length.free(info,context);
      end cmpnil;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  rest             : typeview;                   -- společný typ operandů
  base             : pentity_type;               -- typ báze
  basesize         : t_unsigned32;               -- velikost báze řětězců
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000800,expr^.arity<>eoa_2 or expr^.oper not in expopertypeset:[op_eq,op_ne]);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost báze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- (non)ekvivalence s prázdným řetězcem zleva -----
  if x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s prázdným řětězcem zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecných řetězců -----
  else
    verify({VERIFY=}000624,el^.ntype=nt_imm);

    declare var
      op1          : c_operand;                  -- adresa levého řetězce v ESI
      op1length    : aliased c_operand;          -- počet prvků levého řetězce v registru
      op2          : c_operand;                  -- adresa pravého řetězce v EDI
      op2length    : aliased c_operand;          -- počet prvků pravého řetězce v registru
      tg_end       : itarget;                    -- návěští pro skok na konec porovnání

    begin
      -- %%X Optimalizace: Když je velikost báze rovna LSTRISIZE32, tak nemusím
      -- zvlášť testovat shodnost délek - stačí udělat INC ECX a REPE CMPS

      -- %%X Pozor ! Pro některé typy báze řetězce se to musí dělat jinak
      if base^.stype not in dts_ordinal then
        unimplemented({UNIMP=}000166);
        end if;

      -- načíst adresy obou operandů do ESI a EDI a provést nějaké další operace
      i_str_load_binary(inst,info,context,el,er,op1,op2,
          -- načíst velikost řetězce vlevo
          for op1length   use ^op1length,
          -- načíst velikost řetězce vpravo
          for op2length   use ^op2length,
          -- velikost levého operandu načíst do ECX
          for direct_ecx  use true);

      -- alokovat návěští
      newtarget(info,tg_end);

      -- porovnat velikosti řetězců
      addii(inst,info,ii_cmp,op1length,op2length,op0);

      -- jsou rozdílné ? => pak je porovnání hotové
      addjump(inst,info,context,ic_ne,tg_end,{%%TODO(PREDICTION)}ijp_taken);

      -- Nyní jsou jistě délky řetězců shodné (Zero Flag=0). Původně jsem toho
      -- chtěl využít, abych nemusel ještě testovat ECX na nulu, jenže počet
      -- prvků řetězce se za chvíli bude násobit velikostí báze a tato operace
      -- může ZF změnit.

      -- porovnat ECX na nulu
      addii(inst,info,ii_cmp,op1length{opecx},op_0,op0);
      addjump(inst,info,context,ic_e,tg_end,{%%TODO(PREDICTION)}ijp_not_taken);

      -- posunout pointery na začátky datových částí
      i_str_skip_length(inst,info,context,el,op1);
      i_str_skip_length(inst,info,context,er,op2);

      declare var
        ii         : iinstr;                     -- zvolená porovnávací instrukce
        imm        : timm32;                     -- délka operandu ve slovech

      begin
        -- zvolit, jak budeme porovnávat (podle velikosti báze)
        -- dělitelné 4 ? => po čtveřicích
        if basesize mod 4=0 then
          ii:=ii_cmpsd;
          imm:=unsigned_to_imm32(basesize div 4);
        -- dělitelné 2 ? => po dvojicích
        elsif basesize mod 2=0 then
          ii:=ii_cmpsw;
          imm:=unsigned_to_imm32(basesize div 2);
        -- musíme po bytech
        else
          ii:=ii_cmpsb;
          imm:=unsigned_to_imm32(basesize);
          end if;

        -- vynásobit počet prvků řetězce reziduem velikosti báze
        i_gen_mul_reg(inst,info,context,op1,imm);

        -- shodit Direction Flag - porovnává se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- REPE CMPS
        addip(inst,info,ip_repe);
        addii(inst,info,ii,op0,op0,op0);
        end declare;

      -- a tím by to mělo být hotovo

      -- cíl skoku na toto místo
      settarget(info,tg_end,getaddr(inst));

    leave
      -- uvolnit operandy
      op1.free(info,context);
      op1length.free(info,context);
      op2.free(info,context);
      op2length.free(info,context);
      end declare;

    -- výsledek
    vysl.create_condition(op2cc[expr^.oper,false]);
    end if;
  end i_gen_op_compare_string;



----------------------------------------------------------------------------------------------------
procedure i_str_append_all (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    ptyp           : in pentity_type;            -- typ výsledného řetězce
    op1            : in c_operand;               -- adresa cílového řetězce v EDI
    op1length      : in c_operand;               -- :length cílového řetězce
    op1last        : in c_operand;               -- :last cílového řetězce
    first_expr     : in pexpnode;                -- první připojovaný řetězec
    do_assign      : in t_logical) =             -- T-do levého operandu se bude přiřazovat
-- Na konec zadaného řetězce připojí všechny řetězce počínaje zadaným operandem [er].
-- Jestliže je nastaven příznak [do_assign], tak do cílového operandu zřetězení přiřadí nikoli
-- přiřetězí. :length cílového řetězce na začátku vynuluje.
----------------------------------------------------------------------------------------------------
var
  er               : pexpnode;                   -- pravý podvýraz
  opremaining      : c_operand;                  -- čítač zbývajícího místa v řetězci
  base_size        : t_unsigned32;               -- velikost báze řetězce

    ------------------------------------------------------------------------------------------------
    procedure adjust_target_length (
        oplen      : in c_operand) =             -- velikost, o kterou se řetězec prodlužuje
    -- Prodlouží :length cílového řetězce o zadanou hodnotu. Generuje run-time check.
    ------------------------------------------------------------------------------------------------
    begin
      -- aktualizovat čítač zbývajícího místa v řetězci
      addii(inst,info,ii_sub,opremaining,oplen,op0);

      -- run-time check velikosti cílového řetězce
      -- %%TODO(DYNAMIC_CHECK) Generovat pouze pokud si to vyžádá vyšší vrstva
      i_gen_rcheck_constraint_error_on_condition(inst,info,context,ic_c);

      -- aktualizovat :length levého operandu (v registru)
      addii(inst,info,ii_add,op1length,oplen,op0);
      end adjust_target_length;

begin
  -- předvypočítat velikost báze řětězce
  base_size:=unidata_size_to_unsigned(ptyp^.base.getctype^.size);

  -- shodit Direction Flag - kopíruje se zdola nahoru
  addii(inst,info,ii_cld,op0,op0,op0);


  ----- (1) jedná-li se o přiřazení, tak vyprázdnit řetězec vlevo -----
  if do_assign then
    addii(inst,info,ii_mov,op1length,op_0,op0);
    end if;


  ----- (2) připravit čítač zbývajícího místa v řetězci -----
  -- alokovat dočasnou proměnnou
  opremaining.create_temporary(inst,info,edt_unsigned,4);

  -- pro začátek do ní přiřadit maximální velikost řetězce
  addii(inst,info,ii_mov,opremaining,op1last,op0);

  -- :last od této chvíle už nebude potřeba
  op1last.free(info,context);

  -- a není-li to přiřazení, tak nezapomenout odečíst již obsazenou část řetězce
  if not do_assign then
    i_gen_simple_op(inst,info,context,ii_sub,opremaining,op1length);
    end if;


  ----- (3) posunout pointer na začátek volné oblasti -----
  if not do_assign then
    declare var
      optemp1      : c_operand;                  -- pracovní operand pro mezivýsledek
      optemp2      : c_operand;                  -- pracovní operand pro velikost báze

    begin       
      -- vypočítat :length*:base:size
      optemp1.create_new_register(inst,info,context,edt_unsigned,4);
      optemp2.create_imm(edt_unsigned,0,base_size);
      addii(inst,info,ii_imul,optemp1,op1length,optemp2);

      -- posunout pointer na začátek volného místa
      verify({VERIFY=}001097,op1.optype<>io_reg);
      i_gen_simple_op(inst,info,context,ii_add,op1,optemp1);

    leave
      -- uvolnit pracovní operandy
      optemp1.free(info,context);
      optemp2.free(info,context);
      end declare;
    end if;


  ----- (4) vygenerovat připojení všech operandů -----
  er:=first_expr;
  loop
    -- vygenerovat zřetězení této komponenty
    case er^.concatkind
      -- podřetězec
      when nck_substring do
          declare var
            op2       : c_operand;               -- pravý operand: ESI
            op2length : aliased c_operand;       -- :length pravého operandu

          begin
            -- načíst adresu pravého operandu do ESI
            i_str_load_single(inst,info,context,er,op2,in_esi,
                -- načíst velikost řetězce vpravo
                for oplength    use ^op2length,
                -- velikost řetězce načíst do ECX
                for length_mode use lm_direct_ecx,
                -- posunout pointer na řetězec, aby neukazoval na :length
                for skip_length use true);

            -- obnovit operandy
            op1.refresh(inst,info,context);
            op1length.refresh(inst,info,context);
            op2.refresh(inst,info,context);
            op2length.refresh(inst,info,context);

            -- aktualizovat délku cílového řetězce
            adjust_target_length(op2length);

            -- vlastní přesun dat
            i_gen_movsd_array(inst,info,context,op2,op1,op2length,base_size);

          leave
            -- uvolnit operandy
            op2.free(info,context);
            op2length.free(info,context);
            end declare;

      -- podpole
      when nck_subarray do
          unimplemented({UNIMP=}000272);

      -- komponenta
      when nck_component do
          -- aktualizovat délku cílového řetězce
          adjust_target_length(op_1);

          -- nemá báze příznivou velikost ?
          if base_size=1 or base_size=2 or base_size=4{%%TODO(SET) base_size in [1,2,4]}

            -- má => použít registr
            then
              declare var
                newcontext : iexprcontext;       -- kontext podvýrazů
                op2        : c_operand;          -- hodnota pravého operandu
                op1mem     : c_operand;          -- [EDI]

              begin
                -- načíst pravý operand do registru
                i_newcontext(context,newcontext,lm_reg,ptyp^.base.getctype);
                i_load(inst,info,newcontext,context,er,op2);

                -- obnovit registry
                op1.refresh(inst,info,context);
                op1length.refresh(inst,info,context);
                op2.refresh(inst,info,context);

                -- kromě EDI nyní potřebujeme i [EDI]
                op1mem.clone(inst,info,context,op1);
                op1mem.transform_reg_to_mem(op2.edtype,base_size);

                -- přiřadit
                addii(inst,info,ii_mov,op1mem,op2,op0);

                -- posunout EDI (je-li to třeba)
                if er^.next<>nil then 
                  addopimm(inst,info,context,ii_add,op1,base_size);
                  end if;

              leave
                -- uvolnit operandy
                op1mem.free(info,context);
                op2.free(info,context);
                end declare;

            -- nemá => standardní přesun
            else
              declare var
                newcontext : iexprcontext;       -- kontext podvýrazů
                op2        : c_operand;          -- adresa pravého operandu v ESI

              begin
                -- načíst pravý operand do ESI
                i_newcontext(context,newcontext,lm_addr,nil);
                i_setrpref(newcontext,in_esi,irm_addr);
                i_load(inst,info,newcontext,context,er,op2);

                -- obnovit registry
                op1.refresh(inst,info,context);
                op1length.refresh(inst,info,context);
                op2.refresh(inst,info,context);

                -- přesun
                i_gen_movsd_static(inst,info,context,op2,op1,base_size);

              leave
                -- uvolnit operand
                op2.free(info,context);
                end declare;
              end if;

      when others do verify({VERIFY=}001062,true);
      end case;

    -- další řetězec
    er:=er^.next;
    until er=nil;

leave
  -- uvolnit operandy
  opremaining.free(info,context);
  end i_str_append_all;



----------------------------------------------------------------------------------------------------
procedure i_str_prepare_constrained_temporary_result (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext výrazu
    ptyp           : in pentity_type;            -- typ výsledného řetězce
    optemp         : out c_operand;              -- dočasný mezivýsledek zřetězení
    optemplast     : out c_operand;              -- statický atribut :last
    optemplength   : out c_operand) =            -- dynamický atribut :length
-- Připraví operand reprezentující dočasný mezivýsledek zřetězení.
----------------------------------------------------------------------------------------------------
use
  supervised cx_expr,cx_expr.cx_rta;

var
  rta_modes        : t_rtattrib_modes;           -- módy načtení run-time atributů

begin
  verify({VERIFY=}001063,ptyp^.stype<>dt_string);

  -- alokovat pracovní prostor na stacku
  optemp.create_temporary(inst,info,edt_binary,unidata_size_to_unsigned(ptyp^.size));

  -- asociovat pracovní prostor s odpovídajícím typem, aby správně fungovaly dynamické atributy
  optemp.set_orgtyp(ptyp);

  -- nastavit správně módy run-time atributů
  cx_expr.cx_rta.x_rta_string_attributes_stored_in_value(rta_modes);
  optemp.set_rta_modes(rta_modes);

  -- připravit konstantní atribut :last
  i_rta_load(inst,info,context,optemp,rta_last,optemplast);

  -- připravit dynamický atribut :length
  i_rta_load_address(inst,info,context,optemp,rta_length,optemplength);
  end i_str_prepare_constrained_temporary_result;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_concat_string =
-- Spojování řetězců.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- podvýrazy
  expr^.get(el,er);

  if expr^.assign

    -- zkrácené přiřazení
    then
      declare var
        op1        : c_operand;                  -- levý operand: EDI
        op1last    : aliased c_operand;          -- :last levého operandu
        op1length  : aliased c_operand;          -- :length levého operandu

      begin      
        -- načíst adresu levého operandu di EDI a provést nějaké další operace
        i_str_load_single(inst,info,context,el,op1,in_edi,
            -- načíst maximální velikost řetězce vlevo
            for oplast       use ^op1last,
            -- načíst adresu velikosti řetězce vlevo
            for oplength     use ^op1length,
            -- délka řetězce musí být nezávislý na zdrojovém operandu
            for length_mode  use lm_no_dependance,
            -- posunout pointer na začátek datové oblasti
            for skip_length  use true,
            -- vyvarovat se použití ECX, bude potřeba
            for preserve_ecx use true);

        -- připojit všechny pravé operandy
        i_str_append_all(inst,info,context,expr^.t.getctype,op1,op1length,op1last,er,false);

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op1last.free(info,context);
        op1length.free(info,context);
        end declare;

    -- normální &
    else
      -- alokovat pracovní prostor pro mezivýsledek
      if expr^.t.stype=dt_ustring

        -- výsledek má dynamickou velikost
        then
          unimplemented({UNIMP=}000115);

        -- výsledek má statickou velikost
        else
          declare var
            optemp       : c_operand;            -- dočasný mezivýsledek zřetězení
            optemplast   : c_operand;            -- statický atribut :last
            optemplength : c_operand;            -- dynamický atribut :length

          begin
            -- připravit pracovní prostor pro mezivýsledek
            i_str_prepare_constrained_temporary_result(inst,info,context,expr^.t.getctype,optemp,optemplast,optemplength);

            -- již teď známe výsledek - je to právě alokovaná dočasná proměnná
            vysl.clone(inst,info,context,optemp);

            -- posunout pointer na začátek datové části
            i_str_skip_length(inst,info,context,el,optemp);

            -- načíst adresu (datové části) mezivýsledku do EDI
            i_gen_load_address_to_register(inst,info,context,optemp,for pref_reg use in_edi);

            -- připojit všechny pravé operandy
            i_str_append_all(inst,info,context,expr^.t.getctype,optemp,optemplength,optemplast,el,true);

          leave
            -- uvolnit operandy
            optemp.free(info,context);
            optemplast.free(info,context);
            optemplength.free(info,context);
            end declare;
          end if;
      end if;
  end i_gen_op_concat_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_string =
-- Přiřazení řetězců.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000199,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);


  ----- (1) přiřazení prázdného řetězce ------------------------------------------------------------
  if x_is_nil(er) then
    declare var
      op1        : c_operand;                  -- řetězec
      op1length  : aliased c_operand;          -- jeho :length

    begin
      -- adresa levého operandu
      i_str_load_single(inst,info,context,el,op1,
          -- načíst délku řetězce
          for oplength    use ^op1length,
          -- délku potřebujeme jako adresní operand
          for length_mode use lm_address);

      -- do :length nacpat nulu, tím se řetězec vyprázdní
      addii(inst,info,ii_mov,op1length,op_0,op0);

    leave
      -- uvolnit operandy
      op1.free(info,context);
      op1length.free(info,context);
      end declare;


  ----- (2) přiřazení zřetězení více řetězců -------------------------------------------------------
{ Trochu složitější varianta přiřazení zřetězení, která generuje asi o dvě instrukce lepší kód,
  ale a) je zbytečně složitá a není důvod ji tu mít a b) při přiřazení :length mezivýsledku do
  :length levého operandu vygeneruje chybnou instrukci (internal error 27).

  Do budoucna bude mít tato varianta smysl pouze pro obsluhu přiřazení do unconstrained stringu,
  protože [i_gen_op_concat_string] sám o sobě neví, jak má vyalokovat velký pracovní prostor.

  elsif er^.ntype=nt_operator and then pexpoper(er)^.oper=op_concat then
    -- alokovat pracovní prostor pro mezivýsledek
    if expr^.t.stype=dt_ustring

      -- výsledek má dynamickou velikost
      then
        unimplemented({UNIMP=}000273);

      -- výsledek má statickou velikost
      else
        declare var
          optemp       : c_operand;              -- dočasný mezivýsledek zřetězení
          optemplast   : c_operand;              -- statický atribut :last
          optemplength : c_operand;              -- dynamický atribut :length

        begin
          -- připravit pracovní prostor pro mezivýsledek
          i_str_prepare_constrained_temporary_result(inst,info,context,expr^.t.getctype,optemp,optemplast,optemplength);

          -- posunout pointer na začátek datové části
          i_str_skip_length(inst,info,context,el,optemp);


          ---- (A) sestavit mezivýsledek zřetězení ----
          declare var
            optemp_edi : c_operand;              -- adresa dočasného mezivýsledku v EDI

          begin
            -- načíst adresu (datové části) mezivýsledku do EDI
            optemp_edi.clone(inst,info,context,optemp);
            i_gen_load_address_to_register(inst,info,context,optemp_edi,for pref_reg use in_edi);

            -- připojit všechny pravé operandy
            i_str_append_all(inst,info,context,expr^.t.getctype,optemp_edi,optemplength,optemplast,er^.sub,true);

          leave
            -- uvolnit operandy
            optemp_edi.free(info,context);
            end declare;


          ---- (B) mezivýsledek přiřadit do levého operandu ----
          declare var
            op1        : c_operand;              -- levý operand: EDI
            op1length  : aliased c_operand;      -- :length levého operandu

          begin
            -- načíst adresu levého operandu do EDI a provést nějaké další operace
            i_str_load_single(inst,info,context,el,op1,in_edi,
                -- načíst adresu velikosti řetězce vlevo
                for oplength   use ^op1length);

            -- obnovit registry
            op1.refresh(inst,info,context);
            op1length.refresh(inst,info,context);
            optemp.refresh(inst,info,context);
            optemplast.refresh(inst,info,context);
            optemplength.refresh(inst,info,context);

            -- Poznámka: run-time check velikosti cílového řetězce ani CLD se provádět nemusí,
            -- zařídil to již [i_str_append_all]

            -- načíst adresu (datové části) mezivýsledku do EDI (nyní již natrvalo)
            i_gen_load_address_to_register(inst,info,context,optemp,for pref_reg use in_edi);

            -- uložit :length mezivýsledku do :length levého operandu
            addii(inst,info,ii_mov,op1length,optemplength,op0);

            -- posunout pointer na začátek datové části levého operandu
            i_str_skip_length(inst,info,context,el,op1);

            -- vlastní přesun dat
            i_gen_movsd_array(inst,info,context,optemp,op1,optemplength,unidata_size_to_unsigned(expr^.t.getctype^.base.getctype^.size));

          leave
            -- uvolnit operandy
            op1.free(info,context);
            op1length.free(info,context);
            end declare;

        leave
          -- uvolnit operandy
          optemp.free(info,context);
          optemplast.free(info,context);
          optemplength.free(info,context);
          end declare;
        end if;

      { A takhle jednoduše to může vypadat, když je zaručeno, že operand vlevo není použit i vpravo:

        declare var
          op1              : c_operand;                  -- levý operand: EDI
          op1last          : aliased c_operand;          -- :last levého operandu
          op1length        : aliased c_operand;          -- :length levého operandu

        begin      
          -- načíst adresu levého operandu di EDI a provést nějaké další operace
          i_str_load_single(inst,info,context,el,op1,in_edi,
              -- načíst maximální velikost řetězce vlevo
              for oplast     use ^op1last,
              -- načíst adresu velikosti řetězce vlevo
              for oplength   use ^op1length);

          -- připojit všechny pravé operandy
          i_str_append_all(inst,info,context,expr^.t.getctype,op1,op1length,op1last,er^.sub,true);

        leave
          -- uvolnit operandy
          op1.free(info,context);
          op1last.free(info,context);
          op1length.free(info,context);
          end declare;
      }
}

  ----- (3) ostatní případy ------------------------------------------------------------------------
  else
    declare var
      op1              : c_operand;                  -- levý operand: EDI
      op1last          : aliased c_operand;          -- :last levého operandu
      op1length        : aliased c_operand;          -- :length levého operandu
      op2              : c_operand;                  -- pravý operand: ESI
      op2length        : aliased c_operand;          -- :length pravého operandu

    begin
      -- načíst adresu pravého operandu do ESI
      i_str_load_single(inst,info,context,er,op2,in_esi,
          -- načíst velikost řetězce vpravo
          for oplength    use ^op2length,
          -- velikost řetězce načíst do ECX
          for length_mode use lm_direct_ecx);

      -- načíst adresu levého operandu do EDI a provést nějaké další operace
      i_str_load_single(inst,info,context,el,op1,in_edi,
          -- načíst maximální velikost řetězce vlevo
          for oplast      use ^op1last,
          -- načíst adresu velikosti řetězce vlevo
          for oplength    use ^op1length,
          -- délku potřebujeme jako adresní operand
          for length_mode use lm_address);

      -- obnovit registry
      op2.refresh(inst,info,context);
      op2length.refresh(inst,info,context);
      op1.refresh(inst,info,context);
      op1last.refresh(inst,info,context);
      op1length.refresh(inst,info,context);

      -- shodit Direction Flag - kopíruje se zdola nahoru
      addii(inst,info,ii_cld,op0,op0,op0);

      -- run-time check velikosti cílového řetězce
      -- %%TODO(DYNAMIC_CHECK) Generovat pouze pokud si to vyžádá vyšší vrstva
      i_gen_rcheck_constraint_error_on_compare(inst,info,context,op2length,op1last,ic_a);

      -- uložit :length pravého operandu do :length levého operandu
      addii(inst,info,ii_mov,op1length,op2length,op0);

      -- posunout pointery na začátky datových částí
      i_str_skip_length(inst,info,context,el,op1);
      i_str_skip_length(inst,info,context,er,op2);

      -- vlastní přesun dat
      i_gen_movsd_array(inst,info,context,op2,op1,op2length,unidata_size_to_unsigned(expr^.t.getctype^.base.getctype^.size));

    leave
      -- uvolnit operandy
      op1.free(info,context);
      op1last.free(info,context);
      op1length.free(info,context);
      op2.free(info,context);
      op2length.free(info,context);
      end declare;
    end if;
  end i_gen_op_assign_string;



end ci_string;