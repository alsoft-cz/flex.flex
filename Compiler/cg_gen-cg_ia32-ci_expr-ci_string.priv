----------------------------------------------------------------------------------------------------
module private ci_string =
-- Překladač Flexu.
-- Řetězcové operace.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.04.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_gen_op_order_string =
-- Porovnávání řetězců (< <= > >=).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  rest             : typeview;                   -- společný typ operandů
  base             : pentity_type;               -- typ báze
  basesize         : t_unsigned32;               -- velikost báze řětězců
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000799,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost báze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- diskrétní báze -----
  if base^.stype in dts_ordinal then
    if basesize=1 or basesize=2 or basesize=4{%%TODO(SET) basesize in [1,2,4]}

      -- příznivá velikost báze => přes REPE CMPS
      then
        declare var
          el_uniarray : t_logical;               -- true, je-li levý operand konstanta typu univerzální pole
          er_uniarray : t_logical;               -- true, je-li pravý operand konstanta typu univerzální pole
          op1         : c_operand;               -- adresa levého řetězce v ESI
          op1mem      : c_operand;               -- [ESI]
          op1length   : c_operand;               -- počet prvků levého řetězce v registru
          op2         : c_operand;               -- adresa pravého řetězce v EDI
          op2mem      : c_operand;               -- [EDI]
          op2length   : c_operand;               -- počet prvků pravého řetězce v registru
          opecx       : c_operand;               -- min(op1length,op2length) v ECX`

        begin
          -- není náhodou některý operand konstanta typu univerzální pole ?
          el_uniarray:=(el^.ntype=nt_imm) and t_is_stype(el^.t,dt_uniarray);
          er_uniarray:=(er^.ntype=nt_imm) and t_is_stype(er^.t,dt_uniarray);

          if el_uniarray or er_uniarray then
            -- %%X Pozor, součástí konstanty typu univerzální pole není informace o délce,
            -- což se musí zohlednit při zjišťování a porovnávání velikostí níže.
            -- Srovnej s procedurou I_GEN_OP_COMPARE_STRING.
            unimplemented({UNIMP=}000197);
            end if;

          -- načíst levý operand do ESI
          i_newcontext(context,newcontext,lm_addr,nil);
          i_setrpref(newcontext,in_esi,irm_addr);
          i_load(inst,info,newcontext,context,el,op1);

          -- načíst pravý operand do EDI
          i_newcontext(context,newcontext,lm_addr,nil);
          i_setrpref(newcontext,in_edi,irm_addr);
          i_load(inst,info,newcontext,context,er,op2);

          -- obnovit registry
          op1.refresh(inst,info,context);
          op2.refresh(inst,info,context);

          -- kromě ESI potřebujeme i [ESI]
          op1mem.create_memory_address_from_operand(inst,info,context,edt_unsigned,0,op1);

          -- kromě EDI potřebujeme i [EDI]
          op2mem.create_memory_address_from_operand(inst,info,context,edt_unsigned,0,op2);

          -- rezervovat ECX
          opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

          -- registr na velikost řetězce vlevo
          op1length.create_new_register(inst,info,context,edt_unsigned,lstrisize32);

          -- registr na velikost řetězce vpravo
          op2length.create_new_register(inst,info,context,edt_unsigned,lstrisize32);

          -- načíst velikost řetězce vlevo
          op1mem.adjust_size(lstrisize32);
          addii(inst,info,ii_mov,op1length,op1mem,op0);

          -- načíst velikost řetězce vpravo
          op2mem.adjust_size(lstrisize32);
          addii(inst,info,ii_mov,op2length,op2mem,op0);

          -- do ECX dát přednostně velikost řetězce vlevo
          addii(inst,info,ii_mov,opecx,op1length,op0);

          -- posunout ESI a EDI o LSTRISIZE32
          addopimm(inst,info,context,ii_add,op1,lstrisize32);
          addopimm(inst,info,context,ii_add,op2,lstrisize32);

          -- porovnat velikosti řetězců
          addii(inst,info,ii_cmp,op1length,op2length,op0);

          -- el:length>er:length => ECX:=er:length
          addcmov(inst,info,context,ic_be,opecx,op2length);

          declare var
            tg_cmplength : itarget;              -- návěští pro skok na porovnání délek
            tg_end       : itarget;              -- návěští pro skok na konec porovnání
          begin
            -- alokovat návěští
            newtarget(info,tg_cmplength);
            newtarget(info,tg_end);

            -- ECX=0 => porovnání se redukuje na porovnání délek
            -- %%X neumím JECXZ
            addii(inst,info,ii_cmp,opecx,op_0,op0);
            addjump(inst,info,context,ic_e,tg_cmplength,{%%TODO(PREDICTION)}ijp_not_taken);

            -- shodit Direction Flag - porovnává se zdola nahoru
            addii(inst,info,ii_cld,op0,op0,op0);

            -- REPE CMPS
            addip(inst,info,ip_repe);
            case basesize
              when 1 do addii(inst,info,ii_cmpsb,op0,op0,op0);
              when 2 do addii(inst,info,ii_cmpsw,op0,op0,op0);
              when 4 do addii(inst,info,ii_cmpsd,op0,op0,op0);
              when others do verify({VERIFY=}000468,true);
              end case;

            -- je jednoznačně znám výsledek ? => skok na konec porovnání
            addjump(inst,info,context,ic_ne,tg_end);

            -- cíl skoku na toto místo
            settarget(info,tg_cmplength,getaddr(inst));

            -- porovnání se redukuje na porovnání délek řetězců
            addii(inst,info,ii_cmp,op1length,op2length,op0);

            -- cíl skoku na toto místo
            settarget(info,tg_end,getaddr(inst));
            end declare;

        leave
          -- uvolnit operandy
          op1.free(info,context);
          op1mem.free(info,context);
          op1length.free(info,context);
          op2.free(info,context);
          op2mem.free(info,context);
          op2length.free(info,context);
          opecx.free(info,context);
          end declare;

        -- výsledek
        vysl.create_condition(op2cc[expr^.oper,base^.stype=dt_signed]);

      -- nějaká nestandardní velikost báze
      else
        unimplemented({UNIMP=}000148);
        end if;

  ----- reálná báze -----
  elsif base^.stype in dts_float then
    unimplemented({UNIMP=}000149);

  -- jiné typy báze nelze porovnávat
  else 
    verify({VERIFY=}000467,true);
    end if;
  end i_gen_op_order_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_string =
-- Porovnávání řetězců (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : in pexpnode) =
    -- Porovná zadaný uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      op1       : c_operand;                     -- počet prvků řětězce
      newcontext: iexprcontext;                  -- kontext podvýrazů

    begin
      -- načíst počet prvků řětězce
      i_newcontext(context,newcontext,lm_reg,x^.t.getctype^.srange.getctype);
      i_load(inst,info,newcontext,context,x,op1);

      -- obnovit registry
      op1.refresh(inst,info,context);

      -- porovnat na nulu
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- výsledek
      vysl.create_condition(op2cc[expr^.oper,false]);

    leave
      -- uvolnit operand
      op1.free(info,context);
      end cmpnil;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  rest             : typeview;                   -- společný typ operandů
  base             : pentity_type;               -- typ báze
  basesize         : t_unsigned32;               -- velikost báze řětězců
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000800,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost báze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- (non)ekvivalence s prázdným řetězcem zleva -----
  if x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s prázdným řětězcem zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecných řetězců -----
  else
    verify({VERIFY=}000624,el^.ntype=nt_imm);

    declare var
      er_uniarray  : t_logical;                  -- true, je-li pravý operand konstanta typu univerzální pole
      op1          : c_operand;                  -- adresa levého řetězce v ESI
      op1mem       : c_operand;                  -- [ESI]
      op2          : c_operand;                  -- adresa pravého řetězce v EDI
      op2mem       : c_operand;                  -- [EDI]
      opecx        : c_operand;                  -- min(op1length,op2length) v ECX

    begin
      -- %%X Optimalizace: Když je velikost báze rovna LSTRISIZE32, tak nemusím
      -- zvlášť testovat shodnost délek - stačí udělat INC ECX a REPE CMPS

      -- %%X Pozor ! Pro některé typy báze řetězce se to musí dělat jinak
      if base^.stype not in dts_ordinal then
        unimplemented({UNIMP=}000166);
        end if;

      -- není náhodou pravý operand konstant typu univerzální pole ?
      er_uniarray:=(er^.ntype=nt_imm) and t_is_stype(er^.t,dt_uniarray);

      -- načíst levý operand do ESI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_esi,irm_addr);
      i_load(inst,info,newcontext,context,el,op1);

      -- načíst pravý operand do EDI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_edi,irm_addr);
      i_load(inst,info,newcontext,context,er,op2);

      -- obnovit registry
      op1.refresh(inst,info,context);
      op2.refresh(inst,info,context);

      -- kromě ESI potřebujeme i [ESI]
      op1mem.create_memory_address_from_operand(inst,info,context,edt_unsigned,0,op1);

      -- kromě EDI potřebujeme i [EDI]
      op2mem.create_memory_address_from_operand(inst,info,context,edt_unsigned,0,op2);

      -- rezervovat ECX
      opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

      -- do ECX načíst velikost levého operandu
      op1mem.adjust_size(lstrisize32);
      addii(inst,info,ii_mov,opecx,op1mem,op0);

      -- porovnat s velikostí řetězce vlevo
      if er_uniarray

        -- vpravo je konstanta typu univerzální pole => informace o délce není její součástí
        then
          declare var
            op2len : c_operand;                  -- kosntantní velikost pravého operandu
            ui     : tuniint;

          begin
            -- připravit konstantní operand délky
            imm_get_length(pexpimm(er)^.imm,ui);
            op2len.create_imm(edt_unsigned,lstrisize32,uniint_to_imm32(ui));

            -- porovnat
            addii(inst,info,ii_cmp,opecx,op2len,op0);

          leave
            op2len.free(info,context);
            end declare;

        -- vpravo je něco jiného => informace o délce je její součástí
        else
          op2mem.adjust_size(lstrisize32);
          addii(inst,info,ii_cmp,opecx,op2mem,op0);
          end if;

      declare var
        tg_end     : itarget;                    -- návěští pro skok na konec porovnání

      begin
        -- alokovat návěští
        newtarget(info,tg_end);

        -- jsou rozdílné ? => pak je porovnání hotové
        addjump(inst,info,context,ic_ne,tg_end,{%%TODO(PREDICTION)}ijp_taken);

        -- Nyní jsou jistě délky řetězců shodné (Zero Flag=0). Původně jsem toho
        -- chtěl využít, abych nemusel ještě testovat ECX na nulu, jenže počet
        -- prvků řetězce se za chvíli bude násobit velikostí báze a tato operace
        -- může ZF změnit.

        -- porovnat ECX na nulu
        addii(inst,info,ii_cmp,opecx,op_0,op0);
        addjump(inst,info,context,ic_e,tg_end,{%%TODO(PREDICTION)}ijp_not_taken);

        -- posunout ESI a EDI o LSTRISIZE32
        addopimm(inst,info,context,ii_add,op1,lstrisize32);
        if not er_uniarray then
          addopimm(inst,info,context,ii_add,op2,lstrisize32);
          end if;

        declare var
          ii         : iinstr;                     -- zvolená porovnávací instrukce
          imm        : timm32;                     -- délka operandu ve slovech

        begin
          -- zvolit, jak budeme porovnávat (podle velikosti báze)
          -- dělitelné 4 ? => po čtveřicích
          if basesize mod 4=0 then
            ii:=ii_cmpsd;
            imm:=unsigned_to_imm32(basesize div 4);
          -- dělitelné 2 ? => po dvojicích
          elsif basesize mod 2=0 then
            ii:=ii_cmpsw;
            imm:=unsigned_to_imm32(basesize div 2);
          -- musíme po bytech
          else
            ii:=ii_cmpsb;
            imm:=unsigned_to_imm32(basesize);
            end if;

          -- vynásobit počet prvků řetězce reziduem velikosti báze
          i_gen_mul_reg(inst,info,context,op1,imm);

          -- shodit Direction Flag - porovnává se zdola nahoru
          addii(inst,info,ii_cld,op0,op0,op0);

          -- REPE CMPS
          addip(inst,info,ip_repe);
          addii(inst,info,ii,op0,op0,op0);
          end declare;

        -- a tím by to mělo být hotovo

        -- cíl skoku na toto místo
        settarget(info,tg_end,getaddr(inst));
        end declare;

    leave
      -- uvolnit operandy
      op1.free(info,context);
      op1mem.free(info,context);
      op2.free(info,context);
      op2mem.free(info,context);
      opecx.free(info,context);
      end declare;

    -- výsledek
    vysl.create_condition(op2cc[expr^.oper,false]);
    end if;
  end i_gen_op_compare_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_string_and_last =
-- Načte adresu řetězce do EDI a zjistí jeho :last.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  if expr^.t.stype=dt_ustring

    -- unconstrained string s dynamickou délkou
    then
      -- pak musí mít dynamický :last nebo :size
      verify({VERIFY=}000344,not x_has_dynamic_size(expr));

      declare var
        op1        : c_operand;                  -- operand reprezentující řetězec
        opedi      : c_operand;                  -- registr EDI

      begin
        -- vygenerovat levý operand
        i_newcontext(context,newcontext,lm_addr_attr,nil);
        i_load(inst,info,newcontext,context,expr,op1);

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- pro atribut bude potřeba registr
        oplast.create_new_register(inst,info,context,edt_unsigned,lstrisize32);

        -- je k dispozici přímo :last
        if rta_last in expr^.rta_used{%%ATTR} then
          -- načíst :last
          i_gen_load_rtattrib_value(inst,info,context,expr^.rta_used{%%ATTR},op1,rta_last,oplast);

        -- je k dispozici jen :size
        elsif rta_size in expr^.rta_used{%%ATTR} then
          -- načíst :size
          i_gen_load_rtattrib_value(inst,info,context,expr^.rta_used{%%ATTR},op1,rta_size,oplast);

          -- odečíst velikost interní části řetězce
          addii(inst,info,ii_sub,oplast,op_lstrisize32,op0);

          -- vydělit velikostí prvku
          i_gen_div_reg(inst,info,context,oplast,unidata_size_to_imm32(expr^.t.getctype^.base.getctype^.size));

        -- co si máme počít bez dynamického atributu ?
        else
          verify({VERIFY=}000516,true)
          end if;

        -- registr EDI
        opedi.create_use_register(inst,info,context,edt_address,ir_edi);

        -- načíst adresu řetězce do EDI
        op1.adjust_size(lpointer32);
        addii(inst,info,ii_mov,opedi,op1,op0);

        -- předat výsledek
        op.transfer(opedi);

      leave 
        -- uvolnit operandy
        op1.free(info,context);
        opedi.free(info,context);
        end declare;

    -- řetězec se statickou délkou
    else
      -- připravit konstantní atribut :last
      oplast.create_imm(edt_unsigned,lstrisize32,uniint_to_imm32(expr^.t.getctype^.srange.getctype^.hval));

      -- načíst adresu levého operandu do EDI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_edi,irm_addr);
      i_load(inst,info,newcontext,context,expr,op);
      end if;
  end i_gen_load_string_and_last;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_concat_string =
-- Spojování řetězců.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

    ------------------------------------------------------------------------------------------------
    procedure appendall (
        op1        : in c_operand;               -- levý operand: EDI
        op1mem     : in c_operand;               -- levý operand: [EDI]
        op1length  : in c_operand;               -- :length levého operandu
        op1last    : in c_operand;               -- :last levého operandu
        opbasesize : in c_operand) =             -- konstantní velikost báze řetězce
    -- Přikopírování všech operandů počínaje ER k OP1.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podvýrazů
      tg_end       : itarget;                    -- návěští pro skok na konec zřetězení
      basesize     : t_unsigned32;

    begin
      -- návěští pro skok na konec zřetězení
      newtarget(info,tg_end);

      -- shodit Direction Flag - kopíruje se zdola nahoru
      addii(inst,info,ii_cld,op0,op0,op0);

      -- velikost báze
      basesize:=imm32_to_unsigned(opbasesize.imm);

      loop
        -- vygenerovat zřetězení
        case er^.concatkind
          -- podřetězec
          when nck_substring do
              declare var
                op2       : c_operand;                  -- pravý operand: ESI
                op2mem    : c_operand;                  -- pravý operand: [ESI]
                op2length : c_operand;                  -- :length pravého operandu

              begin
                -- načíst pravý operand do ESI
                i_newcontext(context,newcontext,lm_addr,nil);
                i_setrpref(newcontext,in_esi,irm_addr);
                i_load(inst,info,newcontext,context,er,op2);

                -- obnovit registry
                op1.refresh(inst,info,context);
                op1mem.refresh(inst,info,context);
                op1length.refresh(inst,info,context);
                op2.refresh(inst,info,context);

                -- kromě ESI potřebujeme i [ESI]
                op2mem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op2);

                -- počet prvků řetězce do ECX
                op2length.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
                op2mem.adjust_size(lstrisize32);
                addii(inst,info,ii_mov,op2length,op2mem,op0);

                -- posunout pointer na začátek datové části
                addii(inst,info,ii_add,op2,op_lstrisize32,op0);

                -- není to moc ? (op2length:=min(op2length,op1last-op1length)
                declare var
                  optemp : c_operand;              -- pomocný operand

                begin
                  optemp.create_new_register(inst,info,context,edt_unsigned,lstrisize32);
                  addii(inst,info,ii_mov,optemp,op1last,op0);
                  addii(inst,info,ii_sub,optemp,op1length,op0);
                  addii(inst,info,ii_cmp,op2length,optemp,op0);
                  addcmov(inst,info,context,ic_be,op2length,optemp);
                leave
                  optemp.free(info,context);
                  end declare;

                -- aktualizovat :length levého operandu (v registru)
                addii(inst,info,ii_add,op1length,op2length,op0);

                -- vlastní přesun dat
                i_gen_movsd_array(inst,info,context,op2,op1,op2length,basesize);

              leave
                -- uvolnit operandy vztahující se k pravému operandu
                op2.free(info,context);
                op2mem.free(info,context);
                op2length.free(info,context);
                end declare;

          -- podpole
          when nck_subarray do
              unimplemented({UNIMP=}000121);

          -- komponenta
          when nck_component do
              -- vejde se ještě komponenta do řetězce ?
              addii(inst,info,ii_cmp,op1length,op1last,op0);
              addjump(inst,info,context,ic_ae,tg_end,{%%TODO(PREDICTION)}ijp_not_taken);

              -- inkrementovat :length
              addii(inst,info,ii_inc,op1length,op0,op0);

              -- nemá báze příznivou velikost ?
              if basesize=1 or basesize=2 or basesize=4{%%TODO(SET) basesize in [1,2,4]}

                -- má => použít registr
                then
                  declare var
                    op2 : c_operand;             -- pravý operand: ESI

                  begin
                    -- načíst pravý operand do registru
                    i_newcontext(context,newcontext,lm_reg,expr^.t.getctype^.base.getctype{nil});
                    i_load(inst,info,newcontext,context,er,op2);

                    -- obnovit registry
                    op1.refresh(inst,info,context);
                    op1mem.refresh(inst,info,context);
                    op1length.refresh(inst,info,context);
                    op2.refresh(inst,info,context);

                    -- přiřadit
                    op1mem.adjust_size(basesize);
                    addii(inst,info,ii_mov,op1mem,op2,op0);

                    -- posunout EDI (je-li to třeba)
                    if er^.next<>nil then addii(inst,info,ii_add,op1,opbasesize,op0); end if;

                  leave
                    -- uvolnit operand
                    op2.free(info,context);
                    end declare;

                -- nemá => standardní přesun
                else
                  declare var
                    op2 : c_operand;             -- pravý operand: ESI

                  begin
                    -- načíst pravý operand do ESI
                    i_newcontext(context,newcontext,lm_addr,nil);
                    i_setrpref(newcontext,in_esi,irm_addr);
                    i_load(inst,info,newcontext,context,er,op2);

                    -- obnovit registry
                    op1.refresh(inst,info,context);
                    op1mem.refresh(inst,info,context);
                    op1length.refresh(inst,info,context);
                    op2.refresh(inst,info,context);

                    -- přesun
                    i_gen_movsd_static(inst,info,context,op2,op1,basesize);

                  leave
                    -- uvolnit operand
                    op2.free(info,context);
                    end declare;
                  end if;

          when others do verify({VERIFY=}000376,true);
          end case;

        -- další operand
        er:=er^.next;
        until er=nil;

      -- cíl skoku na toto místo
      settarget(info,tg_end,getaddr(inst));
      end appendall;

var
  opbasesize       : c_operand;                  -- konstantní velikost báze řetězce
  op1org           : c_operand;                  -- původní adresa levého operandu
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  -- připravit operand s velikostí báze řetězce
  opbasesize.create_imm(edt_unsigned,0,unidata_size_to_imm32(expr^.t.getctype^.base.getctype^.size));

  -- podvýrazy
  expr^.get(el,er);

  if expr^.assign

    -- zkrácené přiřazení
    then
      declare var
        op1        : c_operand;                  -- levý operand: EDI
        op1mem     : c_operand;                  -- levý operand: [EDI]
        op1length  : c_operand;                  -- :length levého operandu
        op1last    : c_operand;                  -- :last levého operandu

      begin
        -- načíst adresu levého operandu do EDI
        i_gen_load_string_and_last(inst,info,context,el,op1,op1last);

        -- obnovit registry
        op1.refresh(inst,info,context);
        op1last.refresh(inst,info,context);

        -- schovat si původní adresu levého operandu
        -- %%X Někdy mohu mít k dispozici volný registr, který by šel využít
        op1org.create_temporary(inst,info,edt_address,idefregsize);
        addii(inst,info,ii_mov,op1org,op1,op0);

        -- kromě EDI potřebujeme i [EDI]
        op1mem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op1);

        -- :length řetězce vlevo umístit do registru
        op1mem.adjust_size(lstrisize32);
        op1length.create_new_register(inst,info,context,edt_unsigned,lstrisize32);
        addii(inst,info,ii_mov,op1length,op1mem,op0);
        op1mem.adjust_size(0);

        declare var
          optemp   : c_operand;                  -- pomocný operand

        begin
          -- vypočítat :length*:base:size (index -> offset)
          optemp.create_new_register(inst,info,context,edt_unsigned,lstrisize32);
          addii(inst,info,ii_imul,optemp,op1length,opbasesize);

          -- posunout pointer na začátek volného místa
          addii(inst,info,ii_add,op1,op_lstrisize32,op0);
          addii(inst,info,ii_add,op1,optemp,op0);

        leave
          -- uvolnit pracovní registr
          optemp.free(info,context);
          end declare;

        -- přikopírovat vše počínaje ER
        appendall(op1,op1mem,op1length,op1last,opbasesize);

        -- aktualizovat fyzické :length levého operandu
        op1.adjust_size(idefregsize);
        op1mem.adjust_size(lstrisize32);
        addii(inst,info,ii_mov,op1,op1org,op0);
        addii(inst,info,ii_mov,op1mem,op1length,op0);

        -- uvolnit temporary prostor
        --%%FLEX Tohle se snad udělá samo,ne?
        -- freetemp(inst,info,op1org.disp);

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op1org.free(info,context);
        op1mem.free(info,context);
        op1length.free(info,context);
        op1last.free(info,context);
        end declare;

    -- normální &
    else
      -- alokovat pracovní prostor pro mezivýsledek
      if expr^.t.stype=dt_ustring

        -- výsledek má dynamickou velikost
        then
          unimplemented({UNIMP=}000115);

        -- výsledek má statickou velikost
        else
          declare var
            op1        : c_operand;                  -- levý operand: EDI
            op1mem     : c_operand;                  -- levý operand: [EDI]
            op1length  : c_operand;                  -- :length levého operandu
            op1last    : c_operand;                  -- :last levého operandu

          begin
            -- %%X Nemůže se stát, že bude mezivýsledek příliš velký na to,
            -- aby se nevešel na stack ? Myslím, že klidně může ...

            -- alokovat pracovní prostor na stacku
            op1org.create_temporary(inst,info,edt_binary,unidata_size_to_unsigned(expr^.t.getsize));

            -- připravit konstantní atribut :last
            op1last.create_imm(edt_unsigned,0,uniint_to_imm32(expr^.t.getctype^.srange.getctype^.hval));

            -- počáteční nulové :length mezivýsledku
            op1length.create_new_register(inst,info,context,edt_unsigned,lstrisize32);
            addii(inst,info,ii_mov,op1length,op_0,op0);

            -- adresu začátku datové části umístit do EDI
            op1.clone(inst,info,context,op1org);
            op1.shift_displacement(lstrisize32);
            i_gen_lea(inst,info,context,op1,in_edi);

            -- kromě EDI potřebujeme i [EDI]
            op1mem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op1);

            -- přikopírovat všechny operandy
            er:=el;
            appendall(op1,op1mem,op1length,op1last,opbasesize);

            -- obnovit registry
            op1org.refresh(inst,info,context);

            -- aktualizovat :length
            op1org.adjust_size(lstrisize32);
            addii(inst,info,ii_mov,op1org,op1length,op0);

            -- výsledek
            vysl.transfer(op1org);
            vysl.adjust_size(unidata_size_to_unsigned(expr^.t.getsize));

          leave
            -- uvolnit operandy
            op1.free(info,context);
            op1org.free(info,context);
            op1mem.free(info,context);
            op1last.free(info,context);
            op1length.free(info,context);
            end declare;
          end if;
      end if;

leave
  -- uvolnit operandy
  opbasesize.free(info,context);
  end i_gen_op_concat_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_string =
-- Přiřazení řetězců.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext podvýrazů

begin
  verify({VERIFY=}000199,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  if x_is_nil(er) {er^.t.stype=dt_uninil}

    -- přiřazení prázdného řetězce
    then
      declare var
        op1        : c_operand;                  -- levý operand: EDI

      begin
        -- adresa levého operandu
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,el,op1);

        -- obnovit registry
        op1.refresh(inst,info,context);

        -- levý operand teď ukazuje na interní část řetězce
        -- %%FLEX Xakru neměl by se tady NILovat celý řetězěc včetně nepoužitých bytů?
        -- Minimálně pro řetězec splňující S:secure=true ano.
        op1.adjust_size(4);

        -- přiřadit nulu do :length
        addii(inst,info,ii_mov,op1,op_0,op0);

      leave
        -- uvolnit levý operand
        op1.free(info,context);
        end declare;

    -- ostatní případy
    else
      -- %%X Když je na pravé straně konstanta a el:last je též   
      -- konstantní, lze to celé zjednodušit:
      --   -- do ECX se šoupne konstanta,
      --   -- do [EDI] se šoupne konstanta,
      --   -- nemusí se testovat oříznutí.
      -- Když je navíc konstanta vpravo dostatečně malá,
      -- nemusím se obtěžovat s REP MOVSD ale mohu to rozvinout.

      declare var
        op1              : c_operand;                  -- levý operand: EDI
        op1mem           : c_operand;                  -- levý operand: [EDI]
        op1last          : c_operand;                  -- :last levého operandu
        op2              : c_operand;                  -- pravý operand: ESI
        op2mem           : c_operand;                  -- pravý operand: [ESI]
        op2length        : c_operand;                  -- :length pravého operandu

      begin
        -- načíst adresu pravého operandu do ESI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_esi,irm_addr);
        i_load(inst,info,newcontext,context,er,op2);

        -- načíst adresu levého operandu do EDI
        i_gen_load_string_and_last(inst,info,context,el,op1,op1last);

        -- obnovit registry
        op1.refresh(inst,info,context);
        op1last.refresh(inst,info,context);
        op2.refresh(inst,info,context);

        -- kromě EDI potřebujeme i [EDI]
        op1mem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op1);

        -- kromě ESI potřebujeme i [ESI]
        op2mem.create_memory_address_from_operand(inst,info,context,edt_binary,0,op2);

        -- shodit Direction Flag - kopíruje se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- počet prvků řetězce vpravo do ECX
        op2length.create_use_register(inst,info,context,edt_unsigned,ir_ecx);
        op2mem.adjust_size(lstrisize32);
        addii(inst,info,ii_mov,op2length,op2mem,op0);

        -- není to moc ? (op2length:=min(op2length,op1last)
        addii(inst,info,ii_cmp,op2length,op1last,op0);
        addcmov(inst,info,context,ic_be,op2length,op1last);

        -- uložit :length do levého operandu
        op1mem.adjust_size(lstrisize32);
        addii(inst,info,ii_mov,op1mem,op2length,op0);

        -- posunout pointer na začátek datové části
        addii(inst,info,ii_add,op1,op_lstrisize32,op0);
        addii(inst,info,ii_add,op2,op_lstrisize32,op0);

        -- vlastní přesun dat
        i_gen_movsd_array(inst,info,context,op2,op1,op2length,unidata_size_to_unsigned(expr^.t.getctype^.base.getctype^.size));

      leave
        -- uvolnit operandy
        op1.free(info,context);
        op1mem.free(info,context);
        op1last.free(info,context);
        op2.free(info,context);
        op2mem.free(info,context);
        op2length.free(info,context);
        end declare;
      end if;
  end i_gen_op_assign_string;



end ci_string;
