----------------------------------------------------------------------------------------------------
module private ci_gen =
-- P©eklada‡ Flexu.
-- Generov n¡ cel‚ kompila‡n¡ jednotky.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_def.cc_var,
  cc_base,
  cc_base.cc_debug,
  cc_base.cc_rtl,
  cc_base.cc_sym,
  ci_def,
  ci_code,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_code.ci_instr,
  ci_block,
  cp_cpu.cp_32.cp_def,
  cp_cpu.cp_ia32.ci_abi,
  cg_gen.cg_ia32.ci_context,
  cg_gen.cg_ia32.ci_code.ci_operand,
  cg_gen.cg_ia32.ci_code.ci_operand.c_operand,
  cc_options;


----------------------------------------------------------------------------------------------------
procedure i_gen (
    curr           : in pentity;                 -- generovan˜ symbol
    count          : in out t_unsigned);         -- po‡et ji‘ vygenerovan˜ch entit
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure addcall (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o p©ekladu
    psym           : in pentity_code) =           -- volan˜ podprogram
-- P©id  vol n¡ podprogramu.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addcall], kter  si sama p©iprav¡ kontext v˜razu.
----------------------------------------------------------------------------------------------------
with
  ci_context;
  
var
  context          : iexprcontext;

begin
  -- p©ipravit pr zdn˜ kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skute‡n˜ [addjump]
  ci_instr.addcall(inst,info,context,psym);
  end addcall;



----------------------------------------------------------------------------------------------------
procedure addcallrtl (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o p©ekladu
    rtl            : in t_rtl_entity;            -- volan˜ intern¡ podprogram
    save_regs      : in t_logical:=false) =      -- ulozit pouzite registry?
-- P©id  vol n¡ intern¡ho podprogramu.
-- Varianta [cg_gen.cg_ia32.ci_code.ci_instr.addcallrtl], kter  si sama p©iprav¡ kontext v˜razu.
----------------------------------------------------------------------------------------------------
with
  ci_context;

var
  context          : iexprcontext;

begin
  -- p©ipravit pr zdn˜ kontext
  i_createcontext(context,lm_gen,nil);

  -- zavolat skute‡n˜ [addjump]
  ci_instr.addcallrtl(inst,info,context,rtl,save_regs);
  end addcallrtl;



----------------------------------------------------------------------------------------------------
procedure i_instance (
    curr           : in out class tentity_code;  -- generovan˜ symbol
    inst           : in out picodeinst) =        -- instance
-- Alokuje novou instanci.
----------------------------------------------------------------------------------------------------
var
  psym             : pentity;

begin
  -- p©ipravit instanci na generov n¡
  i_prepare(curr);

  -- p©ipravit instanci
  new inst;
  if picodegen_subprog(curr.codegen)^.ifirst=nil
    then picodegen_subprog(curr.codegen)^.ifirst:=inst;
    else picodegen_subprog(curr.codegen)^.ilast^.next:=inst;
    end if;
  picodegen_subprog(curr.codegen)^.ilast:=inst;

  -- default volac¡ konvence
  if get_call_conv(pentity(^curr)^)=icc_default
    then inst^.profile.call:=icc_flex;
    else inst^.profile.call:=get_call_conv(pentity(^curr)^);
    end if;

  -- zvolit stack-frame
  if picodegen_subprog(curr.codegen)^.def_frame=isf_default
    then inst^.frame:=isf_fptr;
    else inst^.frame:=picodegen_subprog(curr.codegen)^.def_frame;
    end if;

  -- vytvo©it seznam vno©en˜ch podprogram–
  if curr.nesting<>0 then
    -- jestli‘e to nen¡ top-level podprogram, pak sestavit seznam nad©azen˜ch podprogram–
    if curr.nesting-1>0 then
      -- alokovat pamˆŸ
      new inst^.nested.nlist range curr.nesting-1;

      -- sestavit seznam
      psym:=curr.context.entity;
      inst^.nested.nlist^:length:=curr.nesting-1;
      for i in reverse inst^.nested.nlist^:range loop
        verify({VERIFY=}000500,(psym=nil) or not (psym^.etype in ets_subprogram) or (pentity_code(psym)^.nesting<>i));
        inst^.nested.nlist^[i]:=pentity_code(psym);
        psym:=psym^.context.entity;
        end loop;
      end if;
    end if;
  end i_instance;



----------------------------------------------------------------------------------------------------
procedure do_stack_reserve (
    context        : in out iexprcontext;        -- kontext v˜razu
    compi          : in tentity_compile;
    inst           : in out icodeinst;
    info           : in out igeninfo;
    opaddr         : out c_operand) =            -- adresa rezervy na stacku
-- Rezervuje m¡sto na stacku po‘adovan‚ run-time knihovnou pro jej¡ intern¡ struktury.
----------------------------------------------------------------------------------------------------
var
  size             : t_unsigned;                 -- velikost rezervovan‚ho m¡sta

begin
  -- zjisti velikost rezervovaneho mista
  size:=os^.getstackreserve(compi);
  if size<>0 then
    opaddr.create_temporary(inst,info,edt_unsigned,size);  
    end if;
  end do_stack_reserve;



----------------------------------------------------------------------------------------------------
procedure i_gen_program_compile (
    curr           : in out tentity_compile) =   -- kompila‡n¡ jednotka
-- Vygeneruje k¢d kompila‡n¡ jednotky programu
----------------------------------------------------------------------------------------------------
with
  ci_fragment;

var
  inst             : picodeinst;                 -- instance
  info             : igeninfo;                   -- informace o generov n¡
  srch             : tentitysearch;              -- hled tko
  framehandler     : timm32;                     -- adresa polo‘ky HANDLER v exception-frame
  tg_unhandled     : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  tg_endxframe     : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  p                : pentity;
  context          : iexprcontext;               -- kontext v˜razu

begin
  if o_is_option_by_entity(opt_dump_code,curr) then
    debug_dump('-------- Kompilacni jednotka --------------------------------------------------');
    end if;

  -- p©ipravit instanci
  i_instance(curr,inst);

  -- p©ipravit informace o generov n¡
  initinfo(curr,info);

  -- pripravit prazdny kontext vyrazu
  i_createcontext(context,lm_gen,nil);

  if not cfg_no_runtime then
    -- alokovat n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
    newtarget(info,tg_unhandled);
    newtarget(info,tg_endxframe);

    -- prenastavit vyjimky
    i_set_handler(inst^,info,framehandler,tg_unhandled);
    end if;

  -- vytvo©it stack-frame
  i_gen_entry(curr,inst^,info);

  if not cfg_no_runtime then
    
    declare var
      stack_reserve_addr : c_operand;                -- adresa rezervy na stacku

    begin
      -- reservovat misto na stacku
      do_stack_reserve(context,curr,inst^,info,stack_reserve_addr);
      
      -- inicializovat runtime knihovnu
      addcallrtl(inst^,info,rtl_early_runtime_initialize); 

      i_gen_lea(inst^,info,context,stack_reserve_addr,in_none);

      addii(inst^,info,ii_push,stack_reserve_addr,op0,op0);

      -- inicializovat task control block pro hlavn¡ task
      addcallrtl(inst^,info,rtl_register_task);
    
    leave
      stack_reserve_addr.free(info,context);
      end declare; 

    -- vytvo©it exception-frame
    i_create_xframe(inst^,info,framehandler,tg_endxframe);
    end if;

  -- zavolat ENTRY v¨ech modul–
  for i in 1..entrylist.count loop
    -- vyhledat ENTRY
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_entry);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  -- zavolat program
  srch.find_et_first(^curr,rc_primary,et_program,[]);
  if srch.psym<>nil then 
    addcall(inst^,info,pentity_code(srch.psym)); 
    end if;

  -- zavolat EXIT v¨ech modul–
  for i in reverse 1..entrylist.count loop
    -- vyhledat EXIT
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_exit);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  if not cfg_no_runtime then 
    -- adresa obsluhy neobslou‘en˜ch v˜jimek
    settarget(info,tg_endxframe,getaddr(inst^));

    -- zrusit exception-frame
    addcallrtl(inst^,info,rtl_end_topmost_xframe);

    --prenastavit handler
    i_set_handler(inst^,info,framehandler,tg_unhandled);

    -- deinicializovat task control block pro hlavn¡ task
    addcallrtl(inst^,info,rtl_unregister_task);

    -- finalizovat runtime knihovnu
    addcallrtl(inst^,info,rtl_late_runtime_finalize); 
    
    end if;

  -- zru¨it stack-frame
  i_gen_exit(curr,inst^,info);

  if not cfg_no_runtime then 
    -- ukon‡it program
    addcallrtl(inst^,info,rtl_terminate);

    -- adresa obsluhy neobslou‘en˜ch v˜jimek
    settarget(info,tg_unhandled,getaddr(inst^));

    -- zavolat osbluhu neobslou‘en˜ch v˜jimek
    addcallrtl(inst^,info,rtl_unhandled_exception);
    end if;

  -- vyhodnotit lok ln¡ relokace
  localresolve(curr,inst^,info);

  end i_gen_program_compile;



-- %%TODO(?) - vykonnou cast i_gen_lib_compile presunout do os specific
----------------------------------------------------------------------------------------------------
procedure i_gen_lib_compile (
    curr           : in out tentity_compile) =   -- kompila‡n¡ jednotka
-- Vygeneruje k¢d kompila‡n¡ jednotky knihovny
----------------------------------------------------------------------------------------------------
with
  ci_fragment;

var
  inst             : picodeinst;                 -- instance
  info             : igeninfo;                   -- informace o generov n¡
  srch             : tentitysearch;              -- hled tko
  framehandler     : timm32;                     -- adresa polo‘ky HANDLER v exception-frame
  p                : pentity;
  opvar            : c_operand;
  l1               : itarget;
  l_konec          : itarget;
  context          : iexprcontext;               -- kontext v˜razu
  tg_unhandled     : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  tg_endxframe     : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek
  tg_endxframe2    : itarget;                    -- n vˆ¨t¡ obsluhy neobslou‘en˜ch v˜jimek

begin
  if o_is_option_by_entity(opt_dump_code,curr) then
    debug_dump('-------- Kompilacni jednotka --------------------------------------------------');
    end if;

  -- p©ipravit instanci
  i_instance(curr,inst);

  -- p©ipravit informace o generov n¡
  initinfo(curr,info);

  -- pripravit prazdny kontext vyrazu
  i_createcontext(context,lm_gen,nil);

  -- alokovat navesti
  newtarget(info,l1);
  newtarget(info,l_konec);
  newtarget(info,tg_unhandled);
  newtarget(info,tg_endxframe);
  newtarget(info,tg_endxframe2);

  -- vytvo©it stack-frame
  -- stack-frame musi byt EBP relativni
  i_gen_entry(curr,inst^,info);

  -- pushnout esi - windows pouziva pro obnovu stacku
  declare var
    opesi   : c_operand;
  begin
    opesi.create_use_register(inst^,info,context,edt_unsigned,ir_esi);
    addii(inst^,info,ii_push,opesi,op0,op0);
    
    leave
      opesi.free(info,context);;
    end declare;

  if not cfg_no_runtime then 
    -- prenastavit vyjimky
    i_set_handler(inst^,info,framehandler,tg_unhandled);
    end if;
  
  -- fdwReason je 2. parametr DllMain
  opvar.create_memory_address_on_stack(inst^,edt_unsigned,4,signed_to_imm32(12));

  -- pokud fdwReason se nerovna DLL_PROCESS_ATTACH...
  declare var
    opeax   : c_operand;

  begin
    -- pouzijeme eax
    opeax.create_use_register(inst^,info,context,edt_unsigned,ir_eax);
    
    addii(inst^,info,ii_mov,opeax,opvar,op0);
    addopimm(inst^,info,context,ii_cmp,opeax,unsigned_to_imm32(1{DLL_PROCESS_ATTACH}));
    
  leave
    -- uvolnime registr
    opeax.free(info,context);
    end declare;
  
  -- ... odskoc na dalsi test
  addjump(inst^,info,context,ic_ne,l1);
  
  if not cfg_no_runtime then 

    declare var
      stack_reserve_addr : c_operand;                -- adresa rezervy na stacku

    begin
      -- reservovat misto na stacku
      do_stack_reserve(context,curr,inst^,info,stack_reserve_addr);
      
      -- inicializovat runtime knihovnu
      addcallrtl(inst^,info,rtl_early_runtime_initialize); 

      i_gen_lea(inst^,info,context,stack_reserve_addr,in_none);

      addii(inst^,info,ii_push,stack_reserve_addr,op0,op0);

      -- inicializovat task control block pro hlavn¡ task
      addcallrtl(inst^,info,rtl_register_task); 
    leave
      stack_reserve_addr.free(info,context);
      end declare; 

    -- vytvo©it exception-frame
    i_create_xframe(inst^,info,framehandler,tg_endxframe);
    end if;

  -- zavolat ENTRY v¨ech modul–
  for i in 1..entrylist.count loop
    -- vyhledat ENTRY
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_entry);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  if not cfg_no_runtime then 
    -- adresa obsluhy neobslou‘en˜ch v˜jimek
    settarget(info,tg_endxframe,getaddr(inst^));

    -- zru¨it exception-frame
    addcallrtl(inst^,info,rtl_end_topmost_xframe);

    --prenastavit handler
    i_set_handler(inst^,info,framehandler,tg_unhandled);

    -- deinicializovat task control block pro hlavn¡ task
    addcallrtl(inst^,info,rtl_unregister_task);
    end if;

  -- navratova hodnota
  -- uspech 1{TRUE}, neuspech 0{FALSE}
  declare var
    opeax   : c_operand;

  begin
    -- pouzijeme eax
    opeax.create_use_register(inst^,info,context,edt_unsigned,ir_eax);

    addopimm(inst^,info,context,ii_mov,opeax,unsigned_to_imm32(1{TRUE}));
    
  leave
    opeax.free(info,context);
    end declare;

  -- koncime
  addjump(inst^,info,context,ic_ucond,l_konec);
  
  -- navesti pro ne-DLL_PROCESS_ATTACH
  settarget(info,l1,getaddr(inst^));

  -- pokud fdwReason se nerovna DLL_PROCESS_DETACH...
  declare var
    opeax   : c_operand;

  begin
    -- pouzijeme eax
    opeax.create_use_register(inst^,info,context,edt_unsigned,ir_eax);

    addii(inst^,info,ii_mov,opeax,opvar,op0);
    addopimm(inst^,info,context,ii_cmp,opeax,unsigned_to_imm32(0{DLL_PROCESS_DETACH}));

  leave
    opeax.free(info,context);
    end declare;
  
  -- ...koncime
  addjump(inst^,info,context,ic_ne,l_konec);

  if not cfg_no_runtime then 
    declare var
      stack_reserve_addr : c_operand;                -- adresa rezervy na stacku

    begin
      -- reservovat misto na stacku
      do_stack_reserve(context,curr,inst^,info,stack_reserve_addr);
      
      i_gen_lea(inst^,info,context,stack_reserve_addr,in_none);

      addii(inst^,info,ii_push,stack_reserve_addr,op0,op0);

      -- inicializovat task control block pro hlavn¡ task
      addcallrtl(inst^,info,rtl_register_task); 
    leave
      stack_reserve_addr.free(info,context);
      end declare; 

    -- vytvo©it exception-frame
    i_create_xframe(inst^,info,framehandler,tg_endxframe2);
    end if;

  -- zavolat EXIT v¨ech modul–
  for i in reverse 1..entrylist.count loop
    -- vyhledat EXIT
    srch.find_local_all(sym_primary_context(entrylist.list^[i]^),id_exit);

    -- zavolat
    if srch.psym<>nil then addcall(inst^,info,pentity_code(srch.psym)); end if;
    end loop;

  if not cfg_no_runtime then 
    -- adresa obsluhy neobslou‘en˜ch v˜jimek
    settarget(info,tg_endxframe2,getaddr(inst^));

    -- zru¨it exception-frame
    addcallrtl(inst^,info,rtl_end_topmost_xframe);

    --prenastavit handler
    i_set_handler(inst^,info,framehandler,tg_unhandled);

    -- deinicializovat task control block pro hlavn¡ task
    addcallrtl(inst^,info,rtl_unregister_task);

    -- finalizovat runtime knihovnu
    addcallrtl(inst^,info,rtl_late_runtime_finalize); 
    end if;

  -- navratova hodnota se pouziva jen pri DLL_PROCESS_ATTACH 

  -- navesti konce
  settarget(info,l_konec,getaddr(inst^));

  -- popnout esi - windows pouziva pro obnovu stacku
  declare var
    opesi   : c_operand;
  begin
    opesi.create_use_register(inst^,info,context,edt_unsigned,ir_esi);
    addii(inst^,info,ii_pop,opesi,op0,op0);

    leave
      opesi.free(info,context);;
    end declare;
  
  opvar.free(info,context);

  -- zru¨it stack-frame
  i_gen_exit(curr,inst^,info);

  if not cfg_no_runtime then 
    -- adresa obsluhy neobslou‘en˜ch v˜jimek
    settarget(info,tg_unhandled,getaddr(inst^));

    -- zavolat osbluhu neobslou‘en˜ch v˜jimek
    addcallrtl(inst^,info,rtl_unhandled_exception);
    end if;
  
  -- vyhodnotit lok ln¡ relokace
  localresolve(curr,inst^,info);

leave
  opvar.free(info,context);
  end i_gen_lib_compile;



----------------------------------------------------------------------------------------------------
procedure i_gen_compile (
    curr           : in out tentity_compile) =   -- kompila‡n¡ jednotka
-- Vygeneruje k¢d kompila‡n¡ jednotky.
----------------------------------------------------------------------------------------------------
begin
  -- co generujeme?
  case curr.compitype
    -- knihovna
    when ct_library do i_gen_lib_compile(curr);
    
    -- program
    when ct_program do i_gen_program_compile(curr);
    
    -- ostatni nezname
    when others do verify({VERIFY=}000667,true);
    end case;
  end i_gen_compile;



----------------------------------------------------------------------------------------------------
procedure i_gen_context (
    context        : in tcontext;                -- generovan˜ symbol
    count          : in out t_unsigned) =        -- po‡et ji‘ vygenerovan˜ch entit
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;                    -- zpracov van  entita
  region           : pregion;                    -- zpracov van˜ region

begin
  -- vygenerovat k¢d pro v¨echny entity
  entity:=context.region^.entities.first;
  while entity<>nil loop
    -- vygenerovat
    i_gen(entity,count);

    -- dal¨¡ entita
    entity:=entity^.next;
    end loop;

  -- a pro v¨echny podregiony
  region:=context.region^.regions.first;
  while region<>nil loop
    -- vygenerovat
    i_gen_context(sym_build_context(context.entity,region),count);

    -- dal¨¡ region
    region:=region^.next;
    end loop;
  end i_gen_context;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Vygeneruje k¢d pro jeden symbol.
----------------------------------------------------------------------------------------------------
with
  standard.console,
  cc_def.cc_codes;

var
  inst             : picodeinst;                 -- instance

begin
  -- vygenerovat k¢d pro tento symbol
  if curr^.etype in ets_body then
    --write_line(sym_get_qid(curr));

    if o_is_option_by_entity(opt_dump_code,curr^) then
      debug_dump('-------- ' & sym_get_qid(curr) & ' --------');
      end if;

    begin
      -- p©ipravit instanci
      i_instance(pentity_code(curr)^,inst);

      -- vygenerovat blok p©¡kaz–
      i_gen_block(pentity_code(curr)^,inst^);

    catch
      when compiler_error do 
          write_line(sym_get_qid(curr));
      {%%X ??? nem  tu b˜t INTERNAL_ERROR ? } -- nic nedˆlat
      end;

    -- zapo‡¡tat a zobrazit voltmetr
    succ count;
    --showvoltmetr(v,count);
    end if;

  -- zpracovat v¨echny regiony
  for rcategory in tregioncategory loop
    if curr^.regions[rcategory]<>nil then 
      i_gen_context(sym_build_context(curr,curr^.regions[rcategory]),count);
      end if;
    end loop;
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_estimate (
    curr           : in pentity;                 -- generovan˜ symbol
    total          : in out t_unsigned);         -- po‡et generovan˜ch entit
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure i_estimate_context (
    context        : in tcontext;                -- generovan˜ symbol
    total          : in out t_unsigned) =        -- po‡et ji‘ vygenerovan˜ch entit
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------
var
  entity           : pentity;                    -- zpracov van  entita
  region           : pregion;                    -- zpracov van˜ region

begin
  -- vygenerovat k¢d pro v¨echny entity
  entity:=context.region^.entities.first;
  while entity<>nil loop
    -- zpracovat
    i_estimate(entity,total);

    -- dal¨¡ entita
    entity:=entity^.next;
    end loop;

  -- a pro v¨echny podregiony
  region:=context.region^.regions.first;
  while region<>nil loop
    -- vygenerovat
    i_estimate_context(sym_build_context(context.entity,region),total);

    -- dal¨¡ region
    region:=region^.next;
    end loop;
  end i_estimate_context;



----------------------------------------------------------------------------------------------------
procedure i_estimate =
-- Spo‡¡t , kolik se bude generovat entit.
----------------------------------------------------------------------------------------------------
begin
  -- zapo‡¡tat tuto entitu
  if curr^.etype in ets_body then
    succ total;
    end if;

  -- zpracovat v¨echny regiony
  for rcategory in tregioncategory loop
    if curr^.regions[rcategory]<>nil then 
      i_estimate_context(sym_build_context(curr,curr^.regions[rcategory]),total);
      end if;
    end loop;
  end i_estimate;



----------------------------------------------------------------------------------------------------
procedure i_codegen =
-- Hlavn¡ smy‡ka gener toru k¢du.
----------------------------------------------------------------------------------------------------
var
  total            : t_unsigned;
  count            : t_unsigned;

begin
  -- odhadnout d‚lku generov n¡, aby se dal zobrazit voltmetr
  total:=0;
  i_estimate(compi,total);

  -- vygenerovat k¢d v¨ech prvk–
  count:=0;
  i_gen(compi,count{,v});

  -- vygenerovat kod kompila‡n¡ jednotky
  i_gen_compile(compi^);
  end i_codegen;



end ci_gen;
