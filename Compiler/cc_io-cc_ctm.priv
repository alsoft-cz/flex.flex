----------------------------------------------------------------------------------------------------
module private cc_ctm =
-- Překladač Flexu.
-- Compile-Time Metadata.
----------------------------------------------------------------------------------------------------

with 
  standard,
  standard.classes.hash_tables,
  standard.classes.lists,
  cc_def,
  cc_def.cc_gc,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_def.cc_unitype,
  cc_def.cc_lexsym,
  cd_decl.cd_create;

type
  t_ctm_version    = private t_unsigned32;

const
  -- číslo verze CTM souboru -- zvýšit při každé úpravě CTM struktur a ošetřit kompatibilitu
  ctm_curr_version = t_ctm_version(3);
  
  -- minimální podporované číslo verze CTM souboru -- aktualizovat při každé nekompatibilní úpravě CTM struktur
  ctm_min_version  = t_ctm_version(3);

type
  -- identifikátor položky v metadatech
  t_ctm_id         = private unsigned 32;

  -- identifikátor entity v metadatech
  t_ctm_entity_id  = protected t_ctm_id;

  -- identifikátor regionu v metadatech
  t_ctm_region_id  = protected t_ctm_id;

  -- tag recordu metadat
  t_ctm_record_tag = private unsigned 8;

const
  -- tag konce sekvence recordů
  cr_end           = t_ctm_record_tag(0);
  
  -- tag záhlaví CTM souboru         
  cr_header        = t_ctm_record_tag(1);

  -- tag s kontrolním součtem metadat
  cr_sha1          = t_ctm_record_tag(2);

  -- tag regionu
  cr_region        = t_ctm_record_tag(4);

  -- tag tabulky RTL procedur
  cr_rtl           = t_ctm_record_tag(5);

  -- tag položky tabulky RTL procedur
  cr_rtl_entry     = t_ctm_record_tag(6);

  -- tag importní tabulky
  cr_import        = t_ctm_record_tag(3);

  -- tag importní tabulky pro jednu partition
  cr_import_partition = t_ctm_record_tag(7);

  -- tag položky importní tabulky pro jednu partition
  cr_import_entry  = t_ctm_record_tag(8);

var
  -- tagy recordů pro jednotlivé druhy entit s výjimkou typu a třídy
  -- !!! musi byt synchronizovano s etype_by_cr
  cr_by_etype      : const array succ et_undef..tentitytype:last of t_ctm_record_tag := [
      for et_compile    use t_ctm_record_tag(10),
      for et_program    use t_ctm_record_tag(11),
      for et_module     use t_ctm_record_tag(12),
      for et_special    use t_ctm_record_tag(13),
      for et_procedure  use t_ctm_record_tag(14),
      for et_static     use t_ctm_record_tag(15),
      for et_virtual    use t_ctm_record_tag(16),
      for et_task       use t_ctm_record_tag(17),
      for et_override   use t_ctm_record_tag(18),
      for et_macro      use t_ctm_record_tag(19),
      for et_overload   use t_ctm_record_tag(20),
      for et_operator   use t_ctm_record_tag(21),
      for et_var        use t_ctm_record_tag(22),
      for et_type       use t_ctm_record_tag( 0), -- pouze pro úplnost agregátu, používá se kód odvozený z [tdatatype]
      for et_class      use t_ctm_record_tag( 0), -- pouze pro úplnost agregátu, používá se kód odvozený z [tdatatype]
      for et_const      use t_ctm_record_tag(23),
      for et_enum       use t_ctm_record_tag(24),
      for et_param      use t_ctm_record_tag(25),
      for et_message    use t_ctm_record_tag(26),
      for et_label      use t_ctm_record_tag(27),
      for et_template   use t_ctm_record_tag(28),
      for et_tparam     use t_ctm_record_tag(29),
      for et_attribute  use t_ctm_record_tag(30)];

  -- jednotlivé druhy entit s výjimkou typu a třídy pro typy recordů
  -- !!! musi byt synchronizovano s cr_by_etype
  -- %%TODO(MACRO) předělat na automatické vygenerování inverzní transformace makrem
  etype_by_cr      : const array {t_ctm_record_tag}10..{t_ctm_record_tag}30 of tentitytype := [
      for t_ctm_record_tag(10) use et_compile   ,
      for t_ctm_record_tag(11) use et_program   ,
      for t_ctm_record_tag(12) use et_module    ,
      for t_ctm_record_tag(13) use et_special   ,
      for t_ctm_record_tag(14) use et_procedure ,
      for t_ctm_record_tag(15) use et_static    ,
      for t_ctm_record_tag(16) use et_virtual   ,
      for t_ctm_record_tag(17) use et_task      ,
      for t_ctm_record_tag(18) use et_override  ,
      for t_ctm_record_tag(19) use et_macro     ,
      for t_ctm_record_tag(20) use et_overload  ,
      for t_ctm_record_tag(21) use et_operator  ,
      for t_ctm_record_tag(22) use et_var       ,
      for t_ctm_record_tag(23) use et_const     ,
      for t_ctm_record_tag(24) use et_enum      ,
      for t_ctm_record_tag(25) use et_param     ,
      for t_ctm_record_tag(26) use et_message   ,
      for t_ctm_record_tag(27) use et_label     ,
      for t_ctm_record_tag(28) use et_template  ,
      for t_ctm_record_tag(29) use et_tparam    ,
      for t_ctm_record_tag(30) use et_attribute ];

  -- tagy recordů pro jednotlivé druhy deklarativních regionů
--  cr_by_rtype

  -- tagy recordů pro jednotlivé druhy typů
  -- !!! musi byt synchronizovano s dtype_by_cr
  cr_by_dtype      : const array succ dt_ordinal..tdatatype:last of t_ctm_record_tag := [
      -- univerzální typy
      for dt_uniint     use t_ctm_record_tag(50),
      for dt_unireal    use t_ctm_record_tag(51),
      for dt_unilogical use t_ctm_record_tag(52),
      for dt_unichar    use t_ctm_record_tag(53),
      for dt_uniarray   use t_ctm_record_tag(54),
      for dt_uninil     use t_ctm_record_tag(55),
      -- regulární typy
      for dt_signed     use t_ctm_record_tag(56),
      for dt_unsigned   use t_ctm_record_tag(57),
      for dt_float      use t_ctm_record_tag(58),
      for dt_fixed      use t_ctm_record_tag(59),
      for dt_char       use t_ctm_record_tag(60),
      for dt_logical    use t_ctm_record_tag(61),
      for dt_enum       use t_ctm_record_tag(62),
      for dt_string     use t_ctm_record_tag(63),
      for dt_ustring    use t_ctm_record_tag(64),
      for dt_array      use t_ctm_record_tag(65),
      for dt_uarray     use t_ctm_record_tag(66),
      for dt_record     use t_ctm_record_tag(67),
      for dt_class      use t_ctm_record_tag(68),
      for dt_set        use t_ctm_record_tag(69),
      for dt_pointer    use t_ctm_record_tag(70),
      for dt_tag        use t_ctm_record_tag(71),
      -- singulární typy
      for dt_message    use t_ctm_record_tag(72),
      for dt_procedure  use t_ctm_record_tag(73),
      for dt_task       use t_ctm_record_tag(74)];


  -- jednotlivé druhy typů pro tagy recordů
  -- !!! musi byt synchronizovano s cr_by_dtype
  -- %%TODO(MACRO) předělat na automatické vygenerování inverzní transformace makrem
  dtype_by_cr      : const array {t_ctm_record_tag}50..{t_ctm_record_tag}74 of tdatatype := [
      -- univerzální typy
      for t_ctm_record_tag(50) use dt_uniint    ,
      for t_ctm_record_tag(51) use dt_unireal   ,
      for t_ctm_record_tag(52) use dt_unilogical,
      for t_ctm_record_tag(53) use dt_unichar   ,
      for t_ctm_record_tag(54) use dt_uniarray  ,
      for t_ctm_record_tag(55) use dt_uninil    ,
      -- regulární typy                          
      for t_ctm_record_tag(56) use dt_signed    ,
      for t_ctm_record_tag(57) use dt_unsigned  ,
      for t_ctm_record_tag(58) use dt_float     ,
      for t_ctm_record_tag(59) use dt_fixed     ,
      for t_ctm_record_tag(60) use dt_char      ,
      for t_ctm_record_tag(61) use dt_logical   ,
      for t_ctm_record_tag(62) use dt_enum      ,
      for t_ctm_record_tag(63) use dt_string    ,
      for t_ctm_record_tag(64) use dt_ustring   ,
      for t_ctm_record_tag(65) use dt_array     ,
      for t_ctm_record_tag(66) use dt_uarray    ,
      for t_ctm_record_tag(67) use dt_record    ,
      for t_ctm_record_tag(68) use dt_class     ,
      for t_ctm_record_tag(69) use dt_set       ,
      for t_ctm_record_tag(70) use dt_pointer   ,
      for t_ctm_record_tag(71) use dt_tag       ,
      -- singulární typy
      for t_ctm_record_tag(72) use dt_message   ,
      for t_ctm_record_tag(73) use dt_procedure ,
      for t_ctm_record_tag(74) use dt_task      ];

const
  -- tag seznamu vygenerovaných instancí
  cr_code_instances= t_ctm_record_tag(100);
  
  -- tag jedné vygenerované instance
  cr_code_instance = t_ctm_record_tag(101);

const
  -- prázdné CTM ID
  ci_none          = t_ctm_entity_id(0);
  
  -- well-known CTM ID univerzálních typů
  ci_uniint        = t_ctm_entity_id(1);
  ci_unireal       = t_ctm_entity_id(2);
  ci_unilogical    = t_ctm_entity_id(3);
  ci_unichar       = t_ctm_entity_id(4);
  ci_uninil        = t_ctm_entity_id(5);
  ci_unistr        = t_ctm_entity_id(6);

  -- well-known CTM ID interních typů používaných kompilátorem
  ci_inttype_tag              = t_ctm_entity_id(10);
  ci_inttype_status           = t_ctm_entity_id(11);
  ci_inttype_machine_pointer  = t_ctm_entity_id(12);

  -- první uživatelský identifikátor
  ci_user          = 100;



----------------------------------------------------------------------------------------------------
procedure check_error (
    num            : in t_unsigned;
    cond           : in t_logical := true) =
-- Je-li splněna podmínka [cond], tak způsobí chybu [ce_ctm_corrupt].
----------------------------------------------------------------------------------------------------
begin
  if cond then
    ce^.seterror(num,ce_ctm_corrupt);
    ce^.raiseerror;
    end if;
  end check_error;



----------------------------------------------------------------------------------------------------
#separate public cc_registry;
#separate private cc_registry;
-- CTM ID registry pro export a import compile-time metadat.
----------------------------------------------------------------------------------------------------
#separate public cc_formatters;
#separate private cc_formatters;
-- Formátovače pro zápis a čtení compile-time metadat.
----------------------------------------------------------------------------------------------------



var
  -- viditelnostní filtry v závislosti na úrovni detailu
  processing_visibility : const array t_ctm_detail_level of tentityvisibleset := [
      for ctdl_public      use [etv_public,etv_protected,etv_supervised],
      for ctdl_precompiled use [{%%TODO(CTM)}],
      for ctdl_full        use [{%%TODO(CTM)}]];
  traversal_visibility  : const array t_ctm_detail_level of tentityvisibleset := [
      for ctdl_public      use [etv_public,etv_protected,etv_supervised],
      for ctdl_precompiled use [{%%TODO(CTM)}],
      for ctdl_full        use [{%%TODO(CTM)}]];



----------------------------------------------------------------------------------------------------
class private c_ctm_marker = 
-- Označovač entit, které se dostanou do compile-time metadat.
----------------------------------------------------------------------------------------------------

    var
      -- požadovaná úroveň detailu metadat
      detail_level : t_ctm_detail_level;

      -- seznam entit, které se dostanou do metadat
      list         : ^tentitystring;

    ------------------------------------------------------------------------------------------------
    override process_entity_base =
    -- Zápis entity: společný základ.
    ------------------------------------------------------------------------------------------------
    begin
      list^.add(node);
      end process_entity_base;



    ------------------------------------------------------------------------------------------------
    static ctm_mark =
    -- Sestaví seznam entit, které se dostanou do compile-time metadat při uvedené konfiguraci
    -- kořenové entity a úrovně metadat.
    ------------------------------------------------------------------------------------------------
    begin
      -- poznamenat si požadovanou úroveň metada
      detail_level:=level;
      if level>ctdl_public then unimplemented({UNIMP=}000275) end if;

      -- poznamenat si seznam, do kterého doplňujeme entity
      this.list:=^list;

      -- nastavit filtr itertátoru
      set_processing_filter(etypes             ,processing_visibility[detail_level]);
      set_traversal_filter (tentitytypeset:full,traversal_visibility[detail_level]);

      -- %%TODO(CTM) Nějaký advanced filtr na příznak slinkování entity - nelze přeci exportovat 
      -- neslinkované entity (pro [ctdl_precompiled] samozřejmě vynechat)

      -- zpracovat strom entit a sestavit seznam
      traverse_entity(root_entity);
      end ctm_mark;

    end c_ctm_marker;




----------------------------------------------------------------------------------------------------
class private c_ctm_writer =
-- Compile-time metadata writer.
----------------------------------------------------------------------------------------------------

    with
      cc_def.cc_entity.cc_ref,
      cc_registry,
      cc_formatters;

    var
      -- požadovaná úroveň detailu metadat
      detail_level : t_ctm_detail_level;

      -- registr polozek s pridelenymi CTM IDs
      ctm_id       : ^c_ctm_id_partitioned_registry;

      -- výstupní formatter
      f            : c_ctm_binary_writer;
    
    ------------------------------------------------------------------------------------------------
    static is_exportable (
        entity     : in pentity)                 -- testovaná entita
        return t_logical =                       -- T-byla resp. bude exportovaná
    -- True, bude-li zadaná entita exportovaná do metadat.
    ------------------------------------------------------------------------------------------------
    begin
      case detail_level
        when ctdl_public      do result:=etc_globaly_visible in entity^.compile;
        when ctdl_precompiled do unimplemented({UNIMP=}000288);
        when ctdl_full        do unimplemented({UNIMP=}000289);
        end case;
      end is_exportable;



    ------------------------------------------------------------------------------------------------
    static get_well_known_ctm_id (
        ent        : in pentity)
        return t_ctm_entity_id = 
    -- vrati well known CTM ID podle [ent]
    -- aware of well-known CTM IDs
    ------------------------------------------------------------------------------------------------
    begin
      if    ent=def_uniint then result:=ci_uniint;
      elsif ent=def_unireal then result:=ci_unireal;
      elsif ent=def_unilogical then result:=ci_unilogical;
      elsif ent=def_unichar then result:=ci_unichar;
      elsif ent=def_uninil then result:=ci_uninil;
      elsif ent=def_unistr then result:=ci_unistr;
      elsif ent=inttype_tag then result:=ci_inttype_tag;
      elsif ent=inttype_status then result:=ci_inttype_status;
      elsif ent=inttype_machine_pointer then result:=ci_inttype_machine_pointer;
      
      -- jine nezname
      else  
        result:=nil; 
        end if;
      end get_well_known_ctm_id;

    

    ------------------------------------------------------------------------------------------------
    static get_ctm_id (
        ent        : in pentity)
        return t_ctm_entity_id = 
    -- vrati CTM ID podle [ent]
    -- aware of well-known CTM IDs
    ------------------------------------------------------------------------------------------------
    begin
      if ent=nil then
        result:=ci_none;
        return;
        end if;
      
      -- neexportovatelna entita?
      if etc_no_cmt_export in ent^.compile 

        -- unitypy maji well-known CTM IDs
        then
          result:=get_well_known_ctm_id(ent);
          
          -- sedi to?
          verify({VERIFY=}001190,result=nil);
                    
        -- ostatni podle hashtabulky
        else  
          result:=ctm_id^.get_ctm_entity_id(ent);
          end if;  
      end get_ctm_id;


    
    ------------------------------------------------------------------------------------------------
    static write_entity_cr (
        ent        : in pentity) =               -- entita
    -- Zapíše kód typu entity.
    ------------------------------------------------------------------------------------------------
    begin
      if ent^.etype in ets_type
        -- typy se oštřují zvlášť
        then f.write_cr(cr_by_dtype[pentity_type(ent)^.stype]);

        -- ostatní entity standardním způsobem
        else f.write_cr(cr_by_etype[ent^.etype]);
        end if;
      end write_entity_cr;
      
      
      
    ------------------------------------------------------------------------------------------------
    static write_entity_ref (
        ent        : in pentity) =               -- entita
    -- Zapis reference na entitu.
    ------------------------------------------------------------------------------------------------
    begin
      -- kontrola, jestli je entita znama
      -- verify({VERIFY=}001191,ent<>nil and get_well_known_ctm_id(ent)=ci_none and not ctm_id^.has_ctm_entity_id(ent));

      -- CTM ID
      f.write_ci(get_ctm_id(ent));
      if ent=nil then return; end if;
      
      -- CTM record tag
      write_entity_cr(ent);
      end write_entity_ref;

    
    
    ------------------------------------------------------------------------------------------------
    static write_refentity (
        r          : in refentity;               -- reference na entitu
        allow_invisible : in t_logical := false) = -- T-tolerovat odkazy na neviditelné entity
    -- Zapis reference na entitu.
    ------------------------------------------------------------------------------------------------
    begin
      -- bude odkazovaná entita také exportována?
      if r.getuentity<>nil and then not is_exportable(r.getuentity)
      
        -- ne, neviditelná entita => referenci zrušit
        then
          verify({VERIFY=}001387,not allow_invisible);
          write_entity_ref(nil);
          
        -- ano, viditelná entita => zapsat standardní referenci  
        else 
          write_entity_ref(r.getuentity);
          end if;
      end write_refentity;



    ------------------------------------------------------------------------------------------------
    static write_codegen_type (
        codegen    : in p_flex_record) =
    -- Zapíše informace pro generování typu.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      if codegen<>nil 
        -- %%TODO(PORTABILITY) Zobecnit !
        then f.write_unidata_addr(prg32_to_unidata_addr(picodegen_type(codegen)^.desc_addr));
        else f.write_unidata_addr(uda_0);
        end if;
      end write_codegen_type;
      
      
                                                                                             
    ------------------------------------------------------------------------------------------------
    static write_refinterface (
        iface      : in p_class_interface) =
    -- Zapíše referenci na interface.
    ------------------------------------------------------------------------------------------------
    begin
      if iface<>nil
      
        -- interface existuje => zapsat referenci na třídu a index interfacu
        then
        {
          if iface^.refclass.getcentity^.id<>nil and iface^.refclass.getcentity^.id^='C_INPUT_STREAM' then
            declare var x : t_unsigned;
            begin
              x:=x;
              end declare;
            end if;
        }  
          -- odkaz na obalující třídu
          write_entity_ref(iface^.get_enclosing_class);

          -- interface index
          f.write_unsigned(iface^.interface_index);
        
        -- interface neexistuje => zapsat jen prázdnou referenci na třídu
        else  
          write_entity_ref(nil);
          end if;
      end write_refinterface;
      


    ------------------------------------------------------------------------------------------------
    static write_interface_vtable (
        iface      : in p_class_interface) =
    -- Zapíše virtuální tabulku uvedeného interfacu.
    ------------------------------------------------------------------------------------------------
    begin
      if iface^.vtable<>nil 
        then
          -- pocet
          f.write_unsigned32(iface^.vtable^:length);
          
          -- entity
          for i in iface^.vtable^:range loop
            write_entity_ref(iface^.vtable^[i]);
            end loop;
            
        else
          f.write_unsigned32(0);
          end if;
      end write_interface_vtable;
      
      
                                                                                             
    ------------------------------------------------------------------------------------------------
    static write_interface (
        iface      : in p_class_interface) =
    -- Zapíše definici interfacu.
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}001123,iface=nil or else not iface^.is_exposed);
      
      -- odkaz na třídu
      write_refentity(iface^.refclass);

      -- odkaz na instanci interfacu
      write_refentity(iface^.instance);

      -- virtuální tabulka
      write_interface_vtable(iface);
      
      -- původní interface
      write_refinterface(iface^.org_interface);

      -- interface index
      f.write_unsigned(iface^.interface_index);
      
      -- informace o generování
      write_codegen_type(iface^.codegen);
      end write_interface;



    ------------------------------------------------------------------------------------------------
    static write_reftype (
        r          : in reftype) =               -- reference na entitu
    -- Zapis reference na entitu.
    ------------------------------------------------------------------------------------------------
    begin
      write_entity_ref(r.getutype);
      end write_reftype;


    
    ------------------------------------------------------------------------------------------------  
    static write_imm_value (
        val        : in pimm_value) =
    -- zapis okamzite hodnoty
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      -- typ prime hodnoty
      if val=nil 
        then 
          f.write_immclass(ic_undef);
          return;

        else 
          f.write_immclass(val^.ic);
          end if;

      -- typ?
      case val^.ic
        -- ordinal
        when ic_ordinal do f.write_uniint(val^.ui);
        
        -- real
        when ic_real do f.write_unireal(val^.ur);
        
        -- nil
        when ic_nil do ;
        
        -- string
        when ic_condensed do 
            -- verify({VERIFY=}001120,val^.citems.len<>val^.citems.items^:length);

            -- pocet prvku [citems.items^]
            f.write_unsigned32(val^.citems.items^:length);

            -- pocet prvku
            f.write_unsigned(val^.citems.len);
            
            -- velikost prvku
            f.write_unsigned(val^.citems.isize);
            
            -- prvky
            for i in val^.citems.items^:range loop
              f.write_unsigned8(val^.citems.items^[i]);
              end loop;
            
        -- pole
        when ic_array do
            verify({VERIFY=}001108,val^.aitems=nil);
            
            -- pocet slozek
            if val^.aitems^.list<>nil 
              then f.write_unsigned32(val^.aitems^.list^:length);
              else f.write_unsigned32(0);
              end if;

            -- slozky
            if  val^.aitems^.list<>nil then
              for i in val^.aitems^.list^:range loop
                -- spodek
                f.write_uniint(val^.aitems^.list^[i].lval);
                
                -- svrsek
                f.write_uniint(val^.aitems^.list^[i].hval);
                
                -- hodnota
                write_imm_value(^val^.aitems^.list^[i].val);
                end loop;
              end if;
            
            -- hodnota "others"
            write_imm_value(^val^.aitems^.othersval);
        
        -- record
        when ic_record do
            verify({VERIFY=}001109,val^.ritems=nil);

            -- pocet slozek
            if val^.ritems^.list<>nil 
              then f.write_unsigned32(val^.ritems^.list^:length);
              else f.write_unsigned32(0);
              end if;

            -- slozky
            if val^.ritems^.list<>nil then
              for i in val^.ritems^.list^:range loop
                -- souvisejici entita
                write_entity_ref(val^.ritems^.list^[i].item);
                
                -- hodnota
                write_imm_value(^val^.ritems^.list^[i].val);
                end loop;
              end if;

            -- hodnota "others"
            write_imm_value(^val^.ritems^.othersval);

        -- agr. mnoziny
        when ic_set do
            verify({VERIFY=}001113, val^.sitems=nil);

            -- pocet slozek
            if val^.sitems^.list<>nil 
              then f.write_unsigned32(val^.sitems^.list^:length);
              else f.write_unsigned32(0);
              end if;
            
            -- slozky
            if val^.sitems^.list<>nil then
              for i in val^.sitems^.list^:range loop
                -- spodek
                f.write_uniint(val^.sitems^.list^[i].lval);
                
                -- svrsek
                f.write_uniint(val^.sitems^.list^[i].hval);
                end loop;
              end if;
        
        -- nedefinovano
        when ic_undef do ;

        when others do
            -- doplnit prepinac
            verify({VERIFY=}001107,true);
        end case;

      -- adresa přímé hodnoty
      if val^.codegen<>nil 
        -- %%TODO(PORTABILITY) Zobecnit !
        then f.write_unidata_addr(prg32_to_unidata_addr(picodegen_imm(val^.codegen)^.addr))
        else f.write_unidata_addr(uda_0);
        end if;
      end write_imm_value;



    ------------------------------------------------------------------------------------------------
    static write_refimm (
        r          : in refimm) =
    -- Zápis reference na okamžitou hodnotu
    ------------------------------------------------------------------------------------------------
    begin
      write_imm_value(r.getuimm);
      end write_refimm;



    ------------------------------------------------------------------------------------------------
    static write_lexaggregate (
        str        : in plexaggregate) =
    -- Zapis lexaggregate. pokud [str] nil, zapise prazdny retezec
    ------------------------------------------------------------------------------------------------
    begin
      -- nil?
      if str=nil
        
        -- jo - prazdny retezec
        then f.write_unsigned32(0);

        -- ne
        else
          -- delka
          f.write_unsigned32(str^:length);

          -- jednotlive uniznaky
          for i in str^:range loop
            f.write_unichar(str^[i]);
            end loop;
          end if;
      end write_lexaggregate;
    
    

    ------------------------------------------------------------------------------------------------
    static write_lexnode_lex (
        node       : in plexnode_lex) =
    -- Zápis lexikálního elementu
    ------------------------------------------------------------------------------------------------
{
  -- lexikální element sám o sobě
  tlexnode_lex     = tlexnode with record
    + xlex         : cc_lexsym.lexsym;           -- lexikální element
    + xval         : cc_lexsym.lexval;           -- hodnota elementu
    ? xpos         : cc_lexsym.lexpos;           -- pozice elementu
      end record;
  plexnode_lex     = ^class tlexnode_lex;
}
    begin
      verify({VERIFY=}001117,node=nil);
      f.write_lexsym(node^.xlex);

      -- HYNEK - neudelat case node^.xlex? kdyz tech elementu je moc a ostatnich polozek jen par
      f.write_uniint(node^.xval.ui);
      f.write_unireal(node^.xval.ur);
      f.write_entityident(node^.xval.id);
      f.write_logical(node^.xval.can_be_kw);
      f.write_lexcharustr(node^.xval.txt);       -- textová reprezentace elementu
      write_lexaggregate(node^.xval.str);        -- znakový agregát 
      f.write_unsigned(node^.xval.code);         -- rezervováno inline assembler
      f.write_logical(node^.xval.id_used);       -- identifikátor byl použit
      f.write_logical(node^.xval.txt_used);      -- textový tvar byl použit                                
      end write_lexnode_lex;                          



    ------------------------------------------------------------------------------------------------
    override filter_process_entity =
    -- filtr 
    ------------------------------------------------------------------------------------------------
    begin
      -- %%TODO(INHERITED) doplnit volání předka
      
      -- vynechani neexportovatelnych entit, napr. unitypu
      result:=etc_no_cmt_export not in node^.compile and is_exportable(node);
      end filter_process_entity;
    


    ------------------------------------------------------------------------------------------------
    override filter_traverse_entity =
    -- filtr 
    ------------------------------------------------------------------------------------------------
    begin
      -- vynechani neexportovatelnych entit, napr. unitypu
      result:=filter_process_entity(node);
      end filter_traverse_entity;

    
    
    ------------------------------------------------------------------------------------------------
    override process_entity_base =
    -- Zápis entity: společný základ.
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}001215,not is_exportable(node){detail_level=ctdl_public and etc_globaly_visible not in node^.compile});
      write_refentity(node^.ancestor,for allow_invisible use true);
      f.write_visible(node^.visible);
      f.write_visible(node^.full);
      f.write_logical(node^.is_abstract);
      f.write_security_level(node^.sec_level);
      f.write_security_level(node^.sec_required);
    {
      ---- příznaky entity a stavové proměnné ----
 -- ? compile      : tentitycompileset;          -- režim překladu
 -- ? pos          : tentitypositions;           -- pozice symbolu
 -- ? compv        : tcompvar;                   -- parametry překladu
      ---- informace přidané globální analýzou ----
 -- ? loc_var_cache: t_var_cache;                -- lokální příznak volání spec. metod pro proměnné
 -- ? tra_var_cache: t_var_cache;                -- tranzitivní příznak volání spec. metod pro prom.
      ---- generování kódu ----
 -- ? codegen      : p_flex_record;              -- přídavné informace pro generátor kódu
    }
      end process_entity_base;


                     
    ------------------------------------------------------------------------------------------------
    override process_entity_code =
    -- Zápis entity: entita obsahující kód.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding,
      cg_gen.cg_ia32.ci_def,
      cp_os.cp_win32;
      
    begin
      process_entity_base(node);
    {
    - bl           : cc_ref.refblock;            -- blok příkazů
    - nesting      : t_unsigned;                 -- úroveň vnoření podprogramu
    }
    
      -- zapsat informace o importu %%TODO(PORTABILITY) Zobecnit !
      if is_imported(node)

        -- je importovaná 
        then
          -- zapsat příznak importu
          f.write_logical(true);

          -- zapsat importní informace
          declare var
            import_info : pimportinfo;           -- importní informace aktuální entity

          begin
            -- získat importní informace
            import_info:=get_import_info(node);

            -- zapsat údaje
            f.write_external_entity_ident(import_info^.extname);
            f.write_external_entity_ident(import_info^.libname);
            f.write_unicode_addr(import_info^.addr);
            end declare;
        
        -- není importovaná
        else
          -- jen zapsat příznak importu
          f.write_logical(false);
          end if;
    
      -- zapsat všechny instance %%TODO(PORTABILITY) Zobecnit !
      verify({VERIFY=}001382,node^.codegen=nil);
      declare var
        inst       : picodeinst;                 -- právě zpracovávaná instance
        
      begin
        -- tag začátku seznamu instancí
        f.write_cr(cr_code_instances);
        
        -- zpracovat všechny instance
        inst:=picodegen_subprog(node^.codegen)^.ifirst;
        while inst<>nil loop
          -- tag začátku instance
          f.write_cr(cr_code_instance);

          -- volací konvence této instance
          f.write_icallconvention(inst^.profile.call);
          
          -- adresa instance
          f.write_unicode_addr(unsigned_to_unicode_addr(inst^.cstart));

          -- offset THIS parametru
          f.write_unidata_addr(signed_to_unidata_addr(inst^.profile.thisofs));

          -- kolik bytů uvolnit při návratu z procedury
          f.write_unidata_size(unsigned_to_unidata_size(inst^.profile.retfree));

          -- parametry
          if inst^.profile.par<>nil

            -- nějaké máme => zapsat
            then
              -- zapsat počet parametrů
              f.write_unsigned(inst^.profile.par^:length);

              -- zapsat jednotlivé parametry
              for i in inst^.profile.par^:range loop
                -- reference na parametr
                write_entity_ref(inst^.profile.par^[i].pparam);

                -- offset na stacku
                f.write_unidata_addr(signed_to_unidata_addr(inst^.profile.par^[i].ofs));

                -- velikost
                f.write_unidata_size(unsigned_to_unidata_size(inst^.profile.par^[i].size));
                end loop;

            -- žádné nejsou => je to jednoduché
            else
              f.write_unsigned(0);
              end if;

          -- tag konce
          f.write_cr(cr_end);

          -- další instance
          inst:=inst^.next;
          end loop;

        -- tag konce
        f.write_cr(cr_end);
        end declare;
      end process_entity_code;



    ------------------------------------------------------------------------------------------------
    override process_entity_compile =
    -- Zápis entity: Kompilační jednotka.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(node);
      f.write_partition_type(node^.part_type);     -- typ partition
      f.write_partition_result(node^.part_result); -- výsledný tvar přeložené partition
      f.write_external_entity_ident(node^.part_extid); -- externí identifikátor partition
      
      -- uložit image-base této partition
      f.write_unicode_addr(os^.getimagebase(node^));
      
      -- uložit stack reserve této partition
      if node^.part_type in parts_contains_runtime then
        f.write_unidata_size(os^.getstackreserve(node^));
        end if;
      end process_entity_compile;



    ------------------------------------------------------------------------------------------------
    override process_entity_program =
    -- Zápis entity: program.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(node);
    {
    ? export_info  : p_flex_record;              -- informace pro export
    }
      end process_entity_program;



    ------------------------------------------------------------------------------------------------
    override process_entity_module =
    -- Zápis entity: modul.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);
    {
    ? lib_info     : p_flex_record;              -- informace knihovnika
    }
      end process_entity_module;



    ------------------------------------------------------------------------------------------------
    override process_entity_init =
    -- Zápis entity: modul.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);

      write_refimm(node^.init);                  -- inicializační výraz
      end process_entity_init;



    ------------------------------------------------------------------------------------------------
    override process_entity_value =
    -- Zápis entity: Prvek s proměnnou hodnotou
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_init(node);
    {
    - rta_fixed    : t_logical;                  -- T-množina použitých dynamických atributů je
                                                 -- fixovaná a nelze ji již měnit
    }
      write_reftype(node^.typ);              -- typ promenne
      f.write_rtattribset(node^.rta_avail);        -- teoreticky poskytované dynamické atributy
      f.write_rtattribset(node^.rta_used);         -- fakticky použité dynamické atributy
      end process_entity_value;



    ------------------------------------------------------------------------------------------------
    override process_entity_param =
    -- Zápis entity: Formální parametr
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(node);
    {
    ? size         : tunidata_size;              -- velikost (s přihlédnutím k způsobu předání)
    }
      
      f.write_parammode(node^.mode);             -- mód parametru
      f.write_parampass(node^.pass);             -- způsob předání parametru
      f.write_mem_aliased(node^.paliased);       -- povolení aliased přístupu
      end process_entity_param;



    ------------------------------------------------------------------------------------------------
    override process_entity_var =
    -- Zápis entity: Proměnná
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      process_entity_value(node);
    {
      -- programátorem předefinovatelné atributy
    - attr_position: cc_ref.refexpr;             -- pozice složky recordu

      -- exportni informace
    ? export_info  : p_flex_record;              -- informace pro export
    }
      f.write_memclass(node^.mclass);            -- třída proměnné                                        
      f.write_varflagset(node^.vflags);          -- další příznaky                                        
      f.write_varmode(node^.vmode);              -- mód přístupu k proměnné                               
      f.write_varaccess(node^.vaccess);          -- determinace přístupu                                  
      f.write_mem_aliased(node^.valiased);       -- příznak, zda je možné získat adresu proměnné (ALIASED)
      f.write_varimplements(node^.vimplements);  -- jakou "higher-order" konstrukci proměnná implementuje 
      write_entity_ref(node^.imp_param);         -- související parametr

      -- adresa promenne
      if node^.mclass in mcs_offset

        -- pro složky tříd a recordů je adresa přímo součástí proměnné
        then f.write_unidata_addr(node^.addr);

        -- pro normální proměnné se musíme zeptat generátoru kódu
        else
          verify({VERIFY=}001379,node^.codegen=nil);

          -- %%TODO(PORTABILITY) Zobecnit !
          f.write_unidata_addr(prg32_to_unidata_addr(picodegen_var(node^.codegen)^.addr));
          end if;
      end process_entity_var;



    ------------------------------------------------------------------------------------------------
    override process_entity_const =
    -- Zápis entity: Konstanta.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(node);

      f.write_constflagset(node^.cflags);        -- modifikátory
      end process_entity_const;



    ------------------------------------------------------------------------------------------------
    override process_entity_subprogram =
    -- Zápis entity: Podprogram
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(node);

      f.write_instancepass(node^.instance);       -- předávání instance
      write_reftype(node^.typ);                  -- typ podprogramu
      end process_entity_subprogram;



    ------------------------------------------------------------------------------------------------
    override process_entity_static_subprogram =
    -- Zápis entity: Podprogram
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(node);
    {
    ? import_info  : p_flex_record;              -- informace pro import
    ? export_info  : p_flex_record;              -- informace pro export
    }
      
      f.write_logical(node^.no_return);          -- T-z tohoto podprogramu se to již nevrátí
      end process_entity_static_subprogram;



    ------------------------------------------------------------------------------------------------
    override process_entity_procedure =
    -- Zápis entity: Procedura
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_static_subprogram(node);
      end process_entity_procedure;



    ------------------------------------------------------------------------------------------------
    override process_entity_static =
    -- Zápis entity: Statická metoda
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_static_subprogram(node);
      end process_entity_static;



    ------------------------------------------------------------------------------------------------
    override process_entity_virtual =
    -- Zápis entity: Virtuální metoda
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(node);
      f.write_vcalltype(node^.vcall);            -- typ virtuálního volání
      f.write_virtualindex(node^.vindex);        -- index virtuální metody
      end process_entity_virtual;



    ------------------------------------------------------------------------------------------------
    override process_entity_override =
    -- Zápis entity: Přetížení virtuální metody
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(node);
      write_refentity(node^.virt);               -- související virtuální metoda
      write_refinterface(node^.interface);       -- související interface
      end process_entity_override;



    ------------------------------------------------------------------------------------------------
    override process_entity_special =
    -- Zápis entity: Speciální metoda
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(node);
      f.write_spectype(node^.spectype);          -- typ speciální metody                       
      f.write_specobject(node^.specobj);         -- objekt, ke kterému se spec. metoda vztahuje
      end process_entity_special;



    ------------------------------------------------------------------------------------------------
    override process_entity_task =
    -- Zápis entity: Task
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(node);
      end process_entity_task;



    ------------------------------------------------------------------------------------------------
    override process_entity_macro =
    -- Zápis entity: Makro
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(node);
      end process_entity_macro;



    ------------------------------------------------------------------------------------------------
    override process_entity_overload0 =
    -- Zápis entity: Společný základ přetížení a operátoru
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);

      verify({VERIFY=}001172,node^.table=nil);
      
      -- pocet procedur
      f.write_unsigned32(node^.table^:length);

      -- tabulka přetížených procedur
      for i in node^.table^:range loop
        write_refentity(node^.table^[i].psym);
        f.write_ooperarity(node^.table^[i].arity);
        end loop;
      end process_entity_overload0;



    ------------------------------------------------------------------------------------------------
    override process_entity_overload =
    -- Zápis entity: Přetížení
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_overload0(node);
    {
      složka [arity] v [table] z předka nemá význam
    }
      end process_entity_overload;



    ------------------------------------------------------------------------------------------------
    override process_entity_operator =
    -- Zápis entity: Operátor
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_overload0(node);

      f.write_ooperator(node^.oop);              -- přetížitelný operátor 
      end process_entity_operator;



    ------------------------------------------------------------------------------------------------
    override process_entity_enum =
    -- Zápis entity: Prvek výčtového typu.
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);
    {
    ? order        : t_unsigned;                 -- pořadí deklarace
      -- programátorem předefinovatelné atributy
    - attr_ord     : cc_ref.refexpr;             -- :ord
    }
      
      write_entity_ref(node^.typ);               -- související výčtový typ
      f.write_uniint(node^.ordinal);             -- ordinální hodnota
      end process_entity_enum;



    ------------------------------------------------------------------------------------------------
    override process_entity_type =
    -- Zápis entity: Typ
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_ia32.ci_abi;
    
    begin
      process_entity_init(node);
    {
      ----- %%TECH Upozornění ----------------------------------------------------------------------
      -- Při přidávání nové složky nezapomeň doplnit její kopírování nebo
      -- jinou příslušnou akci do CD_EVAL.E_TYPE_DERIVED.
      ----------------------------------------------------------------------------------------------
      -- specifikace obecného typu
    - tkind        : typekind;                   -- druh typu
    + stype        : tdatatype;                  -- o jaký typ se jedná
    => konvertuje se na record tag
      -- %%X má smysl udržovat oddělené EVAL a SEVAL ?
    - seval        : tentityeval;                -- vyhodnocení specifikace
    + size         : tunidata_size;              -- velikost typu
    + derive       : typederive;                 -- typ derivace
    - extofs       : tunidata_addr;              -- posunutí extension
    + tflags       : typeflagsset;               -- flagy typu
    + compat       : typecompat;                 -- determinace kompatibility
    - expr         : cc_ref.refexpr;             -- související výraz
    + align        : tunidata_size;              -- zarovnání složek typu
    + native_align : t_logical;                  -- nativní zarovnání složek menších než [align]
    + tinit        : typeinit;                   -- způsob inicializace typu
    + stable       : tspectable;                 -- tabulka speciálních metoda
      -- %%TECH CCLASS slouží jako cache na výsledek výpočtu procedury         
      -- CC_TYPE.T_CONTAINS_CLASS
    - cclass       : tcontainsclass;-- příznak, zda typ obsahuje instanci třídy
      -- specifikace typu s bázovým typem
    + base         : cc_ref.reftype;             -- bázový typ
      -- specifikace ordinálního typu
    + lval         : tuniint;                    -- ordinalni hodnota dolni meze
    + hval         : tuniint;                    -- ordinalni hodnota horni meze
    + bits         : tunidata_bitsize;           -- velikost v bitech
      -- specifikace celočíselného typu
    + intaritm     : tintaritm;                  -- typ celočíselné aritmetiky
      -- specifikace typu reálné číslo
    + fp           : tfloatparams;               -- parametry reálného čísla
      -- specifikace typu s rozsahem
    + srange       : cc_ref.reftype;             -- rozsah
    + saliased     : t_mem_aliased;              -- příznak, zda je možné získat adresu složky (ALIASED)
      -- specifikace typu string
    --lsize        : tunidata_size;              -- velikost délky řetězce
      -- specifikace typu pointer
    + pflags       : ptrflagsset;                -- modifikátory
    + pclass       : ptrclass;                   -- cílový objekt
    + pbase        : ptrbase;                    -- kompatibilita báze
    + pattrib      : rtattribset;                -- atributy pointeru
    + paccess      : varaccess;                  -- přístup k objektu
      -- specifikace typu procedura nebo zprava
    + rflags       : procflagset;                -- další parametry
    + result       : pentity_param;              -- návratová hodnota funkce
    - parcount     : t_unsigned;                 -- počet parametrů
    + call_conv    : p_flex_record;              -- volaci konvence
      -- specifikace třídy
    + interfaces   : p_interface_list;           -- seznam všech interfaců třídy
      -- programátorem předefinovatelné atributy
    - attr_align   : cc_ref.refexpr;             -- :alignment
    - attr_native_align : cc_ref.refexpr;        -- :native_alignment
    - attr_size    : cc_ref.refexpr;             -- :size
    - attr_mptr    : cc_ref.refexpr;             -- :machine_pointer
    }
      -- typ typ
      f.write_datatype(node^.stype);

      -- spolecne vlastnosti vsech typu
      f.write_unidata_size(node^.size);          -- velikost typu
      f.write_typederive(node^.derive);          -- typ derivace
      f.write_typeflagsset(node^.tflags);        -- flagy typu
      f.write_typecompat(node^.compat);          -- determinace kompatibility
      f.write_unidata_size(node^.align);         -- zarovnání složek typu
      f.write_logical(node^.native_align);       -- nativní zarovnání složek menších než [align]
      f.write_typeinit(node^.tinit);             -- způsob inicializace typu
      
      -- tabulka speciálních metod
      -- pocet elementu
      --f.write_unsigned32(node^.stable:length);
      
      -- jednotlive elementy
      for i in node^.stable:range loop
        write_refentity(node^.stable[i]);
        end loop;

      -- typ s bazi
      if node^.stype in dts_base then
        write_reftype(node^.base);               -- bazovy typ
        end if;
      
      -- ordinal
      if node^.stype in dts_u_ordinal then
        f.write_uniint(node^.lval);              -- ordinalni hodnota dolni meze  
        f.write_uniint(node^.hval);              -- ordinalni hodnota horni meze 
        f.write_unidata_bitsize(node^.bits);     -- velikost v bitech
        end if;

      -- cele cislo
      if node^.stype in dts_u_integer then
        f.write_tintaritm(node^.intaritm);       -- typ celočíselné aritmetiky
        end if;

      -- realne cislo
      if node^.stype in dts_u_float or node^.stype in dts_u_fixed then
        declare var
          params       : pfloatsparams;
        
        begin
          -- verify({VERIFY=}001122,node^.fp.sparams=nil);

          f.write_unireal(node^.fp^.fdelta);                   -- přesnost   
          f.write_uniint(node^.fp^.fdigits);                   -- počet míst
          f.write_unilogical(node^.fp^.rounding);              -- T-zaokrouhlování
          f.write_unilogical(node^.fp^.oflw);                  -- T-přetečení způsobí CONSTRAINT_ERROR
          if node^.fp^.sparams<>nil 
            then
              f.write_unsigned8(1);
              f.write_unireal(node^.fp^.sparams^.low);             -- nejmenší číslo
              f.write_unireal(node^.fp^.sparams^.high);            -- největší číslo
              f.write_unireal(node^.fp^.sparams^.small);           -- nejmenší číslo větší než 0
              f.write_uniint(node^.fp^.sparams^.emin);             -- nejmenší exponent
              f.write_uniint(node^.fp^.sparams^.emax);             -- největší exponent
              f.write_unilogical(node^.fp^.sparams^.signed_zeros); -- T-rozlišuje se +/- 0
              f.write_unireal(node^.fp^.sparams^.positive_inf);    -- Positive Infinity
              f.write_unireal(node^.fp^.sparams^.negative_inf);    -- Negative Infinity
              f.write_unireal(node^.fp^.sparams^.positive_zero);   -- Positive Zero
              f.write_unireal(node^.fp^.sparams^.negative_zero);   -- Negative Zero
              f.write_unireal(node^.fp^.sparams^.not_a_number);    -- Not a Number
            else
              f.write_unsigned8(0);
              end if;
          end declare;
        end if;

      -- typ s rozsahem
      if node^.stype in dts_u_index then
        write_reftype(node^.srange);             -- rozsah
        f.write_mem_aliased(node^.saliased);     -- příznak, zda je možné získat adresu složky (ALIASED)
        end if;

      -- retezec
      if node^.stype in dts_u_string then
        -- nic
        end if;

      -- pointer
      if node^.stype in dts_u_pointer then
        f.write_ptrflagsset(node^.pflags);       -- modifikátory      
        f.write_ptrclass(node^.pclass);          -- cílový objekt     
        f.write_ptrbase(node^.pbase);            -- kompatibilita báze
        f.write_rtattribset(node^.pattrib);      -- atributy pointeru 
        f.write_varaccess(node^.paccess);        -- přístup k objektu 
        end if;

      -- procedura
      if node^.stype=dt_procedure then
        f.write_procflagset(node^.rflags);       -- další parametry
        write_entity_ref(node^.result);          -- návratová hodnota funkce

        -- %%TODO(PORTABILITY) Zobecnit !
        declare var
          callconv : icallconvention;

        begin
          callconv:=i_get_convention_proctype^(node^);
          f.write_icallconvention(callconv);     -- volaci konvence
          end declare;
        end if;

      -- zprava
      if node^.stype in dts_message then
        -- HYNEK - nejake atributy pro zpravu??
        end if;
        
      -- adresa deskriptoru typu
      write_codegen_type(node^.codegen);
       
      -- trida
      if node^.stype in dts_class then
        declare var
          it        : c_list_iterator;
          interface : p_class_interface;
        
        begin
          verify({VERIFY=}001124,node^.interfaces=nil);

          -- HYNEK - konflikt jmen s [c_class_interface.is_exposed], [get_exposed_interfaces] by 
          -- mela vratit i interfejci z bazovych trid iterator na exposovane interfejci krome nativniho

          -- zapsat virtuální tabulku nativního interfacu
          write_interface_vtable(node^.interfaces^.get_native_interface);
          
          -- zapsat počet exposeovaných interfaců
          f.write_unsigned32(node^.interfaces^.exposed_interfaces);
          
          -- zapsat všechny exposeované interfacy
          node^.interfaces^.get_exposed_interfaces(it);
          while it.get(interface) loop
            write_interface(interface);            
            end loop;
          end declare;
        end if;

      -- HYNEK - nevynechalo se neco???
      end process_entity_type;


    
    ------------------------------------------------------------------------------------------------
    override process_entity_attribute =
    -- Zápis entity: Atribut
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(node);
      end process_entity_attribute;




    ------------------------------------------------------------------------------------------------
    override process_entity_message =
    -- Zápis entity: Zpráva
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      process_entity_base(node);
      write_reftype(node^.typ);                  -- typ zprávy

      -- adresa deskriptoru zprávy
      if node^.codegen<>nil 
        -- %%TODO(PORTABILITY) Zobecnit !
        then f.write_unidata_addr(prg32_to_unidata_addr(picodegen_type(node^.codegen)^.desc_addr))
        else f.write_unidata_addr(uda_0);
        end if;
      end process_entity_message;



    ------------------------------------------------------------------------------------------------
    override process_entity_label =
    -- Zápis entity: Návěští
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);
      -- tato entitita se sem při ctdl_public nesmí dostat!
    {
  ?   num          : t_unsigned;                 -- cislo navesti
  ? --addr         : tuniprg;                    -- adresa navesti
  ?   reachable    : t_logical;                  -- přístupné jako cíl skoku
  ?   placed       : t_logical;                  -- návěští bylo umístěno
  ?   level        : t_unsigned;                 -- úroveň umístění návěští
    }
      end process_entity_label;



    ------------------------------------------------------------------------------------------------
    override process_entity_tparam =
    -- Zápis entity: Parametr šablony
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(node);
      end process_entity_tparam;



    ------------------------------------------------------------------------------------------------
    override process_entity_template =
    -- Zápis entity: Šablona
    ------------------------------------------------------------------------------------------------
    var
      plex         : plexnode;
      pocet_uzlu   : t_unsigned32;

    begin
      process_entity_base(node);
    {
    + plex         : plexnode;                   -- obsah metasymbolu
    }

      -- spočítat uzly
      plex:=node^.plex;
      while plex<>nil loop
        succ pocet_uzlu;
        plex:=plex^.next;
        end loop;

      -- zapsat počet uzlů
      f.write_unsigned32(pocet_uzlu);

      -- zapsat postupně všechny uzly
      plex:=node^.plex;
      while plex<>nil loop
        -- zapsat typ uzlu
        f.write_unsigned8(plex^._tag:ord);
        
        -- podle typu uzlu zapsat doplňující informaci
        case plex^._tag
          -- parametr
          when _tag_param do 
              write_entity_ref(plexnode_param(plex)^.pparam);
          
          -- lex
          when _tag_lex do 
              write_lexnode_lex(plexnode_lex(plex));

          -- jine neumime
          when others do verify({VERIFY=}001116,true);
          end case;

        -- další uzel
        plex:=plex^.next;
        end loop;
      end process_entity_template;



    ------------------------------------------------------------------------------------------------
    override enter_region =
    --
    ------------------------------------------------------------------------------------------------
    begin
      -- tag regionu
      f.write_cr(cr_region);

      -- CTM identifikator regionu
      f.write_ci(ctm_id^.get_ctm_region_id(region));
      end enter_region;


    
    ------------------------------------------------------------------------------------------------
    override leave_region =
    --
    ------------------------------------------------------------------------------------------------
    begin
      f.write_cr(cr_end);
      end leave_region;
    


    ------------------------------------------------------------------------------------------------
    override process_region =
    -- proces regionu - zapis atributu regionu
    ------------------------------------------------------------------------------------------------
    begin
      -- typ regionu
      f.write_regiontype(region^.rtype);

      -- WITH tabulka
      declare var
        count      : t_unsigned32;
        
      begin  
        -- spočítat exportovatelné vazby
        if region^.withtable<>nil then
          for i in region^.withtable^:range loop
            if is_exportable(region^.withtable^[i].entity.getcentity) then
              count+1;
              end if;
            end loop;
          end if;
        
        -- zapsat počet položek WITH tabulky
        f.write_unsigned32(count);
        
        -- zapsat jednotlivé položky
        if count<>0 then
          for i in region^.withtable^:range loop
            if is_exportable(region^.withtable^[i].entity.getcentity) then
              f.write_with_mode(region^.withtable^[i].mode);    -- režim vazby
              write_refentity(region^.withtable^[i].entity);    -- symbol
              f.write_with_level(region^.withtable^[i].level);  -- úroveň vazby
              f.write_logical(region^.withtable^[i].automatic); -- automaticky WITH/USE?
              end if;
            end loop;
          end if;
        end declare;
        
      -- implicitni viditelnost vnorenych prvku
      -- f.write_entityvisible(region^.vsect);
      end process_region;

    

    ------------------------------------------------------------------------------------------------
    override enter_node =
    -- Vstup do entity: generovat start tag, CTM ID a popřípadě identifikátor entity.
    ------------------------------------------------------------------------------------------------
    begin
      -- je co zapisovat?
      if not process then return; end if;

      -- CTM record tag
      if node^.etype in ets_type
        -- typy se oštřují zvlášť
        then f.write_cr(cr_by_dtype[pentity_type(node)^.stype]);

        -- ostatní entity standardním způsobem
        else f.write_cr(cr_by_etype[node^.etype]);
        end if;

      -- CTM identitifikátor entity
      f.write_ci(ctm_id^.get_ctm_entity_id(node));

      -- textový identifikátor entity
      f.write_entityident(node^.id);
      end enter_node;



    ------------------------------------------------------------------------------------------------
    override leave_node =
    -- Vstup do entity: generovat end tag.
    ------------------------------------------------------------------------------------------------
    begin
      -- je co zapisovat?
      if not process then return; end if;

      -- koncový tag
      f.write_cr(cr_end);
      end leave_node;



    ------------------------------------------------------------------------------------------------
    static save_ctm_header (
        compi      : in pentity_compile) =       -- související kompilační jednotka
    -- Uloží záhlaví CTM souboru.
    ------------------------------------------------------------------------------------------------
    begin
      -- tag začátku hlavičky
      f.write_cr(cr_header);
      
      -- číslo verze CTM
      f.write_ctm_version(ctm_curr_version);
      
      -- koncový tag
      f.write_cr(cr_end);
      end save_ctm_header;



    ------------------------------------------------------------------------------------------------
    static save_import (
        curr_root  : in pentity_compile) =       -- kořenová entita
    -- Uloží tabulky pro import z jiných partition.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym;
      
    var 
      it           : c_ctm_id_partitioned_registry.c_ctm_id_partitioned_registry_iterator;
      partition    : t_partition_id;             -- ID právě zpracovávané partition
      root         : pentity_compile;            -- root entita právě zpracovávané partition

    begin
      -- tag začátku tabulky
      f.write_cr(cr_import);
      
      -- zpracovat všechny partition
      it.init(ctm_id);
      while it.get_partition(partition,root) loop
        -- importují se jen entity z non-current partition
        if partition<>curr_root^.partition_id then
          -- tag začátku tabulky
          f.write_cr(cr_import_partition);

          -- uložit externí jméno partition
          f.write_external_entity_ident(root^.part_extid);
{
          -- uložit image-base cizí partition
          f.write_unicode_addr(os^.getimagebase(root^));
}
          -- uložit importy jednotlivých entit
          declare var
            entity : pentity;                    -- entita z externí partition
            ctm_id : t_ctm_entity_id;            -- odpovídající CTM ID

          begin
            -- zpracovat všechny entity
            while it.get_entity(entity,ctm_id) loop
              declare var
                qid : p_qualified_entity_ident;  -- kvalifikovaný identifikátor entity
                s   : t_char32str;
                
              begin
                -- tag začátku položky tabulky
                f.write_cr(cr_import_entry);

                -- CTM ID
                f.write_ci(ctm_id);
                
                -- co je entita zač
                write_entity_cr(entity);

                -- kvalifikovaný identifikátor entity
                qid:=string_to_qualified_entity_ident(sym_get_qid(entity));
                f.write_qualified_entity_ident(qid);

                -- tag konce tabulky
                f.write_cr(cr_end);
                
              leave  
                -- uvolnit paměť
                discard qid;
                end declare;
              end loop;
            end declare;
          
          -- tag konce tabulky
          f.write_cr(cr_end);
          end if;
        end loop;

      -- tag konce tabulky
      f.write_cr(cr_end);
      end save_import;



    ------------------------------------------------------------------------------------------------
    static save_rtl_table =
    -- Uloží konfiguraci RTL procedur.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_rtl;

    var
      entity       : pentity;                    -- entita přiřazená dané interní entitě

    begin
      -- tag začátku tabulky
      f.write_cr(cr_rtl);

      -- postupně zpracovat všechny RTL entity
      for rtl in t_rtl_entity loop
        -- zjistit přiřazenou entitu
        rtl_get_entity_internal(rtl,entity);

        -- je-li přiřazena, exportovat
        if entity<>nil then
          -- entita musela být vyexportována
          check_error({CCERR=}000641,not is_exportable(entity));
          
          -- tag začátku položky tabulky
          f.write_cr(cr_rtl_entry);

          -- identifikátor
          declare var
            id     : pentityident;               -- identifikátor interní entity
          begin
            rtl_get_entity_id(rtl,id);
            f.write_entityident(id);
            end declare;

          -- CTM identitifikátor přiřazené entity
          write_entity_ref(entity);

          -- tag konce položky tabulky
          f.write_cr(cr_end);
          end if;
        end loop;

      -- tag konce tabulky
      f.write_cr(cr_end);
      end save_rtl_table;



    ------------------------------------------------------------------------------------------------
    static ctm_save =
    -- Uloží proud compile-time metadat do zadaného výstupního streamu.
    ------------------------------------------------------------------------------------------------
    var
      memory_buffer : c_passive_buffered_stream_connector; -- buffer na předzpracovaný strom entit

    begin
      new ctm_id;

      -- poznamenat si požadovanou úroveň metada
      detail_level:=level;
      if level>ctdl_public then unimplemented({UNIMP=}000274) end if;

      -- inicializovat výstupní formatter, jako výstupní stream přiřadit buffer
      f.init_writer(^c_output_stream:(memory_buffer));
      f.set_lazy_buffer(true);

      -- nastavit filtr itertátoru
      set_processing_filter(tentitytypeset:full,processing_visibility[detail_level]);
      set_traversal_filter (tentitytypeset:full,traversal_visibility[detail_level]);

      -- %%TODO(CTM) Nějaký advanced filtr na příznak slinkování entity - nelze přeci exportovat 
      -- neslinkované entity (pro [ctdl_precompiled] samozřejmě vynechat)

      -- zpracovat strom entit a výsledek nabufferovat
      traverse_entity(root_entity);

      -- zpracovat tabulku RTL procedur
      if root_entity^.part_type in parts_contains_runtime then
        save_rtl_table;
        end if;

      -- změnit výstupní stream výstupního formatteru na skutečný soubor
      -- POZOR: toto je trik, čistší by bylo použít dva formattery (jeden nad memory bufferem a
      -- jeden nad souborem), jenže formatter bych si musel předávat do asi 50 procedur a na to
      -- teď (18.2.2004 15:55, dva dny před termínem JIT překladače) opravdu nemám čas. Ondra.
      f.set_lazy_buffer(false);  -- takový Half-Flush (něco jako Half-Life)
      f.init_writer(output);
      f.set_lazy_buffer(true);

      -- uložit záhlaví souboru
      save_ctm_header(root_entity);

      -- uložit tabulky pro import z jiných partition
      save_import(root_entity);

      -- případně nacachovaná data uložit, ať je možné uložit nabufferovaný strom entit
      f.flush;

      -- uložit nabufferovaný strom entit a tabulku RTL procedur
      --c_output_stream:(memory_buffer).close;
      c_output_stream:(memory_buffer).write_eod;
      c_input_stream:(memory_buffer).transfer_all_packets(output);

    leave
      discard ctm_id;
      end ctm_save;

    end c_ctm_writer;



----------------------------------------------------------------------------------------------------
class private {abstract} c_ctm_reader =
-- Compile-time matadata reader.
----------------------------------------------------------------------------------------------------

    with
      cc_def.cc_entity.cc_ref,
      cc_registry,
      cc_formatters;

    var
      -- registr polozek s pridelenymi CTM IDs
      ctm_id       : ^c_ctm_id_import_registry;

      -- vstupní formatter
      f            : c_ctm_binary_reader;



    ------------------------------------------------------------------------------------------------
    static get_known_entity (
        id         : in t_ctm_entity_id)
        return pentity = 
    -- well-known entitu podle CTM ID
    -- v pripade ze [id] neznaci well-known entitu, vrai [nil]
    ------------------------------------------------------------------------------------------------
    begin
      -- podle identifikatoru vrat prislusnou znamou entitu
      case id
        when ci_uniint     do result:=def_uniint;
        when ci_unireal    do result:=def_unireal;
        when ci_unilogical do result:=def_unilogical;
        when ci_unichar    do result:=def_unichar;
        when ci_uninil     do result:=def_uninil;
        when ci_unistr     do result:=def_unistr;
        when ci_inttype_tag    do result:=inttype_tag;
        when ci_inttype_status do result:=inttype_status;
        when ci_inttype_machine_pointer do result:=inttype_machine_pointer;
        when others do result:=nil;
        end case;
      end get_known_entity;

    
    
    ------------------------------------------------------------------------------------------------
    static read_entity_ref_internal (
        id         : out t_ctm_entity_id;       -- CTM ID odkazované entity
        entity     : out pentity;                -- nalezená entita
        etype      : out tentitytype;            -- typ entity (i v případě, že nebyla nalezena)
        dtype      : out tdatatype) =
    -- Načte referenci na entitu a pokusí se ji vyhledat v tabulce již zpracovaných entit.
    -- Pokud se entitu nepodaří najít, vrátí v [entity] NIL. V obou případech vrátí [etype] podle
    -- údaje uloženého v referenci. Jestliže je entita typ, vrátí i konkrétní datový typ [dtype],
    -- v ostatních případech je hodnota neurčena.
    --   Pokud je reference prázdná (neukazuje na žádnou entitu), vrátí [id] rovno [ci_none].
    --   Pokud se neshoduje [etype] uložené v referenci s [etype] v nalezené entitě, způsobí interní
    -- chybu.
    ------------------------------------------------------------------------------------------------
    var
      cr           : t_ctm_record_tag;
  
    begin
      -- precti identifikaotr
      f.read_ci(t_ctm_id(id));

      -- prazdna reference?
      if id=ci_none then
        return;
        end if;

      -- typ
      f.read_cr(cr);
      
      -- entita krome entity_type
      if cr>=etype_by_cr:first and cr<=etype_by_cr:last then 
        etype:=etype_by_cr[cr];

      -- entity_type
      elsif cr>=dtype_by_cr:first and cr<=dtype_by_cr:last then 
        dtype:=dtype_by_cr[cr];
      
        -- odvodit typ entity podle datového typu
        if dtype=dt_class
          then etype:=et_class
          else etype:=et_type
          end if;

      -- ostatni tu nema co delat
      else 
        check_error({CCERR=}000622);
        end if;
    
      -- zjistit jestli se nejedna o well-known entitu
      entity:=get_known_entity(id);

      -- pokud ne, tak se podívat do tabulky již zpracovaných entit
      if entity=nil then
        entity:=ctm_id^.get_entity(id);
        end if;

      -- pokud se entita našla, tak zkontrolovat její konfiguraci
      if entity<>nil then
        if entity^.etype<>etype or else (etype in ets_type and pentity_type(entity)^.stype<>dtype) then
          check_error({CCERR=}000623);
          end if;
        end if;
      end read_entity_ref_internal;

    
    
    ------------------------------------------------------------------------------------------------
    static read_entity_ref (
        entity     : out pentity) =              -- nalezená entita
    -- Načte referenci na entitu a zkontroluje korektnost metadat (podrobněji viz popis procedury
    -- [read_entity_ref_internal]). Pokud se nejedná o prázdnou referenci a entita nebyla nalezena,
    -- založí ji.
    ------------------------------------------------------------------------------------------------
    var
      id           : t_ctm_entity_id;            -- CTM ID odkazované entity
      etype        : tentitytype;                -- typ entity uložený v referenci
      dtype        : tdatatype;                  -- datový typ entity, je-li to typ

    begin
      -- zpracovat referenci
      read_entity_ref_internal(id,entity,etype,dtype);

      -- pokud se nejedná o prázdnou referenci a entita nebyla nalezena, tak ji vytvořit
      if entity=nil and id<>ci_none then
        -- neni - vytvor prazdnou a zaregistruj
        if etype in ets_type 
          then ctm_id^.create_entity_type(id,dtype,entity);
          else ctm_id^.create_entity(id,etype,entity);
          end if;
        end if;
      end read_entity_ref;



    ------------------------------------------------------------------------------------------------
    static read_entity_ref_existing (
        entity     : out pentity) =              -- nalezená entita
    -- Načte referenci na entitu. 
    -- Entita již musí existovat. Pokud se entita nenalezne, způsobí chybu.
    ------------------------------------------------------------------------------------------------
    var
      id           : t_ctm_entity_id;            -- CTM ID odkazované entity
      etype        : tentitytype;                -- typ entity uložený v referenci
      dtype        : tdatatype;                  -- datový typ entity, je-li to typ

    begin
      -- zpracovat referenci
      read_entity_ref_internal(id,entity,etype,dtype);

      -- pokud se nejedná o prázdnou referenci a entita nebyla nalezena, je to chyba
      check_error({CCERR=}000636,entity=nil and id<>ci_none);
      end read_entity_ref_existing;

    
    
    ------------------------------------------------------------------------------------------------
    static read_refentity (
        rentity    : out refentity) =            -- reference na entitu
    -- Přečte referenci na entitu.
    ------------------------------------------------------------------------------------------------
    var
      ent          : pentity;

    begin
      read_entity_ref(ent);
      rentity.setentity(ent);
      end read_refentity;


              
    ------------------------------------------------------------------------------------------------
    static read_codegen_type (
        codegen    : out p_flex_record) =        -- informace o generování
    -- Přečte informace o generování typu.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    var
      ud     : tunidata_addr;
      
    begin  
      -- %%TODO(PORTABILITY) Zobecnit !
      
      -- načíst adresu 
      f.read_unidata_addr(ud);
      
      -- nenilovou adresu uložit do informací o generování
      if ud<>uda_0 then
        -- připravit informace o generování
        new picodegen_type(codegen);
        c_garbage_collector.get_instance^.register_record(codegen);

        -- uložit adresu do informací o generování
        picodegen_type(codegen)^.desc_addr:=tprg32(unidata_addr_to_unsigned(ud));
        end if;
      end read_codegen_type;


           
    ------------------------------------------------------------------------------------------------
    static read_refinterface (
        iface      : out p_class_interface) =
    -- Přečte odkaz na interface.
    ------------------------------------------------------------------------------------------------
    var
      refclass     : pentity_type;               -- odkazovaná třída
      iface_index  : t_unsigned;                 -- index interfacu v rámci třídy
      
    begin
      -- odkaz na obalující třídu s daným interfacem
      read_entity_ref(refclass);
      
      if refclass<>nil then
        -- index interfacu
        f.read_unsigned(iface_index);
        
        -- dohledat interface podle indexu
        iface:=refclass^.interfaces^.get_interface_by_index(iface_index);
        check_error({CCERR=}000637,iface=nil);
        end if;
      end read_refinterface;
      


    ------------------------------------------------------------------------------------------------
    static read_interface_vtable (
        iface      : in p_class_interface) =
    -- Přečte virtuální tabulku uvedeného interfacu.
    ------------------------------------------------------------------------------------------------
    var
      count : t_unsigned32;

    begin
      -- počet položek virtuální tabulky
      f.read_unsigned32(count);
      
      if count>0 then
        -- založit virtuální tabulku
        new iface^.vtable range count;
        
        -- přečíst položky virtuální tabulky
        for i in 1..count loop
          succ iface^.vtable^:length;
          read_entity_ref(iface^.vtable^[iface^.vtable^:length]);
          end loop;
        end if;
      end read_interface_vtable;
      
      
           
    ------------------------------------------------------------------------------------------------
    static read_interface (
        context    : in tcontext)                -- kontext        
        return p_class_interface =
    -- Přečte definici interfacu.
    ------------------------------------------------------------------------------------------------
    begin
      new result;

      -- související třída
      read_refentity(result^.refclass);
      check_error({CCERR=}000624,not result^.refclass.isset);

      -- instance interfacu
      read_refentity(result^.instance);
      check_error({CCERR=}000625,not result^.instance.isset);

      -- virtuální tabulka
      read_interface_vtable(result);
        
      -- původní interface
      read_refinterface(result^.org_interface);

      -- interface index
      f.read_unsigned(result^.interface_index);
      
      -- informace o generování
      read_codegen_type(result^.codegen);
      end read_interface;



    ------------------------------------------------------------------------------------------------
    static read_reftype (
        context    : in tcontext)                -- kontext        
        return reftype =
    -- Přečte referenci na typ.
    ------------------------------------------------------------------------------------------------
    var
      ent          : pentity;

    begin
      read_entity_ref(ent);
      
      -- prazdna reference?
      if ent=nil then
        return;
        end if;

      -- ent musi byt [tentity_type]
      check_error({CCERR=}000626,ent^.etype not in ets_type);

      -- nastav navratovou hodnotu
      result.settype(pentity_type(ent));
      end read_reftype;


    
    ------------------------------------------------------------------------------------------------  
    static read_imm_value (
        context    : in tcontext;                -- kontext            
        result     : out timm_value) =           -- přečtená přímá hodnota
    -- Přečte přímou hodnotu.
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    var
      count        : t_unsigned32;

    begin
      -- typ hodnoty
      f.read_immclass(result.ic);

      -- typ?
      case result.ic
        -- nedefinovana hodnota
        when ic_undef do ;
        
        -- ordinal
        when ic_ordinal do f.read_uniint(result.ui);
        
        -- real
        when ic_real do f.read_unireal(result.ur);
        
        -- nil
        when ic_nil do ;
        
        -- string
        when ic_condensed do 
            -- pocet prvku [citems.items^]
            f.read_unsigned32(count);
            new result.citems.items range count;
            c_garbage_collector.get_instance^.register_memblock(result.citems.items);
            
            -- pocet prvku
            f.read_unsigned(result.citems.len);
            
            -- velikost prvku
            f.read_unsigned(result.citems.isize);
            
            -- prvky
            for i in result.citems.items^:range loop
              f.read_unsigned8(result.citems.items^[i]);
              end loop;
            
        -- pole
        when ic_array do
            -- pocet slozek
            f.read_unsigned32(count);
            
            -- instance
            new result.aitems;
            c_garbage_collector.get_instance^.register_memblock(result.aitems);

            new result.aitems^.list range count;
            c_garbage_collector.get_instance^.register_memblock(result.aitems^.list);

            -- slozky
            for i in 1..count loop
              declare var
                array_item : timm_array_item;

              begin
                -- spodek
                f.read_uniint(array_item.lval);
                  
                -- svrsek
                f.read_uniint(array_item.hval);
                  
                -- hodnota
                read_imm_value(context,array_item.val);

                -- pridat
                result.aitems^.list^ & array_item;
                end declare;
              end loop;
            
            -- hodnota "others"
            read_imm_value(context,result.aitems^.othersval);
        
        -- record
        when ic_record do
            -- pocet slozek
            f.read_unsigned32(count);

            -- instance
            new result.ritems;
            c_garbage_collector.get_instance^.register_memblock(result.ritems);

            new result.ritems^.list range count;
            c_garbage_collector.get_instance^.register_memblock(result.ritems^.list);
            
            -- slozky
            for i in 1..count loop
              declare var
                record_item : timm_record_item;

              begin
                -- souvisejici entita
                read_entity_ref(record_item.item);
                  
                -- hodnota
                read_imm_value(context,record_item.val);

                -- pridat
                result.ritems^.list^ & record_item;
                end declare;
              end loop;

            -- hodnota "others"
            read_imm_value(context,result.ritems^.othersval);

        -- agr. mnoziny
        when ic_set do
            -- pocet slozek
            f.read_unsigned32(count);
            
            -- instance
            new result.sitems;
            c_garbage_collector.get_instance^.register_memblock(result.sitems);

            new result.sitems^.list range count; 
            c_garbage_collector.get_instance^.register_memblock(result.sitems^.list);
            
            -- slozky
            for i in 1..count loop
              declare var
                set_item : timm_set_item;
              
              begin
                -- spodek
                f.read_uniint(set_item.lval);
                
                -- svrsek
                f.read_uniint(set_item.hval);

                -- pridat
                result.sitems^.list^ & set_item;
                end declare;
              end loop;
        end case;

      -- adresa přímé hodnoty
      -- %%TODO(PORTABILITY) Zobecnit !
      declare var
        ud     : tunidata_addr;
        
      begin  
        -- načíst adresu 
        f.read_unidata_addr(ud);
        
        -- nenilovou adresu uložit do informací o generování
        if ud<>uda_0 then
          -- připravit informace o generování
          new picodegen_imm(result.codegen);
          c_garbage_collector.get_instance^.register_record(result.codegen);

          -- uložit adresu do informací o generování
          picodegen_imm(result.codegen)^.addr:=tprg32(unidata_addr_to_unsigned(ud));
          end if;
        end declare;
          
      -- HYNEK - nevynechalo se neco???
      end read_imm_value;



    ------------------------------------------------------------------------------------------------
    static read_refimm (
        context    : in tcontext)                -- kontext        
        return refimm =
    -- Přečte referenci na přímou hodnotu.
    ------------------------------------------------------------------------------------------------
    begin
      read_imm_value(context,result.getundefimm^);
      end read_refimm;



    ------------------------------------------------------------------------------------------------
    static read_lexaggregate (
        paggregate : out plexaggregate) = 
    -- Zapis lexaggregate. pokud [str] nil, zapise prazdny retezec
    ------------------------------------------------------------------------------------------------
    var
      count   : t_unsigned32;
      char    : tunichar;

    begin
      -- pocet
      f.read_unsigned32(count);
      
      -- instance
      new paggregate range count;
      c_garbage_collector.get_instance^.register_memblock(paggregate);
      
      -- polozky
      for i in 1..count loop
        f.read_unichar(char);
        -- %%TODO(STRING) nějak nefunguje zřetězení
        succ paggregate^:length;
        paggregate^[paggregate^:length]:=char;
        end loop;
      end read_lexaggregate;
    
    

    ------------------------------------------------------------------------------------------------
    static read_lexnode_param (
        plex       : out plexnode_param) =
    -- Čtení lexikálního uzlu šablony reprezentujícího parametr.
    ------------------------------------------------------------------------------------------------
    begin
      -- alokovat paměť
      new plex;
      c_garbage_collector.get_instance^.register_record(plex);

      plex^._tag:=_tag_param;
      
      -- přečíst odkaz na parametr
      read_entity_ref(plex^.pparam);
      end read_lexnode_param;



    ------------------------------------------------------------------------------------------------
    static read_lexnode_lex (
        plex       : out plexnode_lex) =
    -- Čtení lexikálního uzlu šablony reprezentujícího lexikální element.
    ------------------------------------------------------------------------------------------------
    begin
      -- instance
      new plex;
      c_garbage_collector.get_instance^.register_record(plex);

      plex^._tag:=_tag_lex;

      -- HYNEK - neudelat case node^.xlex? kdyz tech elementu je moc a ostatnich polozek jen par
      f.read_lexsym(plex^.xlex);
      f.read_uniint(plex^.xval.ui);
      f.read_unireal(plex^.xval.ur);
      f.read_entityident(plex^.xval.id);
      f.read_logical(plex^.xval.can_be_kw);
      f.read_lexcharustr(plex^.xval.txt);        -- textová reprezentace elementu
      read_lexaggregate(plex^.xval.str);         -- znakový agregát 
      f.read_unsigned(plex^.xval.code);          -- rezervováno inline assembler
      f.read_logical(plex^.xval.id_used);        -- identifikátor byl použit
      f.read_logical(plex^.xval.txt_used);       -- textový tvar byl použit                                
      end read_lexnode_lex;



    ------------------------------------------------------------------------------------------------
    #template process_entity_base_template;
    -- Šablona načtení základu entity vyjma zařazení do struktury.
    ------------------------------------------------------------------------------------------------
      -- načíst základní údaje
      read_refentity(node.ancestor);
      f.read_visible(node.visible);
      f.read_visible(node.full);
      f.read_logical(node.is_abstract);
      f.read_security_level(node.sec_level);
      f.read_security_level(node.sec_required);

      -- vyplnit další služební údaje
      node.linked:=ls_linked;
      node.analyzed:=as_analyzed;
      node.debugstat:=as_analyzed;
      #end process_entity_base_template;
    


    ------------------------------------------------------------------------------------------------
    static process_entity_base (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity) =
    -- Nacte zaklad entity
    ------------------------------------------------------------------------------------------------
    var
      outcontext   : tcontext;

    begin
      sym_add_entity(^node,context,node.id,outcontext);
      process_entity_base_template;
      end process_entity_base;


                              
    ------------------------------------------------------------------------------------------------
    #template process_entity_code_template;
    -- Šablona načtení základu entity vyjma zařazení do struktury.
    ------------------------------------------------------------------------------------------------
      -- přečíst informace o importu %%TODO(PORTABILITY) Zobecnit !
      declare var
        imported   : t_logical;                  -- T-entita byla importovaná
      
      begin  
        -- přečíst příznak importu
        f.read_logical(imported);
        
        -- přečíst případné importní informace
        if imported then
          declare var
            import_info : pimportinfo;           -- importní informace
            extname     : p_external_entity_ident; -- externí jméno
            libname     : p_external_entity_ident; -- jméno knihovny
            
          begin  
            -- přečíst importní údaje
            f.read_external_entity_ident(extname);
            f.read_external_entity_ident(libname);
          
            -- sestavit importní informace
            os^.create_import_info(extname^,libname^,import_info);

            -- adresa importního stubu
            f.read_unicode_addr(import_info^.addr);
            
            -- dosadit do entity
            set_import_info(^node,import_info);
            end declare;
          end if;
        end declare;  

      -- přečíst všechny instance %%TODO(PORTABILITY) Zobecnit !
      declare var
        cr         : t_ctm_record_tag;
       
      begin
        -- tag začátku seznamu instancí
        f.read_cr(cr);
        check_error({CCERR=}000648,cr<>cr_code_instances);
      
        -- založit informace o generování
        i_prepare(node);
      
        -- zpracovat všechny instance
        loop
          -- přečíst další tag
          f.read_cr(cr);
          case cr
            -- záznam instance
            when cr_code_instance do
                declare var
                  inst : picodeinst;             -- právě zpracovávaná instance
                  
                begin  
                  -- vytvořit a zařadit instanci
                  i_create_instance(node,inst);
                  
                  -- volací konvence této instance
                  f.read_icallconvention(inst^.profile.call);
                  
                  -- adresa instance
                  declare var
                    uca : tunicode_addr;
                  begin  
                    f.read_unicode_addr(uca);
                    inst^.cstart:=unicode_addr_to_unsigned(uca);
                    end declare;
          
                  -- offset THIS parametru
                  declare var
                    uda  : tunidata_addr;
                  begin  
                    f.read_unidata_addr(uda);
                    inst^.profile.thisofs:=unidata_addr_to_signed(uda);
                    end declare;
                  
                  -- kolik bytů uvolnit při návratu z procedury
                  declare var
                    uds : tunidata_size;
                  begin  
                    f.read_unidata_size(uds);
                    inst^.profile.retfree:=unidata_size_to_unsigned(uds);;
                    end declare;
                  
                  -- parametry
                  declare var
                    count : t_unsigned;          -- počet parametrů
                    
                  begin 
                    -- přečíst počet parametrů
                    f.read_unsigned(count);
                    
                    -- alokovat paměť pro parametry
                    new inst^.profile.par range count;
                    c_garbage_collector.get_instance^.register_memblock(inst^.profile.par);
                    
                    -- zpracovat uložené parametry
                    for i in 1..count loop
                      declare var
                        par : iparinfo;
                        
                      begin
                        -- reference na parametr
                        read_entity_ref(par.pparam);
                        
                        -- offset na stacku
                        declare var
                          uda  : tunidata_addr;
                        begin  
                          f.read_unidata_addr(uda);
                          par.ofs:=unidata_addr_to_signed(uda);
                          end declare;
                          
                        -- velikost
                        declare var
                          uds : tunidata_size;
                        begin  
                          f.read_unidata_size(uds);
                          par.size:=unidata_size_to_unsigned(uds);
                          end declare;
                          
                        -- zařadit na seznam parametrů
                        inst^.profile.par^ & par;
                        end declare;
                      end loop;
                    end declare;
                  end declare;
                  
                -- tag konce
                f.read_cr(cr);
                check_error({CCERR=}000650,cr<>cr_end);
            
            -- konec tabulky instancí
            when cr_end do break;
            
            -- nic jiného tu nemá co dělat
            when others do check_error({CCERR=}000649);
            end case;
          end loop;
        end declare;
      #end process_entity_code_template;                        
                              
                              
                     
    ------------------------------------------------------------------------------------------------
    static process_entity_code (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_code) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    with
      supervised cc_binding,
      cg_gen.cg_ia32.ci_def,
      cp_os.cp_win32;
      
    begin
      process_entity_base(context,node);
      process_entity_code_template;
      end process_entity_code;



    ------------------------------------------------------------------------------------------------
    static process_entity_compile (
        context    : in out tcontext;            -- kontext    
        node       : in out tentity_compile) =
    -- Nacte [tentity_compile]
    ------------------------------------------------------------------------------------------------
    with
      supervised cc_binding,
      cc_base.cc_options,
      cg_gen.cg_ia32.ci_def,
      cp_os.cp_win32;
      
    begin
      -- zařadit do hierarchie - kompilační jednotka je vždy vrchol hierarchie
      context.entity:=^node;

      -- načíst entitu (přidání entity do nadřazeného kontextu nemá pro kompilační jednotku smysl,
      -- proto zde nemůžeme volat [process_entity_code], ale musíme to provést oklikou přímým 
      -- rozvojem dvou testových substitucí [process_entity_(base|code)_template].
      process_entity_base_template;
      process_entity_code_template;
      f.read_partition_type(node.part_type);     -- typ partition
      f.read_partition_result(node.part_result); -- výsledný tvar přeložené partition
      f.read_external_entity_ident(node.part_extid); -- externí identifikátor partition
      
      -- načíst image-base této partition
      declare var
        uca        : tunicode_addr;
      begin
        f.read_unicode_addr(uca);
        o_set_option_param_unicode_addr(opt_image_base,node,uca);
        end declare;
      
      -- načíst stack reserve této partition
      if node.part_type in parts_contains_runtime then
        declare var
          uds        : tunidata_size;
        begin
          f.read_unidata_size(uds);
          o_set_option_param_unidata_size(opt_stack_reserve,node,uds);
          end declare;
        end if;
        
      -- kompilační jednotka je vždy globálně viditelná
      node.compile+tentitycompileset:[etc_globaly_visible];
      end process_entity_compile;



    ------------------------------------------------------------------------------------------------
    static leave_entity_compile (
        node       : in out tentity_compile) =
    -- Trigger při opouštění načtení [tentity_compile].
    ------------------------------------------------------------------------------------------------
    with
      supervised cc_base.cc_sym.cc_partition;

    begin
      -- kompilační jednotku zaregistrovat
      part_register_partition(^node);
      end leave_entity_compile;
      
      

    ------------------------------------------------------------------------------------------------
    static process_entity_program (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_program) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(context,node);
      end process_entity_program;



    ------------------------------------------------------------------------------------------------
    static process_entity_module (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_module) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(context,node);
      end process_entity_module;



    ------------------------------------------------------------------------------------------------
    static process_entity_init (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_init) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(context,node);
      node.init:=read_refimm(context);           -- inicializační výraz
      end process_entity_init;



    ------------------------------------------------------------------------------------------------
    static process_entity_value (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_value) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_init(context,node);
      node.typ:=read_reftype(context);           -- typ promenne
      f.read_rtattribset(node.rta_avail);        -- teoreticky poskytované dynamické atributy
      f.read_rtattribset(node.rta_used);         -- fakticky použité dynamické atributy
      end process_entity_value;



    ------------------------------------------------------------------------------------------------
    static process_entity_param (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_param) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(context,node);
      f.read_parammode(node.mode);               -- mód parametru
      f.read_parampass(node.pass);               -- způsob předání parametru
      f.read_mem_aliased(node.paliased);         -- povolení aliased přístupu
      end process_entity_param;



    ------------------------------------------------------------------------------------------------
    static process_entity_var (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_var) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      process_entity_value(context,node);
      f.read_memclass(node.mclass);              -- třída proměnné                                        
      f.read_varflagset(node.vflags);            -- další příznaky                                        
      f.read_varmode(node.vmode);                -- mód přístupu k proměnné                               
      f.read_varaccess(node.vaccess);            -- determinace přístupu                                  
      f.read_mem_aliased(node.valiased);         -- příznak, zda je možné získat adresu proměnné (ALIASED)
      f.read_varimplements(node.vimplements);    -- jakou "higher-order" konstrukci proměnná implementuje 
      read_entity_ref(node.imp_param);           -- související parametr                                  

      -- adresa promenne
      if node.mclass in mcs_offset

        -- pro složky tříd a recordů je adresa přímo součástí proměnné
        then f.read_unidata_addr(node.addr);

        -- pro normální proměnné se musíme zeptat generátoru kódu
        else
          -- %%TODO(PORTABILITY) Zobecnit !
          declare var
            ud     : tunidata_addr;
            
          begin  
            -- připravit informace o generování
            new picodegen_var(node.codegen);
            c_garbage_collector.get_instance^.register_record(node.codegen);

            -- načíst adresu 
            f.read_unidata_addr(ud);
            
            -- uložit adresu do informací o generování
            picodegen_var(node.codegen)^.addr:=tprg32(unidata_addr_to_unsigned(ud));
            end declare;
          end if;
      end process_entity_var;



    ------------------------------------------------------------------------------------------------
    static process_entity_const (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_const) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(context,node);
      f.read_constflagset(node.cflags);          -- modifikátory
      end process_entity_const;



    ------------------------------------------------------------------------------------------------
    static process_entity_subprogram (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_subprogram) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(context,node);
      f.read_instancepass(node.instance);        -- předávání instance
      node.typ:=read_reftype(context);           -- typ podprogramu
      end process_entity_subprogram;



    ------------------------------------------------------------------------------------------------
    static process_entity_static_subprogram (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_static_subprogram) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(context,node);
      f.read_logical(node.no_return);            -- T-z tohoto podprogramu se to již nevrátí
      end process_entity_static_subprogram;



    ------------------------------------------------------------------------------------------------
    static process_entity_procedure (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_procedure) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_static_subprogram(context,node);
      end process_entity_procedure;



    ------------------------------------------------------------------------------------------------
    static process_entity_static (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_static) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_static_subprogram(context,node);
      end process_entity_static;



    ------------------------------------------------------------------------------------------------
    static process_entity_virtual (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_virtual) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(context,node);
      f.read_vcalltype(node.vcall);              -- typ virtuálního volání
      f.read_virtualindex(node.vindex);          -- index virtuální metody
      end process_entity_virtual;



    ------------------------------------------------------------------------------------------------
    static process_entity_override (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_override) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_code(context,node);
      read_refentity(node.virt);                 -- související virtuální metoda
      read_refinterface(node.interface);         -- související interface
      end process_entity_override;



    ------------------------------------------------------------------------------------------------
    static process_entity_special (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_special) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(context,node);
      f.read_spectype(node.spectype);            -- typ speciální metody                       
      f.read_specobject(node.specobj);           -- objekt, ke kterému se spec. metoda vztahuje
      end process_entity_special;



    ------------------------------------------------------------------------------------------------
    static process_entity_task (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_task) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(context,node);
      end process_entity_task;



    ------------------------------------------------------------------------------------------------
    static process_entity_macro (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_macro) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_subprogram(context,node);
      end process_entity_macro;



    ------------------------------------------------------------------------------------------------
    static process_entity_overload0 (
        context    : in tcontext;                -- kontext    
        node       : in out class tentity_overload0) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    var
      count : t_unsigned32;
      desc  : toverloaddesc;
    
    begin
      process_entity_base(context,node);

      -- pocet
      f.read_unsigned32(count);

      -- instance
      new node.table range count;
      c_garbage_collector.get_instance^.register_memblock(node.table);

      -- tabulka přetížených procedur
      for i in 1..count loop
        -- entita
        read_refentity(desc.psym);
        
        -- arita
        f.read_ooperarity(desc.arity);
        
        -- pridat
        succ node.table^:length;
        node.table^[node.table^:length]:=desc;
        end loop;
      end process_entity_overload0;



    ------------------------------------------------------------------------------------------------
    static process_entity_overload (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_overload) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_overload0(context,node);
      end process_entity_overload;



    ------------------------------------------------------------------------------------------------
    static process_entity_operator (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_operator) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_overload0(context,node);
      f.read_ooperator(node.oop);              -- přetížitelný operátor 
      end process_entity_operator;



    ------------------------------------------------------------------------------------------------
    static process_entity_enum (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_enum) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym;
      
    begin
      process_entity_base(context,node);
      read_entity_ref(node.typ);                 -- související výčtový typ
      f.read_uniint(node.ordinal);               -- ordinální hodnota

      -- identifikátor výčtového typu zaregistrovat v nadřazeném kontextu
      sym_add_ident(sym_get_enclosing_context_restricted(^node,ets_no_enum_id2),node.id,^node);
      end process_entity_enum;



    ------------------------------------------------------------------------------------------------
    static process_entity_type (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_type) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def,
      cp_cpu.cp_ia32.ci_abi;
    
      
    begin
      process_entity_init(context,node);

      -- datový typ
      f.read_datatype(node.stype);
      
      -- odvodit druh typu (v některých případech - univerzální typy - zůstane nevyplněn)
      if node.stype in dts_regular then node.tkind:=tk_regular;
      elsif node.stype in dts_singular then node.tkind:=tk_singular;
      end if;
    {
    - extofs       : tunidata_addr;              -- posunutí extension
    - cclass       : tcontainsclass;-- příznak, zda typ obsahuje instanci třídy
    - parcount     : t_unsigned;                 -- počet parametrů
    }
   
      -- spolecne vlastnosti vsech typu
      f.read_unidata_size(node.size);            -- velikost typu
      f.read_typederive(node.derive);            -- typ derivace
      f.read_typeflagsset(node.tflags);          -- flagy typu
      f.read_typecompat(node.compat);            -- determinace kompatibility
      f.read_unidata_size(node.align);           -- zarovnání složek typu
      f.read_logical(node.native_align);         -- nativní zarovnání složek menších než [align]
      f.read_typeinit(node.tinit);               -- způsob inicializace typu
      
      -- jednotlive elementy
      for i in node.stable:range loop
        read_refentity(node.stable[i]);
        end loop;

      -- typ s bazi
      if node.stype in dts_base then
        node.base:=read_reftype(context);        -- bazovy typ
        end if;
      
      -- ordinal
      if node.stype in dts_u_ordinal then
        f.read_uniint(node.lval);                -- ordinalni hodnota dolni meze  
        f.read_uniint(node.hval);                -- ordinalni hodnota horni meze 
        f.read_unidata_bitsize(node.bits);       -- velikost v bitech
        end if;

      -- cele cislo
      if node.stype in dts_u_integer then
        f.read_tintaritm(node.intaritm);       -- typ celočíselné aritmetiky
        end if;

      -- realne cislo
      if node.stype in dts_u_float or node.stype in dts_u_fixed then
        declare var
          empty_params : aliased tfloatsparams;
          params       : pfloatsparams;
          parflag      : t_unsigned8;
        
        begin
          new node.fp;
          c_garbage_collector.get_instance^.register_record(node.fp);

          f.read_unireal(node.fp^.fdelta);       -- přesnost   
          f.read_uniint(node.fp^.fdigits);       -- počet míst
          f.read_unilogical(node.fp^.rounding);  -- T-zaokrouhlování
          f.read_unilogical(node.fp^.oflw);      -- T-přetečení způsobí CONSTRAINT_ERROR
          
          -- je sparams ulozeno?
          f.read_unsigned8(parflag);
          if parflag=1 then
            -- ano - instance
            new node.fp^.sparams;
            c_garbage_collector.get_instance^.register_record(node.fp^.sparams);

            -- nacti
            f.read_unireal(node.fp^.sparams^.low);             -- nejmenší číslo
            f.read_unireal(node.fp^.sparams^.high);            -- největší číslo
            f.read_unireal(node.fp^.sparams^.small);           -- nejmenší číslo větší než 0
            f.read_uniint(node.fp^.sparams^.emin);             -- nejmenší exponent
            f.read_uniint(node.fp^.sparams^.emax);             -- největší exponent
            f.read_unilogical(node.fp^.sparams^.signed_zeros); -- T-rozlišuje se +/- 0
            f.read_unireal(node.fp^.sparams^.positive_inf);    -- Positive Infinity
            f.read_unireal(node.fp^.sparams^.negative_inf);    -- Negative Infinity
            f.read_unireal(node.fp^.sparams^.positive_zero);   -- Positive Zero
            f.read_unireal(node.fp^.sparams^.negative_zero);   -- Negative Zero
            f.read_unireal(node.fp^.sparams^.not_a_number);    -- Not a Number
            end if;
          end declare;
        end if;

      -- typ s rozsahem
      if node.stype in dts_u_index then
        node.srange:=read_reftype(context);      -- rozsah
        f.read_mem_aliased(node.saliased);       -- příznak, zda je možné získat adresu složky (ALIASED)
        end if;

      -- retezec
      if node.stype in dts_u_string then
        -- nic
        end if;

      -- pointer
      if node.stype in dts_u_pointer then
        f.read_ptrflagsset(node.pflags);         -- modifikátory      
        f.read_ptrclass(node.pclass);            -- cílový objekt     
        f.read_ptrbase(node.pbase);              -- kompatibilita báze
        f.read_rtattribset(node.pattrib);        -- atributy pointeru 
        f.read_varaccess(node.paccess);          -- přístup k objektu 
        end if;

      -- procedura
      if node.stype=dt_procedure then
        f.read_procflagset(node.rflags);         -- další parametry
        read_entity_ref(node.result);            -- návratová hodnota funkce
        
        -- %%TODO(PORTABILITY) Zobecnit !
        declare var
          callconv : icallconvention;

        begin
          f.read_icallconvention(callconv);      -- volaci konvence
          i_set_convention_proctype^(node,callconv);
          end declare;
        end if;

      -- zprava
      if node.stype in dts_message then
        -- HYNEK - nejake atributy pro zpravu??
        end if;

      -- adresa deskriptoru typu
      read_codegen_type(node.codegen);

      -- třída
      if node.stype in dts_class then
        declare var
          it        : c_list_iterator;
          interface : p_class_interface;
          icount    : t_unsigned32;

        begin
          -- založit tabulku interfaců
          new node.interfaces;

          -- třída je sama sobě nativním interfacem
          node.interfaces^.add_interface(nil,^node);
          
          -- nativní interface má stejné informace o generování jako typ samotný
          node.interfaces^.get_native_interface^.codegen:=node.codegen;
          
          -- virtuální tabulka nativního interfacu
          read_interface_vtable(node.interfaces^.get_native_interface);
          
          -- přečíst počet interfaců
          f.read_unsigned32(icount);

          -- načíst reference na jednotlivé interfacy
          for i in 1..icount loop
            node.interfaces^.add_raw_interface(read_interface(context));
            end loop;
          end declare;
        end if;
          
      -- HYNEK - nevynechalo se neco???
      end process_entity_type;



    ------------------------------------------------------------------------------------------------
    static leave_entity_type (
        node       : in out tentity_type) =
    -- Trigger při opouštění načtení [tentity_type].
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym;
      
    begin
      -- pro typ s parametry (podprogram, task, zpráva) spočítat parametry
      if node.stype in dts_parameterized then
        declare var
          srch     : tentitysearch;
          
        begin
          srch.find_et_first(^node,rc_primary,et_param,[]);
          while srch.psym<>nil and srch.psym<>node.result loop
            succ node.parcount;
            srch.find_et_next;
            end loop;
          end declare;
        end if;
      end leave_entity_type;



    ------------------------------------------------------------------------------------------------
    static process_entity_attribute (
        context    : in tcontext;                -- kontext
        node       : in out tentity_attribute) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_value(context,node);
      end process_entity_attribute;



    ------------------------------------------------------------------------------------------------
    static process_entity_message (
        context    : in tcontext;                -- kontext
        node       : in out tentity_message) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    with
      cp_cpu.cp_32.cp_def,
      cg_gen.cg_ia32.ci_def;
      
    begin
      process_entity_base(context,node);
      node.typ:=read_reftype(context);           -- typ zprávy

      -- adresa deskriptoru zprávy
      -- %%TODO(PORTABILITY) Zobecnit !
      declare var
        ud     : tunidata_addr;

      begin  
        -- načíst adresu 
        f.read_unidata_addr(ud);

        -- nenilovou adresu uložit do informací o generování
        if ud<>uda_0 then
          -- připravit informace o generování
          new picodegen_message(node.codegen);
          c_garbage_collector.get_instance^.register_record(node.codegen);

          -- uložit adresu do informací o generování
          picodegen_message(node.codegen)^.desc_addr:=tprg32(unidata_addr_to_unsigned(ud));
          end if;
        end declare;
      end process_entity_message;



    ------------------------------------------------------------------------------------------------
    static process_entity_label (
        context    : in tcontext;                -- kontext
        node       : in out tentity_label) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(context,node);
      -- tato entitita se sem při ctdl_public nesmí dostat!
      end process_entity_label;



    ------------------------------------------------------------------------------------------------
    static process_entity_tparam (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_tparam) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    begin
      process_entity_base(context,node);
      end process_entity_tparam;



    ------------------------------------------------------------------------------------------------
    static process_entity_template (
        context    : in tcontext;                -- kontext    
        node       : in out tentity_template) =
    -- Nacte [tentity_code]
    ------------------------------------------------------------------------------------------------
    var
      pocet_uzlu   : t_unsigned32;               -- počet lexikálních uzlů
      typ_uzlu     : t_unsigned8;
      last_node    : plexnode;                   -- poslední zpracovaný lexikální uzel

    begin
      process_entity_base(context,node);

      -- přečíst počet lexikální uzlů
      f.read_unsigned32(pocet_uzlu);

      for i in 1..pocet_uzlu loop
        -- přečíst typ uzlu
        f.read_unsigned8(typ_uzlu);

        declare var
          lex_node : plexnode;                   -- aktuální lexikální element
        begin
          -- založit lexikální uzel
          case typ_uzlu
            -- parametr
            when t_unsigned8(_tag_param) do read_lexnode_param(lex_node);

            -- lexikální element
            when t_unsigned8(_tag_lex) do read_lexnode_lex(lex_node);
            
            -- jine nezname
            when others do verify({VERIFY=}001174,true);
            end case;

          -- zařadit do seznamu lexikálních uzlů šablony
          lex_node^.prev:=last_node;
          if node.plex=nil
            then node.plex:=lex_node;
            else last_node^.next:=lex_node;
            end if;
          last_node:=lex_node;
          end declare;
        end loop;
      end process_entity_template;



    ------------------------------------------------------------------------------------------------
    static load_entity_type (
        context    : in out tcontext;            -- nadřazený kontext
        dtype      : in tdatatype);              -- datový typ načítaného typu
    -- Načte entitu/typ uvedeného datového typu. Entitu zařadí do uvedeného kontextu.
    -- Není-li v kontextu definována entita ([context.entity] je NIL), nastaví ji na tuto načítanou.
    ------------------------------------------------------------------------------------------------
    static load_entity (
        context    : in out tcontext;            -- nadřazený kontext
        etype      : in tentitytype);            -- typ načítané entity
    -- Načte entitu uvedeného typu. Entitu zařadí do uvedeného kontextu.
    -- Není-li v kontextu definována entita ([context.entity] je NIL), nastaví ji na tuto načítanou.
    ------------------------------------------------------------------------------------------------



    ------------------------------------------------------------------------------------------------
    #template load_region_body_template (
        after_create_region);                    -- trigger po vytvoření regionu
    -- Šablona těla metody [load_region_*].
    ------------------------------------------------------------------------------------------------
      var
        region       : pregion;                    -- načtený region
        region_context : tcontext;                 -- kontext načteného regionu
        ctmid        : t_ctm_entity_id;
        rtype        : tregiontype;
        count        : t_unsigned32;

      begin
        -- CTM ID
        f.read_ci(t_ctm_id(ctmid));

        -- typ regionu
        f.read_regiontype(rtype);

        -- vytvor a zaregistruj
        ctm_id^.create_region(ctmid,context,rtype,region,region_context);

        -- počet položek WITH tabulky
        f.read_unsigned32(count);

        -- jednotlivé položky
        if count>0 then
          -- instance
          new region^.withtable range count;
          c_garbage_collector.get_instance^.register_memblock(region^.withtable);

          -- nacist
          for i in 1..count loop
            succ region^.withtable^:length;
            f.read_with_mode(region^.withtable^[i].mode);    -- režim vazby
            read_refentity(region^.withtable^[i].entity);    -- entita
            f.read_with_level(region^.withtable^[i].level);  -- úroveň vazby
            f.read_logical(region^.withtable^[i].automatic); -- automaticky WITH/USE?
            end loop;
          end if;

        -- implicitni viditelnost vnorenych prvku
        -- f.read_entityvisible(region^.vsect);
   
        -- trigger po vytvoření regionu
        after_create_region;
        
        -- zpracovat vnitřní deklarace
        declare var
          cr         : t_ctm_record_tag;          

        begin
          loop
            -- tag záznamu
            f.read_cr(cr);

            -- zpracovat
            case cr
              -- entita 
              when etype_by_cr:range do
                  -- načíst entitu
                  load_entity(region_context,etype_by_cr[cr]);

              -- entita (typ)
              when dtype_by_cr:range do
                  -- načíst entitu (typ)
                  load_entity_type(region_context,dtype_by_cr[cr]);

              -- vnořený region
              when cr_region do
                  -- načíst region
                  load_region(region_context);

              -- konec záznamu
              when cr_end do break;

              -- nic jiného tu nemá co dělat
              when others do check_error({CCERR=}000593);
              end case;
            end loop;
          end declare;
      #end load_region_body_template;

                             

    ------------------------------------------------------------------------------------------------
    static load_region (
        context    : in out tcontext) =          -- nadřazený kontext
    -- Načte region.
    ------------------------------------------------------------------------------------------------
    #expand load_region_body_template;
      -- žádné parametry nejsou potřeba
      #end load_region_body_template;
      end load_region;
      
      

    ------------------------------------------------------------------------------------------------
    static load_region_compile (
        context    : in out tcontext) =          -- nadřazený kontext
    -- Načte primární region kompilační jednotky.
    ------------------------------------------------------------------------------------------------
    with
      cd_decl.cd_unit;
      
    #expand load_region_body_template;
      -- trigger po vytvoření regionu
      #for after_create_region use;
        -- připravit prostředí pro kompilaci
        p_setup_compilation_environment(region_context.entity);
      #end load_region_body_template;
      end load_region_compile;
      
      

    ------------------------------------------------------------------------------------------------
    #template load_entity_body_template (
        pentity,                                 -- typ pointeru na entitu
        etype,                                   -- rozlišovací prvek druhu entity
        create_entity,                           -- metoda pro vytvoření nové entity 
        load_entity,                             -- kód pro načtení těla entity
        leave_entity,                            -- trigger při opouštění zpracování entity
        load_region,                             -- metoda pro načtení regionu
        d_end_at_position                        -- dokončovací procedura
        );
    -- Šablona těla metody [load_entity_*].
    ------------------------------------------------------------------------------------------------
      var
        entity       : pentity;                    -- načtená entita
        entity_context : tcontext;                 -- kontext načtené entity
        ctmid        : t_ctm_entity_id;
   
      begin
        -- ctm entity id
        f.read_ci(t_ctm_id(ctmid));

        -- nebyla již entita spekulativně založena ?
        entity:=ctm_id^.get_entity(ctmid);

        -- ne => založit nyní
        if entity=nil then 
          ctm_id^.create_entity(ctmid,etype,entity);
          end if;

        -- sestavit prototyp primárního kontextu
        entity_context.entity:=entity;

        -- textový identifikátor entity
        f.read_entityident(entity^.id);

        -- načíst vnitřek entity
        load_entity;

        -- dokončit deklaraci
        d_end_at_position(entity^,nil,false);
        
        -- zpracovat vnitřní deklarace
        declare var
          cr         : t_ctm_record_tag;          

        begin
          -- tag záznamu
          f.read_cr(cr);

          -- zpracovat
          case cr
            -- region
            when cr_region do
                -- načíst region
                load_region(entity_context);

                -- konec záznamu
                f.read_cr(cr);
                check_error({CCERR=}000594,cr<>cr_end);

            -- konec záznamu
            when cr_end do -- nic nedělat

            -- nic jiného tu nemá co dělat
            when others do check_error({CCERR=}000595);
            end case;
          end declare;

        -- signalizovat opuštění zpracování entity
        leave_entity;
      #end load_entity_body_template;



    ------------------------------------------------------------------------------------------------
    static load_entity_type =
    -- Načte entitu/typ uvedeného datového typu. Entitu zařadí do uvedeného kontextu.
    -- Není-li v kontextu definována entita ([context.entity] je NIL), nastaví ji na tuto načítanou.
    ------------------------------------------------------------------------------------------------
      #expand load_entity_body_template;
        -- typ pointeru na entitu
        #for pentity       use; pentity_type

        -- rozlišovací prvek druhu entity
        #for etype         use; dtype

        -- metoda pro vytvoření nové entity 
        #for create_entity use; create_entity_type

        -- kód pro načtení těla entity
        #for load_entity   use; process_entity_type(context,pentity_type(entity)^);

        -- trigger při opouštění zpracování entity
        #for leave_entity  use; leave_entity_type(pentity_type(entity)^);
         
        -- metoda pro načtení regionu 
        #for load_region   use; load_region
        
        -- dokončovací procedura
        #for d_end_at_position use; d_end_implicit_type
        #end load_entity_body_template;
      end load_entity_type;



    ------------------------------------------------------------------------------------------------
    static load_entity =
    -- Načte entitu uvedeného typu. Entitu zařadí do uvedeného kontextu.
    -- Není-li v kontextu definována entita ([context.entity] je NIL), nastaví ji na tuto načítanou.
    ------------------------------------------------------------------------------------------------
      #expand load_entity_body_template;
        -- typ pointeru na entitu
        #for pentity       use; pentity

        -- rozlišovací prvek druhu entity
        #for etype         use; etype

        -- metoda pro vytvoření nové entity 
        #for create_entity use; create_entity

        -- kód pro načtení těla entity
        #for load_entity   use;
          case etype
          --when et_compile   do process_entity_compile(context,pentity_compile(entity)^);
            when et_program   do process_entity_program(context,pentity_program(entity)^);
            when et_module    do process_entity_module(context,pentity_module(entity)^);
            when et_special   do process_entity_special(context,pentity_special(entity)^);
            when et_procedure do process_entity_procedure(context,pentity_procedure(entity)^);
            when et_static    do process_entity_static(context,pentity_static(entity)^);
            when et_virtual   do process_entity_virtual(context,pentity_virtual(entity)^);
            when et_task      do process_entity_task(context,pentity_task(entity)^);
            when et_override  do process_entity_override(context,pentity_override(entity)^);
            when et_macro     do process_entity_macro(context,pentity_macro(entity)^);
            when et_overload  do process_entity_overload(context,pentity_overload(entity)^);
            when et_operator  do process_entity_operator(context,pentity_operator(entity)^);
            when et_var       do process_entity_var(context,pentity_var(entity)^);
            when et_const     do process_entity_const(context,pentity_const(entity)^);
            when et_enum      do process_entity_enum(context,pentity_enum(entity)^);
            when et_param     do process_entity_param(context,pentity_param(entity)^);
            when et_message   do process_entity_message(context,pentity_message(entity)^);
            when et_label     do process_entity_label(context,pentity_label(entity)^);
            when et_template  do process_entity_template(context,pentity_template(entity)^);
            when et_tparam    do process_entity_tparam(context,pentity_tparam(entity)^);
            when et_attribute do process_entity_attribute(context,pentity_attribute(entity)^);
            when others       do check_error({CCERR=}000627);
            end case;

        -- metoda pro načtení regionu 
        #for load_region   use; load_region
        
        -- dokončovací procedura
        #for d_end_at_position use; d_end_at_position
        #end load_entity_body_template;
      end load_entity;



    ------------------------------------------------------------------------------------------------
    static load_entity_compile (
        context    : in out tcontext) =          -- nadřazený kontext
    -- Načte entitu typu kompilační jednotka. Entitu zařadí do uvedeného kontextu.
    -- Není-li v kontextu definována entita ([context.entity] je NIL), nastaví ji na tuto načítanou.
    ------------------------------------------------------------------------------------------------
      #expand load_entity_body_template;
        -- typ pointeru na entitu
        #for pentity       use; pentity

        -- rozlišovací prvek druhu entity
        #for etype         use; et_compile

        -- metoda pro vytvoření nové entity 
        #for create_entity use; create_entity

        -- kód pro načtení těla entity
        #for load_entity   use; process_entity_compile(context,pentity_compile(entity)^);

        -- trigger při opouštění zpracování entity
        #for leave_entity  use; leave_entity_compile(pentity_compile(entity)^);
         
        -- metoda pro načtení regionu 
        #for load_region   use; load_region_compile
        
        -- dokončovací procedura
        #for d_end_at_position use; d_end_at_position
        #end load_entity_body_template;
      end load_entity_compile;



    ------------------------------------------------------------------------------------------------
    static load_tree (
        root_entity : out pentity_compile) =     -- kořenová kompilační jednotka
    -- Načte strom entit.
    ------------------------------------------------------------------------------------------------
    var
      context      : tcontext;                   -- kontext načtené kořenové entity
      cr           : t_ctm_record_tag;

    begin
      -- tag začátku kompilační jednotky
      f.read_cr(cr);
      check_error({CCERR=}000589,cr_by_etype[et_compile]<>cr);

      -- načíst kompilační jednotku (zpracuje i závěrečný tag)
      load_entity_compile(context);

      -- načtenou kořenovou entitu předat ven
      root_entity:=context.entity;
      end load_tree;



    ------------------------------------------------------------------------------------------------
    static load_ctm_header =
    -- Načte hlavičku CTM souboru.
    ------------------------------------------------------------------------------------------------
    var
      cr           : t_ctm_record_tag;
      version      : t_ctm_version;
    
    begin
      -- tag začátku hlavičky
      f.read_cr(cr);
      check_error({CCERR=}000651,cr<>cr_header);

      -- číslo verze CTM
      f.read_ctm_version(version);
      
      -- zkontrolovat kompatibilitu
      if version>ctm_curr_version or version<ctm_min_version then
        ce^.seterror({CCERR=}000653,ce_ctm_unsupported_version);
        ce^.raiseerror;
        end if;
      
      -- koncový tag
      f.read_cr(cr);
      check_error({CCERR=}000652,cr<>cr_end);
      end load_ctm_header;



    ------------------------------------------------------------------------------------------------
    static load_import =
    -- Načte importní tabulky
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_sym;
      
    var
      cr         : t_ctm_record_tag;

    begin
      -- tag začátku tabulky
      f.read_cr(cr);
      check_error({CCERR=}000596,cr<>cr_import);
      
      loop
        -- přečíst a zpracovat další tag
        f.read_cr(cr);
        case cr
          -- import partition
          when cr_import_partition do
              declare var
                extid : p_external_entity_ident;
                root  : pentity_compile;
{
                image_base : tunicode_addr;
}                
              begin  
                -- externí jméno partition
                f.read_external_entity_ident(extid);
                
                -- zkusit najít kompilační jednotku podle externího identifikátoru
                if global_partitions.list<>nil then
                  for i in global_partitions.list^:range loop
                    if pentity_compile(global_partitions.list^[i])^.part_extid<>nil 
                    and then pentity_compile(global_partitions.list^[i])^.part_extid^=extid^ then
                      root:=global_partitions.list^[i];
                      break;
                      end if;
                    end loop;
                  end if;
                
                -- nenašla-li se, tak ji musíme dočíst/dokompilovat
                if root=nil then
                  unimplemented({UNIMP=}000281);
                  end if;
               
{                
                -- image-base importované partition
                f.read_unicode_addr(image_base);
}                
                -- importy jednotlivých entit
                loop
                  -- přečíst a zpracovat další tag
                  f.read_cr(cr);
                  case cr
                    -- položka importní tabulky
                    when cr_import_entry do
                        declare var
                          ctmid : t_ctm_entity_id;
                          qid   : p_qualified_entity_ident;
                          srch  : tentitysearch;
                          
                        begin
                          -- CTM ID
                          f.read_ci(t_ctm_id(ctmid));
                          
                          -- tag typu entity
                          f.read_cr(cr);
                          
                          -- kvalifikovaný identifikátor
                          f.read_qualified_entity_ident(qid);
                          
                          -- najít entitu podle jejího kvalifikovaného identifikátoru
                          srch.find_global_by_qid(root^,qid^);
                          check_error({CCERR=}000632,srch.psym=nil);
                          
                          -- zařadit do tabulky známých CTM ID
                          ctm_id^.register_entity(ctmid,srch.psym);
                          
                          -- tag konce položky
                          f.read_cr(cr);
                          check_error({CCERR=}000631,cr<>cr_end);
                          
                        leave
                          -- uvolnit paměť
                          c_garbage_collector.get_instance^.unregister_memblock(qid);
                          discard qid;
                          end declare;
                    
                    -- konec importní tabulky
                    when cr_end do break;
                    
                    -- nic jiného tu nemá co dělat
                    when others do check_error({CCERR=}000630);
                    end case;
                  end loop;
                  
                -- [extid] neuvolňovat, [ctm_load_import] ho přiřadil k načtené partition  
                end declare;
                
          -- konec importní tabulky
          when cr_end do break;
          
          -- nic jiného tu nemá co dělat
          when others do check_error({CCERR=}000629);
          end case;
        end loop;
      end load_import;



    ------------------------------------------------------------------------------------------------
    static load_rtl_table =
    -- Načte konfiguraci RTL procedur.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_rtl;

    var
      cr           : t_ctm_record_tag;           -- nalezený tag

    begin
      -- tag začátku tabulky
      f.read_cr(cr);
      check_error({CCERR=}000598,cr<>cr_rtl);

      loop
        -- přečíst následující tag
        f.read_cr(cr);

        case cr
          -- položka tabulky RTL procedur
          when cr_rtl_entry do
              declare var
                rtl    : t_rtl_entity;           -- interní entita překladače
                etype  : tentitytype;            -- požadovaný typ interní entity
                entity : pentity;                -- entita přiřazená dané interní entitě
                id     : pentityident;           -- identifikátor interní entity

              begin
                -- identifikátor interní entity
                f.read_entityident(id);

                -- reference na přiřazenou entitu
                declare var
                  ref_id    : t_ctm_entity_id;   -- CTM ID entity uložené v referenci
                  ref_etype : tentitytype;       -- typ entity uložený v referenci
                  ref_dtype : tdatatype;         -- datový typ entity, je-li to typ

                begin
                  read_entity_ref_internal(ref_id,entity,ref_etype,ref_dtype);
                  check_error({CCERR=}000599,entity=nil);
                  end declare;

                -- převést identifikátor na interní entitu překladače
                rtl_id_to_entity_internal(id^,rtl,etype);
                check_error({CCERR=}000600,etype<>entity^.etype);

                -- přiřadit interní entitu
                rtl_set_entity(rtl,entity);

                -- tag konce položky tabulky
                f.read_cr(cr);
                check_error({CCERR=}000601,cr<>cr_end);

              leave
                -- uvolnit paměť
                c_garbage_collector.get_instance^.unregister_memblock(id);
                discard id;
                end declare;

          -- konec tabulky RTL procedur
          when cr_end do return;

          -- nic jiného tu nemá co dělat
          when others do check_error({CCERR=}000602);
          end case;
        end loop;
      end load_rtl_table;



    ------------------------------------------------------------------------------------------------
    static ctm_load =
    -- Načte proud compile-time metadat ze zadaného vstupního streamu.
    ------------------------------------------------------------------------------------------------
    begin
      new ctm_id;

      -- incializovat vstupní formatter
      f.init_reader(input);

      -- načíst záhlaví souboru
      load_ctm_header;

      -- načíst importní tabulku
      load_import;

      -- načíst strom entit
      load_tree(root_entity);

      -- načíst tabulku RTL procedur
      if root_entity^.part_type in parts_contains_runtime then
        load_rtl_table;
        end if;

    catch
      when stream_read_error do
          ce^.seterror({CCERR=}000603,ce_ctm_corrupt);
          ce^.raiseerror;
    leave
      discard ctm_id;
      end ctm_load;

    end c_ctm_reader;



end cc_ctm;