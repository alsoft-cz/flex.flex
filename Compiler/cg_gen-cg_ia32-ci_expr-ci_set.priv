----------------------------------------------------------------------------------------------------
module private ci_set =
-- Překladač Flexu.
-- Množinové operace.
----------------------------------------------------------------------------------------------------
-- Ondra : 23.04.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_set =
-- Porovnávání polí (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- množiny lze vždy porovnávat jako binární bloky
  i_gen_op_compare_binary(inst,info,context,expr,vysl);
  end i_gen_op_compare_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_set =
-- Množinové operace.
----------------------------------------------------------------------------------------------------
with
  ci_integer;

var
  size             : t_unsigned32;               -- velikost operandů

begin
  -- zjistit velikost operandů
  size:=unidata_size_to_unsigned(expr^.t.getsize);

  if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}

    -- příznivá velikost => optimalizovaná verze celočíselnou aritmetikou
    then begin
      -- provést coby integerovou operaci
      i_gen_op_integer(inst,info,context,expr,vysl);
      verify({VERIFY=}000625,vysl.optype not in t_operand_type_set:[io_reg,io_mem]);

      -- množina je agregátní typ, takže se od nás očekává adresa a ne rovnou hodnota
      -- %%FLEX Tohle se řeší pomocí EDT_BINARY, předělat.
      if vysl.optype=io_reg then
        -- uložit do temporary proměnné
        i_gen_loadtemp(inst,info,context,vysl);
        end if;
      end

    -- nepříznivá velikost => složitě
    else
      unimplementedx({UNIMP=}000132,expr^.pos);
      end if;
  end i_gen_op_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_in_set =
-- Test náležení do množiny.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  op1              : c_operand;                  -- operand 1
  op2              : c_operand;                  -- operand 2
  newcontext       : iexprcontext;               -- kontext podvýrazů
  pbase            : pentity_type;               -- typ báze množiny
  lval             : timm32;                     -- dolní mez báze množiny

begin
  -- podvýrazy
  expr^.get(el,er);

  -- bude potřeba typ báze množiny
  pbase:=er^.t.getctype^.base.getctype;

  -- dolní mez báze množiny
  lval:=uniint_to_imm32(pbase^.lval);

  -- načíst testovanou hodnotu do registru
  -- %%X Zde jsem záměrně nepředal očekávaný typ výrazu i když je režim
  -- generování LM_REG. Nikde jinde se to takhle nedělá, ale já potřebuji,
  -- aby byl výsledek 32-bitový (aby správně fungovalo BT). Nemělo by se
  -- to dělat nějak jinak (například dodatečně registr rozšířit) ?
  i_newcontext(context,newcontext,lm_reg,nil{pbase});
  i_load(inst,info,newcontext,context,el,op1);

  -- načíst množinu (pravý operand)
  i_newcontext(context,newcontext,lm_gen,er^.t.getctype);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  op1.refresh(inst,info,context);
  op2.refresh(inst,info,context);

  -- co je pravý operand zač
  case op2.optype

    -- registr
    when io_reg do
       -- rozhodně ho převést na 32 bitů
       op2.adjust_size(4);

       -- a co levý operand ?
       case op1.optype

         -- přímá hodnota
         when io_imm do
             -- odečíst dolní mez báze množiny
             op1.set_imm(op1.imm-lval);

             -- hodnota je jistě 8-mi bitová v rozsahu 0..31
             verify({VERIFY=}000434,op1.imm>31);
             op1.adjust_size(1);

             -- BT <registr>,<přímá hodnota>
             addii(inst,info,ii_bt,op2,op1,op0);

         -- registr
         when io_reg do
             -- převést i druhý operand na 32 bitů
             op1.adjust_size(4);

             -- odečíst dolní mez
             if lval<>timm32(0) then
               declare var
                 optemp : c_operand;
               begin
                 optemp.create_imm(edt_unsigned,0,lval);
                 addii(inst,info,ii_sub,op1,optemp,op0);
               leave
                 optemp.free(info,context);
                 end declare;
               end if;

             -- BT <registr>,<registr>
             addii(inst,info,ii_bt,op2,op1,op0);

         when others do verify({VERIFY=}000431,true);
         end case;

    -- paměť
    when io_mem do
       declare var
         size      : t_unsigned;                 -- velikost množiny pro zjednodušení
       begin
         size:=unidata_size_to_unsigned(er^.t.getsize);

         -- a co levý operand ?
         case op1.optype
           -- přímá hodnota
           when io_imm do
               declare var
                 bitsize : t_unsigned;           -- velikost množiny v bitech směrem dolů zarovnaná na 32 bitů
               begin  
                 -- odečíst dolní mez báze množiny
                 op1.set_imm(op1.imm-lval);

                 -- vypočítat velikost množiny v bitech směrem dolů zarovnanou na 32 bitů
                 bitsize:=(op2.size div 4)*32;

                 -- množina má 1, 2 nebo 3 byty
                 if op2.size<4 then
                   declare var
                     optemp : c_operand;
                   begin
                     -- potřebujeme pracovní registr
                     optemp.create_new_register(inst,info,context,edt_binary,4);

                     -- 3 byty
                     if op2.size=3 then
                       -- načíst horní byte
                       op2.shift_displacement(2);
                       op2.adjust_size(1);
                       addii(inst,info,ii_movzx,optemp,op2,op0);
                       addii(inst,info,ii_shl,optemp,op_16,op0);

                       -- načíst dolní dva byty
                       op2.unshift_displacement(2);
                       op2.adjust_size(2);
                       optemp.adjust_size(2);
                       addii(inst,info,ii_mov,optemp,op2,op0);
                       optemp.adjust_size(4);

                     -- 1 nebo 2 byty
                     else
                       -- načíst dolní dva byty
                       addii(inst,info,ii_movzx,optemp,op2,op0);
                       end if;

                     -- uvolnit původní operand a nahradit ho pracovním operandem
                     op2.replace(info,context,optemp);

                   leave
                     -- uvolnit pracovní operand
                     optemp.free(info,context);
                     end declare;

                 -- index spadá pod hranici 32bitově zaokrouhlené velikosti množiny
                 elsif op1.imm<bitsize then
                   -- vypočítat offset do množiny
                   op2.shift_displacement(imm32_to_signed({%%TODO(MOD)}timm32(t_mod_unsigned32(op1.imm) shr 5)));
                                          --%%X Ta konverze na SIGNED je dost divná. DISP je přeci
                                          -- taky TIMM32, tak proč nejde shiftnout o jinou TIMM32?

                   -- z čísla bitu nás od teď zajímá jen spodních 5 bitů
                   op1.set_imm({%%TODO(MOD)}timm32(t_mod_unsigned32(op1.imm) and 2$1_1111));

                   -- z celé množiny nás nyní zajímají jen čtyři byty
                   op2.adjust_size(4);

                 -- index spadá nad hranici 32bitově zaokrouhlené velikosti množiny
                 elsif op1.imm>=bitsize then
                   verify({VERIFY=}000495,op2.size<4);

                   -- vypočítat číslo bitu v rámci posledních čtyř bytů
                   op1.set_imm(op1.imm-unsigned_to_imm32(op2.size-4)*timm32(8));

                   -- vypočítat offset na poslední čtyři byty množiny
                   op2.shift_displacement(t_signed(op2.size-4));

                   -- z celé množiny nás nyní zajímají jen čtyři byty
                   op2.adjust_size(4);

                 -- jiný případ by neměl nastat
                 else
                   verify({VERIFY=}000496,true);
                   end if;

                 -- číslo bitu je teď 8-mi bitové mezi 0..31
                 op1.adjust_size(1);

                 -- BT <paměť>,<přímá hodnota>
                 addii(inst,info,ii_bt,op2,op1,op0);
                 end declare;

           -- registr
           when io_reg do
               -- procesor přistupuje k paměti po 32bitových slovech,
               -- takže musíme opravit velikost operandu
               -- if op2.size mod 4<>0 then u_nimplemented(134);

               -- převést i druhý operand na 32 bitů
               op1.adjust_size(4);

               -- odečíst dolní mez
               if lval<>timm32(0) then
                 declare var
                   optemp : c_operand;
                 begin
                   optemp.create_imm(edt_unsigned,0,lval);
                   addii(inst,info,ii_sub,op1,optemp,op0);
                 leave
                   optemp.free(info,context);
                   end declare;
                 end if;

               -- instrukce BT akceptuje jen 32bitové operandy, i když pracuje s libovolně dlouhými
               op2.adjust_size(4);

               -- %%X Následující instrukce může obecně způsobit Access Violation, pokud
               -- bude konec množiny, jejíž velikost nebude násobkech 4, ležet na hranici
               -- stránky. Správně by měla zavolat nějaká RTL funkce, která provede stejný
               -- rozhodovací proces jako v předchozí variantě OP1.OPTYPE=IO_IMM.

               -- BT <paměť>,<registr>
               addii(inst,info,ii_bt,op2,op1,op0);

           when others do verify({VERIFY=}000798,true);
           end case;
        end declare;

    when others do verify({VERIFY=}000430,true);
    end case;

  -- výsledek
  if expr^.oper=op_notin
    then vysl.create_condition(ic_nc);
    else vysl.create_condition(ic_c);
    end if;

leave
  -- uvolnit operandy
  op1.free(info,context);
  op2.free(info,context);
  end i_gen_op_in_set;



end ci_set;
