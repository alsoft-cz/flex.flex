----------------------------------------------------------------------------------------------------
module private cl_pe =
-- Překladač Flexu.
-- Portable Executable.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.04.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_var,
  cc_def.cc_unitype,
  cp_os.cp_win32;

type
  tperva           = private t_unsigned32;       -- Relative Virtual Address

----------------------------------------------------------------------------------------------------
class private c_link_image_pe =
-- Portable Executable image creator.
----------------------------------------------------------------------------------------------------

    with
      standard,
      standard.files,
      standard.streams,
      standard.numerics,
      cc_def.cc_codes,
      cc_def.cc_entity.cc_list,
      cp_os,
      cl_link.cl_debug,
    #if codeview then;
      cl_link.cl_debug.cl_codeview,
    #end if;
      cl_link.cl_def,
      standard.conversions;

    var
      -- signatura PE souboru
      pesign           : const t_unsigned32 := $00004550 {'PE'\0\0};

    const
      -- modifikace PE hlavičky
      magic_rom        = $107;                   -- ROM image
      magic_pe32       = $10B;                   -- PE32
      magic_pe32p      = $20B;                   -- PE32+

      -- offset pointeru na PE hlavičku
      peptrofs         = $3C;

      -- zarovnání
      sectalign        = 4096;                   -- zarovnání sekcí
      filealign        = 512;                    -- zarovnání bloků v souboru

    type
      tpefileptr       = private t_unsigned32;   -- File Pointer
      tpesize          = private t_unsigned32;   -- velikost objektu v bytech
      tpever1          = record                  -- číslo verze
          major        : t_unsigned8;            -- - verze
          minor        : t_unsigned8;            -- - revize
          end record
              for alignment use 1;
      tpever2          = record                  -- číslo verze
          major        : t_unsigned16;           -- - verze
          minor        : t_unsigned16;           -- - revize
          end record
              for alignment use 1;
      tpememsize       = record                  -- velikost paměti
          reserve_size : tpesize;                -- - rezervovat
          commit_size  : tpesize;                -- - alokovat
          end record
              for alignment use 1;
      tpedirentry      = record                  -- položka data directory
          rva          : tperva;                 -- - RVA
          size         : tpesize;                -- - velikost
          end record
              for alignment use 1;

      -- COFF hlavička
      tcoffheader      = record
          machine      : t_unsigned16;           -- cílová platforma
          sectioncount : t_unsigned16;           -- počet sekcí
          datetime     : t_unsigned32;           -- časová značka
          symtab       : tpefileptr;             -- pointer na tabulku symbolů
          symcount     : t_unsigned32;           -- počet symbolu v tabulce
          opthdrsize   : t_unsigned16;           -- velikost volitelné hlavičky (PE hdr)
          flags        : t_mod_unsigned16;       -- další parametry
          end record
              for alignment use 1
              for size      use 20;

      -- základ PE hlavičky
      tpe0header       = record
          magic        : t_unsigned16;           -- modifikace PE hlavičky
          linkerver    : tpever1;                -- verze linkeru
          codetotal    : tpesize;                -- velikost sekcí s kódem
          inittotal    : tpesize;                -- velikost sekcí s init. daty
          datatotal    : tpesize;                -- velikost sekcí s daty
          entrypoint   : tperva;                 -- entry point
          codebase     : tperva;                 -- relativní báze kódu
          end record
              for alignment use 1;

      -- PE32 hlavička (COFF optional header)
      tpe32header      = tpe0header with record
          database     : tperva;                 -- relativní báze dat
          end record
              for alignment use 1
              for size      use 28;

      -- PE32+ hlavička (COFF optional header)
      tpe32pheader     = tpe0header with record
          end record;

      -- image base
      tpe32base        = private t_unsigned32;
    --tpe32pbase       = private t_unsigned64;

      -- PE32 a PE32+ Windows Specific Header
      tpewinheader     = record
          sectalign    : t_unsigned32;           -- section alignment
          filealign    : t_unsigned32;           -- file alignment
          osver        : tpever2;                -- verze operačního systému
          imagever     : tpever2;                -- verze image
          subsysver    : tpever2;                -- verze subsystému
          win32ver     : t_unsigned32;           -- verze Win32
          imagesize    : tpesize;                -- velikost image
          hdrsize      : tpesize;                -- velikost hlaviček
          checksum     : t_unsigned32;           -- kontrolní součet
          subsys       : t_unsigned16;           -- subsystém
          dllflags     : t_mod_unsigned16;       -- další parametry pro DLL
          stack        : tpememsize;             -- velikost stacku
          heap         : tpememsize;             -- velikost heapu
          loaderflags  : t_mod_unsigned32;       -- parametry pro loader
          dircount     : t_unsigned32;           -- počet záznamů v data directory
          end record
              for alignment use 1
              for size      use 64;

      -- PE32 a PE32+ data directory
      tpedatadir       = record
          export       : tpedirentry;            -- export table
          import       : tpedirentry;            -- import table
          resource     : tpedirentry;            -- resource table
          exceptions   : tpedirentry;            -- exception table
          cert         : tpedirentry;            -- certificate table     ! RVA=fileptr
          baserelo     : tpedirentry;            -- base relocation table
          debuginfo    : tpedirentry;            -- debug info
          architecture : tpedirentry;            -- architecture specific data
          globalptr    : tpedirentry;            -- global pointer        ! SIZE:=0
          tls          : tpedirentry;            -- thread local storage table
          loadcfg      : tpedirentry;            -- load config
          boundimport  : tpedirentry;            -- bound import table
          iat          : tpedirentry;            -- import address table
          delayimport  : tpedirentry;            -- delay import descriptor
          compruntime  : tpedirentry;            -- COM+ runtime header
          rezerva      : tpedirentry;
          end record
              for alignment use 1;

      -- PE32 a PE32+ section header
      tpesectname      = array 1..8 of t_char8;
      tpesectheader    = record
          name         : tpesectname;            -- jméno sekce
          virtualsize  : tpesize;                -- velikost sekce v paměti
          virtualaddr  : tperva;                 -- adresa sekce v paměti
          datasize     : tpesize;                -- velikost dat v image souboru
          dataptr      : tpefileptr;             -- pointer na data v image souboru
          reloptr      : tpefileptr;             -- pointer na relokace
          lineptr      : tpefileptr;             -- pointer na řádkové informace
          relocount    : t_unsigned16;           -- počet relokací
          linecount    : t_unsigned16;           -- počet řádkových informací
          flags        : t_mod_unsigned32;       -- další parametry
          end record
              for alignment use 1
              for size      use 40;

    const
      -- cílové platformy
      IMAGE_FILE_MACHINE_ALPHA     = $184;       -- Alpha AXP
      IMAGE_FILE_MACHINE_ARM       = $1c0;       --
      IMAGE_FILE_MACHINE_ALPHA64   = $284;       -- Alpha AXP 64-bit
      IMAGE_FILE_MACHINE_I386      = $14c;       -- Intel 386 or later
      IMAGE_FILE_MACHINE_I486      = $14d;       -- Intel 486 or later
      IMAGE_FILE_MACHINE_PENTIUM   = $14e;       -- Intel Pentium or later
      IMAGE_FILE_MACHINE_IA64      = $200;       -- Intel IA64
      IMAGE_FILE_MACHINE_M68K      = $268;       -- Motorola 68000 series
      IMAGE_FILE_MACHINE_MIPS16    = $266;       --
      IMAGE_FILE_MACHINE_MIPSFPU   = $366;       -- MIPS with FPU
      IMAGE_FILE_MACHINE_MIPSFPU16 = $466;       -- MIPS16 with FPU
      IMAGE_FILE_MACHINE_POWERPC   = $1f0;       -- Power PC, little endian
      IMAGE_FILE_MACHINE_R3000     = $162;       --
      IMAGE_FILE_MACHINE_R4000     = $166;       -- MIPS little endian
      IMAGE_FILE_MACHINE_R10000    = $168;       --
      IMAGE_FILE_MACHINE_SH3       = $1a2;       -- Hitachi SH3
      IMAGE_FILE_MACHINE_SH4       = $1a6;       -- Hitachi SH4
      IMAGE_FILE_MACHINE_THUMB     = $1c2;       --

      -- příznaky
      IMAGE_FILE_RELOCS_STRIPPED         = $0001;-- neobsahuje relokace
      IMAGE_FILE_EXECUTABLE_IMAGE        = $0002;-- soubor je spustitelný
      IMAGE_FILE_LINE_NUMS_STRIPPED      = $0004;-- neobsahuje řádkové info.
      IMAGE_FILE_LOCAL_SYMS_STRIPPED     = $0008;-- neobsahuje lokální symb.
      IMAGE_FILE_AGGRESSIVE_WS_TRIM      = $0010;-- Aggressively trim working set
      IMAGE_FILE_LARGE_ADDRESS_AWARE     = $0020;-- přežije > 2GB paměti
      IMAGE_FILE_16BIT_MACHINE           = $0040;-- Use of this flag is reserved for future use
      IMAGE_FILE_BYTES_REVERSED_LO       = $0080;-- little endian
      IMAGE_FILE_32BIT_MACHINE           = $0100;-- 32-bit-word architecture
      IMAGE_FILE_DEBUG_STRIPPED          = $0200;-- neobsahuje debug info.
      IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = $0400;-- spouštět ze swap filu
      IMAGE_FILE_SYSTEM                  = $1000;-- systémový soubor
      IMAGE_FILE_DLL                     = $2000;-- DLL
      IMAGE_FILE_UP_SYSTEM_ONLY          = $4000;-- File should be run only on a UP machine
      IMAGE_FILE_BYTES_REVERSED_HI       = $8000;-- big endian

      -- subsystémy
      IMAGE_SUBSYSTEM_UNKNOWN            = 0;    -- Unknown subsystem
      IMAGE_SUBSYSTEM_NATIVE             = 1;    -- device drivers and native
      IMAGE_SUBSYSTEM_WINDOWS_GUI        = 2;    -- Windows GUI
      IMAGE_SUBSYSTEM_WINDOWS_CUI        = 3;    -- Windows console
      IMAGE_SUBSYSTEM_POSIX_CUI          = 7;    -- Posix console
      IMAGE_SUBSYSTEM_WINDOWS_CE_GUI     = 9;    -- Windows CE

      -- parametry DLL
      IMAGE_DLLCHARACTERISTICS_NO_BIND   = $0800;-- Do not bind image
      IMAGE_DLLCHARACTERISTICS_WDM_DRIVER= $2000;-- WDM Driver
      IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = $8000; -- Image is Terminal Server aware

      -- parametry sekcí
      IMAGE_SCN_TYPE_REG                 = $00000000;-- Reserved for future use
      IMAGE_SCN_TYPE_DSECT               = $00000001;-- Reserved for future use
      IMAGE_SCN_TYPE_NOLOAD              = $00000002;-- Reserved for future use
      IMAGE_SCN_TYPE_GROUP               = $00000004;-- Reserved for future use
      IMAGE_SCN_TYPE_NO_PAD              = $00000008;-- obsolete
      IMAGE_SCN_TYPE_COPY                = $00000010;-- Reserved for future use
      IMAGE_SCN_CNT_CODE                 = $00000020;-- executable code
      IMAGE_SCN_CNT_INITIALIZED_DATA     = $00000040;-- initialized data
      IMAGE_SCN_CNT_UNINITIALIZED_DATA   = $00000080;-- uninitialized data
      IMAGE_SCN_LNK_OTHER                = $00000100;-- Reserved for future use
      IMAGE_SCN_LNK_INFO                 = $00000200;-- comments or other info.
      IMAGE_SCN_TYPE_OVER                = $00000400;-- Reserved for future use
      IMAGE_SCN_LNK_REMOVE               = $00000800;-- not become part of image
      IMAGE_SCN_LNK_COMDAT               = $00001000;-- COMDAT data
      IMAGE_SCN_MEM_FARDATA              = $00008000;-- Reserved for future use
      IMAGE_SCN_MEM_PURGEABLE            = $00020000;-- Reserved for future use
      IMAGE_SCN_MEM_16BIT                = $00020000;-- Reserved for future use
      IMAGE_SCN_MEM_LOCKED               = $00040000;-- Reserved for future use
      IMAGE_SCN_MEM_PRELOAD              = $00080000;-- Reserved for future use
      IMAGE_SCN_ALIGN_1BYTES             = $00100000;-- 1-byte boundary alignment
      IMAGE_SCN_ALIGN_2BYTES             = $00200000;-- 2-byte boundary
      IMAGE_SCN_ALIGN_4BYTES             = $00300000;-- 4-byte boundary
      IMAGE_SCN_ALIGN_8BYTES             = $00400000;-- 8-byte boundary
      IMAGE_SCN_ALIGN_16BYTES            = $00500000;-- 16-byte boundary
      IMAGE_SCN_ALIGN_32BYTES            = $00600000;-- 32-byte boundary
      IMAGE_SCN_ALIGN_64BYTES            = $00700000;-- 64-byte boundary
      IMAGE_SCN_ALIGN_128BYTES           = $00800000;-- 128-byte
      IMAGE_SCN_ALIGN_256BYTES           = $00900000;-- 256-byte
      IMAGE_SCN_ALIGN_512BYTES           = $00A00000;-- 512-byte
      IMAGE_SCN_ALIGN_1024BYTES          = $00B00000;-- 1024-byte
      IMAGE_SCN_ALIGN_2048BYTES          = $00C00000;-- 2048-byte
      IMAGE_SCN_ALIGN_4096BYTES          = $00D00000;-- 4096-byte
      IMAGE_SCN_ALIGN_8192BYTES          = $00E00000;-- 8192-byte
      IMAGE_SCN_LNK_NRELOC_OVFL          = $01000000;-- extended relocations
      IMAGE_SCN_MEM_DISCARDABLE          = $02000000;-- can be discarded as needed
      IMAGE_SCN_MEM_NOT_CACHED           = $04000000;-- cannot be cached
      IMAGE_SCN_MEM_NOT_PAGED            = $08000000;-- not pageable
      IMAGE_SCN_MEM_SHARED               = $10000000;-- can be shared in memory
      IMAGE_SCN_MEM_EXECUTE              = $20000000;-- can be executed as code
      IMAGE_SCN_MEM_READ                 = $40000000;-- can be read
      IMAGE_SCN_MEM_WRITE                = $80000000;-- can be written to

    var
      stub             : const array 0..255 of t_unsigned8 := [
          $4D, $5A, $50, $00, $02, $00, $00, $00, $04, $00, $0F, $00, $FF, $FF, $00, $00,
          $B8, $00, $00, $00, $00, $00, $00, $00, $40, $00, $1A, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00,
          $BA, $10, $00, $0E, $1F, $B4, $09, $CD, $21, $B8, $01, $4C, $CD, $21, $90, $90,
          $54, $68, $69, $73, $20, $70, $72, $6F, $67, $72, $61, $6D, $20, $6D, $75, $73,
          $74, $20, $62, $65, $20, $72, $75, $6E, $20, $75, $6E, $64, $65, $72, $20, $57,
          $69, $6E, $33, $32, $0D, $0A, $24, $37, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00];



    ------------------------------------------------------------------------------------------------
    override create =
    -- Vytvoří image na základě seznamu vyhodnocených prvků.
    ------------------------------------------------------------------------------------------------
    var
      base         : tpe32base;                  -- image base

        --------------------------------------------------------------------------------------------
        procedure get_seg_virtualsize (
            seg    : in t_image_section) 
            return tpesize =
        -- Vypočítá virtuální velikost zadaného segmentu.
        --------------------------------------------------------------------------------------------
        begin
          result:=((unidata_size_to_unsigned(resolver.getsegtotal(seg))+sectalign-1) div sectalign)*sectalign;
          end get_seg_virtualsize;



        --------------------------------------------------------------------------------------------
        procedure get_seg_virtualaddr (
            seg    : in t_image_section) 
            return tperva =
        -- Vypočítá relativní virtuální adresu zadaného segmentu.
        --------------------------------------------------------------------------------------------
        begin
          result:=unicode_addr_to_unsigned(resolver.getsegbase(seg))-base;
          end get_seg_virtualaddr;



        --------------------------------------------------------------------------------------------
        #template align_datasize (size);
        --------------------------------------------------------------------------------------------
          ((size+filealign-1) div filealign)*filealign
          #end align_datasize;
          


        --------------------------------------------------------------------------------------------
        procedure get_seg_datasize (
            seg    : in t_image_section;
            aligned: in t_logical := true) 
            return tperva =
        -- Vypočítá skutečnou velikost zadaného segmentu v souboru.
        --------------------------------------------------------------------------------------------
        begin
          if aligned
            then result:=align_datasize(unidata_size_to_unsigned(resolver.getsegtotal(seg)));
            else result:=unidata_size_to_unsigned(resolver.getsegtotal(seg));
            end if;
          end get_seg_datasize;


    
    var
      coff         : tcoffheader;                -- COFF hlavička
      coff_ofs     : tpefileptr;                 -- offset COFF hlavičky
      pehdr        : tpe32header;                -- PE32 hlavička
      pehdr_ofs    : tpefileptr;                 -- offset PE32 hlavičky
      winhdr       : tpewinheader;               -- Windows Specific Header
      winhdr_ofs   : tpefileptr;                 -- offset Windows Specific Header
      dir          : tpedatadir;                 -- Data Directory
      dir_ofs      : tpefileptr;                 -- offset Data Directory
      scode        : tpesectheader;              -- sekce: kód
      scode_ofs    : tpefileptr;                 -- offset sekce
      smetadata    : tpesectheader;              -- sekce: metadata
      smetadata_ofs: tpefileptr;                 -- offset sekce
      sconst       : tpesectheader;              -- sekce: konstanty
      sconst_ofs   : tpefileptr;                 -- offset sekce
      sinit        : tpesectheader;              -- sekce: inicializovaná data
      sinit_ofs    : tpefileptr;                 -- offset sekce
      sdata        : tpesectheader;              -- sekce: neinicializovaná data
      sdata_ofs    : tpefileptr;                 -- offset sekce
      srelo        : tpesectheader;              -- sekce: relokace pro operační systém
      srelo_ofs    : tpefileptr;                 -- offset sekce
      srelo_data   : c_output_stream_passive_buffer; -- data sekce
      srelo_size   : t_offset;                   -- velikost data sekce
      sflexrelo    : tpesectheader;              -- sekce: relokace pro Flex
      sflexrelo_ofs: tpefileptr;                 -- offset sekce
      sdebug       : tpesectheader;              -- sekce: debug informace
      sdebug_ofs   : tpefileptr;                 -- offset sekce
      sicode       : tpesectheader;              -- sekce: skoková tabulka importů
      sicode_ofs   : tpefileptr;                 -- offset sekce
      simport      : tpesectheader;              -- sekce: importy
      simport_ofs  : tpefileptr;                 -- offset sekce
      sexport      : tpesectheader;              -- sekce: exporty
      sexport_ofs  : tpefileptr;                 -- offset sekce
      maxrva       : tperva;                     -- maximální dosažená relativní virtuální adr.
      debuginfo_data : p_unsigned8array;         -- pointer na codeview debug data              
      debuginfo_size : t_unsigned32;             -- velikost dat v bufferu                      
      os           : p_stream_binary_writer;     -- output stream
      os_bwriter   : aliased c_stream_binary_writer; -- binary writer
      os_buffer    : aliased c_buffered_file_output_stream;  -- output buffered stream

    begin
      -- zjistit si bázovou adresu relokací
      base:=tpe32base(unicode_addr_to_unsigned(resolver.getaddrbase));

      -- vytvořit soubor
      begin
        f.create(t_fs_object_mode_set:[tfm_write],tfa_random,tfss_not_shared,true);
      catch
        when file_error do
            ce^.seterror({CCERR=}000377,ce_f_create);
            --%%FLEX ce^.setparam(f.name);
            --ce^.raiseerror;
            --%%TODO(EXCEPTION) Záplata, pokud v catch bloku výjimky E1 vyvolám _nepřímo_ E2, pak E1 zůstane neošetřená (na stacku)
            raise compiler_error;
        end;

      -- získat output stream
      os_buffer.init(^f);
      os_bwriter.init_writer(^c_output_stream:(os_buffer));
      os_bwriter.set_lazy_buffer(true);
      os:=^os_bwriter;

      -- uložit stub
      os^.write_unchecked(stub);

      -- signatura
      os^.write_unchecked(pesign);

      -- %%X Zobecnit - parametrizovat vlastnosti EXE 

      -- COFF hlavička
      os^.get_flow(t_offset(coff_ofs));
      coff.machine:=IMAGE_FILE_MACHINE_I386;
      coff.sectioncount:=0;
      coff.datetime:=$3E36B801{%%TODO(LIB) getdatim};
      coff.opthdrsize:=base:size+pehdr:size+winhdr:size+dir:size;
      coff.flags:={IMAGE_FILE_RELOCS_STRIPPED
               or}IMAGE_FILE_EXECUTABLE_IMAGE
               or IMAGE_FILE_LINE_NUMS_STRIPPED
               or IMAGE_FILE_LOCAL_SYMS_STRIPPED
            -- or IMAGE_FILE_LARGE_ADDRESS_AWARE
            -- or IMAGE_FILE_BYTES_REVERSED_LO
               or IMAGE_FILE_32BIT_MACHINE
              {or IMAGE_FILE_DEBUG_STRIPPED}
              {or IMAGE_FILE_BYTES_REVERSED_HI};

      -- pokud se nebudou generovat debug informace, nastavime priznak
      if debug_info=nil then
        coff.flags:=coff.flags or IMAGE_FILE_DEBUG_STRIPPED;
        end if;

      -- pridej DLL flag pro win32 knihovnu
      if library then
        coff.flags:=coff.flags or IMAGE_FILE_DLL;
        end if;
      
      os^.write_unchecked(coff);

      -- PE hlavička
      os^.get_flow(t_offset(pehdr_ofs));
      pehdr.magic:=magic_pe32;
      pehdr.linkerver.major:=linkver_major;
      pehdr.linkerver.minor:=linkver_minor;
      pehdr.codetotal :=unidata_size_to_unsigned(resolver.getsegtotal(tis_code));
      pehdr.inittotal :=unidata_size_to_unsigned(resolver.getsegtotal(tis_flex_metadata))
                       +unidata_size_to_unsigned(resolver.getsegtotal(tis_constants))
                       +unidata_size_to_unsigned(resolver.getsegtotal(tis_initialized_data));
      pehdr.datatotal :=unidata_size_to_unsigned(resolver.getsegtotal(tis_uninitialized_data));
      pehdr.entrypoint:=unicode_addr_to_unsigned(resolver.getentrypoint)-base;
      pehdr.codebase  :=unicode_addr_to_unsigned(resolver.getsegbase(tis_code))-base;
      pehdr.database  :=unicode_addr_to_unsigned(resolver.getsegbase(tis_flex_metadata))-base;
      os^.write_unchecked(pehdr);

      -- image base
      os^.write_unchecked(base);

      -- Windows Specific Header
      os^.get_flow(t_offset(winhdr_ofs));
      winhdr.sectalign:=sectalign;
      winhdr.filealign:=filealign;
      winhdr.osver.major:=1;
      winhdr.osver.minor:=0;
      winhdr.imagever.major:=0;
      winhdr.imagever.minor:=0;
      winhdr.subsysver.major:=4;
      winhdr.subsysver.minor:=0;
      winhdr.imagesize:=0;
      winhdr.hdrsize:=0;

      -- DLL knihovna jen pro GUI subsystem
      if library 
        then winhdr.subsys:=IMAGE_SUBSYSTEM_WINDOWS_GUI;
        else winhdr.subsys:=IMAGE_SUBSYSTEM_WINDOWS_CUI;
        end if;

      winhdr.dllflags:=0;
      winhdr.stack.reserve_size:=1024*1024;
      winhdr.stack.commit_size:=1024*1024;
      winhdr.heap.reserve_size:=1024*1024;
      winhdr.heap.commit_size:=1024*1024;
      winhdr.dircount:=16;
      os^.write_unchecked(winhdr);

      -- Data Directory
      os^.get_flow(t_offset(dir_ofs));

      os^.write_unchecked(dir);

      -- první volná RVA
      maxrva:=0;



      ----- sekce: kód -----------------------------------------------------------------------------
      if resolver.checkseg(tis_code) then
        os^.get_flow(t_offset(scode_ofs));
        scode.name           :={%OFF}'.text'\0\0\0{%ON};
        scode.virtualsize    :=((pehdr.codetotal+sectalign-1) div sectalign)*sectalign;
        scode.virtualaddr    :=pehdr.codebase;
        scode.datasize       :=((pehdr.codetotal+filealign-1) div filealign)*filealign;
        scode.dataptr        :=0;
        scode.flags          :=IMAGE_SCN_CNT_CODE
                          --or IMAGE_SCN_MEM_SHARED %%X
                            or IMAGE_SCN_MEM_EXECUTE
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(scode);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tis_code,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_execute,tcvsf_read],scode.dataptr,scode.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((scode.virtualaddr+scode.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: deskriptory typů ----------------------------------------------------------------
      if resolver.checkseg(tis_flex_metadata) then
        os^.get_flow(t_offset(smetadata_ofs));
        smetadata.name       :={%OFF}'FLEXMETA'{%ON};
        smetadata.virtualsize:=get_seg_virtualsize(tis_flex_metadata); 
        smetadata.virtualaddr:=get_seg_virtualaddr(tis_flex_metadata);
        smetadata.datasize   :=get_seg_datasize(tis_flex_metadata);
        smetadata.dataptr    :=0;
        smetadata.flags      :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(smetadata);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tis_flex_metadata,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read],smetadata.dataptr,smetadata.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((smetadata.virtualaddr+smetadata.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: konstanty -----------------------------------------------------------------------
      if resolver.checkseg(tis_constants) then
        os^.get_flow(t_offset(sconst_ofs));
        sconst.name          :={%OFF}'.const'\0\0{%ON};
        sconst.virtualsize   :=get_seg_virtualsize(tis_constants); 
        sconst.virtualaddr   :=get_seg_virtualaddr(tis_constants);
        sconst.datasize      :=get_seg_datasize(tis_constants);
        sconst.dataptr       :=0;
        sconst.flags         :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sconst);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tis_constants,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read],sconst.dataptr,sconst.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sconst.virtualaddr+sconst.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: inicializovaná data -------------------------------------------------------------
      if resolver.checkseg(tis_initialized_data) then
        os^.get_flow(t_offset(sinit_ofs));
        sinit.name           :={%OFF}'.data'\0\0\0{%ON};
        sinit.virtualsize    :=get_seg_virtualsize(tis_initialized_data); 
        sinit.virtualaddr    :=get_seg_virtualaddr(tis_initialized_data);
        sinit.datasize       :=get_seg_datasize(tis_initialized_data);
        sinit.dataptr        :=0;
        sinit.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
        os^.write_unchecked(sinit);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tis_initialized_data,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read,tcvsf_write],sinit.dataptr,sinit.datasize);
          end if;                    
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sinit.virtualaddr+sinit.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      
      
      ----- sekce: neinicializovaná data -----------------------------------------------------------
      if resolver.checkseg(tis_uninitialized_data) then
        os^.get_flow(t_offset(sdata_ofs));
        sdata.name           :={%OFF}'.bss'\0\0\0\0{%ON};
        sdata.virtualsize    :=get_seg_virtualsize(tis_uninitialized_data); 
        sdata.virtualaddr    :=get_seg_virtualaddr(tis_uninitialized_data);
        sdata.datasize       :=0;
        sdata.dataptr        :=0;
        sdata.flags          :=IMAGE_SCN_CNT_UNINITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
        os^.write_unchecked(sdata);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tis_uninitialized_data,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read,tcvsf_write],sdata.dataptr,sdata.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sdata.virtualaddr+sdata.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      if debug_info<>nil then
        -- vygenerujeme debug informace
        debug_info^.generate;

        -- dump debug informaci
        debug_info^.linkimage(debuginfo_data,debuginfo_size);
        end if;

      
      
      ----- sekce: Import Address Table (povinné) --------------------------------------------------
      os^.get_flow(t_offset(sicode_ofs));
      sicode.name            :={%OFF}'.icode'\0\0{%ON};
      sicode.virtualsize     :=get_seg_virtualsize(tis_import_table); 
      sicode.virtualaddr     :=get_seg_virtualaddr(tis_import_table);
      sicode.datasize        :=get_seg_datasize(tis_import_table);
      sicode.dataptr         :=0;
      sicode.flags           :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
      os^.write_unchecked(sicode);
      succ coff.sectioncount;
      maxrva:=max_unsigned(maxrva,((sicode.virtualaddr+sicode.virtualsize+sectalign-1) div sectalign)*sectalign);

      
      
      ----- sekce: importy (povinné) ---------------------------------------------------------------
      os^.get_flow(t_offset(simport_ofs));
      simport.name           :={%OFF}'.idata'\0\0{%ON};
      simport.virtualsize    :=get_seg_virtualsize(tis_import_metadata);
      simport.virtualaddr    :=get_seg_virtualaddr(tis_import_metadata);
      simport.datasize       :=get_seg_datasize(tis_import_metadata);
      simport.dataptr        :=0;
      simport.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
      os^.write_unchecked(simport);
      succ coff.sectioncount;
      maxrva:=max_unsigned(maxrva,((simport.virtualaddr+simport.virtualsize+sectalign-1) div sectalign)*sectalign);

                                                                       

      ----- sekce: exporty -------------------------------------------------------------------------
      if resolver.checkseg(tis_export_metadata) then
    --if {!!section} sys_export_list.count>0 or library then
        os^.get_flow(t_offset(sexport_ofs));
        sexport.name           :={%OFF}'.edata'\0\0{%ON};
        sexport.virtualsize    :=get_seg_virtualsize(tis_export_metadata);
        sexport.virtualaddr    :=get_seg_virtualaddr(tis_export_metadata);
        sexport.datasize       :=get_seg_datasize(tis_export_metadata);
        sexport.dataptr        :=0;
        sexport.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_READ
                              or IMAGE_SCN_MEM_READ;
                              
        os^.write_unchecked(sexport);
        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sexport.virtualaddr+sexport.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;


      
      ----- sekce: relokace Flex (nepovinné) -------------------------------------------------------
      if resolver.checkseg(tis_flex_relocations) then
    --if {!!section} curr_partition_type<>part_standalone then
        os^.get_flow(t_offset(sflexrelo_ofs));
        sflexrelo.name         :={%OFF}'FLEXRELO'{%ON};
        sflexrelo.virtualsize  :=get_seg_virtualsize(tis_flex_relocations); 
        sflexrelo.virtualaddr  :=get_seg_virtualaddr(tis_flex_relocations);
        sflexrelo.datasize     :=get_seg_datasize(tis_flex_relocations);
        sflexrelo.dataptr      :=0;
        sflexrelo.flags        :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_DISCARDABLE
                              or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sflexrelo);
        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sflexrelo.virtualaddr+sflexrelo.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: relokace (povinné) --------------------------------------------------------------
      {!!section if ... then }
      os^.get_flow(t_offset(srelo_ofs));
      srelo.name             :={%OFF}'.reloc'\0\0{%ON};
      srelo.virtualsize      :=0;      {!!section}
      srelo.virtualaddr      :=maxrva; {!!section}
      srelo.datasize         :=0;
      srelo.dataptr          :=0;
      srelo.flags            :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_DISCARDABLE
                            or IMAGE_SCN_MEM_READ
                           {or IMAGE_SCN_MEM_WRITE};
      os^.write_unchecked(srelo);
      succ coff.sectioncount;

      declare var
        relocations  : p_relocations;
        srelo_writer : c_stream_binary_writer;
        
      begin
        -- inicializovat writer
        srelo_writer.init_writer(^c_output_stream:(srelo_data));
        
        -- načíst setříděný seznam relokačních informací pro aktuální partition
        resolver.get_sorted_relocations_by_partition_id(curr_partition,relocations);

        -- mame nejake relokacni informace ?
        if relocations<>nil then
          -- sestav
          p_link_resolver_image_specific_pe(^image_specific)^.build_pe_relocations(srelo_writer,relocations^);
          end if;
          
        -- konec dat
        c_output_stream:(srelo_data).write_eod;
        end declare;
    
      -- minimální velikost
      c_output_stream:(srelo_data).get_flow(srelo_size);
      srelo.datasize:=align_datasize(srelo_size);
      srelo.virtualsize:=((srelo_size+sectalign-1) div sectalign)*sectalign;
      maxrva:=max_unsigned(maxrva,((srelo.virtualaddr+srelo.virtualsize+sectalign-1) div sectalign)*sectalign);

  

      ----- sekce: debug  --------------------------------------------------------------------------
      if debug_info<>nil then
        os^.get_flow(t_offset(sdebug_ofs));
        sdebug.name            :={%OFF}'.ddir'\0\0\0{%ON};
        sdebug.virtualsize     :=sectalign{0};
        sdebug.virtualaddr     :=maxrva;
        sdebug.datasize        :=0;
        sdebug.dataptr         :=0;
        sdebug.flags           :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sdebug);
     
        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sdebug.virtualaddr+sdebug.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      
      
      -- velikost image
      winhdr.imagesize:=maxrva;

      -- zarovnat soubor
      falign(os,filealign);
      os^.get_flow(t_offset(winhdr.hdrsize));


      -- kód
      if resolver.checkseg(tis_code) then
        os^.get_flow(t_offset(scode.dataptr));
        resolver.write_section(tis_code,os);
        falign(os,filealign);
        end if;

      -- Flex metadata
      if resolver.checkseg(tis_flex_metadata) then
        os^.get_flow(t_offset(smetadata.dataptr));
        resolver.write_section(tis_flex_metadata,os);
        falign(os,filealign);
        end if;

      -- konstanty
      if resolver.checkseg(tis_constants) then
        os^.get_flow(t_offset(sconst.dataptr));
        resolver.write_section(tis_constants,os);
        falign(os,filealign);
        end if;

      -- inicializovaná data
      if resolver.checkseg(tis_initialized_data) then
        os^.get_flow(t_offset(sinit.dataptr));
        resolver.write_section(tis_initialized_data,os);
        falign(os,filealign);
        end if;

      -- neinicializovaná data
      os^.get_flow(t_offset(sdata.dataptr));

      -- importní tabulky (1)
      os^.get_flow(t_offset(sicode.dataptr));
      resolver.write_section(tis_import_table,os);
      falign(os,filealign);
      dir.iat.rva:=sicode.virtualaddr;
      dir.iat.size:=get_seg_datasize(tis_import_table,false);{simport.virtualsize;}

      -- importní tabulky (2)
      os^.get_flow(t_offset(simport.dataptr));
      resolver.write_section(tis_import_metadata,os);
      falign(os,filealign);
      dir.import.rva:=simport.virtualaddr;
      dir.import.size:=get_seg_datasize(tis_import_metadata,false);{simport.virtualsize;}
      
      -- exportní tabulky
      if resolver.checkseg(tis_export_metadata) then
        os^.get_flow(t_offset(sexport.dataptr));
        resolver.write_section(tis_export_metadata,os);
        falign(os,filealign);
        dir.export.rva:=sexport.virtualaddr;
        dir.export.size:=get_seg_datasize(tis_export_metadata,false);{sexport.virtualsize;}
        end if;
     
      -- Flex relokace
      if resolver.checkseg(tis_flex_relocations) then
        os^.get_flow(t_offset(sflexrelo.dataptr));
        resolver.write_section(tis_flex_relocations,os);
        falign(os,filealign);
        end if;

      -- relokace 
      os^.get_flow(t_offset(srelo.dataptr));
      -- %%TODO(LIB) Nepoužívat přímo [_target] ale nějaké [get_target_stream]
      os^.set_lazy_buffer(false);
      srelo_data.transfer_buffered_packets(os^._target); 
      c_output_stream:(srelo_data).close;
      os^.set_lazy_buffer(true);
      falign(os,filealign);
      dir.baserelo.rva:=srelo.virtualaddr;
      dir.baserelo.size:=srelo_size;{srelo.virtualsize;}

    #if codeview then;
      if debug_info<>nil and debug_mode=tdit_codeview then
        os^.get_flow(t_offset(sdebug.dataptr));
        sdebug.datasize:=filealign;

        -- ulozime informace o debug informacich 
        os^.write_unchecked_part(p_codeview(debug_info)^.pe_dir_entry,p_codeview(debug_info)^.pe_dir_entry:size);
        falign(os,filealign);

        dir.debuginfo.rva:=sdebug.virtualaddr;
        dir.debuginfo.size:={sectalign}28;
        end if;
    #end if;

      -- zarovnat celý soubor na velikost sekce
      -- falign(os,sectalign); {%%X potenciální chyba, ne ? }
      
      os_bwriter.set_lazy_buffer(false);
      os_bwriter.flush;
      os_bwriter.close;
      
      -- opravit offset PE hlavičky zapsaný ve stubu
      declare var
        ofs        : t_unsigned32;
      begin
        ofs:=stub:size;
        f.write(peptrofs,ofs,ofs:size);
        end declare;

      -- zpětně přepsat změněné hlavičky
      f.write(coff_ofs,coff,coff:size);
      f.write(pehdr_ofs,pehdr,pehdr:size);
      f.write(winhdr_ofs,winhdr,winhdr:size);
      f.write(dir_ofs,dir,dir:size);
      if resolver.checkseg(tis_code) then
        f.write(scode_ofs,scode,scode:size);
        end if;
      if resolver.checkseg(tis_flex_metadata) then
        f.write(smetadata_ofs,smetadata,smetadata:size);
        end if;
      if resolver.checkseg(tis_constants) then
        f.write(sconst_ofs,sconst,sconst:size);
        end if;
      if resolver.checkseg(tis_initialized_data) then
        f.write(sinit_ofs,sinit,sinit:size);
        end if;
      if resolver.checkseg(tis_uninitialized_data) then
        f.write(sdata_ofs,sdata,sdata:size);
        end if;
      f.write(srelo_ofs,srelo,srelo:size);
      f.write(sicode_ofs,sicode,sicode:size);
      f.write(simport_ofs,simport,simport:size);
      if resolver.checkseg(tis_export_metadata) then
    --if sys_export_list.count>0 or library then
        f.write(sexport_ofs,sexport,sexport:size);
        end if;
      if resolver.checkseg(tis_flex_relocations) then
        f.write(sflexrelo_ofs,sflexrelo,sflexrelo:size);
        end if;
        
      if debug_info<>nil then
        f.write(sdebug_ofs,sdebug,sdebug:size);

      #if codeview then;
        -- aktualizujem info o debug informacich o udaj o jejich pozici
        if debug_mode=tdit_codeview then
          p_codeview(debug_info)^.PE_dir_entry.PointerToRawData:=f.get_size;
          f.write(sdebug.dataptr,p_codeview(debug_info)^.PE_dir_entry,p_codeview(debug_info)^.PE_dir_entry:size);

          -- ulozime vlastni codeview debug informace 
          f.write(f.get_size,debuginfo_data^,debuginfo_size);
          end if;
      #end if;
        end if;

      -- zavřít soubor
      f.close;
      end create;



    ------------------------------------------------------------------------------------------------
    override info =
    -- Výpis souhrnných informací do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;
    
    end c_link_image_pe;
    
    
    
----------------------------------------------------------------------------------------------------
class private c_link_resolver_image_specific_pe = 
-- Vyhodnocovač sekcí specifických pro různé druhy image souborů: Portable Executable.
----------------------------------------------------------------------------------------------------
      
    var
      imagebase    : t_unsigned32;               -- image base výsledného souboru
                 
    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      this.imagebase:=unicode_addr_to_unsigned(imagebase);
      end init;
      
      

    ------------------------------------------------------------------------------------------------
    override build_import_table_and_metadata =
    -- Sestaví importní tabulky.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding;
      
    type  
      -- Import Directory Entry
      tpeidirentry     = record
          ilt          : tperva;                 -- Import Lookup Table
          datetime     : t_unsigned32;           -- 0 (datim knihovny)
          forwarder    : t_unsigned32;           -- forwarder chain
          name         : tperva;                 -- jméno knihovny
          iat          : tperva;                 -- Import Address Table
          end record;
      tpeidir          = array of tpeidirentry;
      ppeidir          = ^tpeidir;

      -- Import Lookup Table
      tpeilookupentry  = record
          {%%TODO(POSITION)}
        --typ          : t_unsigned32 for position use 0; -- 0=by name, $8000_0000=by ordinal
          addr         : t_unsigned32 {for position use 0}; -- adresa Hint-name Tbl/ord. hodnota
          end record
              for alignment use 1
              for size      use 4;
      tpeilookup       = array of tpeilookupentry;
      ppeilookup       = ^tpeilookup;

      -- Hint-Name Table
      tpeiname         = record
          hint         : t_unsigned16;           -- 0
          name         : array 0..255 of t_char8;-- jméno, \0
          end record;

    var  
      dir          : ppeidir;                    -- Import Directory Table
      idirsize     : t_unsigned32;               -- velikost
      lookup       : ppeilookup;                 -- Import Lookup Table
      ilookupsize  : t_unsigned32;               -- velikost
      name         : p_char8uarray;              -- Hint/Name Table
      inamesize    : t_unsigned32;               -- velikost

    var
      nindex       : t_unsigned;                 -- index do NAME

        --------------------------------------------------------------------------------------------
        procedure add_name (
            xname  : in t_external_entity_ident) =
        -- Do tabulky jmen [name] doplni zadané jméno [xname].
        --------------------------------------------------------------------------------------------
        begin
          for i in xname:range loop
            name^[nindex]:=xname[i];
            nindex+1;
            end loop;
          nindex+{\0}1;
          if is_odd_unsigned(nindex) then nindex+{pad}1; end if;
          end add_name;

    var
      libcount     : t_unsigned;                 -- počet knihoven
      lookupcount  : t_unsigned;                 -- počet lookup záznamů
      namelen      : t_unsigned;                 -- paměť potřebná pro jména
      lindex       : t_unsigned;                 -- index do DIR
      pindex       : t_unsigned;                 -- index do LOOKUP
      pbase        : t_unsigned32;               -- bázová adresa LOOKUP
      nbase        : t_unsigned32;               -- bázová adresa NAME

    begin
      -- není co řešit
      if import.list=nil or else import.list^:length=0 then 
        return; 
        end if;

      -- spočítat knihovny
      libcount:=0;
      lookupcount:=0;
      namelen:=0;
      for i in import.list^:range loop
        declare var
          import_info : pimportinfo;             -- importní informace aktuální entity

        begin
          -- pro zjednodušení si zjistit importní informace aktuální entity
          import_info:=get_import_info(import.list^[i],^resolver.aux_registry);
      
          -- změna knihovny, započítat
          if i=import.list^:first or else pimportinfo(get_import_info(import.list^[i-1],^resolver.aux_registry))^.libname^<>import_info^.libname^ then
            -- započítat délku jména knihovny (zarovnání 2)
            namelen+((import_info^.libname^:length+{\0}1+{pad}1) div 2)*2;

            -- další knihovna
            succ libcount;

            -- prázdný lookup záznam
            if i>import.list^:first then succ lookupcount; end if;
            end if;

          -- započítat délku jména (zarovnání 2)
          namelen+{hint}2+((import_info^.extname^:length+{\0}1+{pad}1) div 2)*2;
          end declare;

        -- započítat lookup záznam
        succ lookupcount;
        end loop;

      -- započítat mezery na konci seznamů
      succ libcount;
      succ lookupcount;

      -- alokovat paměť
      idirsize:=tpeidirentry:size*libcount;
      new dir range libcount;
      ilookupsize:=tpeilookupentry:size*lookupcount;
      new lookup range lookupcount;
      inamesize:=namelen;
      new name range namelen;

      -- sestavit tabulky
      lindex:=0;
      pindex:=0;
      nindex:=0;
      pbase:=unicode_addr_to_unsigned(base_metadata)-imagebase+libcount*tpeidirentry:size;
      nbase:=pbase+tpeilookupentry:size*lookupcount;
      for i in import.list^:range loop 
        declare var
          import_info : pimportinfo;             -- importní informace aktuální entity
          
        begin  
          -- pro zjednodušení si zjistit importní informace aktuální entity
          import_info:=get_import_info(import.list^[i],^resolver.aux_registry);

          -- změnila se knihovna, vygenerovat pro ni záznam
          if i=import.list^:first or pimportinfo(get_import_info(import.list^[i-1],^resolver.aux_registry))^.libname^<>import_info^.libname^ then
            -- mezera za předchozí knihovnou v LOOKUP
            if i>import.list^:first then succ pindex; end if;

            -- deskriptor knihovny
            dir^[lindex].ilt :=pbase+pindex*tpeilookupentry:size;
            dir^[lindex].name:=nbase+nindex;
            dir^[lindex].iat :=unicode_addr_to_unsigned(base_table)-imagebase+pindex*tpeilookupentry:size;

            -- doplnit jméno knihovny
            add_name(import_info^.libname^);

            -- další knihovna
            succ lindex;
            end if;

          -- deskriptor procedury
          lookup^[pindex].addr:=nbase+nindex;

          -- hint: 0
          nindex+2;

          -- doplnit jméno procedury
          add_name(import_info^.extname^);
          end declare;

        -- další procedura
        succ pindex;
        end loop;

    commit
      verify({VERIFY=}001345,dir   =nil and then idirsize   <>0);
      verify({VERIFY=}001346,lookup=nil and then ilookupsize<>0);
      verify({VERIFY=}001347,name  =nil and then inamesize  <>0);

      -- zapsat data sekce importní tabulky
      section_table.write_unchecked(lookup^);

      -- zapsat data sekce importních metadat
      section_metadata.write_unchecked(dir^);
      section_metadata.write_unchecked(lookup^);
      section_metadata.write_unchecked(name^);

    leave
      -- uvolnit pracovní paměť
      discard dir;
      discard lookup;
      discard name;
      end build_import_table_and_metadata;



    ------------------------------------------------------------------------------------------------
    override build_export_metadata =
    -- Sestaví exportní tabulky.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding,
      cg_gen.cg_ia32.ci_def;

    type
      -- Export Directory Entry
      tpeedirentry     = record
          exportflags  : t_mod_unsigned32;       -- reserved, set to 0
          datetime     : t_unsigned32;           -- time and date when the export data was created
          majver       : t_unsigned16;           -- major version
          minver       : t_unsigned16;           -- minor version
          namerva      : tperva;                 -- address of the ASCII containing the DLL name 
          ordbase      : t_unsigned32;           -- starting ordinal for the exports
          addrtblentrs : t_unsigned32;           -- number of entries in the Export Address Table
          numnameptr   : t_unsigned32;           -- number of entries in the Name Pointer and Ordinal Table
          expaddrtblrva: tperva;                 -- address of the Export Address Table
          nameptrrva   : tperva;                 -- address of the Export Name Pointer
          ordtblrva    : tperva;                 -- address of the Ordinal Table
          end record
              for alignment use 1;

      -- Export Address Table
      tpeeaddrentry    = tperva;                 -- address of the exported symbol when loaded into memory

      tpeeaddrtable    = array of tpeeaddrentry;
      ppeeaddrtable    = ^tpeeaddrtable;

      -- Export Name Pointer Table
      tpeenameptrentry = tperva;                 -- rva into Export Name Table, ordered lexically
      tpeenameptrtable = array of tpeenameptrentry;
      ppeenameptrtable = ^tpeenameptrtable;

      -- Export Ordinal Table
      tpeeordentry     = t_unsigned16;           -- index into Export Address Table
      tpeeordtable     = array of tpeeordentry;
      ppeeordtable     = ^tpeeordtable;
        
      -- Export Name Table
      tpeenametable    = array of t_char8;       -- list of ascii null-terminated exported names
      ppeenametable    = ^tpeenametable;

      -- %%TECH Algorithm for finding exported symbol's address:
      -- i = Search_ExportNamePointerTable (ExportName);
      -- ordinal = ExportOrdinalTable [i];
      -- SymbolRVA = ExportAddressTable [ordinal - OrdinalBase];
    
    var
      dir          : tpeedirentry;               -- Export Directory Table (obsahuje jen jeden zaznam)
      addr         : ppeeaddrtable;       
      addrsize     : t_unsigned32;
      nameptrs     : ppeenameptrtable;
      nameptrssize : t_unsigned32;
      ordinals     : ppeeordtable;
      ordinalssize : t_unsigned32;
      names        : ppeenametable;
      namessize    : t_unsigned32;
      
        --------------------------------------------------------------------------------------------
        procedure add_name (
            name        : in t_external_entity_ident;
            names       : in ppeenametable;
            names_index : in out t_unsigned32) =
        -- Do jmen [names] doplni zadané jméno [name] na pozici [names_index], kterou updateuje
        --------------------------------------------------------------------------------------------
        begin
          for i in name:range loop
            names^[names_index]:=t_char8(name[i]);
            names_index+1;
            end loop;
          names_index+{\0}1;
          end add_name;
      
    var
      expnameslength  : t_unsigned32;
      expnum          : t_unsigned32; -- pocet exportu
      curraddr        : t_unsigned32;
      n               : t_unsigned32;

    const                 
      -- %%TODO(DLL) - dllname nahradit jmenem souboru linkimage
      dllname         = {: t_char32str :=} 'main.dll';

    begin
      -- osetrit vstup. parametry
      if export.count<=0 or export.list=nil then return; end if;

      -- pocet exportu
      expnum:=export.count;

      -- suma velikosti exportnich jmen
      expnameslength:=0;
      for i in export.list^:range loop
        -- započítat délku vlastního jméno a koncovou nulu
        expnameslength+pexportinfo(get_export_info(export.list^[i]))^.export_name^:length+1;
        end loop;

      expnameslength+dllname:length+1;

      dir.exportflags:=0;
      dir.datetime:=0;
      dir.majver:=0;
      dir.minver:=0;
      dir.namerva:=0;
      dir.ordbase:=1;
      dir.addrtblentrs:=expnum;
      dir.numnameptr:=expnum;

      new addr range expnum;
      addrsize:=tpeeaddrentry:size*expnum;

      new ordinals range expnum;
      ordinalssize:=tpeeordentry:size*expnum;

      new nameptrs range expnum;
      nameptrssize:=tpeenameptrentry:size*expnum;

      new names range expnameslength;
      namessize:=expnameslength;

      dir.expaddrtblrva:=unicode_addr_to_unsigned(base_addr)-imagebase+tpeedirentry:size;
      dir.nameptrrva:=dir.expaddrtblrva+addrsize;
      dir.ordtblrva:=dir.nameptrrva+nameptrssize;
      n:=0;

      -- jmeno dllka
      dir.namerva:=dir.ordtblrva+ordinalssize;
      add_name(dllname,names,n);

      for i in export.list^:range loop
        -- export address table
        addr^[i-1]:=i_get_entity_instance_address(export.list^[i])-imagebase;

        -- name ptr table and names
        nameptrs^[i-1]:=dir.ordtblrva+ordinalssize+n;
        add_name(pexportinfo(get_export_info(export.list^[i]))^.export_name^,names,n);

        -- ord table
        ordinals^[i-1]:=i;
        ordinals^[i-1]-1; {%%TODO(DYNAMIC_CHECK) záplata kvůli rozsahu i od 1 do N }
        end loop;

    commit
      verify({VERIFY=}001348,addr    =nil and then addrsize    <>0);
      verify({VERIFY=}001349,nameptrs=nil and then nameptrssize<>0);
      verify({VERIFY=}001350,ordinals=nil and then ordinalssize<>0);
      verify({VERIFY=}001351,names   =nil and then namessize   <>0);

      -- zapsat data sekce exportních metadat
      section.write_unchecked(dir);
      section.write_unchecked(addr^);
      section.write_unchecked(nameptrs^);
      section.write_unchecked(ordinals^);
      section.write_unchecked(names^);

    leave
      -- uvolnit pracovní paměť
      discard addr;
      discard nameptrs;
      discard ordinals;
      discard names;
      end build_export_metadata;



    ------------------------------------------------------------------------------------------------
    static build_relocations_internal (
        section    : in out c_stream_binary_writer; -- zapisovač data sekce
        relocaddrs : in t_relocations;           -- setrideny seznam adres na kterych je treba provest relokaci
        absrel_code: in t_mod_unsigned16;        -- kód absolutní relokace
        relrel_code: in t_mod_unsigned16;        -- kód relativní relokace
        null_term  : in t_logical := false) =    -- null-terminated sekvence fixup bloku
    -- Sestaví relokační tabulku parametrizovanou buď pro PE nebo pro Flex relokace.
    ------------------------------------------------------------------------------------------------
    type  
      -- reloc fixup block
      tperelocfixupblock = record
          pagerva        : tperva;               -- start RVA of the 4K fixup block
          blocksize      : t_unsigned32;         -- total size of this record + all block size fields
          typeandoffset  : ^array of t_mod_unsigned16; -- block size fields
                                                 -- type of the fixup stored in high 4 bits
                                                 -- offset into the 4K page where the fixup is to be applied  
                                                 -- stored in the remaining 12 bits of the t_unsigned16
          end record
              for alignment use 1;

      -- reloc fixup block table
      tperelocfixuptable = array of tperelocfixupblock;
      pperelocfixuptable = ^tperelocfixuptable;

    var
      fixups     : pperelocfixuptable;           -- PE relokacni informace
      relocdatasize : t_unsigned32;              -- celkova velikost PE relokacnich informaci
    
    var
      fixupblocks  : t_unsigned;

    begin
      -- prazdny seznam relokaci?
      if relocaddrs:length=0 then return; end if;

      -- zjisti kolik ze to 4-kilovych fixup bloku budeme mit
      declare var
        tempaddr   : t_unsigned;

      begin
        -- alespon jeden 4K fixup blok
        fixupblocks:=1;
  
        -- inicalizuj tempaddr prvni adresou
        tempaddr:=relocaddrs[1].address;
        
        -- projed vsechny adresy
        for i in relocaddrs:range loop
          if relocaddrs[i].address-tempaddr>=4096 then
            tempaddr:=relocaddrs[i].address;
            
            -- incrementuj pocet fixup bloku kazdych 4096 bytu
            succ fixupblocks;
            end if;
          end loop;
        end declare;

      -- alokuj pamet pro zjisteny pocet 4-kilovych bloku
      new fixups range fixupblocks;

      -- projed vsechny adresy a vygeneruj relokacni informace
      declare var
        blockindex : t_unsigned := 0;
        blockrelocs: t_unsigned;
        checkrelocs: t_unsigned;                 
        i          : t_unsigned;

      begin
        i:=relocaddrs:first;
        while i<=relocaddrs:length loop
          verify({VERIFY=}001352,not (blockindex<fixupblocks));

          -- do hlavicky bloku uloz page rva, 
          fixups^[blockindex].pagerva:=relocaddrs[i].address-imagebase;

          -- zjisti pocet jednotlivych relokaci v tomto bloku
          declare var
            k    : t_unsigned;
          begin
            k:=i;
            while k<=relocaddrs:length and then relocaddrs[k].address-relocaddrs[i].address<4096 loop 
              succ k;
              end loop;
            blockrelocs:=k-i;
            end declare;

          -- alokuj pole typeandoffset poctem jednotlicych relokaci zjistenym v predchozim kroku
          new fixups^[blockindex].typeandoffset range blockrelocs;

          -- napln typeandoffset jednotlivymi relokacemi
          declare var
            k    : t_unsigned;
          begin
            k:=i;
            while k<=relocaddrs:length and then relocaddrs[k].address-relocaddrs[i].address<4096 loop 
              -- hornich 4 bitu udava typ relokace, zbylych 12 offset od fixups^[blockindex].pagerva
              fixups^[blockindex].typeandoffset^[k-i]:=t_mod_unsigned16(relocaddrs[k].address-relocaddrs[i].address);
              case relocaddrs[k].disposition
                when trd_absolute do fixups^[blockindex].typeandoffset^[k-i] or (absrel_code shl 12);
                when trd_relative do fixups^[blockindex].typeandoffset^[k-i] or (relrel_code shl 12);
                end case;
              succ k;
              
              -- kontrolni promenna
              succ checkrelocs;
              end loop;
            i:=k;
            end declare;

          -- uloz velikost hlavicky bloku a vsech relokaci v bloku do hlavicky 4-K bloku
          fixups^[blockindex].blocksize:=fixups^[blockindex].pagerva:size+fixups^[blockindex].blocksize:size+blockrelocs*t_mod_unsigned16:size;
          
          -- pricist velikost bloku k celkove velikosti PE relokacnich informaci
          relocdatasize+fixups^[blockindex].blocksize;

          -- dalsi block
          succ blockindex;      
          end loop;

        -- pokud checkrelocs se nebude rovnat poctu adres v seznamu relokaci, je chyba v algoritmu teto funkce
        verify({VERIFY=}001353,checkrelocs<>relocaddrs:length);
        end declare;
      
    commit
      -- zapsat data sekce relokací
      for i in fixups^:range loop
        section.write_unchecked(fixups^[i].pagerva);
        section.write_unchecked(fixups^[i].blocksize);
        section.write_unchecked(fixups^[i].typeandoffset^);
        --for j in fixups^[i].typeandoffset^:range loop
        --  section.write_unchecked_part(fixups^[i].typeandoffset^[j],fixups^[i].typeandoffset^[j]:size);
        --  end loop;
        end loop;
    
      -- koncová nula, je-li požadována
      if null_term then
        declare var
          zero     : tperva;
        begin
          section.write_unchecked(zero);
          end declare;
        end if;  
    
    leave
      -- uvolnit paměť
      for i in fixups^:range loop
        discard fixups^[i].typeandoffset;
        end loop;
      discard fixups;
      end build_relocations_internal;



    ------------------------------------------------------------------------------------------------
    override build_flex_relocations =
    -- Sestaví relokační tabulku.
    ------------------------------------------------------------------------------------------------
    with
      cc_base.cc_options,
      cc_binding;
      
    const
      -- dispozice relokací fixup bloků pro vyhodnocení relokací run-time knihovnou
      image_rel_flex_none     = 0;               -- vynechaný fixup záznam
      image_rel_flex_absolute = 1;               -- absolutní relokace
      image_rel_flex_relative = 2;               -- relativní relokace

    var
      relocations  : p_relocations;              -- setříděný seznam relokací
      compi        : pentity_compile;            -- související kompilační jednotka

    begin
      -- načíst první seznam
      if not relo_it.get(relocations,compi) then return end if;
      
      -- uložit originální image base tohoto modulu
      section.write_unchecked(imagebase);
      
      loop
        verify({VERIFY=}001370,compi=nil or else compi^.part_extid=nil);
{        
0040_0000          -- my image base

0000_3000          -- FLEX.@COMPILATION RVA
1000_0000          -- FLEX image base
0000_103F          -- page RVA
0000_0012          -- block size => 5 relokace
     2000
     101A
     2016
     2020
     2025
0000_0000

0000_300C          -- SMPL.@COMPILATION
1000_0000          -- SMPL image base
0000_10A0          -- page RVA
0000_000C          -- block size => 2 relokace
     1000
     200A
0000_0000

0000_0000
}
        -- odkaz na import @COMPILATION
        declare var
          addr     : t_unsigned32;
        begin  
          addr:=unicode_addr_to_unsigned(pimportinfo(get_import_info(compi,^resolver.aux_registry))^.addr)-imagebase;
          section.write_unchecked(addr);
          end declare;
      { 
        -- externí jméno partition
        section.write_unchecked_part(compi^.part_extid^,compi^.part_extid^:length:size+compi^.part_extid^:length*compi^.part_extid^:base:size);
      } 
        -- image base, proti které je tento modul linkován
        declare var
          imagebase : t_unsigned32;

        begin  
          imagebase:=unicode_addr_to_unsigned(os^.getimagebase(compi^));
          section.write_unchecked(imagebase);
          end declare;

        -- tabulka relokací
        build_relocations_internal(section,relocations^,for absrel_code use image_rel_flex_absolute,for relrel_code use image_rel_flex_relative,for null_term use true);
        until not relo_it.get(relocations,compi);

      -- koncová nula, je-li požadována
      declare var
        zero     : tperva;
      begin
        section.write_unchecked(zero);
        end declare;
      end build_flex_relocations;



    ------------------------------------------------------------------------------------------------
    static build_pe_relocations =
    -- Sestaví relokační tabulku PE souboru.
    ------------------------------------------------------------------------------------------------
    const
      -- dispozice relokací fixup bloků pro vyhodnocení relokací systémem (reloc fixup types)
      IMAGE_REL_BASED_ABSOLUTE           = 0;    -- The fixup is skipped. This type can be used to
                                                 -- pad a block.
      IMAGE_REL_BASED_HIGH               = 1;    -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 32-bit word.
      IMAGE_REL_BASED_LOW                = 2;    -- The fixup adds the low 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the low half of a 32-bit word.
      IMAGE_REL_BASED_HIGHLOW            = 3;    -- The fixup applies the delta to the 32-bit field
                                                 -- at Offset.
      IMAGE_REL_BASED_HIGHADJ            = 4;    -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 32-bit word.
                                                 -- The low 16 bits of the 32-bit value are stored
                                                 -- in the 16-bit word that follows this base
                                                 -- relocation. This means that this base
                                                 -- relocation occupies two slots.
      IMAGE_REL_BASED_MIPS_JMPADDR       = 5;    -- Fixup applies to a MIPS jump instruction.
      IMAGE_REL_BASED_SECTION            = 6;    -- Reserved for future use
      IMAGE_REL_BASED_REL32              = 7;    -- Reserved for future use
      IMAGE_REL_BASED_MIPS_JMPADDR16     = 9;    -- Fixup applies to a MIPS16 jump instruction.
      IMAGE_REL_BASED_DIR64              = 10;   -- This fixup applies the delta to the 64-bit field
                                                 -- at Offset
      IMAGE_REL_BASED_HIGH3ADJ           = 11;   -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 48-bit word.
                                                 -- The low 32 bits of the 48-bit value are stored
                                                 -- in the 32-bit word that follows this base
                                                 -- relocation. This means that this base
                                                 -- relocation occupies three slots.

    begin
      build_relocations_internal(section,relocations,for absrel_code use IMAGE_REL_BASED_HIGHLOW,for relrel_code use nil);
      end build_pe_relocations;

    end c_link_resolver_image_specific_pe;

end cl_pe;
