----------------------------------------------------------------------------------------------------
module private cl_pe =
-- Překladač Flexu.
-- Portable Executable.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.04.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private linkimage_pe =
-- Portable Executable image creator.
----------------------------------------------------------------------------------------------------

    with
      standard,
      standard.files,
      standard.streams,
      standard.numerics,
      cc_def.cc_unitype,
      cc_def.cc_codes,
      cc_def.cc_entity.cc_list,
      cc_def.cc_var,
      cp_os,
      cp_os.cp_win32,
      cl_link.cl_debug,
      #if codeview then;
      cl_link.cl_debug.cl_codeview,
      #end if;
      cl_def,
      cg_gen,
      cg_gen.cg_ia32,
      cg_gen.cg_ia32.ci_def,
      standard.console,
      standard.conversions;

    var
      -- signatura PE souboru
      pesign           : const t_unsigned32 := $00004550 {'PE'\0\0};

    const
      -- modifikace PE hlavičky
      magic_rom        = $107;                   -- ROM image
      magic_pe32       = $10B;                   -- PE32
      magic_pe32p      = $20B;                   -- PE32+

      -- offset pointeru na PE hlavičku
      peptrofs         = $3C;

      -- zarovnání
      sectalign        = 4096;                   -- zarovnání sekcí
      filealign        = 512;                    -- zarovnání bloků v souboru

    type
      tpefileptr       = private t_unsigned32;   -- File Pointer
      tperva           = private t_unsigned32;   -- Relative Virtual Address
      tpesize          = private t_unsigned32;   -- velikost objektu v bytech
      tpever1          = record                  -- číslo verze
          major        : t_unsigned8;            -- - verze
          minor        : t_unsigned8;            -- - revize
          end record;
      tpever2          = record                  -- číslo verze
          major        : t_unsigned16;           -- - verze
          minor        : t_unsigned16;           -- - revize
          end record;
      tpememsize       = record                  -- velikost paměti
          reserve_size : tpesize;                -- - rezervovat
          commit_size  : tpesize;                -- - alokovat
          end record;
      tpedirentry      = record                  -- položka data directory
          rva          : tperva;                 -- - RVA
          size         : tpesize;                -- - velikost
          end record;

      -- COFF hlavička
      tcoffheader      = record
          machine      : t_unsigned16;           -- cílová platforma
          sectioncount : t_unsigned16;           -- počet sekcí
          datetime     : t_unsigned32;           -- časová značka
          symtab       : tpefileptr;             -- pointer na tabulku symbolů
          symcount     : t_unsigned32;           -- počet symbolu v tabulce
          opthdrsize   : t_unsigned16;           -- velikost volitelné hlavičky (PE hdr)
          flags        : t_mod_unsigned16;       -- další parametry
          end record
              for alignment use 1
              for size      use 20;
      --%%TODO(CHECK) __tcoffheader        = true..tcoffheader:size=20;

      -- základ PE hlavičky
      tpe0header       = record
          magic        : t_unsigned16;           -- modifikace PE hlavičky
          linkerver    : tpever1;                -- verze linkeru
          codetotal    : tpesize;                -- velikost sekcí s kódem
          inittotal    : tpesize;                -- velikost sekcí s init. daty
          datatotal    : tpesize;                -- velikost sekcí s daty
          entrypoint   : tperva;                 -- entry point
          codebase     : tperva;                 -- relativní báze kódu
          end record;

      -- PE32 hlavička (COFF optional header)
      tpe32header      = tpe0header with record
          database     : tperva;                 -- relativní báze dat
          end record
              for alignment use 1
              for size      use 28;
      --%%TODO(CHECK) __tpe32header        = true..tpe32header:size=28;

      -- PE32+ hlavička (COFF optional header)
      tpe32pheader     = tpe0header with record
          end record;

      -- image base
      tpe32base        = private t_unsigned32;
    --tpe32pbase       = private t_unsigned64;

      -- PE32 a PE32+ Windows Specific Header
      tpewinheader     = record
          sectalign    : t_unsigned32;           -- section alignment
          filealign    : t_unsigned32;           -- file alignment
          osver        : tpever2;                -- verze operačního systému
          imagever     : tpever2;                -- verze image
          subsysver    : tpever2;                -- verze subsystému
          win32ver     : t_unsigned32;           -- verze Win32
          imagesize    : tpesize;                -- velikost image
          hdrsize      : tpesize;                -- velikost hlaviček
          checksum     : t_unsigned32;           -- kontrolní součet
          subsys       : t_unsigned16;           -- subsystém
          dllflags     : t_mod_unsigned16;       -- další parametry pro DLL
          stack        : tpememsize;             -- velikost stacku
          heap         : tpememsize;             -- velikost heapu
          loaderflags  : t_mod_unsigned32;       -- parametry pro loader
          dircount     : t_unsigned32;           -- počet záznamů v data directory
          end record
              for alignment use 1
              for size      use 64;
      --%%TODO(CHECK) __tpewinheader       = true..tpewinheader:size=64;

      -- PE32 a PE32+ data directory
      tpedatadir       = record
          export       : tpedirentry;            -- export table
          import       : tpedirentry;            -- import table
          resource     : tpedirentry;            -- resource table
          exceptions   : tpedirentry;            -- exception table
          cert         : tpedirentry;            -- certificate table     ! RVA=fileptr
          baserelo     : tpedirentry;            -- base relocation table
          debuginfo    : tpedirentry;            -- debug info
          architecture : tpedirentry;            -- architecture specific data
          globalptr    : tpedirentry;            -- global pointer        ! SIZE:=0
          tls          : tpedirentry;            -- thread local storage table
          loadcfg      : tpedirentry;            -- load config
          boundimport  : tpedirentry;            -- bound import table
          iat          : tpedirentry;            -- import address table
          delayimport  : tpedirentry;            -- delay import descriptor
          compruntime  : tpedirentry;            -- COM+ runtime header
          rezerva      : tpedirentry;
          end record;

      -- PE32 a PE32+ section header
      tpesectname      = array 1..8 of t_char8;
      tpesectheader    = record
          name         : tpesectname;            -- jméno sekce
          virtualsize  : tpesize;                -- velikost sekce v paměti
          virtualaddr  : tperva;                 -- adresa sekce v paměti
          datasize     : tpesize;                -- velikost dat v image souboru
          dataptr      : tpefileptr;             -- pointer na data v image souboru
          reloptr      : tpefileptr;             -- pointer na relokace
          lineptr      : tpefileptr;             -- pointer na řádkové informace
          relocount    : t_unsigned16;           -- počet relokací
          linecount    : t_unsigned16;           -- počet řádkových informací
          flags        : t_mod_unsigned32;       -- další parametry
          end record
              for alignment use 1
              for size      use 40;
      --%%TODO(CHECK) __tpesectheader  = true..tpesectheader:size=40;

      -- Import Directory Entry
      tpeidirentry     = record
          ilt          : tperva;                 -- Import Lookup Table
          datetime     : t_unsigned32;           -- 0 (datim knihovny)
          forwarder    : t_unsigned32;           -- forwarder chain
          name         : tperva;                 -- jméno knihovny
          iat          : tperva;                 -- Import Address Table
          end record;
      tpeidir          = array of tpeidirentry;
      ppeidir          = ^tpeidir;

      -- Import Lookup Table
      tpeilookupentry  = record
          {%%TODO(POSITION)}
        --typ          : t_unsigned32 for position use 0; -- 0=by name, $8000_0000=by ordinal
          addr         : t_unsigned32 {for position use 0}; -- adresa Hint-name Tbl/ord. hodnota
          end record
              for alignment use 1
              for size      use 4;
      tpeilookup       = array of tpeilookupentry;
      ppeilookup       = ^tpeilookup;

      -- Hint-Name Table
      tpeiname         = record
          hint         : t_unsigned16;           -- 0
          name         : array 0..255 of t_char8;-- jméno, \0
          end record;

      -- Export Directory Entry
      tpeedirentry     = record
          exportflags  : t_mod_unsigned32;       -- reserved, set to 0
          datetime     : t_unsigned32;           -- time and date when the export data was created
          majver       : t_unsigned16;           -- major version
          minver       : t_unsigned16;           -- minor version
          namerva      : tperva;                 -- address of the ASCII containing the DLL name 
          ordbase      : t_unsigned32;           -- starting ordinal for the exports
          addrtblentrs : t_unsigned32;           -- number of entries in the Export Address Table
          numnameptr   : t_unsigned32;           -- number of entries in the Name Pointer and Ordinal Table
          expaddrtblrva: tperva;                 -- address of the Export Address Table
          nameptrrva   : tperva;                 -- address of the Export Name Pointer
          ordtblrva    : tperva;                 -- address of the Ordinal Table
          end record
              for alignment use 1;


      -- Export Address Table
      tpeeaddrentry    = tperva;                 -- address of the exported symbol when loaded into memory

      tpeeaddrtable    = array of tpeeaddrentry;
      ppeeaddrtable    = ^tpeeaddrtable;


      -- Export Name Pointer Table
      tpeenameptrentry = tperva;                 -- rva into Export Name Table, ordered lexically
      tpeenameptrtable = array of tpeenameptrentry;
      ppeenameptrtable = ^tpeenameptrtable;


      -- Export Ordinal Table
      tpeeordentry     = t_unsigned16;           -- index into Export Address Table
      tpeeordtable     = array of tpeeordentry;
      ppeeordtable     = ^tpeeordtable;
        
      -- Export Name Table
      tpeenametable    = array of t_char8;       -- list of ascii null-terminated exported names
      ppeenametable    = ^tpeenametable;

      -- %%TECH Algorithm for finding exported symbol's address:
      -- i = Search_ExportNamePointerTable (ExportName);
      -- ordinal = ExportOrdinalTable [i];
      -- SymbolRVA = ExportAddressTable [ordinal - OrdinalBase];


      -- reloc fixup block
      tperelocfixupblock = record
        pagerva        : tperva;                 -- start RVA of the 4K fixup block
        blocksize      : t_unsigned32;           -- total size of this record + all block size fields
        typeandoffset  : ^array of t_mod_unsigned16; -- block size fields
                                                 -- type of the fixup stored in high 4 bits
                                                 -- offset into the 4K page where the fixup is to be applied  
                                                 -- stored in the remaining 12 bits of the t_unsigned16
        end record
            for alignment use 1;

      -- reloc fixup block table
      tperelocfixuptable = array of tperelocfixupblock;
      pperelocfixuptable = ^tperelocfixuptable;



    const
      -- cílové platformy
      IMAGE_FILE_MACHINE_ALPHA     = $184;       -- Alpha AXP
      IMAGE_FILE_MACHINE_ARM       = $1c0;       --
      IMAGE_FILE_MACHINE_ALPHA64   = $284;       -- Alpha AXP 64-bit
      IMAGE_FILE_MACHINE_I386      = $14c;       -- Intel 386 or later
      IMAGE_FILE_MACHINE_I486      = $14d;       -- Intel 486 or later
      IMAGE_FILE_MACHINE_PENTIUM   = $14e;       -- Intel Pentium or later
      IMAGE_FILE_MACHINE_IA64      = $200;       -- Intel IA64
      IMAGE_FILE_MACHINE_M68K      = $268;       -- Motorola 68000 series
      IMAGE_FILE_MACHINE_MIPS16    = $266;       --
      IMAGE_FILE_MACHINE_MIPSFPU   = $366;       -- MIPS with FPU
      IMAGE_FILE_MACHINE_MIPSFPU16 = $466;       -- MIPS16 with FPU
      IMAGE_FILE_MACHINE_POWERPC   = $1f0;       -- Power PC, little endian
      IMAGE_FILE_MACHINE_R3000     = $162;       --
      IMAGE_FILE_MACHINE_R4000     = $166;       -- MIPS little endian
      IMAGE_FILE_MACHINE_R10000    = $168;       --
      IMAGE_FILE_MACHINE_SH3       = $1a2;       -- Hitachi SH3
      IMAGE_FILE_MACHINE_SH4       = $1a6;       -- Hitachi SH4
      IMAGE_FILE_MACHINE_THUMB     = $1c2;       --

      -- příznaky
      IMAGE_FILE_RELOCS_STRIPPED         = $0001;-- neobsahuje relokace
      IMAGE_FILE_EXECUTABLE_IMAGE        = $0002;-- soubor je spustitelný
      IMAGE_FILE_LINE_NUMS_STRIPPED      = $0004;-- neobsahuje řádkové info.
      IMAGE_FILE_LOCAL_SYMS_STRIPPED     = $0008;-- neobsahuje lokální symb.
      IMAGE_FILE_AGGRESSIVE_WS_TRIM      = $0010;-- Aggressively trim working set
      IMAGE_FILE_LARGE_ADDRESS_AWARE     = $0020;-- přežije > 2GB paměti
      IMAGE_FILE_16BIT_MACHINE           = $0040;-- Use of this flag is reserved for future use
      IMAGE_FILE_BYTES_REVERSED_LO       = $0080;-- little endian
      IMAGE_FILE_32BIT_MACHINE           = $0100;-- 32-bit-word architecture
      IMAGE_FILE_DEBUG_STRIPPED          = $0200;-- neobsahuje debug info.
      IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = $0400;-- spouštět ze swap filu
      IMAGE_FILE_SYSTEM                  = $1000;-- systémový soubor
      IMAGE_FILE_DLL                     = $2000;-- DLL
      IMAGE_FILE_UP_SYSTEM_ONLY          = $4000;-- File should be run only on a UP machine
      IMAGE_FILE_BYTES_REVERSED_HI       = $8000;-- big endian

      -- subsystémy
      IMAGE_SUBSYSTEM_UNKNOWN            = 0;    -- Unknown subsystem
      IMAGE_SUBSYSTEM_NATIVE             = 1;    -- device drivers and native
      IMAGE_SUBSYSTEM_WINDOWS_GUI        = 2;    -- Windows GUI
      IMAGE_SUBSYSTEM_WINDOWS_CUI        = 3;    -- Windows console
      IMAGE_SUBSYSTEM_POSIX_CUI          = 7;    -- Posix console
      IMAGE_SUBSYSTEM_WINDOWS_CE_GUI     = 9;    -- Windows CE

      -- parametry DLL
      IMAGE_DLLCHARACTERISTICS_NO_BIND   = $0800;-- Do not bind image
      IMAGE_DLLCHARACTERISTICS_WDM_DRIVER= $2000;-- WDM Driver
      IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = $8000; -- Image is Terminal Server aware

      -- parametry sekcí
      IMAGE_SCN_TYPE_REG                 = $00000000;-- Reserved for future use
      IMAGE_SCN_TYPE_DSECT               = $00000001;-- Reserved for future use
      IMAGE_SCN_TYPE_NOLOAD              = $00000002;-- Reserved for future use
      IMAGE_SCN_TYPE_GROUP               = $00000004;-- Reserved for future use
      IMAGE_SCN_TYPE_NO_PAD              = $00000008;-- obsolete
      IMAGE_SCN_TYPE_COPY                = $00000010;-- Reserved for future use
      IMAGE_SCN_CNT_CODE                 = $00000020;-- executable code
      IMAGE_SCN_CNT_INITIALIZED_DATA     = $00000040;-- initialized data
      IMAGE_SCN_CNT_UNINITIALIZED_DATA   = $00000080;-- uninitialized data
      IMAGE_SCN_LNK_OTHER                = $00000100;-- Reserved for future use
      IMAGE_SCN_LNK_INFO                 = $00000200;-- comments or other info.
      IMAGE_SCN_TYPE_OVER                = $00000400;-- Reserved for future use
      IMAGE_SCN_LNK_REMOVE               = $00000800;-- not become part of image
      IMAGE_SCN_LNK_COMDAT               = $00001000;-- COMDAT data
      IMAGE_SCN_MEM_FARDATA              = $00008000;-- Reserved for future use
      IMAGE_SCN_MEM_PURGEABLE            = $00020000;-- Reserved for future use
      IMAGE_SCN_MEM_16BIT                = $00020000;-- Reserved for future use
      IMAGE_SCN_MEM_LOCKED               = $00040000;-- Reserved for future use
      IMAGE_SCN_MEM_PRELOAD              = $00080000;-- Reserved for future use
      IMAGE_SCN_ALIGN_1BYTES             = $00100000;-- 1-byte boundary alignment
      IMAGE_SCN_ALIGN_2BYTES             = $00200000;-- 2-byte boundary
      IMAGE_SCN_ALIGN_4BYTES             = $00300000;-- 4-byte boundary
      IMAGE_SCN_ALIGN_8BYTES             = $00400000;-- 8-byte boundary
      IMAGE_SCN_ALIGN_16BYTES            = $00500000;-- 16-byte boundary
      IMAGE_SCN_ALIGN_32BYTES            = $00600000;-- 32-byte boundary
      IMAGE_SCN_ALIGN_64BYTES            = $00700000;-- 64-byte boundary
      IMAGE_SCN_ALIGN_128BYTES           = $00800000;-- 128-byte
      IMAGE_SCN_ALIGN_256BYTES           = $00900000;-- 256-byte
      IMAGE_SCN_ALIGN_512BYTES           = $00A00000;-- 512-byte
      IMAGE_SCN_ALIGN_1024BYTES          = $00B00000;-- 1024-byte
      IMAGE_SCN_ALIGN_2048BYTES          = $00C00000;-- 2048-byte
      IMAGE_SCN_ALIGN_4096BYTES          = $00D00000;-- 4096-byte
      IMAGE_SCN_ALIGN_8192BYTES          = $00E00000;-- 8192-byte
      IMAGE_SCN_LNK_NRELOC_OVFL          = $01000000;-- extended relocations
      IMAGE_SCN_MEM_DISCARDABLE          = $02000000;-- can be discarded as needed
      IMAGE_SCN_MEM_NOT_CACHED           = $04000000;-- cannot be cached
      IMAGE_SCN_MEM_NOT_PAGED            = $08000000;-- not pageable
      IMAGE_SCN_MEM_SHARED               = $10000000;-- can be shared in memory
      IMAGE_SCN_MEM_EXECUTE              = $20000000;-- can be executed as code
      IMAGE_SCN_MEM_READ                 = $40000000;-- can be read
      IMAGE_SCN_MEM_WRITE                = $80000000;-- can be written to

      -- dispozice relokací fixup bloků pro vyhodnocení relokací systémem (reloc fixup types)
      IMAGE_REL_BASED_ABSOLUTE           = 0;    -- The fixup is skipped. This type can be used to
                                                 -- pad a block.
      IMAGE_REL_BASED_HIGH               = 1;    -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 32-bit word.
      IMAGE_REL_BASED_LOW                = 2;    -- The fixup adds the low 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the low half of a 32-bit word.
      IMAGE_REL_BASED_HIGHLOW            = 3;    -- The fixup applies the delta to the 32-bit field
                                                 -- at Offset.
      IMAGE_REL_BASED_HIGHADJ            = 4;    -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 32-bit word.
                                                 -- The low 16 bits of the 32-bit value are stored
                                                 -- in the 16-bit word that follows this base
                                                 -- relocation. This means that this base
                                                 -- relocation occupies two slots.
      IMAGE_REL_BASED_MIPS_JMPADDR       = 5;    -- Fixup applies to a MIPS jump instruction.
      IMAGE_REL_BASED_SECTION            = 6;    -- Reserved for future use
      IMAGE_REL_BASED_REL32              = 7;    -- Reserved for future use
      IMAGE_REL_BASED_MIPS_JMPADDR16     = 9;    -- Fixup applies to a MIPS16 jump instruction.
      IMAGE_REL_BASED_DIR64              = 10;   -- This fixup applies the delta to the 64-bit field
                                                 -- at Offset
      IMAGE_REL_BASED_HIGH3ADJ           = 11;   -- The fixup adds the high 16 bits of the delta to
                                                 -- the 16-bit field at Offset. The 16-bit field
                                                 -- represents the high value of a 48-bit word.
                                                 -- The low 32 bits of the 48-bit value are stored
                                                 -- in the 32-bit word that follows this base
                                                 -- relocation. This means that this base
                                                 -- relocation occupies three slots.

      -- dispozice relokací fixup bloků pro vyhodnocení relokací run-time knihovnou
      image_rel_flex_none     = 0;               -- vynechaný fixup záznam
      image_rel_flex_absolute = 1;               -- absolutní relokace
      image_rel_flex_relative = 2;               -- relativní relokace

    var
      stub             : const array 0..255 of t_unsigned8 := [
          $4D, $5A, $50, $00, $02, $00, $00, $00, $04, $00, $0F, $00, $FF, $FF, $00, $00,
          $B8, $00, $00, $00, $00, $00, $00, $00, $40, $00, $1A, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00,
          $BA, $10, $00, $0E, $1F, $B4, $09, $CD, $21, $B8, $01, $4C, $CD, $21, $90, $90,
          $54, $68, $69, $73, $20, $70, $72, $6F, $67, $72, $61, $6D, $20, $6D, $75, $73,
          $74, $20, $62, $65, $20, $72, $75, $6E, $20, $75, $6E, $64, $65, $72, $20, $57,
          $69, $6E, $33, $32, $0D, $0A, $24, $37, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
          $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00];



    ------------------------------------------------------------------------------------------------
    static buildimport (
        import     : in tentitystring;           -- seznam importovaných procedur
        idata      : in t_unsigned32;            -- bázová adresa Import Directory Table
        ibase      : in t_unsigned32;            -- bázová adresa Import Address Table
        dir        : out ppeidir;                -- Import Directory Table
        idirsize   : out t_unsigned32;           -- velikost
        lookup     : out ppeilookup;             -- Import Lookup Table
        ilookupsize: out t_unsigned32;           -- velikost
        name       : out p_unsigned8array;       -- Hint/Name Table
        inamesize  : out t_unsigned32) =         -- velikost
    -- Sestaví importní tabulky.
    ------------------------------------------------------------------------------------------------
    var
      nindex       : t_unsigned;                 -- index do NAME

        --------------------------------------------------------------------------------------------
        procedure add_name (
            xname  : in t_char8str) =
        -- Do tabulky jmen [name] doplni zadané jméno [xname].
        --------------------------------------------------------------------------------------------
        with
          advanced.low_level.unchecked_memory_access;

        begin
          --%%TODO(SLICE)
          memory_copy(xname[1],name^[nindex],xname:length);
          nindex+((xname:length+{\0}1+{pad}1) div 2)*2;
          end add_name;

    var
      libcount     : t_unsigned;                 -- počet knihoven
      lookupcount  : t_unsigned;                 -- počet lookup záznamů
      namelen      : t_unsigned;                 -- paměť potřebná pro jména
      lindex       : t_unsigned;                 -- index do DIR
      pindex       : t_unsigned;                 -- index do LOOKUP
      pbase        : t_unsigned32;               -- bázová adresa LOOKUP
      nbase        : t_unsigned32;               -- bázová adresa NAME

    begin
      -- není co řešit
      if import.list=nil or else import.list^:length=0 then 
        return; 
        end if;

      -- spočítat knihovny
      libcount:=0;
      lookupcount:=0;
      namelen:=0;
      for i in import.list^:range loop
        -- změna knihovny, započítat
        if (i=import.list^:first) or else (pimportinfo(pentity_procedure(import.list^[i-1])^.import_info)^.libname<>
        pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname) then
          -- započítat délku jména knihovny (zarovnání 2)
          namelen+((pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname:length+{\0}1+{pad}1) div 2)*2;

          -- další knihovna
          succ libcount;

          -- prázdný lookup záznam
          if i>import.list^:first then succ lookupcount; end if;
          end if;

        -- započítat délku jména (zarovnání 2)
        namelen+{hint}2+((pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.extname:length+{\0}1+{pad}1) div 2)*2;

        -- započítat lookup záznam
        succ lookupcount;
        end loop;

      -- započítat mezery na konci seznamů
      succ libcount;
      succ lookupcount;

      -- alokovat paměť
      idirsize:=tpeidirentry:size*libcount;
      new dir range libcount;
      ilookupsize:=tpeilookupentry:size*lookupcount;
      new lookup range lookupcount;
      inamesize:=namelen;
      new name range namelen;

      -- sestavit tabulky
      lindex:=0;
      pindex:=0;
      nindex:=0;
      pbase:=idata+libcount*tpeidirentry:size;
      nbase:=pbase+tpeilookupentry:size*lookupcount;
      for i in import.list^:range loop 
        -- změnila se knihovna, vygenerovat pro ni záznam
        if (i=import.list^:first) or (pimportinfo(pentity_procedure(import.list^[i-1])^.import_info)^.libname<>
        pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname) then
          -- mezera za předchozí knihovnou v LOOKUP
          if i>import.list^:first then succ pindex; end if;

          -- deskriptor knihovny
          dir^[lindex].ilt :=pbase+pindex*tpeilookupentry:size;
          dir^[lindex].name:=nbase+nindex;
          dir^[lindex].iat :=ibase+pindex*tpeilookupentry:size;

          -- doplnit jméno knihovny
          add_name(pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.libname);

          -- další knihovna
          succ lindex;
          end if;

        -- deskriptor procedury
        lookup^[pindex].addr:=nbase+nindex;

        -- hint: 0
        nindex+2;

        -- doplnit jméno procedury
        add_name(pimportinfo(pentity_procedure(import.list^[i])^.import_info)^.extname);

        -- další procedura
        succ pindex;
        end loop;

    commit
      verify({VERIFY=}001216,dir   =nil and then idirsize   <>0);
      verify({VERIFY=}001217,lookup=nil and then ilookupsize<>0);
      verify({VERIFY=}001218,name  =nil and then inamesize  <>0);
      end buildimport;



    ------------------------------------------------------------------------------------------------
    static buildexport (
        base          : in tpe32base;            --
        export        : in tentitystring;        -- seznam exportovaných symbolu
        edata         : in t_unsigned32;         -- bázová adresa Export Directory Table
        dir           : out tpeedirentry;        -- Export Directory Table (obsahuje jen jeden zaznam)
        addr          : out ppeeaddrtable;       
        addrsize      : out t_unsigned32;
        nameptrs      : out ppeenameptrtable;
        nameptrssize  : out t_unsigned32;
        ordinals      : out ppeeordtable;
        ordinalssize  : out t_unsigned32;
        names         : out ppeenametable;
        namessize     : out t_unsigned32)=
    -- Sestaví exportní tabulky.
    ------------------------------------------------------------------------------------------------
    with
      cc_binding;

        --------------------------------------------------------------------------------------------
        procedure add_name (
            name       : in t_char32str;
            names      : in ppeenametable;
            names_index : in out t_unsigned32) =
        -- Do jmen [names] doplni zadané jméno [name] na pozici [names_index], kterou updateuje
        --------------------------------------------------------------------------------------------
        with
          advanced,
          advanced.low_level,
          advanced.low_level.unchecked_memory_access;

        begin
          for i in name:range loop
            names^[names_index+i-1]:=t_char8(name[i]);
            end loop;
          
          names_index+name:length+{\0}1;
          names^[names_index]:=\0;
          end add_name;
      
    var
      expnameslength  : t_unsigned32;
      expnum          : t_unsigned32; -- pocet exportu
      curraddr        : t_unsigned32;
      n               : t_unsigned32;

      -- %%TODO(DLL) - dllname nahradit jmenem souboru linkimage
      dllname         : t_char32str := 'main.dll';

    begin
      -- osetrit vstup. parametry
      if export.count<=0 or export.list=nil then return; end if;

      -- pocet exportu
      expnum:=export.count;

      -- suma velikosti exportnich jmen
      expnameslength:=0;
      for i in export.list^:range loop
        -- započítat délku vlastního jméno
        expnameslength+pexportinfo(get_export_info(export.list^[i]))^.export_name:length;

        -- a koncovou nulu
        expnameslength+1;
        end loop;

      expnameslength+dllname:length+1;

      dir.exportflags:=0;
      dir.datetime:=0;
      dir.majver:=0;
      dir.minver:=0;
      dir.namerva:=0;
      dir.ordbase:=1;
      dir.addrtblentrs:=expnum;
      dir.numnameptr:=expnum;

      new addr range expnum;
      addrsize:=tpeeaddrentry:size*expnum;

      new ordinals range expnum;
      ordinalssize:=tpeeordentry:size*expnum;

      new nameptrs range expnum;
      nameptrssize:=tpeenameptrentry:size*expnum;

      new names range expnameslength;
      namessize:=expnameslength;

      dir.expaddrtblrva:=edata+tpeedirentry:size;
      dir.nameptrrva:=dir.expaddrtblrva+addrsize;
      dir.ordtblrva:=dir.nameptrrva+nameptrssize;
      n:=0;

      -- jmeno dllka
      dir.namerva:=dir.ordtblrva+ordinalssize;
      add_name(dllname,names,n);

      for i in export.list^:range loop
        -- export address table
        addr^[i-1]:=i_get_entity_instance_address(export.list^[i]);

        -- name ptr table and names
        nameptrs^[i-1]:=dir.ordtblrva+ordinalssize+n;
        add_name(pexportinfo(get_export_info(export.list^[i]))^.export_name,names,n);

        -- ord table
        ordinals^[i-1]:=i;
        ordinals^[i-1]-1; {%%TODO(DYNAMIC_CHECK) záplata kvůli rozsahu i od 1 do N }
        end loop;

    commit
      verify({VERIFY=}001219,addr    =nil and then addrsize    <>0);
      verify({VERIFY=}001220,nameptrs=nil and then nameptrssize<>0);
      verify({VERIFY=}001221,ordinals=nil and then ordinalssize<>0);
      verify({VERIFY=}001222,names   =nil and then namessize   <>0);
      end buildexport; 



    ------------------------------------------------------------------------------------------------
    static build_relocations (
        base       : in t_unsigned32;            -- bázová adresa PE
        relocaddrs : in t_relocations;           -- setrideny seznam adres na kterych je treba provest relokaci
        fixups     : out pperelocfixuptable;     -- PE relokacni informace
        relocdatasize : out t_unsigned32;        -- celkova velikost PE relokacnich informaci
        absrel_code: t_mod_unsigned16;           -- kód absolutní relokace
        relrel_code: t_mod_unsigned16) =         -- kód relativní relokace
    -- Sestaví relokacni tabulku
    ------------------------------------------------------------------------------------------------
    var
      fixupblocks  : t_unsigned;

    begin
      -- prazdny seznam relokaci?
      if relocaddrs:length=0 then return; end if;

      -- zjisti kolik ze to 4-kilovych fixup bloku budeme mit
      declare var
        tempaddr   : t_unsigned;

      begin
        -- alespon jeden 4K fixup blok
        fixupblocks:=1;
  
        -- inicalizuj tempaddr prvni adresou
        tempaddr:=relocaddrs[1].address;
        
        -- projed vsechny adresy
        for i in relocaddrs:range loop
          if relocaddrs[i].address-tempaddr>=4096 then
            tempaddr:=relocaddrs[i].address;
            
            -- incrementuj pocet fixup bloku kazdych 4096 bytu
            succ fixupblocks;
            end if;
          end loop;
        end declare;

      -- alokuj pamet pro zjisteny pocet 4-kilovych bloku
      new fixups range fixupblocks;

      -- projed vsechny adresy a vygeneruj relokacni informace
      declare var
        blockindex : t_unsigned := 0;
        blockrelocs: t_unsigned;
        checkrelocs: t_unsigned;                 
        i          : t_unsigned;

      begin
        i:=relocaddrs:first;
        while i<=relocaddrs:length loop
          verify({VERIFY=}000663,not (blockindex<fixupblocks));

          -- do hlavicky bloku uloz page rva, 
          fixups^[blockindex].pagerva:=relocaddrs[i].address-base;

          -- zjisti pocet jednotlivych relokaci v tomto bloku
          declare var
            k    : t_unsigned;
          begin
            k:=i;
            while k<=relocaddrs:length and then relocaddrs[k].address-relocaddrs[i].address<4096 loop 
              succ k;
              end loop;
            blockrelocs:=k-i;
            end declare;

          -- alokuj pole typeandoffset poctem jednotlicych relokaci zjistenym v predchozim kroku
          new fixups^[blockindex].typeandoffset range blockrelocs;

          -- napln typeandoffset jednotlivymi relokacemi
          declare var
            k    : t_unsigned;
          begin
            k:=i;
            while k<=relocaddrs:length and then relocaddrs[k].address-relocaddrs[i].address<4096 loop 
              -- hornich 4 bitu udava typ relokace, zbylych 12 offset od fixups^[blockindex].pagerva
              fixups^[blockindex].typeandoffset^[k-i]:=t_mod_unsigned16(relocaddrs[k].address-relocaddrs[i].address);
              case relocaddrs[k].disposition
                when trd_absolute do fixups^[blockindex].typeandoffset^[k-i] or (absrel_code shl 12);
                when trd_relative do fixups^[blockindex].typeandoffset^[k-i] or (relrel_code shl 12);
                end case;
              succ k;
              
              -- kontrolni promenna
              succ checkrelocs;
              end loop;
            i:=k;
            end declare;

          -- uloz velikost hlavicky bloku a vsech relokaci v bloku do hlavicky 4-K bloku
          fixups^[blockindex].blocksize:=fixups^[blockindex].pagerva:size+fixups^[blockindex].blocksize:size+blockrelocs*t_unsigned16:size;
          
          -- pricist velikost bloku k celkove velikosti PE relokacnich informaci
          relocdatasize+fixups^[blockindex].blocksize;

          -- dalsi block
          succ blockindex;      
          end loop;

        -- pokud checkrelocs se nebude rovnat poctu adres v seznamu relokaci, je chyba v algoritmu teto funkce
        verify({VERIFY=}000665,checkrelocs<>relocaddrs:length);
        end declare;
      end build_relocations;



    ------------------------------------------------------------------------------------------------
    override create =
    -- Vytvoří image na základě seznamu vyhodnocených prvků.
    ------------------------------------------------------------------------------------------------
    var
      base         : tpe32base;                  -- image base

        --------------------------------------------------------------------------------------------
        procedure get_seg_virtualsize (
            seg    : in tsegment) 
            return tpesize =
        -- Vypočítá virtuální velikost zadaného segmentu.
        --------------------------------------------------------------------------------------------
        begin
          result:=((unidata_size_to_unsigned(resolver.getsegtotal(seg))+sectalign-1) div sectalign)*sectalign;
          end get_seg_virtualsize;



        --------------------------------------------------------------------------------------------
        procedure get_seg_virtualaddr (
            seg    : in tsegment) 
            return tperva =
        -- Vypočítá relativní virtuální adresu zadaného segmentu.
        --------------------------------------------------------------------------------------------
        begin
          result:=unicode_addr_to_unsigned(resolver.getsegbase(seg))-base;
          end get_seg_virtualaddr;



        --------------------------------------------------------------------------------------------
        procedure get_seg_datasize (
            seg    : in tsegment) 
            return tperva =
        -- Vypočítá skutečnou velikost zadaného segmentu v souboru.
        --------------------------------------------------------------------------------------------
        begin
          result:=((unidata_size_to_unsigned(resolver.getsegtotal(seg))+filealign-1) div filealign)*filealign;
          end get_seg_datasize;


    
    var
      coff         : tcoffheader;                -- COFF hlavička
      coff_ofs     : tpefileptr;                 -- offset COFF hlavičky
      pehdr        : tpe32header;                -- PE32 hlavička
      pehdr_ofs    : tpefileptr;                 -- offset PE32 hlavičky
      winhdr       : tpewinheader;               -- Windows Specific Header
      winhdr_ofs   : tpefileptr;                 -- offset Windows Specific Header
      dir          : tpedatadir;                 -- Data Directory
      dir_ofs      : tpefileptr;                 -- offset Data Directory
      scode        : tpesectheader;              -- sekce: kód
      scode_ofs    : tpefileptr;                 -- offset sekce
      smetadata    : tpesectheader;              -- sekce: metadata
      smetadata_ofs: tpefileptr;                 -- offset sekce
      sconst       : tpesectheader;              -- sekce: konstanty
      sconst_ofs   : tpefileptr;                 -- offset sekce
      sinit        : tpesectheader;              -- sekce: inicializovaná data
      sinit_ofs    : tpefileptr;                 -- offset sekce
      sdata        : tpesectheader;              -- sekce: neinicializovaná data
      sdata_ofs    : tpefileptr;                 -- offset sekce
      srelo        : tpesectheader;              -- sekce: relokace pro operační systém
      srelo_ofs    : tpefileptr;                 -- offset sekce
      sflexrelo    : tpesectheader;              -- sekce: relokace pro Flex
      sflexrelo_ofs: tpefileptr;                 -- offset sekce
      sdebug       : tpesectheader;              -- sekce: debug informace
      sdebug_ofs   : tpefileptr;                 -- offset sekce
      sicode       : tpesectheader;              -- sekce: skoková tabulka importů
      sicode_ofs   : tpefileptr;                 -- offset sekce
      simport      : tpesectheader;              -- sekce: importy
      simport_ofs  : tpefileptr;                 -- offset sekce
      maxrva       : tperva;                     -- maximální dosažená relativní virtuální adr.
      idir         : ppeidir;                    -- Import Directory Table
      idirsize     : t_unsigned32;               -- velikost
      ilookup      : ppeilookup;                 -- Import Lookup Table
      ilookupsize  : t_unsigned32;               -- velikost
      iname        : p_unsigned8array;           -- Hint/Name Table
      inamesize    : t_unsigned32;               -- velikost
      os           : p_stream_binary_writer;     -- output stream
      os_bwriter   : aliased c_stream_binary_writer; -- binary writer
      os_buffer    : aliased c_buffered_file_output_stream;  -- output buffered stream

      -- promenne pro export
      sexport      : tpesectheader;              -- sekce: exporty
      sexport_ofs  : tpefileptr;                 -- offset sekce
      edir         : tpeedirentry;
      eaddr        : ppeeaddrtable;
      eaddrsize    : t_unsigned32;
      enameptrs    : ppeenameptrtable;
      enameptrssize: t_unsigned32;
      eordinals    : ppeeordtable;
      eordinalssize: t_unsigned32;
      enames       : ppeenametable;
      enamessize   : t_unsigned32;

      -- promenne pro relokace
      reloctable   : pperelocfixuptable;         -- tabulka PE relokacnich informaci
      relocdatasize : t_unsigned32;

      debuginfo_data : p_unsigned8array;         -- pointer na codeview debug data              
      debuginfo_size : t_unsigned32;             -- velikost dat v bufferu                      

    var
      ofs              : t_unsigned32;
      x                : array 1..16 of t_unsigned8;

    begin
      -- zjistit si bázovou adresu relokací
      base:=tpe32base(unicode_addr_to_unsigned(resolver.getaddrbase));

      -- vytvořit soubor
      begin
        f.create(t_fs_object_mode_set:[tfm_write],tfa_random,tfss_not_shared,true);
      catch
        when file_error do
          ce^.seterror({CCERR=}000377,ce_f_create);
          --%%FLEX ce^.setparam(f.name);
          --ce^.raiseerror;
          --%%TODO(EXCEPTION) Záplata, pokud v catch bloku výjimky E1 vyvolám _nepřímo_ E2, pak E1 zůstane neošetřená (na stacku)
          raise compiler_error;
        end;

      -- získat output stream
      os_buffer.init(^f);
      os_bwriter.init_writer(^c_output_stream:(os_buffer));
      os_bwriter.set_lazy_buffer(true);
      os:=^os_bwriter;

      -- uložit stub
      os^.write_unchecked(stub);

      -- signatura
      os^.write_unchecked(pesign);

      -- %%X Zobecnit - parametrizovat vlastnosti EXE 

      -- COFF hlavička
      os^.get_flow(t_offset(coff_ofs));
      coff.machine:=IMAGE_FILE_MACHINE_I386;
      coff.sectioncount:=0;
      coff.datetime:=$3E36B801{%%TODO(LIB) getdatim};
      coff.opthdrsize:=base:size+pehdr:size+winhdr:size+dir:size;
      coff.flags:={IMAGE_FILE_RELOCS_STRIPPED
               or}IMAGE_FILE_EXECUTABLE_IMAGE
               or IMAGE_FILE_LINE_NUMS_STRIPPED
               or IMAGE_FILE_LOCAL_SYMS_STRIPPED
            -- or IMAGE_FILE_LARGE_ADDRESS_AWARE
            -- or IMAGE_FILE_BYTES_REVERSED_LO
               or IMAGE_FILE_32BIT_MACHINE
              {or IMAGE_FILE_DEBUG_STRIPPED}
              {or IMAGE_FILE_BYTES_REVERSED_HI};

      -- pokud se nebudou generovat debug informace, nastavime priznak
      if debug_info=nil then
        coff.flags:=coff.flags or IMAGE_FILE_DEBUG_STRIPPED;
        end if;

      -- pridej DLL flag pro win32 knihovnu
      if library then
        coff.flags:=coff.flags or IMAGE_FILE_DLL;
        end if;
      
      os^.write_unchecked(coff);

      -- PE hlavička
      os^.get_flow(t_offset(pehdr_ofs));
      pehdr.magic:=magic_pe32;
      pehdr.linkerver.major:=linkver_major;
      pehdr.linkerver.minor:=linkver_minor;
      pehdr.codetotal :=unidata_size_to_unsigned(resolver.getsegtotal(tseg_code));
      pehdr.inittotal :=unidata_size_to_unsigned(resolver.getsegtotal(tseg_metadata))
                       +unidata_size_to_unsigned(resolver.getsegtotal(tseg_const))
                       +unidata_size_to_unsigned(resolver.getsegtotal(tseg_init));
      pehdr.datatotal :=unidata_size_to_unsigned(resolver.getsegtotal(tseg_data));
        pehdr.entrypoint:=unicode_addr_to_unsigned(resolver.getentrypoint)-base;
      pehdr.codebase  :=unicode_addr_to_unsigned(resolver.getsegbase(tseg_code))-base;
      pehdr.database  :=unicode_addr_to_unsigned(resolver.getsegbase(tseg_metadata))-base;
      os^.write_unchecked(pehdr);

      -- image base
      os^.write_unchecked(base);

      -- Windows Specific Header
      os^.get_flow(t_offset(winhdr_ofs));
      winhdr.sectalign:=sectalign;
      winhdr.filealign:=filealign;
      winhdr.osver.major:=1;
      winhdr.osver.minor:=0;
      winhdr.imagever.major:=0;
      winhdr.imagever.minor:=0;
      winhdr.subsysver.major:=4;
      winhdr.subsysver.minor:=0;
      winhdr.imagesize:=0;
      winhdr.hdrsize:=0;

      -- DLL knihovna jen pro GUI subsystem
      if library 
        then winhdr.subsys:=IMAGE_SUBSYSTEM_WINDOWS_GUI;
        else winhdr.subsys:=IMAGE_SUBSYSTEM_WINDOWS_CUI;
        end if;

      winhdr.dllflags:=0;
      winhdr.stack.reserve_size:=1024*1024;
      winhdr.stack.commit_size:=1024*1024;
      winhdr.heap.reserve_size:=1024*1024;
      winhdr.heap.commit_size:=1024*1024;
      winhdr.dircount:=16;
      os^.write_unchecked(winhdr);

      -- Data Directory
      os^.get_flow(t_offset(dir_ofs));

      os^.write_unchecked(dir);

      -- první volná RVA
      maxrva:=0;



      ----- sekce: kód -----------------------------------------------------------------------------
      if resolver.checkseg(tseg_code) then
        os^.get_flow(t_offset(scode_ofs));
        scode.name           :={%OFF}'.text'\0\0\0{%ON};
        scode.virtualsize    :=((pehdr.codetotal+sectalign-1) div sectalign)*sectalign;
        scode.virtualaddr    :=pehdr.codebase;
        scode.datasize       :=((pehdr.codetotal+filealign-1) div filealign)*filealign;
        scode.dataptr        :=0;
        scode.flags          :=IMAGE_SCN_CNT_CODE
                          --or IMAGE_SCN_MEM_SHARED %%X
                            or IMAGE_SCN_MEM_EXECUTE
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(scode);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tseg_code,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_execute,tcvsf_read],scode.dataptr,scode.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((scode.virtualaddr+scode.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: deskriptory typů ----------------------------------------------------------------
      if resolver.checkseg(tseg_metadata) then
        os^.get_flow(t_offset(smetadata_ofs));
        smetadata.name       :={%OFF}'METADATA'{%ON};
        smetadata.virtualsize:=get_seg_virtualsize(tseg_metadata); 
        smetadata.virtualaddr:=get_seg_virtualaddr(tseg_metadata);
        smetadata.datasize   :=get_seg_datasize(tseg_metadata);
        smetadata.dataptr    :=0;
        smetadata.flags      :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(smetadata);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tseg_metadata,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read],smetadata.dataptr,smetadata.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((smetadata.virtualaddr+smetadata.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: konstanty -----------------------------------------------------------------------
      if resolver.checkseg(tseg_const) then
        os^.get_flow(t_offset(sconst_ofs));
        sconst.name          :={%OFF}'.const'\0\0{%ON};
        sconst.virtualsize   :=get_seg_virtualsize(tseg_const); 
        sconst.virtualaddr   :=get_seg_virtualaddr(tseg_const);
        sconst.datasize      :=get_seg_datasize(tseg_const);
        sconst.dataptr       :=0;
        sconst.flags         :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sconst);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tseg_const,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read],sconst.dataptr,sconst.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sconst.virtualaddr+sconst.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;



      ----- sekce: inicializovaná data -------------------------------------------------------------
      if resolver.checkseg(tseg_init) then
        os^.get_flow(t_offset(sinit_ofs));
        sinit.name           :={%OFF}'.data'\0\0\0{%ON};
        sinit.virtualsize    :=get_seg_virtualsize(tseg_init); 
        sinit.virtualaddr    :=get_seg_virtualaddr(tseg_init);
        sinit.datasize       :=get_seg_datasize(tseg_init);
        sinit.dataptr        :=0;
        sinit.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
        os^.write_unchecked(sinit);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tseg_init,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read,tcvsf_write],sinit.dataptr,sinit.datasize);
          end if;                    
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sinit.virtualaddr+sinit.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      
      
      ----- sekce: neinicializovaná data -----------------------------------------------------------
      if resolver.checkseg(tseg_data) then
        os^.get_flow(t_offset(sdata_ofs));
        sdata.name           :={%OFF}'.bss'\0\0\0\0{%ON};
        sdata.virtualsize    :=get_seg_virtualsize(tseg_data); 
        sdata.virtualaddr    :=get_seg_virtualaddr(tseg_data);
        sdata.datasize       :=0;
        sdata.dataptr        :=0;
        sdata.flags          :=IMAGE_SCN_CNT_UNINITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
        os^.write_unchecked(sdata);

      #if codeview then;
        if debug_mode=tdit_codeview and debug_info<>nil then
          p_codeview(debug_info)^.register_segment(tseg_data,coff.sectioncount+1,[tcvsf_sel,tcvsf_32bit,tcvsf_read,tcvsf_write],sdata.dataptr,sdata.datasize);
          end if;
      #end if;

        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sdata.virtualaddr+sdata.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      if debug_info<>nil then
        -- vygenerujeme debug informace
        debug_info^.generate;

        -- dump debug informaci
        debug_info^.linkimage(debuginfo_data,debuginfo_size);
        end if;

      
      
      ----- sekce: Import Address Table (povinné) --------------------------------------------------
      os^.get_flow(t_offset(sicode_ofs));
      sicode.name            :={%OFF}'.icode'\0\0{%ON};
      sicode.virtualsize     :=get_seg_virtualsize(tseg_import); 
      sicode.virtualaddr     :=get_seg_virtualaddr(tseg_import);
      sicode.datasize        :=0;
      sicode.dataptr         :=0;
      sicode.flags           :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
      os^.write_unchecked(sicode);
      succ coff.sectioncount;
      maxrva:=max_unsigned(maxrva,((sicode.virtualaddr+sicode.virtualsize+sectalign-1) div sectalign)*sectalign);

      
      
      ----- sekce: importy (povinné) ---------------------------------------------------------------
      os^.get_flow(t_offset(simport_ofs));
      simport.name           :={%OFF}'.idata'\0\0{%ON};
      simport.virtualsize    :=0;
      simport.virtualaddr    :=maxrva;
      simport.datasize       :=0;
      simport.dataptr        :=0;
      simport.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_READ
                            or IMAGE_SCN_MEM_WRITE;
      os^.write_unchecked(simport);
      succ coff.sectioncount;

      -- sestavit importní tabulky
      buildimport(resolver.import,simport.virtualaddr,sicode.virtualaddr,idir,idirsize,ilookup,ilookupsize,iname,inamesize);

      -- velikost importních tabulek
      simport.virtualsize:=((idirsize+ilookupsize+inamesize+sectalign-1) div sectalign)*sectalign;
      maxrva:=max_unsigned(maxrva,((simport.virtualaddr+simport.virtualsize+sectalign-1) div sectalign)*sectalign);



      ----- sekce: exporty -------------------------------------------------------------------------
      if sys_export_list.count>0 or library then
        os^.get_flow(t_offset(sexport_ofs));
        sexport.name           :={%OFF}'.edata'\0\0{%ON};
        sexport.virtualsize    :=0;
        sexport.virtualaddr    :=maxrva;
        sexport.datasize       :=0;
        sexport.dataptr        :=0;
        sexport.flags          :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_READ
                              or IMAGE_SCN_MEM_READ;
                              
        os^.write_unchecked(sexport);
        succ coff.sectioncount;

        -- sestavit exportni tabulky
        buildexport(base,sys_export_list,sexport.virtualaddr,edir,eaddr,eaddrsize,enameptrs,enameptrssize,eordinals,eordinalssize,enames,enamessize);

        -- velikost exportnich tabulek
        sexport.virtualsize:=max_unsigned(tpeedirentry:size+eaddrsize+enameptrssize+eordinalssize+enamessize, ((tpeedirentry:size+eaddrsize+enameptrssize+eordinalssize+enamessize-1) div sectalign)*sectalign);
        maxrva:=max_unsigned(maxrva,((sexport.virtualaddr+sexport.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;


      
      ----- sekce: relokace (povinné) --------------------------------------------------------------
      os^.get_flow(t_offset(srelo_ofs));
      srelo.name             :={%OFF}'.reloc'\0\0{%ON};
      srelo.virtualsize      :=0;
      srelo.virtualaddr      :=maxrva;
      srelo.datasize         :=0;
      srelo.dataptr          :=0;
      srelo.flags            :=IMAGE_SCN_CNT_INITIALIZED_DATA
                            or IMAGE_SCN_MEM_DISCARDABLE
                            or IMAGE_SCN_MEM_READ
                           {or IMAGE_SCN_MEM_WRITE};
      os^.write_unchecked(srelo);
      succ coff.sectioncount;

      declare var
        relocations : p_relocations;
      begin
        -- načíst setříděný seznam relokačních informací pro aktuální partition
        resolver.get_sorted_relocations_by_partition_id(curr_partition,relocations);

        -- mame nejake relokacni informace ?
        if relocations<>nil then
          -- sestav
          build_relocations(base,relocations^,reloctable,relocdatasize,for absrel_code use IMAGE_REL_BASED_HIGHLOW,for relrel_code use nil);
          end if;
        end declare;

      -- minimální velikost
      if relocdatasize<sectalign then srelo.virtualsize:=sectalign; else srelo.virtualsize:=relocdatasize; end if;
      maxrva:=max_unsigned(maxrva,((srelo.virtualaddr+srelo.virtualsize+sectalign-1) div sectalign)*sectalign);



      ----- sekce: relokace Flex (nepovinné) -------------------------------------------------------
      if curr_partition_type<>part_standalone then
        os^.get_flow(t_offset(sflexrelo_ofs));
        sflexrelo.name         :={%OFF}'FLEXRELO'{%ON};
        sflexrelo.virtualsize  :=0;
        sflexrelo.virtualaddr  :=maxrva;
        sflexrelo.datasize     :=0;
        sflexrelo.dataptr      :=0;
        sflexrelo.flags        :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_DISCARDABLE
                              or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sflexrelo);
        succ coff.sectioncount;
        end if;



      ----- sekce: debug  --------------------------------------------------------------------------
      if debug_info<>nil then
        os^.get_flow(t_offset(sdebug_ofs));
        sdebug.name            :={%OFF}'.ddir'\0\0\0{%ON};
        sdebug.virtualsize     :=sectalign{0};
        sdebug.virtualaddr     :=maxrva;
        sdebug.datasize        :=0;
        sdebug.dataptr         :=0;
        sdebug.flags           :=IMAGE_SCN_CNT_INITIALIZED_DATA
                              or IMAGE_SCN_MEM_READ;
        os^.write_unchecked(sdebug);
     
        succ coff.sectioncount;
        maxrva:=max_unsigned(maxrva,((sdebug.virtualaddr+sdebug.virtualsize+sectalign-1) div sectalign)*sectalign);
        end if;

      
      
      -- velikost image
      winhdr.imagesize:=maxrva;

      -- zarovnat soubor
      falign(os,filealign);
      os^.get_flow(t_offset(winhdr.hdrsize));

      -- kód
      if resolver.checkseg(tseg_code) then
        os^.get_flow(t_offset(scode.dataptr));
        resolver.writesegment(tseg_code,os);
        falign(os,filealign);
        end if;

      -- deskriptory typů
      if resolver.checkseg(tseg_metadata) then
        os^.get_flow(t_offset(smetadata.dataptr));
        resolver.writesegment(tseg_metadata,os);
        falign(os,filealign);
        end if;

      -- konstanty
      if resolver.checkseg(tseg_const) then
        os^.get_flow(t_offset(sconst.dataptr));
        resolver.writesegment(tseg_const,os);
        falign(os,filealign);
        end if;

      -- inicializovaná data
      if resolver.checkseg(tseg_init) then
        os^.get_flow(t_offset(sinit.dataptr));
        resolver.writesegment(tseg_init,os);
        falign(os,filealign);
        end if;

      -- neinicializovaná data
      os^.get_flow(t_offset(sdata.dataptr));

      -- importní tabulky (1)
      os^.get_flow(t_offset(sicode.dataptr));
      sicode.datasize:=((ilookupsize+filealign-1) div filealign)*filealign;
      if ilookup<>nil then
        os^.write_unchecked_part(ilookup^,ilookupsize);
        end if;
      falign(os,filealign);

      -- importní tabulky (2)
      os^.get_flow(t_offset(simport.dataptr));
      simport.datasize:=((idirsize+ilookupsize+inamesize+filealign-1) div filealign)*filealign;
      if idir<>nil then
        os^.write_unchecked_part(idir^,idirsize);
        end if;
      if ilookup<>nil then
        os^.write_unchecked_part(ilookup^,ilookupsize);
        end if;
      if iname<>nil then
        os^.write_unchecked_part(iname^,inamesize);
        end if;
      falign(os,filealign);

      dir.import.rva:=simport.virtualaddr;
      dir.import.size:=simport.virtualsize;{sectalign;}

      -- exportni tabulky
      if sys_export_list.count>0 or library then
        os^.get_flow(t_offset(sexport.dataptr));
        sexport.datasize:=((tpeedirentry:size+eaddrsize+enameptrssize+eordinalssize+enamessize+filealign-1) div filealign)*filealign;
        os^.write_unchecked_part(edir,tpeedirentry:size);
        if eaddr<>nil then
          os^.write_unchecked_part(eaddr^,eaddrsize);
          end if;
        if enameptrs<>nil then
          os^.write_unchecked_part(enameptrs^,enameptrssize);
          end if;
        if eordinals<>nil then
          os^.write_unchecked_part(eordinals^,eordinalssize);
          end if;
        if enames<>nil then
          os^.write_unchecked_part(enames^,enamessize);
          end if;

        falign(os,filealign);

        dir.export.rva:=sexport.virtualaddr;
        dir.export.size:=sexport.virtualsize;
        end if;
      
      -- relokace
      os^.get_flow(t_offset(srelo.dataptr));
      srelo.datasize:=relocdatasize;
      
      if reloctable<>nil then    
        for i in reloctable^:range loop
          os^.write_unchecked_part(reloctable^[i].pagerva,reloctable^[i].pagerva:size);
          os^.write_unchecked_part(reloctable^[i].blocksize,reloctable^[i].blocksize:size);
          for k in reloctable^[i].typeandoffset^:range loop
            os^.write_unchecked_part(reloctable^[i].typeandoffset^[k],reloctable^[i].typeandoffset^[k]:size);
            end loop;
          end loop;
        end if;
      
      falign(os,filealign);

      dir.baserelo.rva:=srelo.virtualaddr;
      dir.baserelo.size:=sectalign;

    #if codeview then;
      if debug_info<>nil and debug_mode=tdit_codeview then
        os^.get_flow(t_offset(sdebug.dataptr));
        sdebug.datasize:=filealign;

        -- ulozime informace o debug informacich 
        os^.write_unchecked_part(p_codeview(debug_info)^.pe_dir_entry,p_codeview(debug_info)^.pe_dir_entry:size);
        falign(os,filealign);

        dir.debuginfo.rva:=sdebug.virtualaddr;{sdebug.dataptr;}
        dir.debuginfo.size:={sectalign}28;
        end if;
    #end if;

      -- zarovnat celý soubor na velikost sekce
      -- falign(os,sectalign); {%%X potenciální chyba, ne ? }
      
      os_bwriter.set_lazy_buffer(false);
      os_bwriter.flush;
      os_buffer.close;

      -- opravit offset PE hlavičky zapsaný ve stubu
      ofs:=stub:size;
      f.write(peptrofs,ofs,ofs:size);

      -- zpětně přepsat změněné hlavičky
      f.write(coff_ofs,coff,coff:size);
      f.write(pehdr_ofs,pehdr,pehdr:size);
      f.write(winhdr_ofs,winhdr,winhdr:size);
      f.write(dir_ofs,dir,dir:size);
      if resolver.checkseg(tseg_code) then
        f.write(scode_ofs,scode,scode:size);
        end if;
      if resolver.checkseg(tseg_metadata) then
        f.write(smetadata_ofs,smetadata,smetadata:size);
        end if;
      if resolver.checkseg(tseg_const) then
        f.write(sconst_ofs,sconst,sconst:size);
        end if;
      if resolver.checkseg(tseg_init) then
        f.write(sinit_ofs,sinit,sinit:size);
        end if;
      if resolver.checkseg(tseg_data) then
        f.write(sdata_ofs,sdata,sdata:size);
        end if;
      f.write(srelo_ofs,srelo,srelo:size);
      f.write(sicode_ofs,sicode,sicode:size);
      f.write(simport_ofs,simport,simport:size);
      if sys_export_list.count>0 or library then
        f.write(sexport_ofs,sexport,sexport:size);
        end if;

      if debug_info<>nil then
        f.write(sdebug_ofs,sdebug,sdebug:size);

      #if codeview then;
        -- aktualizujem info o debug informacich o udaj o jejich pozici
        if debug_mode=tdit_codeview then
          p_codeview(debug_info)^.PE_dir_entry.PointerToRawData:=f.get_size;
          f.write(sdebug.dataptr,p_codeview(debug_info)^.PE_dir_entry,p_codeview(debug_info)^.PE_dir_entry:size);

          -- ulozime vlastni codeview debug informace 
          f.write(f.get_size,debuginfo_data^,debuginfo_size);
          end if;
      #end if;
        end if;

      -- zavřít soubor
      f.close;
      end create;



    ------------------------------------------------------------------------------------------------
    override info =
    -- Výpis souhrnných informací do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;
    
    end linkimage_pe;

end cl_pe;
