----------------------------------------------------------------------------------------------------
module private cx_type =
-- Překladač Flexu.
-- Typová kontrola výrazu.
----------------------------------------------------------------------------------------------------
-- Ondra : 10.09.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cx_resolve,cx_util,cx_rta,
  cc_options;

  

----------------------------------------------------------------------------------------------------
procedure x_check_assign (
    curr           : in tcontext;                -- překládaný prvek
    el             : in pexpnode;                -- levá strana přiřazení
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Testuje, zda na levé straně přiřazení je proměnná.
----------------------------------------------------------------------------------------------------
begin
  -- na levé straně je vnořené přiřazení, již je zkontrolováno
  if el^.ntype in nodetypeset:[nt_operator,nt_unary] and pexpnoper(el)^.assign then
    return;
    end if; 

  -- na levé straně musí být proměnná
  if el^.nclass<>nc_var then
    ce^.seterror({CCERR=}000509,ce_lvar);
    el^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  end x_check_assign;



----------------------------------------------------------------------------------------------------
procedure a_type_overloaded (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpnode;            -- výraz
    poper          : in pentity_subprogram;      -- přetížený operátor
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Převede výraz na přetížený operátor.
----------------------------------------------------------------------------------------------------
with
  cx_phase;
  
var
  info2            : expinfo;                    -- simulované informace o průběhu analýzy
  call             : pexplist;                   -- volání procedury
  name             : pexpcomponent;              -- jméno procedury
  arg              : pexpitem;                   -- agrument
  last             : pexpnode;
  cexp             : pexpnode;
  nexp             : pexpnode;

begin
  -- jméno procedury 
  newnode(pexpnode(name),info,nt_component);
  name^.id:=poper^.id;
  name^.s.set_entity(poper);
  name^.t.init(curr,poper^.typ.getctype);
  name^.nclass:=nc_proc;

  -- ostatní uzly se vytvářejí jakoby od počáteční fáze 
  info2:=info;
  info2.phase:=succ ep_syntax;

  -- volání 
  newnodex(pexpnode(call),info2,nt_list);
  call^.sub:=name;

  -- argumenty 
  last:=call^.sub;
  cexp:=expr^.sub;
  while cexp<>nil loop
    -- poznamenat si další operand 
    nexp:=cexp^.next;

    -- vyřadit operand ze seznamu 
    cexp^.next:=nil;

    -- argument 
    newnodex(pexpnode(arg),info2,nt_item);
    arg^.itype:=ei_expr;
    arg^.sub:=cexp;

    -- zařadit argument 
    last^.next:=arg;
    last:=arg;

    -- další operand 
    cexp:=nexp;
    end loop;

  -- předat ven 
  expr:=call;

  -- provést všechny fáze 
  x_phase_prev(curr,expr,ptyp,{nemá význam:}eu_none,info);
  if expr^.zprac<info.phase then return; end if;
  end a_type_overloaded;



----------------------------------------------------------------------------------------------------
procedure a_type_operator_lang (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola jazykem definovaného operátoru.
----------------------------------------------------------------------------------------------------
label
  k1;

    ------------------------------------------------------------------------------------------------
    procedure c_type (
        curr       : in tcontext;                -- překládaný prvek
        expr       : in out pexpnode;            -- výraz
        ptyp       : in typeview;                -- požadovaný typ výrazu
        info       : in expinfo) =               -- informace o průběhu analýzy
    -- Typová kontrola výrazu při zřetězení.
    ------------------------------------------------------------------------------------------------
    begin
      -- zjistit způsob zřetězení 
      x_getconcatkind(curr,expr,ptyp,expr^.concatkind);

      -- provést typovou kontrolu se správným typem 
      case expr^.concatkind
        -- substring, subpole, množina
        when nck_substring, nck_subarray, nck_set do a_type(curr,expr,ptyp,info);

        -- komponenta
        when nck_component do a_type(curr,expr,ptyp.getbase(curr),info);

        when others do verify({VERIFY=}000371,true);
        end case;
      end c_type;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  res              : typeview;                   -- typ výsledku

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- nyní již jsou definitivně vybrávy typy operandů, upřesnit podle nich skutečně výsledý operátor 
  x_refine_binary(expr^.oper,el^.t,er^.t,expr^.oper);

  if expr^.assign

    -- přiřazení 
    then
      -- typová kontrola levého operandu 
      a_type(curr,el,nulltype,info);

      -- na levé straně přiřazení musí být proměnná 
      x_check_assign(curr,el,info);

      -- typová kontrola pravého operandu 
      if expoperinfo[expr^.oper].tc<>tc_concat {expr^.oper not in ops_aggregate_composition}

        -- pro většinu operátorů je to triviální 
        then a_type(curr,er,el^.t,info)

        -- pro operace kompozice agregátu je to o dost složitější 
        else c_type(curr,er,el^.t,info);
        end if;

      -- dosadit do výrazu nový typ 
      expr^.t:=el^.t;

    -- normální operátor 
    else
      -- je podvýraz kompatibilní s dodaným typem ? 
      if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000510,ce_incompatible);
        expr^.join(el,er);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;

      -- zvolit přesnější typ výsledku 
      x_resolve_by_result(curr,ptyp,expr^.t,res);

      -- typová kontrola podvýrazů 
      case expoperinfo[expr^.oper].tc
        when tc_none    do a_type(curr,el,nulltype,info); a_type(curr,er,nulltype,info);
        when tc_left    do a_type(curr,el,res     ,info); a_type(curr,er,nulltype,info);
        when tc_right   do a_type(curr,el,nulltype,info); a_type(curr,er,res     ,info);
        when tc_both    do a_type(curr,el,res     ,info); a_type(curr,er,res     ,info);
        when tc_concat  do c_type(curr,el,res     ,info); c_type(curr,er,res     ,info);
        when others     do verify({VERIFY=}000372,true);
        end case;

      -- upravit typ výrazu (pokud se mohl změnit) 
      if (res.tview=tview_full) and not t_equal(expr^.t,res) then
        -- typ výsledku 
        expr^.t:=res;
        end if;
      end if;

  -- povedla se typová kontrola podvýrazů ? 
  if el^.zprac<ep_type or er^.zprac<ep_type then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy
  expr^.join(el,er);
  end a_type_operator_lang;



----------------------------------------------------------------------------------------------------
procedure a_type_operator (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola operátoru.
----------------------------------------------------------------------------------------------------
var
  poper            : pentity_subprogram;         -- přetížený operátor

begin
  -- vyhodnotit nejednoznačné typy 
  a_resolve(curr,expr,ptyp,info);

  -- není to náhodou přetížený operátor ? 
  expr^.gettypesym(0,pentity(poper));
  if poper<>nil

    -- ano, je to přetížený operátor, konvertovat na volání procedury 
    then a_type_overloaded(curr,pexpnode(expr),poper,ptyp,info)

    -- ne, jazykem definovaný operátor 
    else a_type_operator_lang(curr,expr,ptyp,info);
    end if;
  end a_type_operator;



----------------------------------------------------------------------------------------------------
procedure a_type_unary_lang (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpunary;           -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola jazykem definovaného unárního operátoru.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podvýraz                                    
  res              : typeview;                   -- typ výsledku                                

begin
  -- rozdělit podvýrazy 
  expr^.split(el);

  -- nyní již jsou definitivně vybrávy typy operandů, upřesnit podle nich skutečně výsledý operátor 
  x_refine_unary(expr^.oper,el^.t,expr^.oper);

  -- typová kontrola levého podvýrazu 
  if expr^.assign

    -- přiřazení 
    then
      -- typová kontrola levého operandu 
      a_type(curr,el,nulltype,info);

      -- na levé straně přiřazení musí být proměnná 
      x_check_assign(curr,el,info);

      -- dosadit do výrazu nový typ 
      expr^.t:=el^.t;

    -- normální operátor 
    else
      -- je podvýraz kompatibilní s dodaným typem ? 
      if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000511,ce_incompatible);
        expr^.join(el);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;

      -- zvolit přesnější typ výsledku 
      x_resolve_by_result(curr,ptyp,expr^.t,res);

      -- typová kontrola podvýrazu 
      a_type(curr,el,res,info);

      -- upravit typ výrazu (pokud se mohl změnit) 
      if (res.tview=tview_full) and not t_equal(expr^.t,res) then
        -- typ výsledku 
        expr^.t:=res;
        end if;
      end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

  -- sloučit podvýrazy 
  expr^.join(el);
  end a_type_unary_lang;



----------------------------------------------------------------------------------------------------
procedure a_type_unary (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpunary;           -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola unárního operátoru.
----------------------------------------------------------------------------------------------------
var
  poper            : pentity_subprogram;         -- přetížený operátor

begin
  -- vyhodnotit nejednoznačné typy
  a_resolve(curr,expr,ptyp,info);

  -- není to náhodou přetížený operátor ? 
  expr^.gettypesym(0,pentity(poper));

  if poper<>nil

    -- ano, je to přetížený operátor, konvertovat na volání procedury 
    then a_type_overloaded(curr,pexpnode(expr),poper,ptyp,info)

    -- ne, jazykem definovaný operátor 
    else a_type_unary_lang(curr,expr,ptyp,info);
    end if;
  end a_type_unary;



----------------------------------------------------------------------------------------------------
procedure a_type_component (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcomponent;       -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola komponenty.
----------------------------------------------------------------------------------------------------
label
  k1;

begin
  -- typová kontrola podvýrazu
  if expr^.sub<>nil then
    -- typová kontrola podvýrazu
    a_type(curr,expr^.sub,nulltype,info);

    -- povedla se typová kontrola podvýrazu ?
    if expr^.sub^.zprac<ep_type then goto k1; end if;
    end if;

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000512,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola úspěšně dokončena
  expr^.zprac:=ep_type;

k1:
  end a_type_component;



----------------------------------------------------------------------------------------------------
procedure a_type_imm (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpimm;             -- výraz
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola přímé hodnoty.
----------------------------------------------------------------------------------------------------
begin
  if ptyp.tview<>tview_null then
    -- je podvýraz kompatibilní s dodaným typem ?
    if not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
      {%%X zpřesnit chybové hlášení }
      ce^.seterror({CCERR=}000513,ce_incompatible);
      expr^.errpos;
      {%%RESUME ce^.raiseerror;}
      ce^.resumeerror;
      end if;

{ Ondra 30.11.1999 : Tak přesně tohle nesmím udělat s žádnou konstantou.
   Protipříklad    : var x : range -10..10 := -10;
                 ...
                 x:=x+20; -- naprosto legální !
                 ...

    -- kovertovat přímou hodnotu 
    imm_settype(expr^.imm,expr^.t.typ,ptyp);

    -- dosadit nový typ 
    expr^.settype(curr,ptyp);
}
    end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;
  end a_type_imm;



----------------------------------------------------------------------------------------------------
procedure a_type_param (
    curr           : in tcontext;                -- překládaný prvek
    arg            : in out pexpitem;            -- skutečný parametr
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola skutečného parametru.
----------------------------------------------------------------------------------------------------
-- %%TECH Všechny operace se provádějí na ARG^.SUB, takže se nemusí
-- v nadřazené proceduře dělat SPLIT/JOIN.
----------------------------------------------------------------------------------------------------
begin
  -- zpracovávat jen výrazy z bezprostředně předchozí fáze 
  if arg^.zprac<>pred ep_type then return end if;

  if arg^.sub<>nil then
    -- typová kontrola podvýrazu 
    if pentity_param(arg^.sym)^.pass in pps_tagged
      -- pro tagged režimy předání se nebere ohled na typ formálního parametru, protože nám jde
      -- primárně o typ skutečného parametru a konverze nás nezajímají
      then a_type(curr,arg^.sub,arg^.sub^.t,info);
      -- pro untagged režimy nás samozřejmě primárně zajímá typ formálního parametru, protože
      -- na ten se musí konvertovat skutečný parametr
      else a_type(curr,arg^.sub,arg^.t,info);
      end if;
    
    -- povedla se typová kontrola podvýrazu ? 
    if arg^.sub^.zprac<ep_type then return; end if;

    ---- pro zjednodušení převzít typ a třídu podvýrazu 
    --arg^.t:=arg^.sub^.t;

    -- pro zjednodušení převzít třídu podvýrazu 
    arg^.nclass:=arg^.sub^.nclass;
    end if;

  -- typová kontrola úspěšně dokončena 
  arg^.zprac:=ep_type;
  end a_type_param;



----------------------------------------------------------------------------------------------------
procedure a_type_call (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- volání procedury
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola volání procedury.
----------------------------------------------------------------------------------------------------
label k1;

var
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     
  arg              : pexpitem;                   -- skutečný parametry procedury                
  el               : pexpnode;                   -- jméno procedury                             
  arglist          : pexpitem;                   -- skutečné parametry procedury                

begin
  -- oddělit prefix a argumenty 
  expr^.split(el,arglist);

  -- typová kontrola jména procedury 
  a_type(curr,el,nulltype,info);

  -- povedla se typová kontrola jména procedury ? 
  if el^.zprac<ep_type then goto k1; end if;

  ----- %%TECH -----------------------------------------------------------
  -- Typovou kontrolu mohu provést nezávisle pro všechny argumenty, takže     
  -- se případné nevyhodnocení detekuje až téměř na konci této procedury.     
  -- (Na rozdíl od typové kontroly jména procedury, jejíž provedení je nutná  
  -- podmínka pro provedení typové kontroly argumentů.)                       
  -- Srovnej CX_FORM.A_FORM_LIST, CX_OPT.A_OPT_CALL                           
  --------------------------------------------------------------------------------------------------

  -- typová kontrola argumentů 
  vyhodnoceno:=true;
  arg:=arglist;
  while arg<>nil loop
    -- typová kontrola argumentu 
    -- SPLIT/JOIN se nedělá, viz A_TYPE_PARAM 
    a_type_param(curr,arg,info);
    vyhodnoceno:=vyhodnoceno and (arg^.zprac>=ep_type);

    -- další podvýraz 
    arg:=pexpitem(arg^.next);
    end loop;

  -- typová kontrola návratové hodnoty 
  if expr^.nclass=nc_none

    -- procedura nevrací hodnotu 
    then
      -- ale nějakou to chce, chyba 
      if ptyp.tview<>tview_null then
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000514,ce_incompatible);
        expr^.join(el,arglist);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;

    -- procedura vrací hodnotu 
    else
      {%%X no a co ? }

      -- je podvýraz kompatibilní s dodaným typem ? 
      if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
        {%%X zpřesnit chybové hlášení }
        ce^.seterror({CCERR=}000515,ce_incompatible);
        expr^.join(el,arglist);
        expr^.errpos;
        {%%RESUME ce^.raiseerror;}
        ce^.resumeerror;
        end if;
      end if;

  -- povedla se typová kontrola argumentů ? 
  if not vyhodnoceno then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit prefix a argumenty 
  expr^.join(el,arglist);
  end a_type_call;



----------------------------------------------------------------------------------------------------
procedure a_type_range (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexprange;           -- rozsah
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola rozsahu.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý a pravý podvýraz
  er               : pexpnode;                   -- levý a pravý podvýraz

begin
  -- vyhodnotit nejednoznačné typy 
  a_resolve(curr,expr,ptyp,info);

  -- rozdělit podvýrazy
  expr^.split(el,er);

  {%%X nemůže se stát, že by dodaný typ byl třeba REAL ? }

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000516,ce_incompatible);
    expr^.join(el,er);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola podvýrazů 
  a_type(curr,el,ptyp,info);
  a_type(curr,er,ptyp,info);

  -- dosadit do výrazu nový typ 
  if ptyp.tview<>tview_null then expr^.t:=ptyp; end if;

  -- povedla se typová kontrola podvýrazů ? 
  if (el^.zprac<ep_type) or (er^.zprac<ep_type) then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el,er);
  end a_type_range;



----------------------------------------------------------------------------------------------------
procedure a_type_index (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpindex;           -- rozsah
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola indexu pole.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  -- rozdělit podvýrazy 
  expr^.split(el,er);

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000517,ce_incompatible);
    expr^.join(el,er);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola levého podvýrazů 
  a_type(curr,el,nulltype,info);

  -- typová kontrola pravého podvýrazu 
  a_type(curr,er,el^.t.getrange(curr),info);

  -- povedla se typová kontrola podvýrazů ? 
  if (el^.zprac<ep_type) or (er^.zprac<ep_type) then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el,er);
  end a_type_index;



----------------------------------------------------------------------------------------------------
procedure a_type_ref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpref;             -- reference
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola reference.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- podvýraz                                    

begin
  -- rozdělit podvýrazy 
  expr^.split(el);

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000518,ce_incompatible);
    expr^.join(el);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola levého podvýrazu 
  a_type(curr,el,nulltype,info);

  -- povedla se typová kontrola podvýrazu ? 
  if el^.zprac<ep_type then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el);
  end a_type_ref;



----------------------------------------------------------------------------------------------------
procedure a_type_deref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpderef;           -- dereference
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola dereference.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- podvýraz                                    

begin
  -- rozdělit podvýrazy 
  expr^.split(el);

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000519,ce_incompatible);
    expr^.join(el);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola levého podvýrazů 
  a_type(curr,el,nulltype,info);

  -- povedla se typová kontrola podvýrazů ? 
  if el^.zprac<ep_type then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el);
  end a_type_deref;



----------------------------------------------------------------------------------------------------
procedure a_type_attrib (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpattrib;          -- atribut
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola atributu.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- podvýraz                                    
  arglist          : pexpitem;                   -- argumenty                                   

begin
  -- rozdělit podvýrazy 
  expr^.split(el,arglist);

  -- je podvýraz kompatibilní s dodaným typem ? 
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000520,ce_incompatible);
    expr^.join(el,arglist);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola podvýrazu 
  a_type(curr,el,nulltype,info);

  -- povedla se typová kontrola podvýrazů ? 
  if el^.zprac<ep_type then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el,arglist);
  end a_type_attrib;



----------------------------------------------------------------------------------------------------
procedure a_type_typecast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- přetypování
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola přetypování.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- podvýraz
  arg              : pexpitem;                   -- argument

begin
  -- oddělit prefix a argumenty
  expr^.split(el,arg);

  -- je podvýraz kompatibilní s dodaným typem ?
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000521,ce_incompatible);
    expr^.join(el,arg);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola levého podvýrazu
  a_type(curr,el,nulltype,info);

  -- typová kontrola pravého podvýrazu
  a_type(curr,arg^.sub,nulltype,info);
  arg^.zprac:=arg^.sub^.zprac;

  -- povedla se typová kontrola podvýrazů ?
  if (el^.zprac<ep_type) or (arg^.zprac<ep_type) then goto k1; end if;

  -- typová kontrola úspěšně dokončena
  expr^.zprac:=ep_type;

k1:
  -- sloučit prefix a argumenty 
  expr^.join(el,arg);
  end a_type_typecast;



----------------------------------------------------------------------------------------------------
procedure a_type_interface_cast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpinterfacecast;   -- přetypování
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola interface castu.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpitem;                   -- pravý podvýraz

begin
  -- oddělit prefix a argumenty
  expr^.split(el,er);

  -- je podvýraz kompatibilní s dodaným typem ?
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000522,ce_incompatible);
    expr^.join(el,er);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola levého podvýrazu
  a_type(curr,el,nulltype,info);

  -- typová kontrola pravého podvýrazu
  a_type(curr,er,nulltype,info);

  -- povedla se typová kontrola podvýrazů ?
  if el^.zprac<ep_type or er^.zprac<ep_type then goto k1; end if;

  -- typová kontrola úspěšně dokončena
  expr^.zprac:=ep_type;

k1:
  -- sloučit prefix a argumenty 
  expr^.join(el,er);
  end a_type_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_type_aggregate (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpaggregate;       -- agregát
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola agregátu.
----------------------------------------------------------------------------------------------------
with
  cc_sym,
  cx_phase;
  
label 
  k1;

var
  el               : pexpnode;                   -- podvýraz
  xel              : pexpnode;                   -- podvýrazy složky
  xer              : pexpnode;                   -- podvýrazy složky
  arglist          : pexpitem;                   -- složky
  x                : pexpitem;                   -- složka
  xtyp             : typeview;                   -- typ složky                                  
  ctyp             : typeview;                   -- typ výběru                                  
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny všechny podvýrazy             
  srch             : tentitysearch;              -- složka recordu

begin
  -- oddělit prefix a argumenty
  expr^.split(el,arglist);

  ---- nejdřív určit typ celého agregátu ----
  if expr^.t.tview=tview_aggregate

    -- typ není určen
    then
      verify({VERIFY=}000245,el<>nil);

      --- z kontextu je znám agregátní typ => použít ho ---
      if t_is_sts(ptyp,dts_aggregate) then
        expr^.t:=ptyp;
      {  
        expr^.akind:=x_get_aggregate_kind(expr^.t);
      }
      --- z kontextu je znám ordinální typ => použít jako bázi množiny ---
      elsif t_is_sts(ptyp,dts_ordinal) then
        t_create_uniarray(curr,expr^.t,ptyp.getctype);
        --unimplemented({UNIMP=}000087);

      --- z kontextu není k dispozici rozumný typ => vymyslet množinu ---
      else
        -- prolézt všechny prvky množiny a nalézt první ordinální typ
        declare var
          first_u  : pentity_type;
          first    : pentity_type;
          er       : pexpitem;

        begin
          er:=arglist;
          while er<>nil loop
            -- je-li to nepoziční složka, nemůže to být množina
            if er^.itype<>ei_expr then
              ce^.seterror({CCERR=}000683,ce_aggregate_no_type);
              expr^.errpos;
              ce^.resumeerror;
              end if;

            -- zpracovat všechny možné typy uzlu
            for eri in 0..er^.sub^.gettypecount-1 loop
              declare var
                ert : ptypeview;                 -- [eri]-tý typ podvýrazu

              begin
                -- získat typ
                er^.sub^.gettype(eri,ert);

                -- první konkrétní ordinální typ => zapamatovat
                if first=nil and t_is_sts(ert^,dts_ordinal) then
                  first:=ert^.getctype;

                -- první univerzální ordinální typ => zapamatovat
                elsif first_u=nil and t_is_sts(ert^,dts_u_ordinal*dts_unitype) then
                  first_u:=ert^.getctype;
                  end if;
                end declare;
              end loop;

            -- další prvek
            er:=er^.next;
            end loop;
          
          -- zvolit typ množiny (přednost má neuniverzální typ)
          if first<>nil then t_create_uniarray(curr,expr^.t,first);
          elsif first_u<>nil then t_create_uniarray(curr,expr^.t,first_u);
          else
            ce^.seterror({CCERR=}000684,ce_aggregate_no_type);
            expr^.errpos;
            ce^.resumeerror;
            end if;
          end declare;
        end if;

      vyhodnoceno:=true;

    -- typ je určen
    else
      -- Univerzální pole dále očekáváme pouze ve smyslu množiny. Pokud se tento ty zde někdy
      -- vyskytne, bude se to muset přepracovat - napříkald doplnit nějaký význam agregátu.
      verify({VERIFY=}001474,t_is_stype(expr^.t,dt_uniarray));
      
      -- typová kontrola prefixu
      a_type(curr,el,nulltype,info);
      vyhodnoceno:=el^.zprac>=ep_type;
      end if;

  ---- typová kontrola složek v závislosti na typu agregátu ----
  case expr^.t.stype
    -- record
    when dt_record do
        -- nalézt první složku recordu
        srch.find_et_first(expr^.t.getctype,rc_primary,et_var,[esf_ancestor]);

        -- typová kontrola všech složek
        x:=arglist;
        while x<>nil loop
          -- podvýrazy složky
          x^.split(xel,xer);

          -- typová kontrola vazby 
          case x^.itype
            -- poziční složka
            when ei_expr   do
                -- je vůbec nějaká složka k dispozici ?
                if srch.psym=nil then
                  ce^.seterror({CCERR=}000523,ce_toomanyitems);
                  x^.join(xel,xer);
                  x^.errpos;
                  ce^.resumeerror;
                  end if;

                -- poznamenat do složky související symbol
                x^.sym:=srch.psym;

                -- typ složky
                xtyp.init(curr,pentity_var(srch.psym)^.typ.getctype);

                -- pro příště vyhledat další složku
                srch.find_et_next;

            -- klíčová
            when ei_choice do
                -- musí to být jeden identifikátor
                if (xer=nil) or (xer^.ntype<>nt_component) or (pexpcomponent(xer)^.id=nil) or (xer^.sub<>nil) then
                  ce^.seterror({CCERR=}000524,ce_i_association);
                  x^.join(xel,xer);
                  x^.errpos;
                  ce^.resumeerror;
                  end if;

                -- předělat uzel, ať se s ním lépe pracuje
                x^.itype:=ei_ident;
                x^.id:=pexpcomponent(xer)^.id;

                -- %%TECH Formální kontrola již zajistila, že po výskytu první klíčové složky
                -- již nenásledují žádné poziční složky, takže to samé hledátko můžeme použít
                -- i zde. %%X Je to však prasárna, takže by se zde mělo použít jiné hledátko
                -- deklarované jako lokální proměnná bloku.

                -- najít složku podle identifikátoru
                srch.find_local(sym_primary_context(expr^.t.getutype^),x^.id^,[etv_public]);
                if srch.psym=nil then
                  ce^.seterror({CCERR=}000525,ce_undeclared);
                  ce^.setparam(entityident_to_string(x^.id^));
                  x^.join(xel,xer);
                  x^.errpos;
                  ce^.resumeerror;
                  end if;

                -- poznamenat do složky související symbol
                x^.sym:=srch.psym;

                -- typ složky
                xtyp.init(curr,pentity_var(srch.psym)^.typ.getctype);

            -- OTHERS
            when ei_others do unimplemented({UNIMP=}000093);

            when others    do verify({VERIFY=}000447,true);
            end case;

          -- typová kontrola hodnoty složky
          a_type(curr,xel,xtyp,info);
          vyhodnoceno:=vyhodnoceno and (xel^.zprac>=ep_type);

          -- sloučit podvýrazy
          x^.join(xel,xer);

          -- další složka
          x:=pexpitem(x^.next);
          end loop;

    -- pole, řetězec
    when dt_array,dt_uarray,dt_string,dt_ustring do
        -- vypočítat typ složky
        xtyp:=expr^.t.getbase(curr);

        -- vypočítat typ výběru
        ctyp:=expr^.t.getrange(curr);

        -- typová kontrola všech složek
        x:=arglist;
        while x<>nil loop
          -- podvýrazy složky
          x^.split(xel,xer);

          -- typová kontrola vazby
          case x^.itype
            -- poziční složka
            when ei_expr   do { nic nedělat };

            -- klíčová
            when ei_choice do
                x_phase_prev(curr,xer,ctyp,eu_use,info);
                vyhodnoceno:=vyhodnoceno and (xer^.zprac>=ep_type);

            -- OTHERS
            when ei_others do { nic nedělat };

            when others    do verify({VERIFY=}000248,true);
            end case;

          -- typová kontrola hodnoty složky
          a_type(curr,xel,xtyp,info);
          vyhodnoceno:=vyhodnoceno and (xel^.zprac>=ep_type);

          -- sloučit podvýrazy
          x^.join(xel,xer);

          -- další složka
          x:=pexpitem(x^.next);
          end loop;

    -- množina, univerzální pole
    when dt_set,dt_uniarray do
        -- typ složky je typ báze množiny
        xtyp:=expr^.t.getbase(curr);

        -- typová kontrola všech složek
        x:=arglist;
        while x<>nil loop
          -- podvýrazy složky
          x^.split(xel,xer);

          -- jediný povolený typ složky je výraz
          if x^.itype<>ei_expr then
            ce^.seterror({CCERR=}000526,ce_i_association);
            x^.errpos;
            ce^.resumeerror;
            end if;

          -- typová kontrola hodnoty složky
          a_type(curr,xel,xtyp,info);
          vyhodnoceno:=vyhodnoceno and (xel^.zprac>=ep_type);

          -- sloučit podvýrazy
          x^.join(xel,xer);

          -- další složka
          x:=pexpitem(x^.next);
          end loop;
        -- unimplemented({UNIMP=}000094);

    when others do verify({VERIFY=}000246,true);
    end case;

  -- povedla se typová kontrola podvýrazů ?
  if not vyhodnoceno then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el,arglist);
  end a_type_aggregate;



----------------------------------------------------------------------------------------------------
procedure a_type_message (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- zpráva
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola přijetí/odeslání zprávy.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- podvýraz
  arglist          : pexpitem;                   -- paramety                                    
  arg              : pexpitem;                   -- parametr                                    
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty                     

begin
  -- oddělit prefix a argumenty 
  expr^.split(el,arglist);

  -- nevrací hodnotu 
  {%%X zpřesnit chybové hlášení }
  if ptyp.tview<>tview_null then
    ce^.seterror({CCERR=}000527,ce_incompatible);
    expr^.join(el,arglist);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola prefixu 
  a_type(curr,el,nulltype,info);

  -- typová kontrola argumentů 
  vyhodnoceno:=true;
  arg:=arglist;
  while arg<>nil loop
    unimplemented({UNIMP=}000101);
    end loop;

  -- povedla se typová kontrola podvýrazů ? 
  if (el^.zprac<ep_form) or not vyhodnoceno then goto k1; end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;

k1:
  -- sloučit podvýrazy 
  expr^.join(el,arglist);
  end a_type_message;



----------------------------------------------------------------------------------------------------
procedure a_type_this (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpthis;            -- THIS
    ptyp           : in typeview;                -- požadovaný typ výrazu
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Typová kontrola THIS.
----------------------------------------------------------------------------------------------------
begin
  -- je podvýraz kompatibilní s dodaným typem ?
  if ptyp.tview<>tview_null and not t_compatible(curr,toc_transform,false,ptyp,expr^.t) then
    {%%X zpřesnit chybové hlášení }
    ce^.seterror({CCERR=}000528,ce_incompatible);
    expr^.errpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- typová kontrola úspěšně dokončena 
  expr^.zprac:=ep_type;
  end a_type_this;



----------------------------------------------------------------------------------------------------
procedure a_type =
-- Typová kontrola výrazu.                                                    
----------------------------------------------------------------------------------------------------
with
  cc_debug;

begin
  verify({VERIFY=}000004,expr=nil);

  -- zpracovávat jen výrazy z bezprostředně předchozí fáze 
  if expr^.zprac<>pred ep_type then return end if;

  -- zpracovávat jen výrazy, kde předchozí fáze proběhla bez chyb
  if expr^.erroneous then return end if;

  -- zkontrolovat výraz 
  case expr^.ntype
    -- operátor 
    when nt_operator  do a_type_operator(curr,pexpoper(expr),ptyp,info);

    -- unární operátor
    when nt_unary     do a_type_unary(curr,pexpunary(expr),ptyp,info);

    -- komponenta
    when nt_component do a_type_component(curr,pexpcomponent(expr),ptyp,info);

    -- přímá hodnota
    when nt_imm       do a_type_imm(curr,pexpimm(expr),ptyp,info);

    -- volání procedury
    when nt_call      do a_type_call(curr,pexplist(expr),ptyp,info);

    -- rozsah
    when nt_range     do a_type_range(curr,pexprange(expr),ptyp,info);

    -- index pole
    when nt_index     do a_type_index(curr,pexpindex(expr),ptyp,info);

    -- reference
    when nt_ref       do a_type_ref(curr,pexpref(expr),ptyp,info);

    -- dereference
    when nt_deref     do a_type_deref(curr,pexpderef(expr),ptyp,info);

    -- atribut
    when nt_attrib    do a_type_attrib(curr,pexpattrib(expr),ptyp,info);

    -- přetypování
    when nt_typecast  do a_type_typecast(curr,pexplist(expr),ptyp,info);

    -- interface cast
    when nt_interface_cast do a_type_interface_cast(curr,pexpinterfacecast(expr),ptyp,info);

    -- agregát
    when nt_aggregate do a_type_aggregate(curr,pexpaggregate(expr),ptyp,info);

    -- odeslání zprávy
    when nt_send      do a_type_message(curr,pexplist(expr),ptyp,info);

    -- přijmutí zprávy
    when nt_accept    do a_type_message(curr,pexplist(expr),ptyp,info);

    -- THIS
    when nt_this      do a_type_this(curr,pexpthis(expr),ptyp,info);

    -- jiné symboly tu nemají co dělat
    when others       do verify({VERIFY=}000005,true);
    end case;

  -- podařila se typová kontrola výrazu ?
  if expr^.zprac<>ep_type then return end if;

  -- kontrola dynamických atributů
  begin
    -- zjistit, jaké dynamické atributy může výraz použít
    x_rta_provided_attributes(curr,expr);

    -- zkontrolovat, jestli má výraz resp. jeho podvýrazy všechny atributy, které potřebují
    x_rta_check_attributes(curr,expr);

  catch
    when others do
      #if #declared debug; #and then; debug then;{%OFF}
        if o_is_option_by_context(opt_dump,curr) then 
          debug_dump('---- Chybny strom -------------------------------------------------------------');
          dumptree(expr); 
          end if;
      #end if;{%ON}

        -- při chybě vrátíme fázi zpracování výrazu zpět, protože se nepovedla celá kontrola
        expr^.zprac:=pred ep_type;

        -- a výjimku pošleme dál
        raise;
    end;

catch
  when resume_error do
      -- kontrola
      verify({VERIFY=}000859,expr^.zprac>=ep_type);

      -- nastavit příznak, že tento uzel byl chybný
      expr^.erroneous:=true;

      -- znovu vyvolat vyjímku
      if not node_catch_resume_error(catch_mode,expr^.ntype) then raise;end if;
  end a_type;



end cx_type;
