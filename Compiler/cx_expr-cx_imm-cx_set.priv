----------------------------------------------------------------------------------------------------
module private cx_set =
-- P©eklada‡ Flexu.
-- Pr ce s agreg tem mno‘iny.
----------------------------------------------------------------------------------------------------
-- Ondra : 27.07.2001 : Vytvo©il.
----------------------------------------------------------------------------------------------------

type
  _ = enum
      cc_choice_case;
      cc_choice_array;
      cc_choice_set;
      end enum;
const
  cc_choice        = cc_choice_set;

#include 'cc_choice0.src';

----------------------------------------------------------------------------------------------------
procedure choice_remove_single =
-- Odebere ze seznamu optimalizovan˜ch v˜bˆr– jednu hodnotu.
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

var
  i                : t_unsigned;

begin
  -- seznam je pr zdn˜ => nen¡ co odstra¤ovat
  if clist.list=nil or else clist.list^:length=0 then 
    return; 
    end if;

  -- zkusit naj¡t spr vn˜ interval
  i:=1;
  while i<=clist.list^:length loop
    -- jednobodov˜ interval ? 
    if clist.list^[i].lval=ui and clist.list^[i].hval=ui then
      -- interval odstranit %%TODO(SLICE)
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+1],clist.list^[i],(clist.list^:length-i)*clist.list^[1]:size);
      pred clist.list^:length;

      -- a konec 
      break;

    -- neshoduje se lev  mez ? 
    elsif clist.list^[i].lval=ui then
      -- posunout levou mez intervalu
      clist.list^[i].lval:=clist.list^[i].lval+ui_1;

      -- a konec 
      break;

    -- neshoduje se prav  mez ? 
    elsif clist.list^[i].hval=ui then
      -- posunout pravou mez intervalu 
      clist.list^[i].hval:=clist.list^[i].hval-ui_1;

      -- a konec 
      break;

    -- nele‘¡ uvnit© ? 
    elsif ui>clist.list^[i].lval and ui<clist.list^[i].hval then
      -- prodlou‘it %%TODO(SLICE)
      choice_extend(clist,1);
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i],clist.list^[i+1],(clist.list^:length-(i-1))*clist.list^[1]:size);
      succ clist.list^:length;

      -- vypo‡¡tat horn¡ mez intervalu vlevo od UI 
      clist.list^[i].hval:=ui-ui_1;

      -- vypo‡¡tat doln¡ mez intervalu vpravo od UI
      clist.list^[i+1].lval:=ui+ui_1;

      -- a konec 
      break;
      end if;

    -- dal¨¡ interval 
    succ i;
    end loop;
  end choice_remove_single;



----------------------------------------------------------------------------------------------------
procedure choice_remove_range =
-- Odebere ze seznamu optimalizovan˜ch v˜bˆr– rozsah hodnot.
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

var
  i                : t_unsigned;

begin
  -- seznam je pr zdn˜ => nen¡ co odstra¤ovat 
  if clist.list=nil or else clist.list^:length=0 then 
    return; 
    end if;

  -- zkusit naj¡t spr vn˜ interval 
  i:=1;
  while i<=clist.list^:length loop
    -- pokr˜v  cel˜ interval 
    if lval<=clist.list^[i].lval and hval>=clist.list^[i].hval then
      -- interval odstranit
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+1],clist.list^[i],(clist.list^:length-i)*clist.list^[1]:size);
      pred clist.list^:length;

      -- je¨tˆ nem–‘eme kon‡it 

    -- pokr˜v  levou polovinu intervalu 
    elsif lval<=clist.list^[i].lval and hval>=clist.list^[i].lval then
      -- posunout levou mez intervalu 
      clist.list^[i].lval:=lval+ui_1;

      -- a konec, dal¨¡ intervaly jsou ji‘ jistˆ vˆt¨¡
      break;

    -- pokr˜v  pravou polovinu intervalu
    elsif lval<=clist.list^[i].hval and hval>=clist.list^[i].hval then
      -- posunout pravou mez intervalu
      clist.list^[i].hval:=hval-ui_1;

      -- je¨tˆ nem–‘eme kon‡it

    -- pokr˜v  vnit©ek intervalu
    elsif lval>clist.list^[i].lval and hval<clist.list^[i].hval then
      -- prodlou‘it %%TODO(SLICE)
      choice_extend(clist,1);
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i],clist.list^[i+1],(clist.list^:length-(i-1))*clist.list^[1]:size);
      succ clist.list^:length;

      -- vypo‡¡tat horn¡ mez intervalu vlevo od LVAL
      clist.list^[i].hval:=lval-ui_1;

      -- vypo‡¡tat doln¡ mez intervalu vpravo od HVAL
      clist.list^[i+1].lval:=hval+ui_1;

      -- a konec, dal¨¡ intervaly jsou ji‘ jistˆ disjunktn¡
      break;

    -- le‘¡ cel˜ pod t¡mto intervalem
    elsif hval<clist.list^[i].lval then
      -- konec, dal¨¡ intervaly jsou je¨tˆ vˆt¨¡
      break;
      end if;

    -- dal¨¡ interval 
    succ i;
    end loop;
  end choice_remove_range;



end cx_set;
