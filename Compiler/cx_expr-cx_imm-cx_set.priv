----------------------------------------------------------------------------------------------------
module private cx_set =
-- Překladač Flexu.
-- Práce s agregátem množiny.
----------------------------------------------------------------------------------------------------
-- Ondra : 27.07.2001 : Vytvořil.
----------------------------------------------------------------------------------------------------

type
  _ = enum
      cc_choice_case;
      cc_choice_array;
      cc_choice_set;
      end enum;
const
  cc_choice        = cc_choice_set;

#include 'cc_choice0.src';

----------------------------------------------------------------------------------------------------
procedure choice_remove_single =
-- Odebere ze seznamu optimalizovaných výběrů jednu hodnotu.
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

var
  i                : t_unsigned;

begin
  -- seznam je prázdný => není co odstraňovat
  if clist.list=nil or else clist.list^:length=0 then 
    return; 
    end if;

  -- zkusit najít správný interval
  i:=1;
  while i<=clist.list^:length loop
    -- jednobodový interval ? 
    if clist.list^[i].lval=ui and clist.list^[i].hval=ui then
      -- interval odstranit %%TODO(SLICE)
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+1],clist.list^[i],(clist.list^:length-i)*clist.list^[1]:size);
      pred clist.list^:length;

      -- a konec 
      break;

    -- neshoduje se levá mez ? 
    elsif clist.list^[i].lval=ui then
      -- posunout levou mez intervalu
      clist.list^[i].lval:=clist.list^[i].lval+ui_1;

      -- a konec 
      break;

    -- neshoduje se pravá mez ? 
    elsif clist.list^[i].hval=ui then
      -- posunout pravou mez intervalu 
      clist.list^[i].hval:=clist.list^[i].hval-ui_1;

      -- a konec 
      break;

    -- neleží uvnitř ? 
    elsif ui>clist.list^[i].lval and ui<clist.list^[i].hval then
      -- prodloužit %%TODO(SLICE)
      choice_extend(clist,1);
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i],clist.list^[i+1],(clist.list^:length-(i-1))*clist.list^[1]:size);
      succ clist.list^:length;

      -- vypočítat horní mez intervalu vlevo od UI 
      clist.list^[i].hval:=ui-ui_1;

      -- vypočítat dolní mez intervalu vpravo od UI
      clist.list^[i+1].lval:=ui+ui_1;

      -- a konec 
      break;
      end if;

    -- další interval 
    succ i;
    end loop;
  end choice_remove_single;



----------------------------------------------------------------------------------------------------
procedure choice_remove_range =
-- Odebere ze seznamu optimalizovaných výběrů rozsah hodnot.
----------------------------------------------------------------------------------------------------
use
  advanced,
  advanced.low_level,
  advanced.low_level.unchecked_memory_access;

var
  i                : t_unsigned;

begin
  -- seznam je prázdný => není co odstraňovat 
  if clist.list=nil or else clist.list^:length=0 then 
    return; 
    end if;

  -- zkusit najít správný interval 
  i:=1;
  while i<=clist.list^:length loop
    -- pokrývá celý interval 
    if lval<=clist.list^[i].lval and hval>=clist.list^[i].hval then
      -- interval odstranit
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i+1],clist.list^[i],(clist.list^:length-i)*clist.list^[1]:size);
      pred clist.list^:length;

      -- ještě nemůžeme končit 

    -- pokrývá levou polovinu intervalu 
    elsif lval<=clist.list^[i].lval and hval>=clist.list^[i].lval then
      -- posunout levou mez intervalu 
      clist.list^[i].lval:=lval+ui_1;

      -- a konec, další intervaly jsou již jistě větší
      break;

    -- pokrývá pravou polovinu intervalu
    elsif lval<=clist.list^[i].hval and hval>=clist.list^[i].hval then
      -- posunout pravou mez intervalu
      clist.list^[i].hval:=hval-ui_1;

      -- ještě nemůžeme končit

    -- pokrývá vnitřek intervalu
    elsif lval>clist.list^[i].lval and hval<clist.list^[i].hval then
      -- prodloužit %%TODO(SLICE)
      choice_extend(clist,1);
      advanced.low_level.unchecked_memory_access.memory_copy(clist.list^[i],clist.list^[i+1],(clist.list^:length-(i-1))*clist.list^[1]:size);
      succ clist.list^:length;

      -- vypočítat horní mez intervalu vlevo od LVAL
      clist.list^[i].hval:=lval-ui_1;

      -- vypočítat dolní mez intervalu vpravo od HVAL
      clist.list^[i+1].lval:=hval+ui_1;

      -- a konec, další intervaly jsou již jistě disjunktní
      break;

    -- leží celý pod tímto intervalem
    elsif hval<clist.list^[i].lval then
      -- konec, další intervaly jsou ještě větší
      break;
      end if;

    -- další interval 
    succ i;
    end loop;
  end choice_remove_range;



end cx_set;
