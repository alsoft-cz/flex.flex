----------------------------------------------------------------------------------------------------
module private cc_pre =
-- Překladač Flexu.
-- Preprocesor.
----------------------------------------------------------------------------------------------------
-- Ondra : 11.04.2000 : Vytvořil
-- Hynek : 29.04.2003 : Pridana podpora pro #pragma library
----------------------------------------------------------------------------------------------------
with
  standard.console,
  cc_def.cc_gc,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_def.cc_env,
  cc_def.cc_files,
  cc_base.cc_sym,
  cc_base.cc_rtl,
  cc_base.cc_text,
  cd_decl,
  cd_decl.cd_create,
  cx_expr,
  cx_expr.cx_def,
  cx_expr.cx_compile;

type
  -- akce pro zpracování metapříkazu
  tmetaaction      = procedure (
      curr         : in tcontext);               -- aktuální kontext
  pmetaaction      = ^tmetaaction;

var
  metatab          : array tmetacmd of pmetaaction;

----------------------------------------------------------------------------------------------------
procedure searchmeta (
    id             : in tentityident;            -- identifikátor
    meta           : out tmetacmd) =             -- metapříkaz
-- Převede identifikátor na metapříkaz.
----------------------------------------------------------------------------------------------------
with
  standard,console,conversions;

var
  zac              : t_unsigned; -- metacmdtab:range;
  stred            : t_unsigned; -- metacmdtab:range;
  kon              : t_unsigned; -- metacmdtab:range;

begin
  zac:=metacmdtab:first;
  kon:=metacmdtab:last;
  loop
    stred:=(zac+kon) div 2;
    if id>metacmdtab[stred].txt
      then zac:=stred+1;
      else kon:=stred;
      end if;
    until zac>=kon;
  if id=metacmdtab[zac].txt
    -- nalezeno
    then meta:=metacmdtab[zac].meta
    -- nenalezeno
    else meta:=meta_unknown;
    end if;
  end searchmeta;



----------------------------------------------------------------------------------------------------
procedure lex_get_lex_element_inside_meta (
    terminators    : in tmetacmdset;             -- množina metapříkazů ukončujících zpracování
    depth          : in out t_unsigned;          -- aktuální úroveň vnoření metapříkazů
    quit           : out t_logical;              -- ukončit zpracování
    lex            : out lexsym;                 -- ziskany symbol
    cmd            : out tmetacmd) =             -- související metapříkaz
-- Získá ze vstupu jeden lexikální prvek. Bere při tom ohled na vnořené metapříkazy a najde-li na 
-- nulté úrovni vnoření metapříkaz z množiny [terminators], ukončí zpracování s příznakem 
-- [quit]=true. Podobně ukončí zpracování nalezne-li metapříkaz #END na nulté úrovni.
----------------------------------------------------------------------------------------------------
begin
  -- přečíst symbol
  lex_get_lex_element(lex);

  -- konec souboru
  if lex=lex_eof then
    lex_input^.check_meta_statements;
    return;
    end if;

  -- analyzovat metapříkaz
  if lex=lex_meta_id then
    -- vyhledat
    searchmeta(getlexid^,cmd);

    -- není to terminující element?
    if depth=0 and then cmd in terminators then
      quit:=true;
      return;
      end if;

    -- zpracovat některé metapříkazy
    case cmd
      -- začátek párového metapříkazu
      when meta_if, meta_syntax, meta_expand, meta_template do 
          succ depth;

      -- konec párového metapříkazu
      when meta_end do
          -- není to náš #end ?
          if depth=0
            -- ano => konec #if
            then quit:=true
            -- ne => pokračovat dál
            else pred depth
            end if;

      -- jiné metapříkazy nás nezajímají
      when others do -- nic nedělat
      end case;
    end if;
  end lex_get_lex_element_inside_meta;



----------------------------------------------------------------------------------------------------
procedure p_skipunknown (
    curr           : in tcontext;                -- aktuální kontext
    num            : in t_unsigned;              -- číslo varování
    warn           : in twarningcode;            -- varování
    id             : in tentityident) =          -- identifikátor
-- Přeskočí text neznámého metapříkazu.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- varování
  ce^.setwarning(curr,num,warn);
  ce^.setparam(entityident_to_string(id));
  ce^.loadpos;

  -- vyčíst symboly až do středníku
  loop
    getlex(curr,lex);
    case lex
      when lex_scol do break;
      when lex_eof  do lex_input^.check_meta_statements; return;
      when others   do -- nic nedělat
      end case;
    end loop;
  end p_skipunknown;



----------------------------------------------------------------------------------------------------
procedure p_skipparams (
    curr           : in tcontext) =              -- aktuální kontext
-- preskoci parametry metaprikazu
----------------------------------------------------------------------------------------------------
var
  x                : pexpnode;
  lex              : lexsym;                     -- lexikální symbol

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000078,ce_x_lpar);
    ce^.loadpos;
    end if;


  -- vyčíst parametry az do prave zavorky
  loop
    -- parametr
    x_vyraz(curr,x,es_expr);

    getlex(curr,lex);
    case lex
      -- carka je ok -pokracujeme dal
      when lex_comma    do;
      
      -- prava zavorka - koncime
      when lex_rpar     do break;
      
      -- konec - koncime
      when lex_eof      do lex_input^.check_meta_statements; return;
      
      -- ostatni - chyba - cekame pravou zavorku
      when others       do
        ce^.seterror({CCERR=}000079,ce_x_rpar);
        ce^.loadpos;
      end case;

    end loop;

  -- strednik
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000080,ce_x_scol);
    ce^.loadpos;
    end if;
  end p_skipparams;
    


----------------------------------------------------------------------------------------------------
procedure p_pragma_import (
    curr           : in tcontext) =              -- aktuální kontext
-- Pragma IMPORT.
----------------------------------------------------------------------------------------------------
with
  cc_binding;

use
  cc_sym.cc_advanced;

var
  lex              : lexsym;                     -- lexikální symbol
  x1               : pexpnode;                   -- výraz
  x2               : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  psym             : pentity;                    -- importovaná entita
  extname          : t_char32str;                -- jméno knihovny
  libname          : t_char32str;                -- jméno knihovny

begin
  -- bezpečnostní kontroly
  check_security_level({CCERR=}000656,curr,sl_import_entity{%%TODO(SECURITY),ce^.loadpos});

  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000081,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- jméno importované entity
  x_vyraz(curr,x1,es_name);
  x_evaluate(curr,x1,ek_sym_import,nil,eu_formal,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  psym:=x1^.getsymbol;
  verify({VERIFY=}001331,psym=nil);

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000644,ce_x_comma);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- další parametr: externí jméno nebo jméno knihovny
  x_vyraz(curr,x2,es_expr);
  x_evaluate(curr,x2,ek_const_str,nil,eu_read,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }

  -- pro přímo importovatelnou entitu může být uvedeno explicitní externí jméno
  if psym^.etype in ets_importable and then checklex(curr,lex_comma) 
  
    -- následuje čárka, je to externí jméno => následuje jméno knihovny
    then
      -- převzít externí jméno
      x_const_sysstr(x2,extname);
     
      -- další parametr: již určitě jméno knihovny
      x_vyraz(curr,x2,es_expr);
      x_evaluate(curr,x2,ek_const_str,nil,eu_read,true,eval);

    -- nenásleduje čárka, už je to jméno externí knihovny
    else
      -- nic nedělat
      end if;
      
  -- převzít jméno knihovny    
  x_const_sysstr(x2,libname);

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000645,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000646,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- importovat
  import_entity(psym,
      for library_name use string_to_external_entity_ident(libname)^,
      for external_name use string_to_external_entity_ident(extname)^,
      for traverse use psym^.etype not in ets_importable{extname=''});
  verify({VERIFY=}001391,psym^.etype in ets_importable and not is_imported(psym));

  -- entitu označit jako deklarovanou a vyhodnocenou
  cc_sym.cc_advanced.sym_set_evaluated(psym);
  end p_pragma_import;



----------------------------------------------------------------------------------------------------
procedure p_pragma_convention (
    curr           : in tcontext) =              -- aktuální kontext
-- Pragma CONVENTION.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  proc             : pentity;                    -- procedura
  id               : pentityident;               -- identifikátor volací konvence

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000088,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- procedura nebo proceduralni typ
  x_vyraz(curr,expr,es_name);
  x_evaluate(curr,expr,ek_sym_proc_proctype,nil,eu_formal,true,eval);
  proc:=expr^.getsymbol;

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000089,ce_x_comma);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- identifikátor
  getlex(curr,lex);
  if lex<>lex_id then
    ce^.seterror({CCERR=}000090,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000091,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000092,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit volací konvenci
  os^.setconvention(proc,id^);
  end p_pragma_convention;



----------------------------------------------------------------------------------------------------
procedure p_pragma_stackframe (
    curr           : in tcontext) =              -- aktuální kontext
-- Pragma STACKFRAME.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  proc             : pentity_procedure;          -- procedura
  id               : pentityident;               -- identifikátor volací konvence

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000093,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- jméno procedury
  x_vyraz(curr,expr,es_name);
  x_evaluate(curr,expr,ek_sym_proc,nil,eu_formal,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  pentity(proc):=expr^.getsymbol;

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000094,ce_x_comma);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- identifikátor
  getlex(curr,lex);
  if lex<>lex_id then
    ce^.seterror({CCERR=}000095,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000096,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000097,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit volací konvenci
  cpu^.setstackframe(proc,id^);
  end p_pragma_stackframe;



----------------------------------------------------------------------------------------------------
procedure p_pragma_assign (
    curr           : in tcontext) =              -- aktuální kontext
-- Pragma ASSIGN.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_sym.cc_partition;
  
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  rtl              : t_rtl_entity;               -- interní entita překladače
  etype            : tentitytype;                -- typ skutečné entity

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000098,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- identifikátor vazby
  getlex(curr,lex);
  if lex<>lex_id then
    ce^.seterror({CCERR=}000099,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- zjistit typ interní entity
  rtl_id_to_entity(curr,getlexid^,rtl,etype);

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000100,ce_x_comma);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- jméno procedury
  x_vyraz(curr,expr,es_name);
  case etype
    when et_undef     do x_evaluate(curr,expr,ek_sym,nil,eu_formal,true,eval);
    when et_procedure do x_evaluate(curr,expr,ek_sym_proc,nil,eu_formal,true,eval);
    when et_message   do x_evaluate(curr,expr,ek_context_message,nil,eu_formal,true,eval);
    when others       do verify({VERIFY=}000672,true);
    end case;
  {%%X a co když je EVAL<>SE_EVALUATED ? }

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000101,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000102,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- má #pragma assign v této partition vůbec smysl ?
  if part_get_partition_type(curr) not in parts_contains_runtime then
    ce^.setwarning(curr,{CCERR=}000640,cw_pragma_not_applicable);
    ce^.loadpos;
    return;
    end if;
                  
  -- vytvořit vazbu na překladač
  if rtl<>rtl_unknown then
    rtl_set_entity(rtl,expr^.getsymbol);
    end if;
  end p_pragma_assign;



----------------------------------------------------------------------------------------------------
procedure p_pragma_export (
    curr           : in tcontext) =
-- pragma export
----------------------------------------------------------------------------------------------------
with
  cc_binding;

var
  lex              : lexsym;                     -- lexikální symbol
  x1               : pexpnode;                   -- výraz
  x2               : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  psym             : pentity;                    -- exp. symbol
  expname          : t_char32str;                -- volitelné jméno pro export

begin
  -- bezpečnostní kontroly
  check_security_level({CCERR=}000655,curr,sl_export_entity{%%TODO(SECURITY),ce^.loadpos});

  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000103,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- jméno exportované entity
  x_vyraz(curr,x1,es_name);
  x_evaluate(curr,x1,ek_sym_export,nil,eu_formal,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  psym:=x1^.getsymbol;
  verify({VERIFY=}000661,psym=nil);

  -- pro přímo exportovatelnou entitu může být uvedeno explicitní externí jméno
  if psym^.etype in ets_exportable and then not followlex(curr,lex_comma) then
    -- ANO
    -- nasleduje volitelne exportni jmeno
    x_vyraz(curr,x2,es_expr);
    x_evaluate(curr,x2,ek_const_str,nil,eu_read,true,eval);
    {%%X a co když je EVAL<>SE_EVALUATED ? }
    x_const_sysstr(x2,expname);
    end if;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000104,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000105,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- exportovat symbol
  export_entity(psym,string_to_external_entity_ident(expname)^);
  verify({VERIFY=}001392,psym^.etype in ets_exportable and not is_exported(psym));
  end p_pragma_export;



----------------------------------------------------------------------------------------------------
procedure p_pragma_no_return (
    curr           : in tcontext) =
-- pragma no_return
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  x1               : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  pproc            : pentity_static_subprogram;  -- statický podprogram

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000106,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- jméno procedury
  x_vyraz(curr,x1,es_name);
  x_evaluate(curr,x1,ek_sym_static_subprogram,nil,eu_formal,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  pproc:=x1^.getsymbol;
  if pproc=nil then 
    return;
    end if;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000107,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000108,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit příznak, že z procedury se to již nevrátí
  pproc^.no_return:=true;
  end p_pragma_no_return;



----------------------------------------------------------------------------------------------------
procedure p_pragma_library (
    curr           : in tcontext) =
-- pragma library
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice
  modul            : pentity_module;             -- module
  id               : pentityident;

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000109,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- typ knihovny
  getlex(curr,lex);
  if lex<>lex_id then
    ce^.seterror({CCERR=}000110,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  id:=getlexid;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000111,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000112,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  os^.setlibrary(pentity_module(curr.entity),id^);
  end p_pragma_library;



----------------------------------------------------------------------------------------------------
procedure p_meta_include : tmetaaction =
-- Metapříkaz #INCLUDE.
----------------------------------------------------------------------------------------------------
use
  supervised c_source_file;

var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  n1               : t_char32str;                -- jméno includovaného souboru
  n2               : t_char32str;                -- jméno includovaného souboru

begin
  -- jméno souboru
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_str,nil,eu_read,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  x_const_sysstr(expr,n1);

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000113,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nalézt soubor
  n2:=cfg_files^.get_included_file_name(lex_input^.get_file_name(),n1);
  if n2='' then
    ce^.seterror({CCERR=}000114,ce_f_notfound);
    ce^.setparam(n1);
    expr^.errpos;
    ce^.raiseerror;
    end if;

  -- includovat soubor
  text_open(n2,true,oft_include);
  end p_meta_include;



----------------------------------------------------------------------------------------------------
procedure p_meta_separate : tmetaaction =
-- Metapříkaz #SEPARATE.
----------------------------------------------------------------------------------------------------
with
  standard,console;

var
  lex              : lexsym;                     -- lexikální symbol
  n1               : t_char32str;                -- jméno includovaného souboru
  n2               : t_char32str;                -- jméno includovaného souboru
  part             : t_part;                     -- část jména souboru
  psym             : pentity;                           

begin
  -- PUBLIC/PRIVATE/nic
  getlex(curr,lex);
  case lex
    when lex_public  do part:=part_public;
    when lex_private do part:=part_private;
    when others do
        part:=part_all;
        ungetlex;
    end case;

  -- identifikátor modulu
  getlex(curr,lex);
  if lex<>lex_id then
    ce^.seterror({CCERR=}000115,ce_x_id);
    ce^.loadpos;
    ce^.resumeerror;
    end if;
  n1:=entityident_to_string(getlexid^){+ext};

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000116,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- sestavit jméno modulu "pomlčkovou konvencí"
  psym:=curr.entity;
  while psym<>nil loop
    -- modul/program/třída
    if psym^.etype in tentitytypeset:[et_program,et_module,et_class] then
      n1:=entityident_to_string(psym^.id^) & '-' & n1;

    -- kompilační jednotka
    elsif psym^.etype=et_compile then
      -- nic nedělat

    -- něco jiného => chyba
    else
      ce^.seterror({CCERR=}000117,ce_meta_i_separate);
      ce^.loadpos;
      ce^.resumeerror;
      end if;

    -- nadřazený symbol
    psym:=psym^.context.entity;
    end loop;

  -- nalézt soubor
  n2:=cfg_files^.get_source_file_name(n1,part);
  if n2='' then
    ce^.seterror({CCERR=}000118,ce_f_notfound);
    ce^.setparam(n1);
    ce^.loadpos;
    ce^.raiseerror;
    end if;

  -- includovat soubor
  text_open(n2,true,oft_separate);
  end p_meta_separate;



----------------------------------------------------------------------------------------------------
procedure p_meta_option_warning (
    curr         : in tcontext) =
-- Metapříkaz #option - specialni pripad warning
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  idwarning        : pentityident;               -- identifikátor warningu
  ul               : tunilogical;
  eval             : tentityeval;

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000119,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- identifikátor warningu
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000120,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  idwarning:=getlexid;

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000121,ce_x_comma);
    ce^.loadpos;
    end if;

  -- výraz
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_logical,nil,eu_use,true,eval);
  verify({VERIFY=}000768,eval<>ete_evaluated);

  -- hodnota výrazu
  x_const_logical(expr,ul);

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000122,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000123,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit
  sym_set_warning(curr,idwarning^,ul=ul_true);
  end p_meta_option_warning;



----------------------------------------------------------------------------------------------------
procedure p_meta_option_hint (
    curr         : in tcontext) =
-- Metapříkaz #option - specialni pripad HINT
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  idhint           : pentityident;               -- identifikátor hintu
  ul               : tunilogical;
  eval             : tentityeval;

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000124,ce_x_lpar);
    ce^.loadpos;
    end if;

  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000125,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  idhint:=getlexid;

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000126,ce_x_comma);
    ce^.loadpos;
    end if;

  -- výraz
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_logical,nil,eu_use,true,eval);
  verify({VERIFY=}000769,eval<>ete_evaluated);

  -- hodnota výrazu
  x_const_logical(expr,ul);

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000127,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000128,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit
  sym_set_hint(curr,idhint^,ul=ul_true);
  end p_meta_option_hint;



----------------------------------------------------------------------------------------------------
procedure p_meta_option_diagnostic (
    curr         : in tcontext) =
-- Metapříkaz #option - speciální případ diagnostické hlášení
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  iddiag           : pentityident;               -- identifikátor diagnostického hlášení
  ul               : tunilogical;
  eval             : tentityeval;

begin
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000129,ce_x_lpar);
    ce^.loadpos;
    end if;

  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000130,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  iddiag:=getlexid;

  -- čárka
  if followlex(curr,lex_comma) then
    ce^.seterror({CCERR=}000131,ce_x_comma);
    ce^.loadpos;
    end if;

  -- výraz
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_logical,nil,eu_use,true,eval);
  verify({VERIFY=}000770,eval<>ete_evaluated);

  -- hodnota výrazu
  x_const_logical(expr,ul);

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000132,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000133,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nastavit
  sym_set_diag(curr,iddiag^,ul=ul_true);
  end p_meta_option_diagnostic;



----------------------------------------------------------------------------------------------------
procedure p_meta_option : tmetaaction =
-- Metapříkaz #OPTION.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_options;

var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  idopt            : pentityident;               -- identifikátor parametru
  ul               : tunilogical;
  ui               : tuniint;
  eval             : tentityeval;
  option           : toption;
  switchable       : t_logical;
  paramtype        : toption_param_type;
  paramexpr        : expkind;

begin
  -- identifikátor
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000134,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  idopt:=getlexid;

  -- není to nastavení varování ?
  if idopt^=opt_warning then 
    p_meta_option_warning(curr); 
    return; 
    end if;

  -- není to nastavení hintu?
  if idopt^=opt_hint then 
    p_meta_option_hint(curr); 
    return; 
    end if;

  -- není to nastavení diagnostického hlášení?
  if idopt^=opt_diag then 
    p_meta_option_diagnostic(curr); 
    return; 
    end if;

  -- zjisti option
  begin
    o_get_option_by_id(idopt^,option)
  
  catch    
    -- neznama option?
    when o_operation_failed do
        -- neznama  
        
        -- waruj
        ce^.setwarning(curr,{CCERR=}000135,cw_unknown_option);
        ce^.setparam(entityident_to_string(idopt^));
        ce^.loadpos;
        
        -- preskoc zbytek
        p_skipparams(curr);
        return;
    end;

  -- da se nastaveni pouzit v tomto contextu?
  if not o_is_option_applicable(option,curr) then
    -- neda
    ce^.setwarning(curr,{CCERR=}000136,cw_option_not_applicable);
    ce^.setparam(entityident_to_string(idopt^));
    ce^.loadpos;

    -- preskoc zbytek
    p_skipparams(curr);

    -- konec
    return;
    end if;
  
  -- levá závorka
  if followlex(curr,lex_lpar) then
    ce^.seterror({CCERR=}000137,ce_x_lpar);
    ce^.loadpos;
    end if;

  -- da se nastaveni vypnout?
  switchable:=o_is_option_switchable(option);
  if switchable then
    -- da - ocekavame logicky vyraz
    x_vyraz(curr,expr,es_expr);
    x_evaluate(curr,expr,ek_const_logical,nil,eu_use,true,eval);
    verify({VERIFY=}000771,eval<>ete_evaluated);

    -- hodnota výrazu
    x_const_logical(expr,ul);
    end if;

  -- pokud se neda nastaveni vypnout, je jiz definovane, ale nededi se, varuj
  if not switchable and not o_is_option_inheritable(option) and o_is_option_by_context(option,curr) then
    -- varuj
    ce^.setwarning(curr,{CCERR=}000138,cw_option_redefined);
    ce^.setparam(entityident_to_string(idopt^));
    ce^.loadpos;
    end if;

  -- datovy typ parametru parametru nastaveni
  paramtype:=o_get_option_param_type(option);

  -- ocekavame parametr?
  if paramtype<>optt_undef then
    -- ocekavame
    
    -- pokud vypinatelne
    if switchable then
      -- čárka
      if followlex(curr,lex_comma) then
        ce^.seterror({CCERR=}000139,ce_x_comma);
        ce^.loadpos;
        end if;
      end if;

    -- typ ocekavaneho vyrazu podle datoveho typu parametru nastaveni
    case paramtype
      -- konstantni cele kladne cislo
      when optt_unicode_addr,optt_unidata_size do paramexpr:=ek_const_int;
      
      -- konstatntni cele cislo
      when optt_uniint do paramexpr:=ek_const_ord;
    
      -- nic jineho nezname - podle potreby pridat dalsi typy
      when others do verify({VERIFY=}000681,true);
      end case;
    
    x_vyraz(curr,expr,es_expr);
    x_evaluate(curr,expr,paramexpr,nil,eu_use,true,eval);
    verify({VERIFY=}000772,eval<>ete_evaluated);

    -- podle typu ziskej hodnotu vyrazu
    case paramexpr
      when ek_const_int,ek_const_ord do
          -- zjisti hodnotu univerzalniho cisla
          x_const_int(expr,ui);
          
          -- z unicisla zformatuj ocekavany typ
          case paramtype
            when optt_unicode_addr do o_set_option_param_unicode_addr(option,curr.entity^,uniint_to_unicode_addr(ui));
            when optt_unidata_size do o_set_option_param_unidata_size(option,curr.entity^,uniint_to_unidata_size(ui));
            when optt_uniint       do o_set_option_param_uniint(option,curr.entity^,ui);
            
            -- jiny datovy typ nezname - podle potreby dodelat
            when others do verify({VERIFY=}000773,true);
            end case;

      -- jiny vyraz zatim nezname - podle potreby dodelat
      when others do verify({VERIFY=}000774,true);
      end case;
    end if;

  -- nastaveni se vypina?
  if switchable and ul=ul_false 

    -- ano - vypni
    then o_set_option_off(option,curr);
  
    -- ne - zapni
    else o_set_option_on(option,curr);
    end if;

  -- pravá závorka
  if followlex(curr,lex_rpar) then
    ce^.seterror({CCERR=}000140,ce_x_rpar);
    ce^.loadpos;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000141,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end p_meta_option;



----------------------------------------------------------------------------------------------------
procedure p_meta_pragma : tmetaaction =
-- Metapříkaz #PRAGMA.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  id               : pentityident;               -- identifikátor

begin
  -- identifikátor
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000142,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- %%X Tohle vymyslet nějak líp - aby to parametry načítalo
  -- a předzpracovávalo samo a ne v každém pragma znovu

  -- #pragma convention
  if id^=pragma_convention then
    p_pragma_convention(curr);

  -- #pragma import
  elsif id^=pragma_import then
    p_pragma_import(curr);

  -- #pragma export
  elsif id^=pragma_export then
    p_pragma_export(curr);

  -- #pragma library
  elsif id^=pragma_library then
    p_pragma_library(curr);

  -- #pragma assign
  elsif id^=pragma_assign then
    p_pragma_assign(curr);

  -- #pragma stackframe
  elsif id^=pragma_stackframe then
    p_pragma_stackframe(curr);

  -- #pragma no_return
  elsif id^=pragma_no_return then
    p_pragma_no_return(curr);

  -- neznámé pragma
  else 
    p_skipunknown(curr,{CCERR=}000143,cw_unknown_pragma,id^);
    end if;
  end p_meta_pragma;



----------------------------------------------------------------------------------------------------
procedure p_meta_environment : tmetaaction =
-- Metapříkaz #ENVIRONMENT.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  id               : pentityident;               -- identifikátor
  env              : tenvvar;                    -- #environment proměnná
  val              : lexval;                     -- hodnota #environment proměnné

begin
  -- identifikátor
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000144,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000145,ce_x_scol);
    ce^.loadpos;
    end if;

  -- zjistit, o jakou #environment proměnnou se jedná
  env_search(id^,env);

  -- zpracovat
  if env=env_none

    -- nenalezeno, předat NIL
    then
      -- varování
      ce^.setwarning(curr,{CCERR=}000146,cw_unknown_environment);
      ce^.setparam(entityident_to_string(id^));
      ce^.loadpos;

      -- předat NIL
      setlex(lex_nil);
      ungetlex;

    -- nalezeno, předat její hodnotu
    else
      -- zjistit hodnotu
      env_get_var(env,lex,val);

      -- předat do zdrojáku
      setlex(lex);
      setlexval(val);
      ungetlex;
      end if;
  end p_meta_environment;



----------------------------------------------------------------------------------------------------
procedure p_meta_syntax : tmetaaction =
-- Metapříkaz #SYNTAX.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  id               : pentityident;               -- identifikátor
  ms               : tmetastackitem;             -- položka zásobníku blokových metapříkazů

begin
  -- zapamatovat si počáteční pozici metapříkazu
  getlexpos(ms.pos.b,ll_curr,false);
  
  -- identifikátor
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000147,ce_x_id);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000148,ce_x_scol);
    ce^.loadpos;
    end if;

  -- zapamatovat si koncovou pozici metapříkazu
  getlexpos(ms.pos.e,ll_curr,true);

  -- připravit záznam na stacku vnoření metapříkazů
  ms.open:=meta_syntax;
  ms.id:=id;
--ms.flag:=0;
  lex_input^.metastack & ms;

  -- #SYNTAX ASM
  if id^=metaid_asm then
    -- nasledujici blok symbolu bude zpracovan jako kod assembleru
    setlex(lex_asm);
    ungetlex;

  -- jiné jazyky zatím neumíme
  else
    -- varování
    ce^.setwarning(curr,{CCERR=}000149,cw_unknown_syntax);
    ce^.setparam(entityident_to_string(id^));
    ce^.loadpos;

    -- přeskočit text do příslušného #END <id>
    loop
      getlex(curr,lex);
      case lex
        when lex_endasm,lex_meta_end do break;
        when lex_eof do lex_input^.check_meta_statements; return;
        when others do -- nic nedělat
        end case;
      end loop;
    end if;
  end p_meta_syntax;



----------------------------------------------------------------------------------------------------
procedure p_meta_and_then : tmetaaction =
-- Metapříkaz #AND THEN.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- THEN
  if followlex(curr,lex_then) then
    ce^.seterror({CCERR=}000150,ce_x_then);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000151,ce_x_scol);
    ce^.loadpos;
    end if;

  -- vrátit lexikální metaelement #AND THEN;
  setlex(lex_meta_and_then);
  ungetlex;
  end p_meta_and_then;



----------------------------------------------------------------------------------------------------
procedure p_meta_or_else : tmetaaction =
-- Metapříkaz #or else.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- ELSE
  if followlex(curr,lex_else) then
    ce^.seterror({CCERR=}000152,ce_x_else);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000153,ce_x_scol);
    ce^.loadpos;
    end if;

  -- vrátit lexikální metaelement #or else;
  setlex(lex_meta_or_else);
  ungetlex;
  end p_meta_or_else;



----------------------------------------------------------------------------------------------------
procedure p_meta_for : tmetaaction =
-- Metapříkaz #or else.
----------------------------------------------------------------------------------------------------
begin
  -- vrátit lexikální metaelement #for
  setlex(lex_meta_for);
  ungetlex;
  end p_meta_for;



----------------------------------------------------------------------------------------------------
procedure p_meta_metaerr : tmetaaction =
-- Chyba v metapříkazu #IF #ELSIF #ELSE #ENDIF #ASM #ENDASM.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;

begin
  ce^.seterror({CCERR=}000154,ce_meta_i_use);
  ce^.setparam(lexcharstr_to_string(getlextxt^));
  ce^.loadpos;
  {%%RESUME ce^.raiseerror;}
  resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
  end p_meta_metaerr;



----------------------------------------------------------------------------------------------------
procedure p_meta_if_cont (
    curr           : in tcontext;                -- aktuální kontext
    _cmd           : in tmetacmd) =              -- metapříkaz
-- Metapříkaz #IF #ELSIF #ELSE #ENDIF.
----------------------------------------------------------------------------------------------------
label
  k1;

{%%TODO(TYPE)
var
  lextxt           : const array lex_meta_and_then..lex_meta_or_else of t_char32str := [
     for lex_meta_and_then use '#and then;',
     for lex_meta_or_else  use '#or else;');
}
    procedure lextxt (lex : in lexsym) return t_char32str =
    begin
      case lex
        when lex_meta_and_then do result:='#and then;';
        when lex_meta_or_else  do result:='#or else;';
        when others            do verify({VERIFY=}001253);
        end case;
      end lextxt;

var
  lex              : lexsym;                     -- lexikální symbol
  lexoper          : lexsym;                     -- metaoperátor
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  vysl             : t_logical;                  -- vysledek vyhodnoceni podminky
  ul               : tunilogical;
  ms               : tmetastackitem;             -- položka zásobníku blokových metapříkazů
  cmd              : tmetacmd;                   -- metapříkaz
  depth            : t_unsigned;                 -- úroveň vnoření podmíněného překladu
  quit             : t_logical;                  -- T-nalezen terminující metapříkaz

begin
  cmd:=_cmd;
  loop
    case cmd
      -- #if
      when meta_if do
          -- zapamatovat si počáteční pozici metapříkazu
          getlexpos(ms.pos.b,ll_curr,false);

          -- připravit položku zásobníku blokových metapříkazů
          ms.open:=meta_if;
        --ms.flag:=0;

      -- #elsif, #end
      when meta_elsif, meta_end do
          if lex_input^.metastack:length=0 or lex_input^.metastack[lex_input^.metastack:length].open<>meta_if then
            p_meta_metaerr(curr);
            return;
            end if;

      -- #else
      when meta_else do
         if lex_input^.metastack:length=0 
         or lex_input^.metastack[lex_input^.metastack:length].open<>meta_if
         or lex_input^.metastack[lex_input^.metastack:length].flag>1 then
           p_meta_metaerr(curr);
           return;
           end if;
           
      when others do verify({VERIFY=}000120,true);
      end case;

    -- po #if a #elsif nasleduje podminka
    if cmd in tmetacmdset:[meta_if,meta_elsif] then
      begin
        -- zpracovat metavýraz
        lexoper:=lex_nul;
        loop
          -- přeložit výraz
          x_vyraz(curr,expr,es_expr);

          -- vyhodnotit výraz, je-li to první výraz v řadě
          if (lexoper=lex_nul)
          -- nebo je oddělen #and then; a výsledek je stále ovlivnitelný
          or else (lexoper=lex_meta_and_then and vysl)
          -- nebo je oddělen #or else; a výsledek je stále ovlivnitelný
          or else (lexoper=lex_meta_or_else and not vysl) then
            -- vyhodnotit výraz
            x_evaluate(curr,expr,ek_const_logical,nil,eu_read,true,eval);
            {%%X a co když je EVAL<>SE_EVALUATED ? }

            -- zazpracovat mezivýsledek podle posledního metaoperátoru
            x_const_logical(expr,ul);
            case lexoper
              when lex_nul           do vysl:=ul=ul_true;
              when lex_meta_and_then do vysl:=vysl and ul=ul_true;
              when lex_meta_or_else  do vysl:=vysl or ul=ul_true;
              when others do verify({VERIFY=}000553,true);
              end case;
            end if;

          -- metaoperátor nebo konec výrazu
          getlex(curr,lex);
          if lex not in lexsymset:[lex_meta_and_then,lex_meta_or_else] then
            ungetlex;
            break;
            end if;

          -- kolikátý metaoperátor to je ?
          if lexoper=lex_nul

            -- první => zapamatovat si ho, musí být všechny stejné
            then lexoper:=lex

            -- další => zkontrolovat, jestli je stále stejný
            else
              if lex<>lexoper then
                ce^.seterror({CCERR=}000155,ce_i_operator);
                --%%TODO(LIB) ce^.setinfo(formats2(hint_meta_a_and_b_or_c,lextxt(lexoper),lextxt(lex)));
                ce^.loadpos2;
                end if;
              end if;

          end loop;

        -- THEN
        if followlex(curr,lex_then) then
          ce^.seterror({CCERR=}000156,ce_x_then);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          end if;

      catch
        when resume_error do
            resumelex(curr,lex,lex_scol,rl_leave,lex_scol,rt_leave);
            vysl:=false;
        end

    -- #else
    elsif cmd=meta_else then
      -- vysledek (bere se vazne jen pokud jeste nebyl vyhodnocen zadny blok podmineneho prekladu)
      vysl:=true and (lex_input^.metastack[lex_input^.metastack:length].flag=0);

      -- uz nesmi nasledovat zadny ELSE
      succ lex_input^.metastack[lex_input^.metastack:length].flag;

    -- #end
    elsif cmd=meta_end then
      -- IF
      if followlex(curr,lex_if) then
        ce^.seterror({CCERR=}000157,ce_meta_x_end_if);
        ce^.loadpos2;
        {%%RESUME ce^.raiseerror;}
        end if;

      -- dekrementovat pocet podminenych prekladu
      pred lex_input^.metastack:length;
      end if;

    -- středník
    if followlex(curr,lex_scol) then
      ce^.seterror({CCERR=}000158,ce_x_scol);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- je-li to začátek podmíněného překladu, pak uložit na stack blokových metapříkazů 
    if cmd=meta_if then
      -- zapamatovat si koncovou pozici metapříkazu
      getlexpos(ms.pos.e,ll_curr,true);

      -- zařadit na stack
      lex_input^.metastack & ms;

    -- podmíněný překlad již nepokračuje
    elsif cmd=meta_end then 
      return; 
      end if;

    if vysl

      -- je-li podminka platna, nasleduje blok, ktery se bere vazne
      then
        -- zmenit priznak
        succ lex_input^.metastack[lex_input^.metastack:length].flag;
        -- a konec
        return;

      -- jinak vyčíst az do dalsiho podmineneho symbolu
      else
        depth:=0;
        loop
          -- přečíst symbol
          lex_get_lex_element_inside_meta([meta_elsif,meta_else],depth,quit,lex,cmd);

          -- byl-li konec souboru, tak hned končíme
          if lex=lex_eof then return end if;

          -- jinak končit až po nalezení terminujícího metapříkazu
          until quit;        
        end if;
    end loop;
  end p_meta_if_cont;



----------------------------------------------------------------------------------------------------
procedure p_meta_if : tmetaaction =
-- Metapříkaz #IF.
----------------------------------------------------------------------------------------------------
begin
  p_meta_if_cont(curr,meta_if);
  end p_meta_if;



----------------------------------------------------------------------------------------------------
procedure p_meta_elsif : tmetaaction =
-- Metapříkaz #ELSIF.
----------------------------------------------------------------------------------------------------
begin
  p_meta_if_cont(curr,meta_elsif);
  end p_meta_elsif;



----------------------------------------------------------------------------------------------------
procedure p_meta_else : tmetaaction =
-- Metapříkaz #ELSE.
----------------------------------------------------------------------------------------------------
begin
  p_meta_if_cont(curr,meta_else);
  end p_meta_else;



----------------------------------------------------------------------------------------------------
procedure p_meta_end_syntax : tmetaaction =
-- Metapříkaz #END ukončující #SYNTAX.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  -- identifikátor
  if followlex(curr,lex_id) or else (getlexid^<>lex_input^.metastack[lex_input^.metastack:length].id^) then
    ce^.seterror({CCERR=}000159,ce_meta_x_end_id);
    ce^.setparam(entityident_to_string(lex_input^.metastack[lex_input^.metastack:length].id^));
    ce^.loadpos2;
    end if;

  -- zrušit ze stacku položku
  pred lex_input^.metastack:length;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000160,ce_x_scol);
    ce^.loadpos;
    end if;

  -- nasledujici symbol znamena konec sekce #syntax
  setlex(lex_endasm);
  ungetlex;
  end p_meta_end_syntax;



----------------------------------------------------------------------------------------------------
procedure p_meta_end_expand : tmetaaction =
-- Metapříkaz #END ukončující #EXPAND.
----------------------------------------------------------------------------------------------------
begin
  -- identifikátor expandované šablony     
  if followlex(curr,lex_id) or else 
  (lex_input^.metastack[lex_input^.metastack:length].id<>nil and then
  getlexid^<>lex_input^.metastack[lex_input^.metastack:length].id^) then
    ce^.seterror({CCERR=}000161,ce_meta_x_end_id);
    ce^.setparam(entityident_to_string(lex_input^.metastack[lex_input^.metastack:length].id^));
    ce^.loadpos2;
    end if;

  -- zrušit ze stacku položku
  pred lex_input^.metastack:length;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000162,ce_x_scol);
    ce^.loadpos2;
    end if;

  -- nasledujici symbol znamena konec sekce #EXPAND
  setlex(lex_meta_end);
  ungetlex;
  end p_meta_end_expand;



----------------------------------------------------------------------------------------------------
procedure p_meta_end : tmetaaction =
-- Metapříkaz #END.
----------------------------------------------------------------------------------------------------
begin
  -- provadi se nejaky blok metaprikazu ?
  if lex_input^.metastack:length>0
    then 
      case lex_input^.metastack[lex_input^.metastack:length].open
        when meta_if     do p_meta_if_cont(curr,meta_end);
        when meta_syntax do p_meta_end_syntax(curr);
        when meta_expand do p_meta_end_expand(curr);
        when others      do verify({VERIFY=}000146,true);
        end case;
    else
      p_meta_metaerr(curr);
      end if;
  end p_meta_end;



----------------------------------------------------------------------------------------------------
procedure p_meta_error : tmetaaction =
-- Metapříkaz #ERROR.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  msg              : t_char32str;                -- zpráva

begin
  -- zpráva
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_str,nil,eu_read,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  x_const_sysstr(expr,msg);

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000163,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- vygenerovat chybu
  ce^.seterror({CCERR=}000164,ce_meta_error);
  ce^.setparam(msg);
  ce^.loadpos;
  ce^.raiseerror;
  end p_meta_error;



----------------------------------------------------------------------------------------------------
procedure p_meta_warning : tmetaaction =
-- Metapříkaz #WARNING.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  msg              : t_char32str;                -- zpráva

begin
  -- zpráva
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_str,nil,eu_read,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  x_const_sysstr(expr,msg);

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000165,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- vygenerovat varování
  ce^.setwarning(curr,{CCERR=}000166,cw_meta_warning);
  ce^.setparam(msg);
  ce^.loadpos;
  end p_meta_warning;



----------------------------------------------------------------------------------------------------
procedure p_meta_display : tmetaaction =
-- Metapříkaz #DISPLAY.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  eval             : tentityeval;                -- vyhodnocení
  msg              : t_char32str;                -- zpráva

begin
  -- zpráva
  x_vyraz(curr,expr,es_expr);
  x_evaluate(curr,expr,ek_const_str,nil,eu_read,true,eval);
  {%%X a co když je EVAL<>SE_EVALUATED ? }
  x_const_sysstr(expr,msg);

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000167,ce_x_scol);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- vygenerovat zprávu
  ce^.setmsg({CCERR=}000168,msg);
  ce^.loadpos;
  end p_meta_display;



----------------------------------------------------------------------------------------------------
procedure p_meta_declared : tmetaaction =
-- Metapříkaz #DECLARED.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  id               : pentityident;               -- identifikátor
  srch             : tentitysearch;              -- hledátko

begin
  -- identifikátor
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000169,ce_x_id);
    ce^.loadpos;
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000170,ce_x_scol);
    ce^.loadpos;
    end if;

  -- zkusit vyhledat
  srch.find_global(curr,id^);

  -- uložit výsledek
  ungetlex;
  if srch.psym<>nil
    then setlex(lex_meta_true);
    else setlex(lex_meta_false);
    end if;
  --u_nimplemented(102);
  end p_meta_declared;



----------------------------------------------------------------------------------------------------
procedure p_meta_template : tmetaaction =
-- Metapříkaz #TEMPLATE.
----------------------------------------------------------------------------------------------------
var
  ptemplate        : pentity_template;           -- šablona
  template_context : tcontext;                   -- kontext šablony
  pos              : lexposblock;                -- pozice šablony
  pparam           : pentity_tparam;             -- parametr
  param_context    : tcontext;                   -- kontext parametru
  parampos         : lexposblock;                -- pozice parametru
  srch             : tentitysearch;              -- hledátko

begin
  -- začátek deklarace
  d_create(curr,pentity(ptemplate),template_context,et_template,pos);

  -- může následovat seznam parametrů
  if checklex(template_context,lex_lpar) then
    loop
      -- založit parametr
      d_create(template_context,pentity(pparam),param_context,et_tparam,parampos);

      -- konec deklarace
      d_end(pparam^,parampos);
      until not checklex(template_context,lex_comma);

    -- pravá závorka
    if followlex(template_context,lex_rpar) then
      ce^.seterror({CCERR=}000171,ce_x_rpar);
      ce^.loadpos2;
      ce^.resumeerror;
      end if;
    end if;

  -- středník
  if followlex(template_context,lex_scol) then
    ce^.seterror({CCERR=}000172,ce_x_scol);
    ce^.loadpos2;
    ce^.resumeerror;
    end if;

  -- tělo deklarace
  d_next(ptemplate^,pos);

  declare var
    lexnode        : plexnode;                   -- jeden lexikální element šablony
    lexlast        : plexnode;                   -- zatím poslední zpracovaný element šablony
    xlex           : lexsym;                     -- ziskany symbol
    cmd            : tmetacmd;                   -- vnořený metapříkaz
    depth          : t_unsigned;                 -- hloubka vnoření párových metapříkazů
    quit           : t_logical;                  -- T-nalezen terminující metapříkaz

    -- uvnitř šablony se nerozlišují klíčová slova a hlásí se prázdné řádky
    _behavior      : c_lex_behavior_plain;

  begin
    -- zpracovat všechny lexikální elementy až do odpovídajícího #end;
    depth:=0;
    lexlast:=nil;
    loop
      -- přečíst symbol
      lex_get_lex_element_inside_meta([],depth,quit,xlex,cmd);

      -- byl-li konec souboru, tak hned končíme
      if xlex=lex_eof then return end if;

      -- jinak končit až po nalezení terminujícího metapříkazu
      if quit then break end if;

      -- je-li to identifikátor, tak zkusit najít parametr
      if xlex=lex_id then
        srch.find_local_all(template_context,getlexid^);
        end if;

      -- jak to dopadlo ?
      if xlex=lex_id and srch.psym<>nil

        -- založit jako odkaz na parametr
        then
          verify({VERIFY=}000554,srch.psym^.etype<>et_tparam);
          
          -- alokovat paměť
          new plexnode_param(lexnode);
          c_garbage_collector.get_instance^.register_record(lexnode);

          plexnode(lexnode)^._tag:=_tag_param;

          -- doplnit údaje
          plexnode_param(lexnode)^.pparam:=pentity_tparam(srch.psym);

        -- založit jako lexikální element
        else
          -- alokovat paměť
          new plexnode_lex(lexnode);
          c_garbage_collector.get_instance^.register_record(lexnode);

          plexnode(lexnode)^._tag:=_tag_lex;

          -- doplnit údaje
          plexnode_lex(lexnode)^.xlex:=xlex;
          getlexval(plexnode_lex(lexnode)^.xval);
          getlexpos(plexnode_lex(lexnode)^.xpos,ll_curr,false);
          end if;

      -- zařadit na konec
      if lexlast<>nil
        then lexlast^.next:=lexnode;
        else ptemplate^.plex:=lexnode;
        end if;
      lexnode^.prev:=lexlast;
      lexlast:=lexnode;
      end loop;
    end declare;

  -- identifikátor
  if followlex(template_context,lex_id) or else getlexid^<>ptemplate^.id^ then
    ce^.seterror({CCERR=}000173,ce_meta_x_end_id);
    ce^.setparam(entityident_to_string(ptemplate^.id^));
    ce^.loadpos2;
    ce^.resumeerror;
    end if;

  -- středník
  if followlex(template_context,lex_scol) then
    ce^.seterror({CCERR=}000174,ce_x_scol);
    ce^.loadpos2;
    ce^.resumeerror;
    end if;

  -- konec deklarace
  d_end(ptemplate^,pos);
  end p_meta_template;



-- dopředné deklarace
class c_expand_parameter; type p_expand_parameter = ^class c_expand_parameter;
class c_expand_template;  type p_expand_template  = ^class c_expand_template;

----------------------------------------------------------------------------------------------------
class public c_expand_parameter = extend c_lexer;
-- Expandovač parametrů šablon.
----------------------------------------------------------------------------------------------------
    
    ------------------------------------------------------------------------------------------------
    static init (
        param      : in pentity_tparam);         -- parametr šablony
    -- Inicializuje expandovač parametrů šablon. Hodnota [param]=nil je chápána jako OTHERS.
    ------------------------------------------------------------------------------------------------
    static match_param (
        param      : in pentity_tparam)          -- zkoumaný parametr šablony
        return t_logical;
    -- True, je-li toto expandovač pro zadaný parametr
    ------------------------------------------------------------------------------------------------
    static add_element (
        lex        : in lexsym;                  -- ziskany element
        val        : in lexval;                  -- hodnota elementu
        pos        : in lexpos);                 -- pozice elementu
    -- Do hodnoty parametru přidá jeden lexikální element.
    ------------------------------------------------------------------------------------------------
    static trim_eols;
    -- Odřízne všechny úvodní a koncové konce řádků.
    ------------------------------------------------------------------------------------------------
    static reset;
    -- Resetuje expandovač na první lexikální element.
    ------------------------------------------------------------------------------------------------

    var
      next         : p_expand_parameter;         -- další parametr

    end c_expand_parameter;



----------------------------------------------------------------------------------------------------
class private c_expand_parameter = 
-- Expandovač parametrů šablon.
----------------------------------------------------------------------------------------------------
    
    var
      -- související parametr
      param        : pentity_tparam;

      -- seznam lexikálních elementů tvořících hodnotu parametru
      first_lex    : plexnode_lex;               -- první lexikální element
      last_lex     : plexnode_lex;               -- poslední lexikální element
      curr_lex     : plexnode_lex;               -- aktuální lexikální element

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializuje expandovač parametrů šablon. Hodnota [param]=nil je chápána jako OTHERS.
    ------------------------------------------------------------------------------------------------
    begin
      this.param:=param;
      end init;



    ------------------------------------------------------------------------------------------------
    static match_param =
    -- True, je-li toto expandovač pro zadaný parametr
    ------------------------------------------------------------------------------------------------
    begin
      result:=this.param=param or else this.param=nil;
      end match_param;



    ------------------------------------------------------------------------------------------------
    static add_element =
    -- Do hodnoty parametru přidá jeden lexikální element.
    ------------------------------------------------------------------------------------------------
    var
      lexnode      : plexnode_lex;

    begin
      -- úvodní konce řádků jsou nezajímavé, ba až kontraproduktivní
      if lex=lex_eoln and first_lex=nil then 
        return 
        end if;

      -- alokovat paměť
      new lexnode;
      plexnode(lexnode)^._tag:=_tag_lex;

      -- doplnit údaje
      lexnode^.xlex:=lex;
      lexnode^.xval:=val;
      lexnode^.xpos:=pos;

      -- zařadit do seznamu
      if last_lex<>nil
        then last_lex^.next:=lexnode
        else first_lex:=lexnode
        end if;
      lexnode^.prev:=last_lex;
      last_lex:=lexnode;
      end add_element;



    ------------------------------------------------------------------------------------------------
    static trim_eols =
    -- Odřízne všechny úvodní a koncové konce řádků.
    ------------------------------------------------------------------------------------------------
    begin
      -- stačí odřezat ty koncové, úvodní za nás ošetřil [add_element]
      while last_lex<>nil and then last_lex^.xlex=lex_eoln loop
        declare var
          p : plexnode_lex;
        begin
          p:=last_lex;
          last_lex:=last_lex^.prev;
          if last_lex=nil 
            then first_lex:=nil 
            else last_lex^.next:=nil
            end if;         
        commit
          discard p;
          end declare;
        end loop;
      end trim_eols;



    ------------------------------------------------------------------------------------------------
    static reset =
    -- Resetuje expandovač na první lexikální element.
    ------------------------------------------------------------------------------------------------
    begin
      curr_lex:=first_lex;
      last:=nil;
      end reset;
    


    ------------------------------------------------------------------------------------------------
    override get_lex_element =
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud již není co expandovat, tak konec
      if curr_lex=nil then
        last.lex:=lex_eof;
        return;
        end if;

      -- vrátit element
      last.lex:=curr_lex^.xlex;
      last.val:=curr_lex^.xval;
      last.pos:=curr_lex^.xpos;

      -- připravit si element pro příště
      curr_lex:=curr_lex^.next;
      end get_lex_element;



    ------------------------------------------------------------------------------------------------
    override discardable =
    ------------------------------------------------------------------------------------------------
    begin
      result:=false;
      end discardable;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalizace.
    ------------------------------------------------------------------------------------------------
    begin
      -- uvolnit všechny lexikální elementy
      curr_lex:=first_lex;
      while curr_lex<>nil loop
        first_lex:=curr_lex^.next;
        discard curr_lex;
        curr_lex:=first_lex;
        end loop;
      end exit;

    end c_expand_parameter;



----------------------------------------------------------------------------------------------------
class public c_expand_template = extend c_lexer;
-- Expandovač šablon.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static init (
        template   : in pentity_template);       -- Expandovaná šablona
    -- Inicializace expandovače šablon.
    ------------------------------------------------------------------------------------------------
    static add_parameter (
        param      : in pentity_tparam;          -- parametr
        expander   : out p_expand_parameter);    -- expandovač parametru
    -- Vyvoří expandovač zadaného parametru.
    ------------------------------------------------------------------------------------------------
    static match_param (
        param      : in pentity_tparam)          -- zkoumaný parametr šablony
        return t_logical;
    -- True, je-li pro zadaný parametr definována hodnota.
    ------------------------------------------------------------------------------------------------

    end c_expand_template;



----------------------------------------------------------------------------------------------------
class private c_expand_template = 
-- Expandovač šablon.
----------------------------------------------------------------------------------------------------

    var
      template     : pentity_template;           -- expandovaná šablona
      curr_lex     : plexnode;                   -- aktuální lexikální element

      -- seznam hodnot parametrů
      first_param  : p_expand_parameter;         -- první parameter
      last_param   : p_expand_parameter;         -- poslední parametr



    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace expandovače šablon.
    ------------------------------------------------------------------------------------------------
    begin
      -- poznamenat si dodanou šablonu
      this.template:=template;

      -- zresetovat pozici na první lexikální element
      curr_lex:=template^.plex;
      end init;



    ------------------------------------------------------------------------------------------------
    static add_parameter =
    -- Vyvoří expandovač zadaného parametru.
    ------------------------------------------------------------------------------------------------
    begin
      begin
        -- vytvořit expandovač
        new expander;

        -- inicializovat
        expander^.init(param);
      
      rollback
        discard expander;
        end;

      -- zařadit do seznamu
      if last_param<>nil
        then last_param^.next:=expander;
        else first_param:=expander;
        end if;
      last_param:=expander;
      end add_parameter;



    ------------------------------------------------------------------------------------------------
    static match_param =
    -- True, je-li pro zadaný parametr definována hodnota.
    ------------------------------------------------------------------------------------------------
    var
      curr_param   : p_expand_parameter;

    begin
      -- projet všechny parametry a najít ten náš
      curr_param:=first_param;
      while curr_param<>nil and then not curr_param^.match_param(param) loop curr_param:=curr_param^.next end loop;
      result:=curr_param<>nil;
      end match_param;



    ------------------------------------------------------------------------------------------------
    override get_lex_element =
    ------------------------------------------------------------------------------------------------
    begin
      -- pokud již není co expandovat, tak konec
      if curr_lex=nil then
        last.lex:=lex_eof;
        return;
        end if;

      -- vrátit element
      case curr_lex^._tag
        -- přímo lexikální element
        when _tag_lex do 
            -- předat ven
            last.lex:=plexnode_lex(curr_lex)^.xlex;
            last.val:=plexnode_lex(curr_lex)^.xval;
            last.pos:=plexnode_lex(curr_lex)^.xpos;

        -- parameter
        when _tag_param do
            declare var
              param : p_expand_parameter;        -- expandovač parametru

            begin
              -- nevrátit nic
              last.lex:=lex_nul;

              -- vyhledat hodnotu parametru
              param:=first_param;
              while param<>nil and then not param^.match_param(plexnode_param(curr_lex)^.pparam) loop
                param:=param^.next;
                end loop;
              
              -- našlo-li se něco, tak zařadit do zpracování
              if param<>nil then
                param^.reset;
                lex_set_lexer(param);
                end if;
              end declare;
        end case;

      -- připravit si element pro příště
      curr_lex:=curr_lex^.next;
      end get_lex_element;



    ------------------------------------------------------------------------------------------------
    exit =
    -- Finalizace
    ------------------------------------------------------------------------------------------------
    var
      curr_param   : p_expand_parameter;

    begin
      -- zrušit všechny parametry
      curr_param:=first_param;
      while curr_param<>nil loop
        first_param:=curr_param^.next;
        discard curr_param;
        curr_param:=first_param;
        end loop;
      end exit;

    end c_expand_template;



----------------------------------------------------------------------------------------------------
procedure p_meta_expand : tmetaaction =
-- Metapříkaz #EXPAND.
----------------------------------------------------------------------------------------------------
with
  console;

var
  template         : pentity_template;           -- expandovaná šablona
  lex              : lexsym;                     -- ziskany symbol
  quit             : t_logical;                  -- T-nalezen terminující metapříkaz

begin
  -- připravit záznam na stacku vnoření metapříkazů
  -- udělat ještě před čtením identifikátoru šablony, abychom zabránili rekurzivní
  -- expanzi přes [p_try_expand_template].
  declare var
    ms             : tmetastackitem;             -- položka zásobníku blokových metapříkazů
  begin
    ms.open:=meta_expand;
  --ms.id:=template^.id;
    lex_input^.metastack & ms; {%%TODO(AGGREGATE)}
    end declare;

  -- %%X Myslím si, že pokud do doby, než se nastaví identifikátor šablony, tak to
  -- v případném [p_meta_end] chcípne na [memory_error]. Nešlo by to řešit pomocí
  -- %%TODO(ROLLBACK) rollback sekce ?

  -- identifikátor šablony
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000175,ce_x_id);
    ce^.loadpos2;
    ce^.resumeerror;
    end if;

  -- dohledat šablonu
  declare var
    srch           : tentitysearch;              -- hledátko

  begin
    -- vyhledat entitu s tímto identifikátorem
    srch.find_global(curr,getlexid^);

    -- musí to být šablona
    if srch.psym=nil or else srch.psym^.etype<>et_template then
      ce^.seterror({CCERR=}000176,ce_x_id_template);
      ce^.loadpos2;
      ce^.resumeerror;
      end if;
    
    -- převzít šablonu
    template:=srch.psym;

    -- poznamenat další použití šablony
    succ template^.stat_usage;
    end declare;

  -- středník
  if followlex(curr,lex_scol) then
    ce^.seterror({CCERR=}000177,ce_x_scol);
    ce^.loadpos2;
    ce^.resumeerror;
    end if;

  -- do stacku vnoření metapříkazů doplnit identifikátor šablony
  lex_input^.metastack[lex_input^.metastack:length].id:=template^.id;

  declare var
    expander       : p_expand_template;          -- expandovač šablony
    param          : pentity_tparam;             -- parametr šablony
    param_expander : p_expand_parameter;         -- expandovač parametru
    cmd            : tmetacmd;                   -- metapříkaz

  begin
    -- alokovat expandovač
    new expander;
    expander^.init(template);

    -- zpracovat všechny asociace parametrů
    if checklex(curr,lex_meta_for) then 
      loop
        -- identifikátor nebo others parametru
        getlex(curr,lex);
        case lex
          -- identifikátor parametru
          when lex_id do
              -- dohledat parametr
              declare var
                srch : tentitysearch;            -- hledátko

              begin
                srch.find_local_all(sym_primary_context(template^),getlexid^);
                if srch.psym=nil or else srch.psym^.etype<>et_tparam then
                  ce^.seterror({CCERR=}000178,ce_x_id_tparam);
                  ce^.loadpos2;
                  ce^.resumeerror;
                  end if;
                param:=srch.psym;
                end declare;

          -- OTHERS
          when lex_others do
              -- žádný konkrétní parametr to nebude
              param:=nil;

          -- cokoliv jiného je chyba
          when others do
              ce^.seterror({CCERR=}000179,ce_x_id_others);
              ce^.loadpos2;
              ce^.resumeerror;
          end case;

        -- USE
        if followlex(curr,lex_use) then
          ce^.seterror({CCERR=}000180,ce_x_use);
          ce^.loadpos2;
          ce^.resumeerror;
          end if;

        -- středník
        if followlex(curr,lex_scol) then
          ce^.seterror({CCERR=}000181,ce_x_scol);
          ce^.loadpos2;
          ce^.resumeerror;
          end if;

        -- zjistit, jestli takový parametr nebyl již deklarován
        if expander^.match_param(param) then
          ce^.seterror({CCERR=}000182,ce_duptparam);
          ce^.loadpos2;
          ce^.resumeerror;
          end if;

        -- založit parametr
        expander^.add_parameter(param,param_expander);

        -- zpracovat všechny symboly až do dalšího #FOR nebo #END a zařadit je do hodnoty parametru
        declare var
          depth    : t_unsigned;                 -- úroveň vnoření podmíněného překladu
          val      : lexval;                     -- hodnota elementu
          pos      : lexpos;                     -- pozice elementu

          -- uvnitř šablony se nerozlišují klíčová slova a hlásí se prázdné řádky
          _behavior: c_lex_behavior_plain;

        begin
          depth:=0;
          cmd:=meta_unknown;
          loop
            -- přečíst symbol
            lex_get_lex_element_inside_meta([meta_for],depth,quit,lex,cmd);

            -- byl-li konec souboru, tak hned končíme
            if lex=lex_eof then return end if;

            -- jinak končit až po nalezení terminujícího metapříkazu
            if quit then break end if;

            -- zařadit element do parametru
            getlexval(val);
            getlexpos(pos,ll_curr,false);
            param_expander^.add_element(lex,val,pos);
            end loop;

          -- z parametru odstranit úvodní a koncové line-endy
          param_expander^.trim_eols;
          end declare;
        until cmd=meta_end;
      end if;

    -- %%X To "if quit..." se mi vůbec nelíbí. Je to dáno tím, že u neprázdného body expandu mi 
    -- #end sežre [lex_get_lex_element_inside_meta], kterýžto nepodporuje [ungetlex], zatímco u 
    -- prázdného body to neproleze ani přes checklex(curr,lex_meta_for), takže se může (a musí)
    -- použít [followlex] rovnou.
    if quit then p_meta_end(curr) end if;

    -- #END <identifikátor>;  
    if followlex(curr,lex_meta_end) then
      ce^.seterror({CCERR=}000183,ce_meta_x_for_end);
      ce^.loadpos2;
      ce^.resumeerror;
      end if;

  rollback
    -- pokud se něco, tak expandovač zase poslat do háje
    discard expander;

  commit
    -- zařadit expandovač do lexikální analýzy
    lex_set_lexer(expander);
    end declare;
  end p_meta_expand;



----------------------------------------------------------------------------------------------------
procedure p_try_expand_template (
      curr         : in tcontext;                -- aktuální kontext
      id           : in tentityident;            -- potenciální identifikátor šablony
      konec        : out t_logical) =            -- T-nic se neexpandovalo
-- Zjistí, jestli dodaný identifikátor neodpovídá nějaké šabloně a pokud ano, tak ji expanduje.
----------------------------------------------------------------------------------------------------
var
  template         : pentity_template;           -- expandovaná šablona

begin
  -- předpoklad: bude se expandovat
  konec:=false;

  -- uvnitř metapříkazu expand se vnořenou expanzí šablon vůbec nezabývat
  if lex_input^.metastack:length>0 and then lex_input^.metastack[lex_input^.metastack:length].open=meta_expand then
    konec:=true;
    return;
    end if;

  -- dohledat šablonu
  declare var
    srch           : tentitysearch;              -- hledátko

  begin
    -- vyhledat entitu s tímto identifikátorem
    srch.find_global_ex(curr,getlexid^,et_template);

    -- pokud se nic nenašlo
    if srch.psym=nil 
    -- nebo to není šablona
    or else srch.psym^.etype<>et_template 
    -- nebo sice je, ale její deklarace ještě nebyla dokončena
    or else srch.psym^.declared<>etd_full then
      -- tak končíme
      konec:=true;
      return;
      end if;

    -- převzít nalezenou šablonu
    template:=srch.psym;

    -- poznamenat další použití šablony
    succ template^.stat_usage;
    end declare;

  -- připravit expandovač šablony
  declare var
    expander       : p_expand_template;          -- expandovač šablony

  begin
    -- alokovat expandovač
    new expander;
    expander^.init(template);

    -- zpracovat všechny parametry
    if checklex(curr,lex_lpar) then 
      declare var
        lex        : lexsym;                     -- poslední lexikální element
        srch       : tentitysearch;              -- hledátko

        -- uvnitř šablony se nerozlišují klíčová slova a hlásí se prázdné řádky
        _behavior      : c_lex_behavior_plain;

      begin
        srch.find_et_first(template,rc_primary,et_tparam,[]);
        while lex<>lex_rpar and srch.psym<>nil loop
          declare var
            param_expander : p_expand_parameter; -- expandovač parametru
            depth    : t_unsigned;               -- úroveň vnoření podmíněného překladu
            val      : lexval;                   -- hodnota elementu
            pos      : lexpos;                   -- pozice elementu

          begin
            -- založit parametr
            expander^.add_parameter(srch.psym,param_expander);

            -- zpracovat všechny symboly až do dalšího #FOR nebo #END a zařadit je do hodnoty parametru
            depth:=0;
            loop
              -- přečíst symbol
              lex_get_lex_element(lex);

              -- byl-li konec souboru, tak hned končíme
              if lex=lex_eof then
                lex_input^.check_meta_statements;
                return;

              -- levá závorka => vnoření
              elsif lex in lexsymset:[lex_lpar,lex_lbra] then
                succ depth;

              -- pravá závorka
              elsif lex in lexsymset:[lex_rpar,lex_rbra] then 
                if depth=0
                  -- na nulté úrovni je to konec všech parametrů
                  then break;
                  -- na 
                  else pred depth;
                  end if;

              -- čárka na nulté úrovni => konec parametru
              elsif lex=lex_comma and depth=0 then 
                break;
                end if;

              -- nyní už můžeme zařadit lexikální element do hodnoty parametru
              getlexval(val);
              getlexpos(pos,ll_curr,false);
              param_expander^.add_element(lex,val,pos);
              end loop;

            -- z parametru odstranit úvodní a koncové line-endy
            param_expander^.trim_eols;
            end declare;

          -- další parametr
          srch.find_et_next;
          end loop;

        -- poslední zpracovávaný element měla být pravá závorka
        if lex<>lex_rpar then
          ce^.seterror({CCERR=}000184,ce_x_rpar);
          ce^.loadpos;{%%X Tuhle pozici to nastaví blbě, ne, když element není v high-level bufferu ? }
          ce^.resumeerror;
          end if;
        end declare;
      end if;

  rollback
    -- pokud se něco, tak expandovač zase poslat do háje
    discard expander;

  commit
    -- zařadit expandovač do lexikální analýzy
    lex_set_lexer(expander);
    end declare;
  end p_try_expand_template;



----------------------------------------------------------------------------------------------------
procedure p_meta_unknown : tmetaaction =
-- Neznámý metapříkaz.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol

begin
  p_skipunknown(curr,{CCERR=}000185,cw_unknown_meta,getlexid^);
  end p_meta_unknown;



----------------------------------------------------------------------------------------------------
procedure p_metacmd (
    curr           : in tcontext;                -- aktuální kontext
    id             : in tentityident) =          -- identifikátor metapříkazu
-- Vyhodnotí metapříkaz.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  meta             : tmetacmd;                   -- metapříkaz

  -- pro metapříkazy potřebujeme detekci klíčových slov
  _behavior      : c_lex_behavior_flex;

begin
  -- vyhledat
  searchmeta(id,meta);

  -- zpracovat
  verify({VERIFY=}000088,metatab[meta]=nil);
  metatab[meta]^(curr);

catch
  when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_scol,rt_skip);
  end p_metacmd;



----------------------------------------------------------------------------------------------------
procedure p_preprocessor =
-- Preprocesor.
----------------------------------------------------------------------------------------------------
begin
  -- identifikátor
  if xlex=lex_id then
    p_try_expand_template(curr,xval.id^,konec);

  -- metapříkaz
  elsif xlex=lex_meta_id then
    p_metacmd(curr,xval.id^);
    konec:=false;

  -- něco jiného
  else 
    konec:=true;
    end if;
  end p_preprocessor;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  metatab[meta_unknown]    :=^p_meta_unknown;
  metatab[meta_include]    :=^p_meta_include;
  metatab[meta_option]     :=^p_meta_option;
  metatab[meta_pragma]     :=^p_meta_pragma;
  metatab[meta_environment]:=^p_meta_environment;
  metatab[meta_syntax]     :=^p_meta_syntax;
  metatab[meta_error]      :=^p_meta_error;
  metatab[meta_if]         :=^p_meta_if;
  metatab[meta_elsif]      :=^p_meta_elsif;
  metatab[meta_else]       :=^p_meta_else;
  metatab[meta_end]        :=^p_meta_end;
  metatab[meta_and]        :=^p_meta_and_then;
  metatab[meta_or]         :=^p_meta_or_else;
  metatab[meta_warning]    :=^p_meta_warning;
  metatab[meta_display]    :=^p_meta_display;
  metatab[meta_declared]   :=^p_meta_declared;
  metatab[meta_template]   :=^p_meta_template;
  metatab[meta_expand]     :=^p_meta_expand;
  metatab[meta_separate]   :=^p_meta_separate;
  metatab[meta_for]        :=^p_meta_for;
  end entry;



end cc_pre;
