----------------------------------------------------------------------------------------------------
class private cc_lex0 =
-- P©eklada‡ Flexu.
-- Lexik ln¡ analyz tor, oddˆlen¡ lexik ln¡ch element–.
----------------------------------------------------------------------------------------------------
-- Ondra : 11.07.1998 : Vytvo©il.
----------------------------------------------------------------------------------------------------

with
  standard,
  cc_unitype,
  supervised cc_base.cc_text;

use
  standard.conversions;

----------------------------------------------------------------------------------------------------
#separate public cc_buffer;
#separate private cc_buffer;
-- Textov˜ buffer.
-- %%X CC_BUFFER by mˆla b˜t generick  t©¡da, abych se vyvaroval pras ren p©i konverzi
-- datov˜ch typ– (identifik tor/znakov˜ agreg t/textov  reprezentace)
----------------------------------------------------------------------------------------------------

var
  {%%TODO(TASK) Kdy‘ je [cc_lex0] t©¡da, tak to snad nemus¡ b˜t taskov‚ promˆnn‚, ne? }
  -- buffer na identifik tory
  buf_id           : {%%TODO(TASK) task} cc_buffer;
  -- buffer na textov‚ reprezentace lexik ln¡ch element–
  buf_txt          : {%%TODO(TASK) task} cc_buffer;
  -- buffer na hodnoty znakov˜ch agreg t–
  buf_str          : {%%TODO(TASK) task} cc_buffer;
  -- pracovn¡ buffer na ‡ sti numerick˜ch liter l–
  buf_num          : {%%TODO(TASK) task} cc_buffer;

----------------------------------------------------------------------------------------------------
static upcase (
    c              : in lexchar)                 -- vstupn¡ znak
    return lexchar =                             -- konvertovan˜ znak
-- P©evede znaky "a".."z" na "A".."Z"
----------------------------------------------------------------------------------------------------
begin
  if c>="a" and c<="z"
    then result:ord:=c:ord-("a":ord-"A":ord)
    else result:=c
    end if;
  end upcase;



----------------------------------------------------------------------------------------------------
static getui (
    radix          : standard.conversions.t_radix;-- z klad ‡¡seln‚ soustavy
    ui             : out tuniint;                -- p©eveden‚ ‡¡slo
    default        : in tuniint) =               -- implicitn¡ hodnota
-- P©evede ‡¡slo v BUF_NUM na univerz ln¡ integer.
-- Pokud je buffer pr zdn˜, vr t¡ implicitn¡ hodnotu DEFAULT.
----------------------------------------------------------------------------------------------------
var
  s                : p_char32ustr;               -- textov  reprezentace ‡¡sla
  error            : standard.conversions.t_conversion_result;  -- chyba v ‡¡sle

begin
  -- textov  reprezentace ‡¡sla
  s{%%X viz pozn mka o genericitˆ CC_BUFFER}:unchecked:=buf_num.endtext;
  if s^=''

    -- nic, vr tit implicitn¡ hodnotu
    then
      ui:=default;

    -- konvertovat
    else
      standard.conversions.string_to_unsigned_primitive(s^,radix,ui,error);
      if error<>standard.conversions.tcres_ok then
        ce^.seterror({CCERR=}000069,ce_errnum);
        ce^.loadtextpos;
        end if;
      end if;

  -- ‡¡slo odstranit z bufferu, u‘ nebude pot©eba
  buf_num.discardlast;
  end getui;



----------------------------------------------------------------------------------------------------
static getnum (
    lex            : out lexsym;                 -- lexik ln¡ element
    val            : out lexval;                 -- hodnota elementu
    append         : in t_logical) =             -- T-textovou reprezentaci p©idat k ji‘ existuj¡c¡
-- Ziska z prectene hodnoty cislo.
----------------------------------------------------------------------------------------------------
var
  c                : lexchar;                    -- znak ze vstupu
  c1               : lexchar;                    -- znak ze vstupu
  ui               : tuniint;                    -- hodnota ‡¡sla
  radix            : standard.conversions.t_radix;-- ‡¡seln  soustava

begin
  -- p©ipravit buffer na textovou reprezentaci ‡¡sla
  if not append then
    buf_txt.newtext;
    end if;

  -- p©ipravit buffer na dekadickou ‡ st ‡¡sla
  buf_num.newtext;

  -- dekadick  ‡ st ‡¡sla
  loop
    -- p©e‡¡st znak
    lex_input^.getchar(c);
    if {%%TODO(IN) c not in ["0".."9","_"]} not (c>="0" and c<="9") and c<>"_" then break end if;

    -- za©adit do bufferu textov‚ reprezentace
    buf_txt.addchar(c);

    -- za©adit do bufferu numerick‚ho liter lu
    if c<>"_" then
      buf_num.addchar(c);
      end if;
    end loop;

  -- pod¡vat se o znak dop©edu
  lex_input^.getchar(c1);
  lex_input^.ungetchar;

  ----- ‡¡slo v obecn‚ soustavˆ -----
  if c="$" then
    -- za©adit do bufferu textov‚ reprezentace
    buf_txt.addchar(c);

    -- ‡¡slo mus¡ za‡¡nat ‡¡slic¡
    if {%%TODO(IN) c1 not in ["0".."9","a".."z","A".."Z"]} not ((c1>="0" and c1<="9") or (c1>="A" and c1<="Z") or (c1>="a" and c1<="z")) then
      ce^.seterror({CCERR=}000070,ce_errnum);
      ce^.loadtextpos;
      lex_input^.getchar(c);
      end if;

    -- ur‡it ‡¡selnou soustavu
    getui(10,ui,ui_radix_hex);
    if ui<ui_radix_first or ui>ui_radix_last
      then
        ce^.seterror({CCERR=}000071,ce_radix);
        ce^.loadtextpos;
        radix:=36;
      else
        radix:=uniint_to_unsigned(ui);
        end if;

    -- p©ipravit buffer na vlastn¡ ‡¡slo
    buf_num.newtext;

    -- na‡¡st ‡¡slo
    loop
      -- p©e‡¡st znak
      lex_input^.getchar(c);
      if {%%TODO(IN) c not in ["0".."9","a".."z","A".."Z","_"]} not ((c>="0" and c<="9") or (c>="A" and c<="Z") or (c>="a" and c<="z") or c="_") then 
        lex_input^.ungetchar;
        break;
        end if;

      -- za©adit do bufferu textov‚ reprezentace
      buf_txt.addchar(c);

      -- za©adit do bufferu numerick‚ho liter lu
      if c<>"_" then
        buf_num.addchar(c);
        end if;
      end loop;

    -- konvertovat ‡¡slo
    getui(radix,val.ui,ui_0);

    -- v˜sledn˜ lexik ln¡ element
    lex:=lex_numi;

  ----- re ln‚ ‡¡slo -----
  elsif c="e" or c="E" or (c="." and c1>="0" and c1<="9") then
    -- desetinn  ‡ st
    if c="." then
      -- za©adit desetinnou te‡ku do bufferu textov‚ reprezentace
      buf_txt.addchar(c);

      -- dekadick  ‡ st ‡¡sla
      loop
        -- p©e‡¡st znak
        lex_input^.getchar(c);
        if {%%TODO(IN) c not in ["0".."9","_"]} not (c>="0" and c<="9") and c<>"_" then break end if;

        -- za©adit do bufferu textov‚ reprezentace
        buf_txt.addchar(c);

        -- za©adit do bufferu numerick‚ho liter lu
        if c<>"_" then
          buf_num.addchar(c);
          end if;
        end loop;
      end if;

    -- konvertovat desetinnou ‡ st
    buf_num.discardlast;

    -- exponent
    if c="e" or c="E" then
      -- za©adit zna‡ku exponentu do bufferu textov‚ reprezentace
      buf_txt.addchar(c);

      -- p©ipravit buffer na exponent
      buf_num.newtext;

      -- m–‘e n sledovat +/-
      lex_input^.getchar(c);
      if c="+" or c="-" then
        -- za©adit znam‚nko do bufferu textov‚ reprezentace
        buf_txt.addchar(c);

        -- dal¨¡ znak
        lex_input^.getchar(c);
        end if;

      -- mus¡ n sledovat ‡¡slice
      lex_input^.ungetchar;
      if not (c>="0" and c<="9") then
        ce^.seterror({CCERR=}000072,ce_errnum);
        ce^.loadtextpos;
        end if;

      -- hodnota exponentu
      loop
        -- p©e‡¡st znak
        lex_input^.getchar(c);
        if {%%TODO(IN) c not in ["0".."9","_"]} not (c>="0" and c<="9") and c<>"_" then break end if;

        -- za©adit do bufferu textov‚ reprezentace
        buf_txt.addchar(c);

        -- za©adit do bufferu numerick‚ho liter lu
        if c<>"_" then
          buf_num.addchar(c);
          end if;
        end loop;

      -- konvertovat exponent
      end if;

    -- v˜sledn˜ lexik ln¡ element
    lex:=lex_numr;

  ----- dekadick‚ ‡¡slo -----
  else
    -- poslednˆ p©e‡ten˜ znak vr tit zpˆt do vstupu
    lex_input^.ungetchar;

    -- konvertovat
    getui(10,val.ui,ui_0);

    -- v˜sledn˜ lexik ln¡ element
    lex:=lex_numi;
    end if;

  -- z¡skat pointer na textovou reprezentaci ‡¡sla
  if not append then
    val.txt:=buf_txt.endtext;
    end if;  
  end getnum;



----------------------------------------------------------------------------------------------------
static get_char_encoding (
    ui         : out tuniint) =                  -- ordin ln¡ hodnota znaku
-- Ziska znak zapsan˜ sv˜m ordin ln¡m ‡¡slem.
----------------------------------------------------------------------------------------------------
var
  ord              : lexval;                     -- ordin ln¡ ‡¡slo znaku
  nlex             : lexsym;                     -- symbol ziskany pri vyhodnoceni cisla

begin
  -- p©e‡¡st ‡¡slo znaku
  getnum(nlex,ord,true);

  -- vejde se do jednoho znaku ?
  if ord.ui<ui_unichar_first or ord.ui>ui_unichar_last then
    ord.ui:=ui_0;
    end if;

  -- p©edat ven
  ui:=ord.ui;
  end get_char_encoding;



----------------------------------------------------------------------------------------------------
static getstr (
    isfc           : in t_logical;               -- T-FC je platn‚
    fc             : in tunichar) =              -- prvn¡ znak agreg tu
-- Ziska z prectene hodnoty retezec.
-- Je-li ISFC=True, je ve FC ulo‘en prvn¡ znak agreg tu z¡skan˜ jinou cestou.
----------------------------------------------------------------------------------------------------
var
  c                : lexchar;                    -- znak p©e‡ten˜ ze vstupu
  uc               : tunichar;
  ui               : tuniint;

begin
  -- p©ipravit buffer na znakov˜ agreg t
  buf_str.newtext;

  -- nem me u‘ k dispozici prvn¡ znak ?
  if isfc

    -- ano => za©adit do znakov‚ho agreg tu
    then
      buf_str.addchar(lexchar(fc:unchecked));

    -- ne => aspo¤ p©ipravit buffer na textovou reprezentaci
    else
      buf_txt.newtext;
      end if;

  loop
    -- p©e‡¡st znak ze vstupu
    lex_input^.getchar(c);

    case c
      -- ©etˆzec v apostrofech
      when "'" do
          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);

          loop
            -- p©e‡¡st znak
            lex_input^.getchar(c);

            -- ulo‘it do bufferu textov‚ reprezentace
            buf_txt.addchar(c);

            case c
              -- konec © dku => chyba
              when \10,\13,\0 do
                  ce^.seterror({CCERR=}000073,ce_x_delim);
                  ce^.loadtextpos;
                  lex_input^.ungetchar;
                  return;

              -- nezobraziteln˜ znak => chyba
              when \1..\31 do
                  ce^.seterror({CCERR=}000074,ce_strelem);
                  ce^.loadtextpos;

              -- konec ©etˆzce v apostrofech nebo dvojit˜ apostrof
              when "'" do
                  -- co dal¨¡ znak ?
                  lex_input^.getchar(c);
                  if c="'"

                    -- dva apostrofy za sebou => jeden ulo‘it do agreg tu
                    then
                      -- p©elo‘it (#representation)
                      --%%X

                      -- ulo‘it do bufferu znakov‚ho agreg tu
                      buf_str.addchar(c);

                    -- jen jeden apostrof => konec ©etˆzce (resp. t‚to jeho ‡ sti)
                    else
                      lex_input^.ungetchar;
                      break;
                      end if;

              -- zobraziteln˜ znak
              when others do
                  -- p©elo‘it (#representation)
                  --%%X

                  -- ulo‘it do bufferu znakov‚ho agreg tu
                  buf_str.addchar(c);

              end case;
            end loop;

      -- ‡¡slo znaku
      when "\" do
          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);

          -- z¡skat znak
          get_char_encoding(ui);

          -- ulo‘it do bufferu znakov‚ho agreg tu (bez p©ekladu)
          --%%X Tohle se mi v–bec nel¡b¡. Pot©ebuju proceduru UNICHAR_TO_LEXCHAR, jen‘e ji nem–‘u
          -- deklarovat v CC_UNITYPE kam pat©¡, proto‘e tam nen¡ vidˆt LEXCHAR...
          uc:=uniint_to_unichar(ui);
          buf_str.addchar(lexchar(uc:unchecked));

      -- nˆco jin‚ho => konec ©etˆzce
      when others do
          lex_input^.ungetchar;
          break;
      end case;
    end loop;

  -- z¡skat pointer na textovou reprezentaci a hodnotu znakov‚ho agreg tu
  last.val.txt:=buf_txt.endtext;
  last.val.str{%%X viz pozn mka o genericitˆ CC_BUFFER}:unchecked:=buf_str.endtext;

  -- v˜sledn˜ lexik ln¡ element
  last.lex:=lex_str;
  end getstr;


{
----------------------------------------------------------------------------------------------------
static count_new_line =
-- Zapo‡¡t  do statistiky dal¨¡ zpracovan˜ © dek.
----------------------------------------------------------------------------------------------------
begin
  -- posunout ‡¡ta‡ © dk–
  lex_input^.next_line;

  -- p©ibyl jeden zpracovan˜ © dek
  succ total_lines;

  -- postarat se t‚‘ o ‡¡ta‡ efektivn¡ch (nepr zdn˜ch, nekoment ©ov˜ch) © dk–
  if lex_input^.effective then
    succ effective_lines;
    lex_input^.effective:=false;
    end if;
  end count_new_line;
}


----------------------------------------------------------------------------------------------------
static comment =
-- Preskoci komentar typu { }.
----------------------------------------------------------------------------------------------------
var
  hloubka          : t_unsigned;                 -- hloubka vnoreni komentare
  c                : lexchar;                    -- znak ze vstupu
  pos              : lexposblock;

begin
  hloubka:=1;
  loop
    lex_input^.getchar(c);
    --%%X scanchar("{","}",c);
    if c="{" then succ hloubka;
    elsif c="}" then pred hloubka;
    elsif c=\10 then lex_input^.next_line{count_new_line};
    elsif c=\0 and lex_input^.is_eof then
      lex_input^.next_line{count_new_line};
      ce^.seterror({CCERR=}000075,ce_comment);
      ce^.setpos(pos);
      ce^.raiseerror;
      end if;
    until hloubka=0;
  end comment;



----------------------------------------------------------------------------------------------------
override get_lex_element =
-- Z¡sk  ze vstupu jeden lexik ln¡ prvek.
----------------------------------------------------------------------------------------------------
with
  console;

var
  c                : lexchar;                    -- p©e‡ten˜ znak

begin
#if #declared profiler_lex; #and then; profiler_lex then;
  succ _get_lex_element;
  rdtsc_start;
#end if;

  -- zat¡m nen¡ ‘ dn˜ element k dispozici
  last:=nil;

  loop
    -- ignorovat mezery pred symbolem
    loop
      lex_input^.getchar(c);
      until c<>" ";

    -- poznamenat si sou©adnice, na nich‘ element za‡¡n 
    lex_input^.get_position(last.pos);

    -- zpracovat
    case c

      -- identifik tor nebo kl¡‡ov‚ slovo
      when "a".."z","A".."Z","_" do
          -- %%X Kdy‘ je v identifik toru znak "_", tak to ur‡itˆ nen¡ kl¡‡ov‚ slovo.
          -- Nezrychlilo by se tak testov n¡ ?

          -- p©ipravit buffer na identifik tor a jeho textovou reprezentaci
          buf_txt.newtext;
          buf_id.newtext;

          -- p©e‡¡st p¡smenn˜ prefix identifik toru
          while (c>="a" and c<="z") or (c>="A" and c<="Z") loop
            -- ulo‘it do bufferu textov‚ reprezentace
            buf_txt.addchar(c);

            -- ulo‘it do bufferu identifik toru
            buf_id.addchar(upcase(c));

            -- dal¨¡ znak
            lex_input^.getchar(c);
            end loop;

          -- nepokra‡uje identifik tor je¨tˆ ?
          if c="_" or (c>="0" and c<="9")

            -- ano => p©e‡¡st zbytek
            then
              -- teƒ u‘ je jasn‚, ‘e to nebude kl¡‡ov‚ slovo
              last.val.can_be_kw:=false;

              loop
                -- ulo‘it do bufferu textov‚ reprezentace
                buf_txt.addchar(c);

                -- ulo‘it do bufferu identifik toru
                buf_id.addchar(upcase(c));

                -- dal¨¡ znak
                lex_input^.getchar(c);
                until not ((c>="a" and c<="z") or (c>="A" and c<="Z") or c="_" or (c>="0" and c<="9")) {%%TODO(IN): c not in ["a".."z","A".."Z","_","0".."9"]};
            
            -- ne => mohlo by to b˜t kl¡‡ov‚ slovo
            else
              last.val.can_be_kw:=true;
              end if;
            
          -- posledn¡ znak ji‘ pat©¡ do jin‚ho elementu
          lex_input^.ungetchar;

          -- z¡skat pointer na textovou reprezentaci a identifik tor
          last.val.txt:=buf_txt.endtext;
          last.val.id{%%X viz pozn mka o genericitˆ CC_BUFFER}:unchecked:=buf_id.endtext;

          -- p©edat ven identifik tor
          last.lex:=lex_id;

      -- ‡¡slo
      when "0".."9","$" do
          lex_input^.ungetchar;
          getnum(last.lex,last.val,false);

      -- znakov˜ liter l
      when """ do 
          -- p©ipravit buffer na textovou reprezentaci
          buf_txt.newtext;

          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);
          
          -- vlastn¡ znak
          lex_input^.getchar(c);

          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);

          -- ulo‘it do hodnoty lexik ln¡ho symbolu
          --%%X Tohle se mi v–bec nel¡b¡. Pot©ebuju proceduru LEXCHAR_TO_UNIINT, jen‘e ji nem–‘u
          -- deklarovat v CC_UNITYPE kam pat©¡, proto‘e tam nen¡ vidˆt LEXCHAR...
          last.val.ui:=unichar_to_uniint(tunichar(c:unchecked));
          last.lex:=lex_char;

          -- ukon‡ovac¡ uvozovka
          lex_input^.getchar(c);
          if c<>""" then
            ce^.seterror({CCERR=}000076,ce_x_quotation);
            ce^.loadtextpos;
            {%%RESUME ce^.raiseerror;}
            lex_input^.ungetchar;
            end if;

          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);

          -- z¡skat pointer na textovou reprezentaci
          last.val.txt:=buf_txt.endtext;

      -- znakov˜ agreg t
      when "'" do
          lex_input^.ungetchar;
          getstr(false,uc_nil);

      -- znakov˜ liter l nebo znakov˜ agreg t
      when "\" do
          -- p©ipravit buffer na textovou reprezentaci
          buf_txt.newtext;

          -- ulo‘it do bufferu textov‚ reprezentace
          buf_txt.addchar(c);

          -- p©e‡¡st k¢d znaku
          get_char_encoding(last.val.ui);

          -- co je za‡ dal¨¡ znak ?
          lex_input^.getchar(c);
          lex_input^.ungetchar;
          if c="\" or c="'"

            -- pokra‡uje znakov˜ agreg t
            then 
              getstr(true,uniint_to_unichar(last.val.ui));

            -- byl to znakov˜ liter l
            else
              -- z¡skat pointer na textovou reprezentaci
              last.val.txt:=buf_txt.endtext;

              -- p©edat ven jako znakov˜ liter l
              last.lex:=lex_char;
              end if;

      -- *
      when "*" do last.lex:=lex_mul;

      -- /
      when "/" do last.lex:=lex_div;

      -- +
      when "+" do last.lex:=lex_add;

      -- - nebo jedno© dkov˜ koment ©
      when "-" do
          lex_input^.getchar(c);
          if c="-"

            -- jedno© dkov˜ koment ©
            then
              --%%X scanchar(\13,\10,c);
              loop
                lex_input^.getchar(c);
                until {c=\13 or} c=\10 {or c=\12 or c=\27} or (c=\0 and lex_input^.is_eof) {%%TODO(IN): c in [\13,\10,\0]};

              -- p©edat ven konec © dku nebo souboru
              if c=\0 then last.lex:=lex_eof;
              elsif c=\10 then last.lex:=lex_eoln;
              else last.lex:=lex_nul;
              end if;

              -- zapo‡¡tat konec © dku
              if last.lex<>lex_nul then
                lex_input^.next_line{count_new_line};
                end if;

            -- -
            else
              lex_input^.ungetchar;
              last.lex:=lex_sub;
              end if;

      -- (
      when "(" do last.lex:=lex_lpar;

      -- )
      when ")" do last.lex:=lex_rpar;

      -- [
      when "[" do last.lex:=lex_lbra;

      -- ]
      when "]" do last.lex:=lex_rbra;

      -- :: := :
      when ":" do
          lex_input^.getchar(c);
          case c
            when ":" do last.lex:=lex_op1;
            when "=" do last.lex:=lex_assign
            when others do
                lex_input^.ungetchar;
                last.lex:=lex_col;
            end case;

      -- ;
      when ";" do last.lex:=lex_scol;

      -- ,
      when "," do last.lex:=lex_comma;

      -- .. .
      when "." do
          lex_input^.getchar(c);
          if c="."
            then last.lex:=lex_ddot;
            else lex_input^.ungetchar; last.lex:=lex_dot;
            end if;

      -- =
      when "=" do last.lex:=lex_eq;

      -- <= <> <
      when "<" do
          lex_input^.getchar(c);
          case c
            when "=" do last.lex:=lex_le;
            when ">" do last.lex:=lex_ne;
            when others do
                lex_input^.ungetchar;
                last.lex:=lex_lt;
            end case;

      -- >= >
      when ">" do
          lex_input^.getchar(c);
          if c="="
            then last.lex:=lex_ge;
            else lex_input^.ungetchar; last.lex:=lex_gt;
            end if;

      -- &
      when "&" do last.lex:=lex_concat;

      -- ^
      when "^" do last.lex:=lex_ptr;

      -- metap©¡kaz
      when "#" do
          -- p©ipravit buffer na identifik tor a jeho textovou reprezentaci
          buf_txt.newtext;
          buf_id.newtext;

          -- p©e‡¡st cel˜ identifik tor
          loop
            -- ulo‘it do bufferu textov‚ reprezentace
            buf_txt.addchar(c);

            -- ulo‘it do bufferu identifik toru
            buf_id.addchar(upcase(c));

            -- dal¨¡ znak
            lex_input^.getchar(c);
            until not ((c>="a" and c<="z") or (c>="A" and c<="Z") or c="_" or (c>="0" and c<="9")) {%%TODO(IN): c not in ["a".."z","A".."Z","_","0".."9"]};

          -- posledn¡ znak ji‘ pat©¡ do jin‚ho elementu
          lex_input^.ungetchar;

          -- z¡skat pointer na textovou reprezentaci a identifik tor
          last.val.txt:=buf_txt.endtext;
          last.val.id{%%X viz pozn mka o genericitˆ CC_BUFFER}:unchecked:=buf_id.endtext;

          -- je to metaidentifik tor
          last.lex:=lex_meta_id;
         
      -- lok ln¡ n vˆ¨t¡ v assembleru
      when "@" do
          -- p©ipravit buffer na identifik tor a jeho textovou reprezentaci
          buf_txt.newtext;
          buf_id.newtext;

          -- p©e‡¡st cel˜ identifik tor
          loop
            -- ulo‘it do bufferu textov‚ reprezentace
            buf_txt.addchar(c);

            -- ulo‘it do bufferu identifik toru
            buf_id.addchar(upcase(c));

            -- dal¨¡ znak
            lex_input^.getchar(c);
            until not ((c>="a" and c<="z") or (c>="A" and c<="Z") or c="_" or (c>="0" and c<="9")) {%%TODO(IN): c not in ["a".."z","A".."Z","_","0".."9"]};

          -- posledn¡ znak ji‘ pat©¡ do jin‚ho elementu
          lex_input^.ungetchar;

          -- z¡skat pointer na textovou reprezentaci a identifik tor
          last.val.txt:=buf_txt.endtext;
          last.val.id{%%X viz pozn mka o genericitˆ CC_BUFFER}:unchecked:=buf_id.endtext;

          -- je to metaidentifik tor
          last.lex:=lex_asm_label;

      -- koment © { }
      when "{" do
          comment;

      -- znak "konec © dku" - LF
      when \10 do 
          -- p©edat ven konec © dku
          last.lex:=lex_eoln;

          -- a zapo‡¡tat dal¨¡ © dek zdroj ku
          lex_input^.next_line{count_new_line};

      -- znak "konec © dku" - ostatn¡ znaky
      when \13,\12,\27 do
          -- ignorovat
          last.lex:=lex_nul;

      -- mohl by to b˜t konec souboru
      when \0 do
          -- je to skute‡nˆ konec souboru?
          if lex_input^.is_eof

            -- ano
            then
              -- ohl sit konec souboru
              last.lex:=lex_eof;
      
              -- a zapo‡¡tat dal¨¡ © dek zdroj ku
              lex_input^.next_line{count_new_line};

            -- ne, je to jen n hodn  nula uprost©ed souboru
            else
              -- ignorovat
              last.lex:=lex_nul;
              end if;

      -- ignorovan˜ znak
      when \9,\26 do
          last.lex:=lex_nul;

      -- nep©¡pustn˜ znak
      when others do
          ce^.seterror({CCERR=}000077,ce_illegal_char);
          ce^.loadtextpos;
      end case;

    until last.lex<>lex_nul {and then (src.doeoln or else last.lex<>lex_eoln)};

  -- dopo‡¡tat d‚lku elementu
  lex_input^.get_length(last.pos);

  -- nepr zdn˜ lexik ln¡ element indikuje efektivn¡ © dek
  if last.lex not in lexsymset:[lex_nul,lex_eof,lex_eoln] then
    lex_input^.set_effective();
    end if;

#if #declared profiler_lex; #and then; profiler_lex then;
  rdtsc_stop(_get_lex_element_t);
#end if;
  end get_lex_element;
{%ON}



------------------------------------------------------------------------------------------------
override top_level =
-- True, je-li to top-level lexik ln¡ analyz tor, kter˜ nesm¡ b˜t odstranˆn bez toho, ‘e by se
-- p©e¨lo k nad©azen‚mu souboru.
------------------------------------------------------------------------------------------------
begin
  result:=true;
  end top_level;



------------------------------------------------------------------------------------------------
override optimize_memory =
-- Optimalizuje pamˆŸ vyu‘itou poslednˆ vr cen˜m lexik ln¡m elementem.
------------------------------------------------------------------------------------------------
begin
{
  if not val.id_used and val.id<>nil then
    buf_id.discardlast
    end if;
  if not val.txt_used and val.txt<>nil then
    buf_txt.discardlast
    end if;
}
  end optimize_memory;

end cc_lex0;
