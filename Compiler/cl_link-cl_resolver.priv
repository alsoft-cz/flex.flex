----------------------------------------------------------------------------------------------------
module private cl_resolver =
-- P©eklada‡ Flexu.
-- Vyhodnocova‡ cross-referenc¡ a adres.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private abstract linkresolver =
-- Vyhodnocova‡ cross-referenc¡ a adres.
----------------------------------------------------------------------------------------------------

    with
      standard.classes,
      standard.classes.lists,
      cx_expr,
      cx_expr.cx_imm,
      cc_def,
      cc_def.cc_var;

    ------------------------------------------------------------------------------------------------
    static domark (
        curr       : in pentity) =               -- symbol
    -- Vlastni marknuti
    ------------------------------------------------------------------------------------------------
    with
      cc_base,
      cc_base.cc_sym;

        --------------------------------------------------------------------------------------------
        procedure marktype =
        -- Ozna‡en¡ typu/t©¡dy na vyhodnocen¡.
        --------------------------------------------------------------------------------------------
        begin
          verify({VERIFY=}000823,tf_temp in pentity_type(curr)^.tflags);
          verify({VERIFY=}000824,tf_tagged not in pentity_type(curr)^.tflags);

          -- za©adit p©edka na vyhodnocen¡ (pokud je t‚‘ tagged)
          if curr^.ancestor.isset then
            declare var
              ancestor : pentity_type;           -- p©edek vyhodnocovan‚ho typu
            begin
              pentity(ancestor):=curr^.ancestor.getcentity;
              if tf_tagged in ancestor^.tflags then mark(ancestor); end if;
              end declare;
            end if;

          -- za©adit na vyhodnocen¡ b zov˜ typ
          if pentity_type(curr)^.stype in dts_base then
            mark(pentity_type(curr)^.base.getctype);
            end if;
          
          -- za©adit na vyhodnocen¡ typ rozsahu
          if pentity_type(curr)^.stype in dts_index then
            mark(pentity_type(curr)^.srange.getctype);
            end if;
          
          -- za©adit na vyhodnocen¡ interfacy
          if curr^.etype=et_class then
            declare var
              it            : c_list_iterator;     -- iter tor p©es interfacy
              exposed_iface : p_class_interface;   -- interface t©¡dy

            begin
              pentity_type(curr)^.interfaces^.get_exposed_interfaces(it);
              while it.get(exposed_iface) loop
                mark(exposed_iface^.refclass.getcentity);
                end loop;
              end declare;
            end if;

          -- za©adit na vyhodnocen¡ v¨echny speci ln¡ metody
          for tst in pentity_type(curr)^.stable:range loop
            if pentity_type(curr)^.stable[tst].isset then
              mark(pentity_type(curr)^.stable[tst].getcentity);
              end if;
            end loop;  

          -- za©adit na seznam entit, pro kter‚ se generuj¡ metadata
          this.metadata.add(curr);
          end marktype;

    begin
      -- ji‘ ozna‡en˜mi symboly se nezab˜vat
      if curr^.linked<>ls_undef then return; end if;

      -- ozna‡it symbol jako pou‘it˜
      curr^.linked:=ls_used;

      -- promˆnn 
      if curr^.etype=et_var then
        case pentity_var(curr)^.mclass
          -- statick 
          when mc_static do
              -- za©adit do p©¡slu¨n‚ho datov‚ho segmentu
              if pentity_var(curr)^.init.isset and not imm_isnil(pentity_var(curr)^.init.getimm^)
                -- inicializovan  promˆnn 
                then this.idata.add(curr)
                -- neinicializovan  promˆnn 
                else this.data.add(curr)
                end if;

          -- taskov 
          when mc_task do 
              -- za©adit do p©¡slu¨n‚ho datov‚ho segmentu - neinicializovan  promˆnn 
              this.data.add(curr)

          when mc_class do { nic nedelat }

          when others do verify({VERIFY=}000191,true);
          end case;

      -- prvek obsahuj¡c¡ k¢d
      elsif curr^.etype in ets_code then
        if curr^.etype=et_procedure{in ets_subprog} and then pentity_procedure{subprog}(curr)^.import_info<>nil

          -- extern¡ symbol
          then
            this.import.add(curr);

           -- norm ln¡ symbol
          else
            verify({VERIFY=}000584,pentity_code(curr)^.codegen=nil);

            -- symbol za©adit pro pozdˆj¨¡ vyhodnocen¡
            this.code.add(curr);

            -- trasovat tabulku relokac¡
            this.trace(curr);
            end if;

      -- typ
      elsif curr^.etype=et_type then
        -- za©adit na vyhodnocen¡
        marktype;

      -- t©¡da
      elsif curr^.etype=et_class then     
        -- za©adit na vyhodnocen¡
        marktype;

        -- za©adit na vyhodnocen¡ v¨echny metody z tabulky virtu ln¡ch metod
        declare var
          it       : c_list_iterator;            -- iter tor
          interface: p_class_interface;          -- interface t©¡dy

        begin
          -- p©ipravit iter tor
          pentity_type(curr)^.interfaces^.get_all_interfaces(it);

          -- zpracovat v¨echny interfacy
          while it.get(interface) loop
            if interface^.vtable<>nil then
              for i in interface^.vtable^:range loop
                if interface^.vtable^[i]<>nil then
                  mark(interface^.vtable^[i]);
                  end if;
                end loop;
              end if;  
            end loop;
          end declare;

      -- zpr va
      elsif curr^.etype=et_message then
        -- za©adit p©edka na vyhodnocen¡ (pokud je t‚‘ tagged)
        if curr^.ancestor.isset then
          mark(curr^.ancestor.getcentity);
          end if;

        -- za©adit typ zpr vy na vyhodnocen¡
        mark(pentity_message(curr)^.typ.getctype);

        -- za©adit na seznam entit, pro kter‚ se generuj¡ metadata
        this.metadata.add(curr);

      -- dal¨¡ prvky
      elsif curr^.etype in ets_enclosed then

      -- nic jin‚ho tu nem  co dˆlat
      else 
        verify({VERIFY=}000032,true);
        end if;

    {
      -- proj¡t lok ln¡ tabulku symbol–
      p:=curr^.symtab;
      while p<>nil loop
        if p^.etype in ets_code+ets_enclosed{-[et_module]} then mark(p); end if;
        p:=p^.next;
        end loop;
    }
      end domark;


    
    ------------------------------------------------------------------------------------------------
    static mark_exports =
    -- Ozna‡¡ pro linkov n¡ v¨echny exportovan‚ entity.
    ------------------------------------------------------------------------------------------------
    begin
      -- je co exportovat?
      if export_list.list=nil then return; end if;

      -- ozna‡it v¨echny exporovan‚ entity
      for i in export_list.list^:range loop
        domark(export_list.list^[i]);
        end loop;
      end mark_exports;

 
    
    ------------------------------------------------------------------------------------------------
    static mark =
    -- F ze 1: Ozna‡en¡ symbol– pro linkov n¡.
    ------------------------------------------------------------------------------------------------
    begin
      mark_exports;
      domark(curr);
      end mark;



    ------------------------------------------------------------------------------------------------
    procedure add_relocation = 
    -- Zatridi relocaddr do seznamu relocaddrs
    ------------------------------------------------------------------------------------------------
    var
      ptempaddrlist     : relocaddrs:type;       -- docasny seznam
      tempaddr          : t_unsigned;            -- pomocna promenna
      
    begin
      verify({VERIFY=}000725,relocaddr<unicode_addr_to_unsigned(getaddrbase));

      if relocaddrs=nil then
        -- alokuj novy seznam relokaci
        new relocaddrs range 255;
        end if;
      
      -- pokud prazdny
      if relocaddrs^:length=0 then
        --rovnou napln
        relocaddrs^ & relocaddr;
        return;
        end if;

      -- pokud jiz v seznamu
      if relocaddrs^[relocaddrs^:length]=relocaddr then
        -- nezarazuj
        return;
        end if;

      -- realokuj pokud treba
      if relocaddrs^:length=relocaddrs^:last then
        -- naalokuj 2x vic pameti nez ma puvodni seznam
        new ptempaddrlist range relocaddrs^:last*2;
        
        -- a prekopiruj puvodni seznam do nove alokovaneho seznamu
        ptempaddrlist^:=relocaddrs^;

        -- stary seznam uz nebudeme potrebovat
        discard relocaddrs;
        relocaddrs:=ptempaddrlist;
        end if;

      -- pridej adresu na konec uz sortnuteho seznamu
      relocaddrs^ & relocaddr;

      -- posledni prvek sortni tam kam patri - od nejmensiho k nejvetsimu
      for i in reverse relocaddrs^:range loop
        -- neni prvni prvek a mensi nez predchozi?
        if i>1 and relocaddrs^[i]<relocaddrs^[i-1] 
        
          -- ano - swapni
          then
            tempaddr:=relocaddrs^[i-1];
            relocaddrs^[i-1]:=relocaddrs^[i];
            relocaddrs^[i]:=tempaddr;
          
          -- ne - vse setrideno, muzeme ukoncit loop
          else
            break;
            end if;
        end loop;
      end add_relocation;
    

    
    ------------------------------------------------------------------------------------------------
    procedure getrelocaddrs =
    -- vrati seznam adres na kterych je treba provest relokaci
    ------------------------------------------------------------------------------------------------
    begin
      result:=relocaddrs;
      end getrelocaddrs;
    
    end linkresolver;



----------------------------------------------------------------------------------------------------
procedure ffillz (
    os             : in p_stream_binary_writer;
    size           : in t_unsigned) =
-- Zap¡¨e do souboru zadan˜ po‡et nulov˜ch byt–.
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  -- v˜pl¤: nuly
  fill_zeros       : const array t_unsigned8 of t_unsigned8 := nil;

var
  i                : t_unsigned;
  j                : t_unsigned;

begin
  i:=size;
  while i>0 loop
    j:=min_unsigned(i,fill_zeros:size);
    os^.write_unchecked_part(fill_zeros,j);
    i-j;
    end loop;
  end ffillz;



----------------------------------------------------------------------------------------------------
#separate private cl_ia32;
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------

end cl_resolver;