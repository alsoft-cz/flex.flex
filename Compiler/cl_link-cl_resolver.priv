----------------------------------------------------------------------------------------------------
module private cl_resolver =
-- Překladač Flexu.
-- Vyhodnocovač cross-referencí a adres.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.04.2002 : Vytvořil
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private abstract linkresolver =
-- Vyhodnocovač cross-referencí a adres.
----------------------------------------------------------------------------------------------------

    with
      standard.classes,
      standard.classes.lists,
      cx_expr,
      cx_expr.cx_imm,
      cc_def,
      cc_def.cc_var;

    ------------------------------------------------------------------------------------------------
    static domark (
        curr       : in pentity) =               -- symbol
    -- Vlastni marknuti
    ------------------------------------------------------------------------------------------------
    with
      cc_base,
      cc_base.cc_sym;

        --------------------------------------------------------------------------------------------
        procedure marktype =
        -- Označení typu/třídy na vyhodnocení.
        --------------------------------------------------------------------------------------------
        begin
          verify({VERIFY=}000823,tf_temp in pentity_type(curr)^.tflags);
          verify({VERIFY=}000824,tf_tagged not in pentity_type(curr)^.tflags);

          -- zařadit předka na vyhodnocení (pokud je též tagged)
          if curr^.ancestor.isset then
            declare var
              ancestor : pentity_type;           -- předek vyhodnocovaného typu
            begin
              pentity(ancestor):=curr^.ancestor.getcentity;
              if tf_tagged in ancestor^.tflags then mark(ancestor); end if;
              end declare;
            end if;

          -- zařadit na vyhodnocení bázový typ
          if pentity_type(curr)^.stype in dts_base then
            mark(pentity_type(curr)^.base.getctype);
            end if;
          
          -- zařadit na vyhodnocení typ rozsahu
          if pentity_type(curr)^.stype in dts_index then
            mark(pentity_type(curr)^.srange.getctype);
            end if;
          
          -- zařadit na vyhodnocení interfacy
          if curr^.etype=et_class then
            declare var
              it            : c_list_iterator;     -- iterátor přes interfacy
              exposed_iface : p_class_interface;   -- interface třídy

            begin
              pentity_type(curr)^.interfaces^.get_exposed_interfaces(it);
              while it.get(exposed_iface) loop
                mark(exposed_iface^.refclass.getcentity);
                end loop;
              end declare;
            end if;

          -- zařadit na vyhodnocení všechny speciální metody
          for tst in pentity_type(curr)^.stable:range loop
            if pentity_type(curr)^.stable[tst].isset then
              mark(pentity_type(curr)^.stable[tst].getcentity);
              end if;
            end loop;  

          -- zařadit na seznam entit, pro které se generují metadata
          this.metadata.add(curr);
          end marktype;

    begin
      -- zajímají nás pouze entity z aktuální parition
      if curr^.partition_id<>curr_partition then return end if;

      -- již označenými symboly se nezabývat
      if curr^.linked<>ls_undef then return; end if;

      -- označit symbol jako použitý
      curr^.linked:=ls_used;

      -- proměnná
      if curr^.etype=et_var then
        case pentity_var(curr)^.mclass
          -- statická
          when mc_static do
              -- zařadit do příslušného datového segmentu
              if pentity_var(curr)^.init.isset and not imm_isnil(pentity_var(curr)^.init.getimm^)
                -- inicializovaná proměnná
                then this.idata.add(curr)
                -- neinicializovaná proměnná
                else this.data.add(curr)
                end if;

          -- tasková
          when mc_task do 
              -- zařadit do příslušného datového segmentu - neinicializovaná proměnná
              this.data.add(curr)

          when mc_class do { nic nedelat }

          when others do verify({VERIFY=}000191,true);
          end case;

      -- prvek obsahující kód
      elsif curr^.etype in ets_code then
        if curr^.etype=et_procedure{in ets_subprog} and then pentity_procedure{subprog}(curr)^.import_info<>nil

          -- externí symbol
          then
            this.import.add(curr);

           -- normální symbol
          else
            verify({VERIFY=}000584,pentity_code(curr)^.codegen=nil);

            -- symbol zařadit pro pozdější vyhodnocení
            this.code.add(curr);

            -- trasovat tabulku relokací
            this.trace(curr);
            end if;

      -- typ
      elsif curr^.etype=et_type then
        -- zařadit na vyhodnocení
        marktype;

      -- třída
      elsif curr^.etype=et_class then     
        -- zařadit na vyhodnocení
        marktype;

        -- zařadit na vyhodnocení všechny metody z tabulky virtuálních metod
        declare var
          it       : c_list_iterator;            -- iterátor
          interface: p_class_interface;          -- interface třídy

        begin
          -- připravit iterátor
          pentity_type(curr)^.interfaces^.get_all_interfaces(it);

          -- zpracovat všechny interfacy
          while it.get(interface) loop
            if interface^.vtable<>nil then
              for i in interface^.vtable^:range loop
                if interface^.vtable^[i]<>nil then
                  mark(interface^.vtable^[i]);
                  end if;
                end loop;
              end if;  
            end loop;
          end declare;

      -- zpráva
      elsif curr^.etype=et_message then
        -- zařadit předka na vyhodnocení (pokud je též tagged)
        if curr^.ancestor.isset then
          mark(curr^.ancestor.getcentity);
          end if;

        -- zařadit typ zprávy na vyhodnocení
        mark(pentity_message(curr)^.typ.getctype);

        -- zařadit na seznam entit, pro které se generují metadata
        this.metadata.add(curr);

      -- další prvky
      elsif curr^.etype in ets_enclosed then

      -- nic jiného tu nemá co dělat
      else 
        verify({VERIFY=}000032,true);
        end if;

    {
      -- projít lokální tabulku symbolů
      p:=curr^.symtab;
      while p<>nil loop
        if p^.etype in ets_code+ets_enclosed{-[et_module]} then mark(p); end if;
        p:=p^.next;
        end loop;
    }
      end domark;


    
    ------------------------------------------------------------------------------------------------
    static mark_exports =
    -- Označí pro linkování všechny exportované entity.
    ------------------------------------------------------------------------------------------------
    begin
      -- je co exportovat?
      if export_list.list=nil then return; end if;

      -- označit všechny exporované entity
      for i in export_list.list^:range loop
        domark(export_list.list^[i]);
        end loop;
      end mark_exports;

 
    
    ------------------------------------------------------------------------------------------------
    static mark =
    -- Fáze 1: Označení symbolů pro linkování.
    ------------------------------------------------------------------------------------------------
    begin
      mark_exports;
      domark(curr);
      end mark;



    ------------------------------------------------------------------------------------------------
    procedure add_relocation = 
    -- Zatridi relocaddr do seznamu relocaddrs
    ------------------------------------------------------------------------------------------------
    var
      ptempaddrlist     : relocaddrs:type;       -- docasny seznam
      tempaddr          : t_unsigned;            -- pomocna promenna
      
    begin
      verify({VERIFY=}000725,relocaddr<unicode_addr_to_unsigned(getaddrbase));

      if relocaddrs=nil then
        -- alokuj novy seznam relokaci
        new relocaddrs range 255;
        end if;
      
      -- pokud prazdny
      if relocaddrs^:length=0 then
        --rovnou napln
        relocaddrs^ & relocaddr;
        return;
        end if;

      -- pokud jiz v seznamu
      if relocaddrs^[relocaddrs^:length]=relocaddr then
        -- nezarazuj
        return;
        end if;

      -- realokuj pokud treba
      if relocaddrs^:length=relocaddrs^:last then
        -- naalokuj 2x vic pameti nez ma puvodni seznam
        new ptempaddrlist range relocaddrs^:last*2;
        
        -- a prekopiruj puvodni seznam do nove alokovaneho seznamu
        ptempaddrlist^:=relocaddrs^;

        -- stary seznam uz nebudeme potrebovat
        discard relocaddrs;
        relocaddrs:=ptempaddrlist;
        end if;

      -- pridej adresu na konec uz sortnuteho seznamu
      relocaddrs^ & relocaddr;

      -- posledni prvek sortni tam kam patri - od nejmensiho k nejvetsimu
      for i in reverse relocaddrs^:range loop
        -- neni prvni prvek a mensi nez predchozi?
        if i>1 and relocaddrs^[i]<relocaddrs^[i-1] 
        
          -- ano - swapni
          then
            tempaddr:=relocaddrs^[i-1];
            relocaddrs^[i-1]:=relocaddrs^[i];
            relocaddrs^[i]:=tempaddr;
          
          -- ne - vse setrideno, muzeme ukoncit loop
          else
            break;
            end if;
        end loop;
      end add_relocation;
    

    
    ------------------------------------------------------------------------------------------------
    procedure getrelocaddrs =
    -- vrati seznam adres na kterych je treba provest relokaci
    ------------------------------------------------------------------------------------------------
    begin
      result:=relocaddrs;
      end getrelocaddrs;
    
    end linkresolver;



----------------------------------------------------------------------------------------------------
procedure ffillz (
    os             : in p_stream_binary_writer;
    size           : in t_unsigned) =
-- Zapíše do souboru zadaný počet nulových bytů.
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  -- výplň: nuly
  fill_zeros       : const array t_unsigned8 of t_unsigned8 := nil;

var
  i                : t_unsigned;
  j                : t_unsigned;

begin
  i:=size;
  while i>0 loop
    j:=min_unsigned(i,fill_zeros:size);
    os^.write_unchecked_part(fill_zeros,j);
    i-j;
    end loop;
  end ffillz;



----------------------------------------------------------------------------------------------------
#separate private cl_ia32;
-- Vyhodnocovač cross-referencí a adres: IA-32.
----------------------------------------------------------------------------------------------------

end cl_resolver;