---------------------------------------------------------------------------------------------------
module private cx_opt =
-- Překladač Flexu.
-- Optimalizace.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.09.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cx_util,cx_imm;

type
  -- optimalizační metoda
  toperopt         = procedure (
      curr         : in tcontext;                -- překládaný prvek
      expr         : in out pexpoper;            -- operátor
      info         : in expinfo);                -- informace o průběhu analýzy
  poperopt         = ^toperopt;

  -- řídící tabulka optimalizace binárních operátorů
  topertab         = array expopertype,tdatatype of poperopt;

  -- optimalizační metoda
  tunaryopt        = procedure (
      curr         : in tcontext;                -- překládaný prvek
      expr         : in out pexpunary;           -- operátor
      el           : in out pexpnode;            -- podvýraz
      result       : out pexpnode;               -- výsledný uzel (změnil-li se)
      info         : in expinfo);                -- informace o průběhu analýzy
  punaryopt        = ^tunaryopt;

  -- řídící tabulka optimalizace binárních operátorů
  tunarytab        = array expunarytype,tdatatype of punaryopt;

var
  opertab          : topertab;
  unarytab         : tunarytab;

var
  -- záplata na chybu, která neumožňuje do IN UNCHECKED parametru předat konstantu
  __dts_u_logical  : tdatatypeset := dts_u_logical;
  __dts_u_set      : tdatatypeset := dts_u_set;
  __dts_u_string_dts_u_array : tdatatypeset := dts_u_string+dts_u_array;

----------------------------------------------------------------------------------------------------
procedure oset11 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in poperopt) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end oset11;



----------------------------------------------------------------------------------------------------
procedure oset1s (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertype;             -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in poperopt) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=method;
      end if;
    end loop;
  end oset1s;



----------------------------------------------------------------------------------------------------
procedure osetss (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in poperopt) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end osetss;



----------------------------------------------------------------------------------------------------
procedure osets1 (
    tab            : in out topertab;            -- řídící tabulka
    op             : in expopertypeset;          -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in poperopt) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expopertype loop
    if i in op then
      tab[i,stype]:=method;
      end if;
    end loop;
  end osets1;



----------------------------------------------------------------------------------------------------
procedure uset11 (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytype;            -- operátor
    stype          : in tdatatype;               -- typ výrazu
    method         : in punaryopt) =             -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end uset11;



----------------------------------------------------------------------------------------------------
procedure usetss (
    tab            : in out tunarytab;           -- řídící tabulka
    op             : in expunarytypeset;         -- operátor
    stype          : in tdatatypeset;            -- typ výrazu
    method         : in punaryopt) =             -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  for i in expunarytype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end usetss;



---- %%TECH Detekce výrazů konstantních v důsledku optimalizace ------------------------------------
--
-- Optimalizátor provádí zjednodušení výrazů např. typu 1+6*8 na 49.
-- Pokud lze výraz s proměnnou (proměnnými) optimalizovat na konst. výraz, např:
-- (3-3)*x, je výsledkem konstanta, tedy uzel typu [nt_imm]. Tento mechanismus by tedy
-- povoloval např. inicializace typu
--
-- var
--   x : integer;
--   i : integer := 0*x;
--
-- které jsou jazykově nepřípustné. Proto je zaveden příznak uzlu [nf_const],
-- který je nastaven výhradně pro přímé hodnoty (které nevznikly v důsledku optimalizace)
-- a optimalizované výrazy jimi indukované.
--
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure a_opt_sequence (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    all            : out t_logical;              -- T-optimalizovány všechny operandy
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace sekvence operandů.
----------------------------------------------------------------------------------------------------
var
  pexp             : pexpnode;                   -- předchozí podvýraz
  cexp             : pexpnode;                   -- aktuální podvýraz
  nexp             : pexpnode;                   -- následující podvýraz

begin
  pexp:=nil;
  cexp:=expr^.sub;
  all:=true;
  while cexp<>nil loop
    -- podvýraz osamostatnit
    nexp:=cexp^.next;
    cexp^.next:=nil;

    -- optimalizovat
    a_opt(curr,cexp,info);

    -- povedla se optimalizace výrazu ?
    all and cexp^.zprac>=ep_opt;

    -- podvýraz zařadit
    if pexp<>nil
      then pexp^.next:=cexp
      else expr^.sub:=cexp;
      end if;
    pexp:=cexp;
    cexp:=nexp;
    end loop;
  end a_opt_sequence;



----------------------------------------------------------------------------------------------------
procedure a_opt_finalize_sequence (
    expr           : in out pexpoper) =          -- výraz
-- Dokončení optimalizace n-árního oprátoru.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000474,expr^.sub=nil);

  if expr^.sub^.next=nil

    -- zbyl jen jeden operand
    then
      if expr^.assign and expr^.sub^.ntype not in nts_operator
        -- zkrácené přiřazení ze kterého zbylo jen jméno => zrušit celý příkaz
        then expr:=nil
        -- normální operátor => zrušit operátor a nahradit výsledkem
        else pexpnode(expr):=expr^.sub
        end if;

    -- optimalizace úspěšně dokončena
    else expr^.zprac:=ep_opt;
    end if;
  end a_opt_finalize_sequence;



----------------------------------------------------------------------------------------------------
procedure a_opt_reoptimize (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpnode;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Reoptimalizace výrazu.
----------------------------------------------------------------------------------------------------
begin
  expr^.zprac:=pred ep_opt;
  a_opt(curr,expr,info);
  end a_opt_reoptimize;



-------- %%TECH Přerovnávání binárních operátorů na n-ární -----------------------------------------
--
-- Optimalizace přerovnává binární operátory na n-ární. Přerovnávání se řídí
-- vlastnostmi operátorů definovanými v EXPOPERINFO. Aby mohl být uzel
-- přerovnán, musí splňovat předpoklady dané použitou přerovnávací procedurou.
--
-- Příklady:
--
--   Zdroják                 Interní tvar
--   -------------------     ------------
--   a and b and c           --> AND(a,b,c)
--   (a and b) and c         --> AND(AND(a,b),c)
--   a and (b and c)         --> AND(a,AND(b,c))
--   (a and (b and c)) and d --> AND(AND(a,AND(b,c)),d)
--   ((a and b) and c) and d --> AND(AND(AND(a,b),c),d)
--
-- %%X Otázka k diskusi: Explicitní uzávorkování zakazuje přerovnání
-- podvýrazu i pro asociativní operátory.
--
----------------------------------------------------------------------------------------------------

type
  treorderproc     = procedure (
      node         : in pexpnode;
      param        : in unchecked)
                   return t_logical;
  preorderproc     = ^treorderproc;

----------------------------------------------------------------------------------------------------
procedure a_opt_reorder_type : treorderproc =
-- Porovnávací funkce pro A_OPT_REORDER.
----------------------------------------------------------------------------------------------------
begin
  result:=t_equal_view(node^.t,typeview(param));
  end a_opt_reorder_type;



----------------------------------------------------------------------------------------------------
procedure a_opt_reorder_sts : treorderproc =
-- Porovnávací funkce pro A_OPT_REORDER.
----------------------------------------------------------------------------------------------------
begin
  result:=t_is_sts(node^.t,tdatatypeset(param));
  end a_opt_reorder_sts;



----------------------------------------------------------------------------------------------------
procedure a_opt_reorder (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    cmp            : in preorderproc;            -- porovnávací funkce
    param          : in unchecked;               -- parametr
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Přerovná výraz ve tvaru OP(OP(OP(a,b),c),d) na OP(a,b,c,d).
-- Přerovnávané výrazy musí reprezentovat stejný operátor a vyhovovat
-- porovnávací funkci CMP.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure reorder (
        node     : in pexpnode;                  -- přerovnávaný uzel
        left     : in t_logical;                 -- T-levý podstrom
        f        : out pexpnode;                 -- výsledný seznam operandů - první
        l        : out pexpnode) =               -- výsledný seznam operandů - poslední
    -- Přerovná jeden uzel. Výsledný seznam operandů uloží do F, L.
    ------------------------------------------------------------------------------------------------
    var
      b            : pexpnode;
      c            : pexpnode;
      el           : pexpnode;
      er           : pexpnode;

    begin
      -- je to přerovnatelný uzel ?
      if not (
      -- je to ten samý operátor
      node^.ntype=nt_operator and then pexpoper(node)^.oper=expr^.oper
      -- a pořád je stejného typu
      and then cmp^(node,param){(node^.t.typ=expr^.t.typ)}
      -- a je to levý podstrom nebo je asociativní nebo není uzávorkovaný
      and then (left or expoperinfo[expr^.oper].asoc=eoa_full or nf_parenthesized not in node^.nflags)
      {and nf_parenthesized not in node^.nflags}
      ) then
        f:=node;
        l:=node;
        return;
        end if;

      if pexpoper(node)^.arity=eoa_n

        -- již je to n-ární operátor
        then
          f:=node^.sub;
          l:=f;
          while l^.next<>nil loop l:=l^.next; end loop;

        -- přerovnat
        else
          pexpoper(node)^.split(el,er);
          reorder(el,true,f,b);
          reorder(er,false,c,l);
          b^.next:=c;
          end if;
      end reorder;

var
  f                : pexpnode;
  l                : pexpnode;
  b                : pexpnode;
  c                : pexpnode;
  el               : pexpnode;
  er               : pexpnode;

begin
  -- již přerovnané operandy přeskočit
  if expr^.arity=eoa_n then return; end if;

  -- přerovnat
  expr^.split(el,er);
  reorder(el,true,f,b);
  reorder(er,false,c,l);
  expr^.sub:=f;
  b^.next:=c;

  -- označit operand jako n-ární
  expr^.arity:=eoa_n;
  end a_opt_reorder;



----------------------------------------------------------------------------------------------------
procedure a_opt_reorder_imm (
    expr           : in out pexpoper) =          -- výraz
-- Přerovná konstantní operandy na konec řetězce.
----------------------------------------------------------------------------------------------------
var
  mf               : pexpnode;                   -- první konstantní uzel
  ml               : pexpnode;                   -- poslední konstantní uzel
  vf               : pexpnode;                   -- první proměnný uzel
  vl               : pexpnode;                   -- poslední proměnný uzel
  x                : pexpnode;
  y                : pexpnode;

begin
  mf:=nil; ml:=nil;
  vf:=nil; vl:=nil;
  x:=expr^.sub;

  -- přeskočit počáteční konstantu
  if expoperinfo[expr^.oper].com=eoc_pfull and x<>nil and x^.ntype=nt_imm then
    vf:=x;
    vl:=x;
    x:=x^.next;
    vl^.next:=nil;
    end if;

  -- přerovnat
  while x<>nil loop
    -- vyřadit ze seznamu
    y:=x^.next;
    x^.next:=nil;

    -- zařadit
    if x^.ntype=nt_imm
      -- do seznamu konstant
      then
        if ml<>nil
          then ml^.next:=x
          else mf:=x;
          end if;
        ml:=x;

      -- do seznamu proměnných
      else
        if vl<>nil
          then vl^.next:=x
          else vf:=x;
          end if;
        vl:=x;
        end if;

    -- další operand
    x:=y;
    end loop;

  -- sestavit
  expr^.sub:=vf;
  if mf<>nil then
    if expoperinfo[expr^.oper].com=eoc_pfull and (vf<>nil and then vf^.ntype=nt_imm)

      -- konstanty zařadit za úvodní konstantu
      then
        ml^.next:=vf^.next;
        vf^.next:=mf;

      -- konstanty zařadit na konec
      else
        if vl<>nil
          then vl^.next:=mf
          else expr^.sub:=mf;
          end if;
        end if;
    end if;
  end a_opt_reorder_imm;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_iaritm : toperopt =
-- Celočíselné aritmetické operace.
----------------------------------------------------------------------------------------------------

----- %%TECH Postup při optimalizaci n-árních operátorů --------------------------------------------
-- Jako první krok se pro komutativní a asociativní operátory přerovnají
-- konstantní operandy na konec výrazu.
--   Optimalizátor se dále snaží eliminovat sekvence konstantních podvýrazů
-- a dvojice s jedním podvýrazem konstantním a druhým proměnným. Optimalizace
-- využívá vlastností operátorů:
--
-- Asociativita:
--   -- neasociativní: Pro první dvojici operandů "A op B op ..." se provádí
--                     úplná optimalizace, pro další operandy jen eliminace
--                     operací triviálních vzhledem k výrazu vpravo.
--   -- asociativní:   Pro každou dvojici sousedních operandů (pro
--                     jednoduchost se nebere ohled na komutativitu
--                     a nezkouší se všech n! permutací) se provádí úplná
--                     optimalizace.
--   -- p-asociativní: Podobně jako v předchozím případě se provádí
--                     optimalizace po dvojicích s vytýkáním operátoru před
--                     závorku.
--
-- Komutativita:
--   -- nekomutativní: Nevyužívá se.
--   -- komutativní:   Využívá se pouze pro sousední operady.
--   -- p-komutativní:
----------------------------------------------------------------------------------------------------

label
  k0;
  k1;

    ------------------------------------------------------------------------------------------------
    procedure opt (
        el         : in pexpnode;                -- levý podvýraz
        er         : in pexpnode;                -- pravý podvýraz
        A          : in out tuniint;             -- hodnota konstantního operandu
        left       : in t_logical;               -- T- 0 + X, F- X + 0
        first      : in t_logical;               -- T-jsou to první dva operandy v řadě
        newexpr    : out pexpnode;               -- nový výraz
        all        : out t_logical) =            -- T-nový výraz nahrazuje vše
    -- jednostranné optimalizace
    ------------------------------------------------------------------------------------------------
    var
      x            : pexpnode;
      ui           : tuniint;
      i            : t_unsigned32;

    begin
      all:=false;

      case expr^.oper
        when op_add  do
            -- X + 0 --> X
            if a=ui_0 then
              newexpr:=el;
            -- X + 1 --> succ X
            elsif a=ui_1 then
              x_addunary(pexpunary(newexpr),expr,un_succ,first,el,info);
              a_opt_reoptimize(curr,newexpr,info);
            -- X + (-1) --> pred X
            elsif a=ui_minus_1 then
              x_addunary(pexpunary(newexpr),expr,un_pred,first,el,info);
              a_opt_reoptimize(curr,newexpr,info);
              end if;

        when op_sub  do
            if left
              -- const - X
              then
                -- 0 - X -- > -X
                if a=ui_0 then
                  x_addunary(pexpunary(newexpr),expr,un_minus,false,er,info);
                  a_opt_reoptimize(curr,newexpr,info);
                  end if;
              -- X - const
              else
                -- X - 0 --> X
                if a=ui_0 then
                  newexpr:=el;
                -- X - 1 --> pred X
                elsif a=ui_1 then
                  if first then
                    x_addunary(pexpunary(newexpr),expr,un_pred,first,el,info);
                    a_opt_reoptimize(curr,newexpr,info);
                    end if;
                -- X - (-1) --> succ X
                elsif a=ui_minus_1 then
                  if first then
                    x_addunary(pexpunary(newexpr),expr,un_succ,first,el,info);
                    a_opt_reoptimize(curr,newexpr,info);
                    end if;
                  end if;
                end if;

        when op_mul  do
            -- X * 0 --> 0
            if a=ui_0 then
              newexpr:=er;
              all:=true;

              -- výsledek je přímou hodnotou v důsledku optimalizace
              newexpr^.nflags-nodeflagset:[nf_const];
            -- X * 1 --> X
            elsif a=ui_1 then
              newexpr:=el;
            -- X * (-1) --> -X
            elsif a=ui_minus_1 then
              x_addunary(pexpunary(newexpr),expr,un_minus,first,el,info);
              a_opt_reoptimize(curr,newexpr,info);
            -- X * 2^n -- > X shl n
            elsif uniint_is_power2(a){uicmp2n(a,i)} then
              -- %%HYNEK - nemelo by byt na generatoru, aby si shl pripadne upravil na mul?
              --  ma X modularni aritmetiku?
              if el^.t.getctype^.intaritm=tia_modular then
                -- ano - shl misto mul
                ui:=unsigned_to_uniint(uniint_get_power2(a)); {uiload(ui,i);}
                x_addop(curr,pexpoper(newexpr),expr,el,op_shl,first,ui,info);
                a_opt_reoptimize(curr,newexpr,info);
                end if;

              --x_changeop(curr,expr,pexpimm(er),op_shl,ui,info);
              end if;

        when op_idiv do
            if left
              -- const - X
              then
                -- 0 div X --> 0
                if a=ui_0 then
                  newexpr:=el;
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
              -- X - const
              else
                -- X div 1 --> X
                if a=ui_1 then
                  newexpr:=el;
                -- X div (-1) --> -X
                elsif a=ui_minus_1 then
                  x_addunary(pexpunary(newexpr),expr,un_minus,first,el,info);
                  a_opt_reoptimize(curr,newexpr,info);
                -- X div 2^n -- > X shr n
                elsif uniint_is_power2(a){uicmp2n(a,i)} then
                  ui:=unsigned_to_uniint(uniint_get_power2(a)); {uiload(i);}
                  x_addop(curr,pexpoper(newexpr),expr,el,op_shr,first,ui,info);
                  a_opt_reoptimize(curr,newexpr,info);
                  --x_changeop(curr,expr,pexpimm(er),op_shr,ui,info);
                  end if;
                end if;

        when op_imod do
            if left
              -- const - X
              then
                -- 0 mod X --> 0
                if a=ui_0 then
                  newexpr:=el;
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
              -- X - const
              else
                -- X mod 1, X mod (-1) --> 0
                if a=ui_1 or a=ui_minus_1 then
                  x_addui(pexpimm(newexpr),expr,ui_0,info);
                  all:=true;
                -- X mod 2^n -- > X and (2^n - 1)
                elsif uniint_is_power2(a){uicmp2n(a,i)} then
                  ui:=a-ui_1; {uiloadp2(ui,i); uisub(ui,ui_1);}
                  x_addop(curr,pexpoper(newexpr),expr,el,op_bitand,first,ui,info);
                  a_opt_reoptimize(curr,newexpr,info);
                  --x_changeop(curr,expr,pexpimm(er),op_bitand,ui,info);
                  end if;
                end if;

        when op_shl  do
            if left
              -- const - X
              then
                -- 0 shl X --> 0
                if a=ui_0 then
                  newexpr:=el;
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
              -- X - const
              else
                -- X shl 0 --> X
                if a=ui_0 then
                  newexpr:=el;
                -- X shl B, B>=X:bits --> 0
                elsif uniint_to_unidata_bitsize(a)>=expr^.t.getbits then
                  x_addui(pexpimm(newexpr),expr,ui_0,info);
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
                end if;

        when op_shr  do
            if left
              -- const - X
              then
                -- 0 shr X --> 0
                if a=ui_0 then
                  newexpr:=el;
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
              -- X - const
              else
                -- X shr 0 --> X
                if a=ui_0 then
                  newexpr:=el;
                -- X shr B, B>=X:bits --> 0/2$11...11
                elsif uniint_to_unidata_bitsize(a)>=expr^.t.getbits then
                  if expr^.t.stype=dt_signed
                    -- 2$11..11
                    then
                      i:=unidata_bitsize_to_unsigned(expr^.t.getbits);
                      ui:=unsigned_to_uniint_power2(i)-ui_1;
                      x_addui(pexpimm(newexpr),expr,ui,info);
                    -- 0
                    else x_addui(pexpimm(newexpr),expr,ui_0,info);
                    end if;
                  all:=true;

                  -- výsledek je přímou hodnotou v důsledku optimalizace
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;
                end if;


        -- %%X pro AND/OR/XOR jsou optimalizace poněkud problematické
        -- vzhledem k možným kombinacím SIGNED/UNSIGNED
        when op_bitand  do
        {
            -- stačí zkoumat X:bits dolních bitů konstanty, ostatní nemají
            -- na výsledek vliv (AND je vynuluje)
            udtouint(pspecordinal(expr^.t.typ^.s)^.bits,i);
            -- X and $FF --> X
            if uimcpFF(b,i) then
              newexpr:=el;
            -- X and 0 --> 0
            elsif uicmp00(b,i) then
              -- pravý operand nemusí být nutně 0
              -- (X and $100, kde X je typu BYTE)
              x_addui(pexpimm(newexpr),oldexpr,ui_0,info);
              end if;
        }

        when op_bitor do
        {
            udtouint(pspecordinal(expr^.t.typ^.s)^.bits,i);
            -- X or $FF --> $FF
            if uimcpFF(b,i) then
              newexpr:=er;
            -- X or 0 --> X
            elsif uicmpz(b) then
              newexpr:=el;
              end if;
        }

        when op_bitxor  do
        {
            -- X xor $FF --> not X
            -- X xor 0 --> X
            if uicmpz(b) then
              newexpr:=el;
              end if;
        }

        when others do verify({VERIFY=}000039,true);
        end case;
      end opt;

var
  ep               : pexpnode;                   -- předchozí podvýraz
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  en               : pexpnode;                   -- následující podvýraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů
  first            : t_logical;                  -- T-EL je skutečně první (levý) operand
  node             : pexpnode;                   -- nový uzel
  all              : t_logical;                  -- T-nahradit celý výraz novým uzlem
  left             : t_logical;                  -- T-tvar 0 + X, F-tvar X + 0
  x                : pexpnode;

begin
  -- přerovnat na n-ární vyjádření
  a_opt_reorder(curr,expr,^a_opt_reorder_type,expr^.t{.typ},info);

  -- optimalizovat podvýrazy
  a_opt_sequence(curr,expr,all,info);

  -- povedla se optimalizace všech operandů ?
  if not all then return; end if;

  -- přerovnat konstantní operandy (p-)komutativních
  -- a (p-)asociativních operandů
  -- POZN: proč mi nestačí (p-)komutativita?
  if (expoperinfo[expr^.oper].com in expopercomset:[eoc_full,eoc_pfull])
  and (expoperinfo[expr^.oper].asoc in expoperasocset:[eoa_full,eoa_pfull]) then
    a_opt_reorder_imm(expr);
    end if;

  -- vyhodnotit konstantní operandy
  -- %%X Kostra algoritmu je stejná jako pro množinové operátory, sloučit do #template
  ep:=nil;
  el:=expr^.sub;
  first:=true;
  while el<>nil loop
    -- poznamenat si následující podvýraz
    er:=el^.next;

    if el^.ntype=nt_imm then
      -- načíst hodnotu levého podvýrazu
      load_uniint(pexpimm(el)^.imm,a);

      --- vyhodnotit asociativní a p-asociativní operátory ---
      if expoperinfo[expr^.oper].asoc in expoperasocset:[eoa_full,eoa_pfull]
      --- a první dvojici neasociativních operátorů ---
      or (first and expoperinfo[expr^.oper].asoc=eoa_none) then
        declare var
          all_const: t_logical;                  -- příznak konstantnosti, ne z důvodu optimalizace,
                                                 -- všech konstantních operandů v sekvenci
        begin
          -- T-levý podvýraz je konstantní, ne z důvodu optimalizace
          all_const:=nf_const in el^.nflags;

          -- zpracovat všechny pravé konstantní operandy
          while er<>nil and then er^.ntype=nt_imm loop
            -- T-doposud všechny podvýrazy konstantní, ne z důvodu optimalizace
            all_const and nf_const in er^.nflags;

            -- načíst hodnotu pravého podvýrazu
            load_uniint(pexpimm(er)^.imm,b);

            -- vypočítat
            case expr^.oper
              -- sčítání
              when op_add  do a+b;

              -- odčítání
              when op_sub  do
                  if first
                    -- A - B - ... --> (A - B) - ...
                    then a-b
                    -- ... - A - B - ... --> ... - (A + B) - ...
                    else a+b;
                    end if;

              -- násobení
              when op_mul  do a*b;

              -- dělení
              when op_idiv do
                  -- nesmí se dělit nulou => ukončit opt. fázi, ve finalizaci bude hlášena chyba
                  if b=ui_0 then
                    goto k0;
                    end if;
                  if first
                    -- A div B div ... --> (A div B) div ...
                    then a div b
                    -- ... div A div B - ... --> ... div (A * B) div ...
                    else a*b;
                    end if;

              -- zbytek po dělení
              when op_imod do
                  -- nesmí se dělit nulou => ukončit opt. fázi, ve finalizaci bude hlášena chyba
                  if b=ui_0 then
                    goto k0;
                    end if;
                  verify({VERIFY=}000132,not first);
                  {%%X Doplnit: X mod C1 mod C2, C1<C2 --> X mod C1 }
                  a mod b;

              -- shift doleva
              when op_shl  do
                  -- nesmí se shiftovat o zápornou hodnotu => ukončit opt. fázi,
                  -- ve finalizaci bude hlášena chyba
                  if b<ui_0 then
                    goto k0;
                    end if;
                  if first
                    -- A shl B shl ... --> (A shl B) shl ...
                    then
                      -- příliš velký shift
                      if b>ui_precision then
                        {%%X hlásit varování }
                        end if;
                      a shl b;
                    -- ... shl A shl B shl ... --> ... shl (A + B) shl ...
                    else a+b;
                    end if;

              -- shift doprava
              when op_shr  do
                  -- nesmí se shiftovat o zápornou hodnotu => ukončit opt. fázi,
                  -- ve finalizaci bude hlášena chyba
                  if b<ui_0 then
                    goto k0;
                    end if;
                  if first
                    -- A shr B shr ... --> (A shr B) shr ...
                    then
                      -- příliš velký shift
                      if b>ui_precision then
                        {%%X hlásit varování }
                        end if;
                      a shr b;
                    -- ... shr A shr B shr ... --> ... shr (A + B) shr ...
                    else a+b;
                    end if;

              -- bitový and
              when op_bitand do a and b;

              -- bitový or
              when op_bitor  do a or b;

              -- bitový xor
              when op_bitxor do a xor b;

              when others    do verify({VERIFY=}000038,true);
              end case;

            -- další uzel
            er:=er^.next;
            end loop;

          -- vytvořit nový uzel
          {%%X Tímto příkazem se nastaví pozice NODE na celý EXPR. }
          x_addui(pexpimm(node),expr,a,info,all_const);
          end declare;

        -- zařadit
        if ep<>nil
          then ep^.next:=node
          else expr^.sub:=node;
          end if;
        node^.next:=er;
        el:=node;
        end if;
      end if;

    -- další operand  
    ep:=el;
    el:=er{el^.next};
    first:=false;
    end loop;

  -- jednostranné optimalizace
  ep:=nil;
  el:=expr^.sub;
  first:=true;
  while el<>nil loop
    -- poznamenat si následující podvýrazy
    er:=el^.next;
    if er<>nil then
      en:=er^.next;
      end if;

    node:=nil; 
    all:=false;

    -- levý operand je konstantní
    if el^.ntype=nt_imm then
      -- načíst hodnotu levého podvýrazu
      load_uniint(pexpimm(el)^.imm,a);

      if er<>nil then
        -- pro komutativní operátory přehodit operandy
        if expoperinfo[expr^.oper].com=eoc_full
          then opt(er,el,a,false,true,node,all);
          else opt(el,er,a,true,true,node,all);
          end if;
        end if;

    -- pravý operand je konstantní
    elsif er<>nil and then er^.ntype=nt_imm then
      -- načíst hodnotu pravého podvýrazu
      load_uniint(pexpimm(er)^.imm,a);

      -- optimalizace
      opt(el,er,a,false,first,node,all);
      end if;

    -- konsolidace operandů
    if node<>nil
      -- nahradit operandy novým uzlem
      then
        if all
          -- nahradit celý výraz
          then
            pexpnode(expr):=node;
            node^.next:=nil;
            goto k1;

          -- nahradit pouze optimalizované operandy
          else
            -- [el] byl nejlevější operand
          if first
            then expr^.sub:=node;
            else ep^.next:=node;
            end if;
          node^.next:=en;
          end if;

        -- posun o 1 operand vpravo: [ep] stávající, [el] na [node]
        el:=node;

      -- nic se nezměnilo
      else
        -- posun o 1 operand vpravo: [ep] na [el], [el] na [er]
        ep:=el;
        el:=er;
        first:=false;
        end if;
    end loop;
k0:
  -- dokončit optimalizaci n-árního operátoru
  a_opt_finalize_sequence(expr);

k1:
  end a_opt_oper_iaritm;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_ordinal_rel : toperopt =
-- Ordinální relační operace.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů
  vysl             : t_logical;                  -- výsledek porovnání
  ui               : tuniint;

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  -- načíst hodnotu levého podvýrazu
  if el^.ntype=nt_imm then
    load_uniint(pexpimm(el)^.imm,a);
    end if;

  -- načíst hodnotu pravého podvýrazu
  if er^.ntype=nt_imm then
    load_uniint(pexpimm(er)^.imm,b);
    end if;

  ----- oba operandy konstantní --------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    -- vypočítat
    imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,nil,nil);

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    {%%X dodělat }


  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_ordinal_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_logical_xor : toperopt =
-- Logická operace XOR.
----------------------------------------------------------------------------------------------------
var
  pexp             : pexpnode;                   -- předchozí podvýraz
  cexp             : pexpnode;                   -- aktuální podvýraz
  nexp             : pexpnode;                   -- následující podvýraz
  uloper           : tunilogical;                -- hodnota operandu
  ulresult         : tunilogical;                -- hodnota výsledku
  found            : t_logical;                  -- T-již byl nalezen nějaký konstantní operand
  all              : t_logical;                  -- T-povedla se optimalizace všech operandů
  all_const        : t_logical := true;          -- příznak konstantnosti všech operandů v sekvenci,
                                                 -- ne v důsledku optimalizace

begin
  -- přerovnat operandy
  a_opt_reorder(curr,expr,^a_opt_reorder_sts,__dts_u_logical,info);

  -- optimalizovat podvýrazy
  a_opt_sequence(curr,expr,all,info);

  -- povedla se optimalizace všech operandů ?
  if not all then return; end if;

  -- zjednodušit ...
  cexp:=expr^.sub;
  pexp:=nil;
  found:=false;
  while cexp<>nil loop
    -- poznamenat si následující operand
    nexp:=cexp^.next;

    -- konstanta
    if cexp^.ntype=nt_imm then
      -- T-doposud všechny operandy konstantní, ne v důsledku optimalizace
      all_const and nf_const in cexp^.nflags;

      -- operand vyřadit
      if pexp<>nil
        then pexp^.next:=nexp
        else expr^.sub:=nexp;
        end if;

      -- hodnota operandu
      load_unilogical(pexpimm(cexp)^.imm,uloper);

      -- započítat do výsledku
      if found
        -- nějaká další hodnota => přixorovat
        then ulresult xor uloper
        -- první nalezená konstantní hodnota => použít jako počáteční hodnotu výsledku
        else
          ulresult:=uloper;
          found:=true;
          end if;
      end if;

    -- další operand
    cexp:=nexp;
    end loop;

  -- ve výrazu nezbyl žádný operand, nahradit konstantou ULRESULT
  if expr^.sub=nil then
    -- vytvořit uzel
    x_addul(pexpimm(cexp),expr,ulresult,info,all_const);

    -- předat ven
    expr:unchecked:=cexp;

  -- ve výrazu něco zbylo, přixorovat konstantní mezivýsledek (máme-li nějaký)
  elsif found then
    x_addul(pexpimm(cexp),expr,ulresult,info,all_const);
    cexp^.next:=expr^.sub;
    expr^.sub:=cexp;
    end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;
  end a_opt_oper_logical_xor;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_logical : toperopt =
-- Logické operace AND, OR, AND THEN, OR ELSE.
----------------------------------------------------------------------------------------------------

----- %%LANG Logická konjunkce a disjunkce ---------------------------------------------------------
-- Jazyk definuje dvě formy logické konjunkce a disjunkce:
--   -- standardní (operátory AND, OR): Program vyhodnocuje operandy
--         zleva doprava (resp. v pořadí nemajícím vliv na výsledek), přičemž
--         není definováno kolik operandů se s ohledem na aktuální
--         mezivýsledek vyhodnotí - program může vyhodnotit všechny operandy
--         i když výsledek výrazu je zřejmý již po vyhodnocení prvního
--         z nich; stejně tak se ale může chovat jako by to byla sekvenční
--         forma (v jednom programu se k vyhodnocení různých výrazů mohou
--         uplatnit dokonce obě strategie současně).
--   -- sekvenční (operátory AND THEN, OR ELSE): Program vyhodnocuje oprandy
--         zleva doprava dokud není jistý výsledek výrazu (vyhodnotil všechny
--         operandy nebo je mezivýsledek False pro AND THEN resp. True pro
--         OR ELSE). Operandy, které nemají vliv na výsledek (konstanty),
--         se nevyhodnocují.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure simplify (
        seq        : in t_logical;               -- T-sekvenční forma
        default    : in tunilogical) =           -- default hodnota formy
    -- Optimalizuje n-ární operandy AND, OR, AND THEN, OR ELSE.
    -- Standardní forma (SEQ=False):
    --   Z výrazu vypustí všechny operandy, které nemají vliv na výsledek
    --   (mají hodnotu NOT DEFAULT) a při nalezení operandu s hodnotou
    --   DEFAULT nahradí celý výraz tímto operandem.
    -- Sekvenční forma (SEQ=True):
    --   Z výrazu vypustí všechny operandy, které nemají vliv na výsledek
    --   (mají hodnotu NOT DEFAULT) a při nalezení operandu s hodnotou
    --   DEFAULT vypustí z výrazu všechny ostatní operandy.
    ------------------------------------------------------------------------------------------------
    var
      pexp         : pexpnode;                   -- předchozí podvýraz
      cexp         : pexpnode;                   -- aktuální podvýraz
      nexp         : pexpnode;                   -- následující podvýraz
      ub           : tunilogical;
      ui           : tuniint;
      all_const    : t_logical := true;          -- příznak konstantnosti všech operandů v sekvenci,
                                                 -- ne v důsledku optimalizace

    begin
      cexp:=expr^.sub;
      pexp:=nil;
      while cexp<>nil loop
        -- poznamenat si následující operand
        nexp:=cexp^.next;

        -- konstanta
        if cexp^.ntype=nt_imm
          then
            -- T-operand je konstantní, ne v důsledku optimalizace
            all_const and nf_const in cexp^.nflags;

            -- operand osamostatnit
            cexp^.next:=nil;

            -- hodnota operandu
            load_unilogical(pexpimm(cexp)^.imm,ub);
            if ub=default

              -- UB=DEFAULT, ...
              then
                if seq
                  -- ... následující podvýrazy již nemají vliv na výsledek
                  then -- řetězec operandů je již přerušen
                  -- ... nahradit jím celý výraz
                  else expr^.sub:=cexp;
                  end if;
                break;

              -- UB=NOT DEFAULT, nemá vliv na výsledek => vypustit
              else
                if pexp<>nil
                  then pexp^.next:=nexp
                  else expr^.sub:=nexp;
                  end if;
                end if;

          -- proměnná
          else
            all_const:=false;
            pexp:=cexp;
            end if;

        -- další operand
        cexp:=nexp;
        end loop;

      -- ve výrazu nezbyl žádný operand, nahradit konstantou NOT DEFAULT
      if expr^.sub=nil then
        -- (vůbec nevadí, že se to ukládá jako integer...)
        x_addul(pexpimm(cexp),expr,not default,info,all_const);

        -- předat ven
        expr:unchecked:=cexp;

      -- ve výrazu zbyl jen jeden operand, nahradit jím celý výraz
      elsif expr^.sub^.next=nil then
        -- nahradit
        pexp:=expr;
        pexpnode(expr):=expr^.sub;

        -- typ by měl zůstat alespoň formálně stejný
        {%%X A co když je to proměnný typu logical 8 a já to nahradím za logical 32 ?? }
        expr^.t:=pexp^.t;
        end if;
      end simplify;

var
  all              : t_logical;                  -- T-povedla se optimalizace všech operandů

begin
  -- přerovnat operandy
  a_opt_reorder(curr,expr,^a_opt_reorder_sts,__dts_u_logical,info);

  -- optimalizovat podvýrazy
  a_opt_sequence(curr,expr,all,info);

  -- povedla se optimalizace všech operandů ?
  if not all then return; end if;

  -- zjednodušit ...
  simplify(expr^.oper in expopertypeset:[op_and_then,op_or_else],logical_to_unilogical(expr^.oper in expopertypeset:[op_or,op_or_else]));

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;
  end a_opt_oper_logical;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_assign : toperopt =
-- Optimalizace přiřazení.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
  expr^.join(el,er)
  end a_opt_oper_assign;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_string_rel : toperopt =
-- Relační operace nad řetězci a poli.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  vysl             : t_logical;                  -- výsledek porovnání

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní --------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    declare var
      typ          : typeview;                   -- společný typ operandů

    begin
      -- odvodit společný typ; pouze pro účel porovnání konstant
      x_resolve(el^.t,er^.t,true,typ);

      -- vypočítat
      imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,typ,curr);
      end declare;

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    {%%X dodělat }

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_string_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_string_concat : toperopt =
-- Spojování řetězců a polí.
----------------------------------------------------------------------------------------------------
label
  l1;
var
  cexp             : pexpnode;                   -- aktuálně zpracovávaný operand
  all              : t_logical;                  -- T-optimalizace všech podvýrazů proběhla ok
  all_const        : t_logical := true;          -- T-operandy konstantní, ne v důsledku optimalizace

begin
  -- přerovnat operandy
  a_opt_reorder(curr,expr,^a_opt_reorder_sts,__dts_u_string_dts_u_array,info);

  -- optimalizovat podvýrazy
  a_opt_sequence(curr,expr,all,info);

  -- povedla se optimalizace všech operandů ?
  if not all then return; end if;

  -- spojit konstantní části
  cexp:=expr^.sub;
  while cexp<>nil loop
    -- levý operand je konstantní
    if cexp^.ntype=nt_imm
    -- pravý operand je konstantní
    and then cexp^.next<>nil
    and then cexp^.next^.ntype=nt_imm
      -- oba operandy konstantní => optimalizovat
      then
        -- T-operandy jsou konstantní, ne v důsledku optimalizace
        all_const and nf_const in cexp^.nflags and nf_const in cexp^.next^.nflags;

        -- oba operandy jsou agregáty
        if cexp^.concatkind in nodeconcatkindset:[nck_substring,nck_subarray]
        and cexp^.next^.concatkind in nodeconcatkindset:[nck_substring,nck_subarray]
          -- zřetězit agregáty
          then
            imm_concat_strings_assign(pexpimm(cexp)^.imm,pexpimm(cexp^.next)^.imm);

        -- jeden z operandů je agregát (nebo neurčeno), druhý je komponenta
        elsif cexp^.concatkind=nck_component
        xor cexp^.next^.concatkind=nck_component
          -- zřetězit agregát a komponentu
          then
            {%%TODO(CONCAT) dodělat, po implementaci odstranit odskok a přechod na další operand}
            cexp:=cexp^.next;
            goto l1;

        -- oba operandy jsou komponenty
        elsif cexp^.concatkind=nck_component
        and cexp^.next^.concatkind=nck_component
          -- zřetězit komponenty
          then
            {%%TODO(CONCAT) dodělat, po implementaci odstranit odskok a přechod na další operand}
            cexp:=cexp^.next;
            goto l1;

        -- jinak chyba
        else verify({VERIFY=}000988,true);
            end if;

        -- ošetřit konstantnost v důsledku optimalizace
        if all_const
          then cexp^.nflags+nodeflagset:[nf_const];
          else cexp^.nflags-nodeflagset:[nf_const];
          end if;

        -- zahodit pravý operand; ponechat levý operand jako aktuální
        cexp^.next:=cexp^.next^.next;

      -- jeden z operandů je nekonstantní
      else
        -- další operand
        cexp:=cexp^.next;
        end if;
l1:
    end loop;

  -- optimalizováno
  a_opt_finalize_sequence(expr);
  end a_opt_oper_string_concat;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_pointer_rel : toperopt =
-- Relační operace nad pointery.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů
  vysl             : t_logical;                  -- výsledek porovnání
  ui               : tuniint;

begin
  verify({VERIFY=}000851,expr^.oper not in expopertypeset:[op_eq,op_ne]);

  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní --------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    -- vypočítat
    imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,nil,nil);

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    -- prohodit operandy
    x_swap(el,er);

    {%%X dodělat }

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_pointer_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_tag_rel : toperopt =
-- Relační operace nad tagy.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů
  vysl             : t_logical;                  -- výsledek porovnání
  ui               : tuniint;

begin
  verify({VERIFY=}000852,expr^.oper not in expopertypeset:[op_eq,op_ne]);

  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní ---------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    -- vypočítat
    imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,nil,nil);

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    -- prohodit operandy
    x_swap(el,er);

    {%%X dodělat }
    unimplemented({UNIMP=}000201);

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_tag_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_record_rel : toperopt =
-- Relační operace nad recordy.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů
  vysl             : t_logical;                  -- výsledek porovnání
  ui               : tuniint;

begin
  verify({VERIFY=}000853,expr^.oper not in expopertypeset:[op_eq,op_ne]);

  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní ---------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    declare var
      typ          : typeview;                   -- společný typ operandů

    begin
      -- odvodit společný typ; pouze pro účel porovnání konstant
      x_resolve(el^.t,er^.t,true,typ);

      -- vypočítat
      imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,typ,curr);
      end declare;

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    -- prohodit operandy
    x_swap(el,er);

    {%%X dodělat }
    unimplemented({UNIMP=}000202);

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_record_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_set : toperopt =
-- Množinové operace.
----------------------------------------------------------------------------------------------------
label
  k1;

    ------------------------------------------------------------------------------------------------
    procedure opt (
        el       : in pexpnode;                  -- levý podvýraz
        er       : in pexpnode;                  -- pravý podvýraz
        left     : in t_logical;                 -- T- [] + X, F- X + []
        newexpr  : out pexpnode;                 -- nový výraz
        all      : out t_logical) =              -- T-nový výraz nahrazuje vše
    ------------------------------------------------------------------------------------------------
    var
      x            : pexpnode;

    begin
      all:=false;

      case expr^.oper
        -- sjednocení množin
        when op_union do
            -- S + [] --> S
            if imm_isnil(pexpimm(er)^.imm) then
              newexpr:=el;

            -- S + EXPR:type:full --> S:type:full
            elsif imm_isfullset(pexpimm(er)^.imm,expr^.t.getctype) then
              newexpr:=er;
              all:=true;
              end if;

        -- rozdíl množin
        when op_diff  do
            if left
              -- const - S
              then
                -- [] - S --> []
                if imm_isnil(pexpimm(el)^.imm) then
                  newexpr:=el;
                  all:=true;

                  -- výsledek je konstantní v důsledku optimalizace, shodit příznak [nf_const]
                  newexpr^.nflags-nodeflagset:[nf_const];
                  end if;

              -- S - const
              else
                -- S - [] --> S
                if imm_isnil(pexpimm(er)^.imm) then
                  newexpr:=el;
                -- S - EXPR:type:full --> []
                elsif imm_isfullset(pexpimm(er)^.imm,expr^.t.getctype) then
                  x_add_imm(pexpimm(newexpr),er,info,false);
                  store_set(pexpimm(newexpr)^.imm);
                  all:=true;
                  end if;
                end if;

        -- průnik množin
        when op_isect do
            -- S * [] --> []
            if imm_isnil(pexpimm(er)^.imm) then
              newexpr:=er;
              all:=true;

              -- výsledek je konstantní v důsledku optimalizace, shodit příznak [nf_const]
              newexpr^.nflags-nodeflagset:[nf_const];

            -- S * EXPR:type:full --> S
            elsif imm_isfullset(pexpimm(er)^.imm,expr^.t.getctype) then
              newexpr:=el;
              end if;

        when others do verify({VERIFY=}000453,true);
        end case;
      end opt;

var
  all              : t_logical;                  -- T-nahradit celý výraz novým uzlem
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  ep               : pexpnode;                   -- předchozí podvýraz
  epp              : pexpnode;                   -- předchozí podvýraz
  first            : t_logical;                  -- T-EL je skutečně první (levý) operand
  node             : pexpnode;                   -- nový uzel
  left             : t_logical;                  -- T-tvar 0 + X, F-tvar X + 0

begin
  -- přerovnat operandy
  a_opt_reorder(curr,expr,^a_opt_reorder_sts,__dts_u_set,info);

  -- optimalizovat podvýrazy
  a_opt_sequence(curr,expr,all,info);

  -- povedla se optimalizace všech operandů ?
  if not all then return; end if;

  -- přerovnat konstantní operandy (p-)komutativních
  -- a (p-)asociativních operandů
  if (expoperinfo[expr^.oper].com in expopercomset:[eoc_full,eoc_pfull])
  and (expoperinfo[expr^.oper].asoc in expoperasocset:[eoa_full,eoa_pfull]) then
    a_opt_reorder_imm(expr);
    end if;

  -- vyhodnotit konstantní operandy
  {%%X Kostra algoritmu je stejná jako pro celočíselné operátory, sloučit do #define }
  epp:=nil;
  ep:=nil;
  el:=expr^.sub;
  first:=true;
  while el<>nil loop
    -- poznamenat si následující podvýraz
    er:=el^.next;

    if el^.ntype=nt_imm then
      --- vyhodnotit asociativní a p-asociativní operátory ---
      if (expoperinfo[expr^.oper].asoc in expoperasocset:[eoa_full,eoa_pfull]
      --- a první dvojici neasociativních operátorů ---
      or (first and expoperinfo[expr^.oper].asoc=eoa_none))
      --- a je k dispozici alespoň jeden pravý konstantní operand ---
      and er<>nil and er^.ntype=nt_imm then
        -- vytvořit nový uzel
        x_add_imm(pexpimm(node),expr,info);

        -- zkopírovat do něj přímou hodnotu na levé straně
        store_imm(pexpimm(node)^.imm,pexpimm(el)^.imm);

        declare var
          all_const: t_logical;                  -- příznak konstantnosti sekvence operandů,
                                                 -- ne v důsledku optimalizace
        begin
          -- T-první operand konstantní, ne v důsledku optimalizace
          all_const:=nf_const in el^.nflags;

          -- zpracovat všechny pravé konstantní operandy
          while (er<>nil) and (er^.ntype=nt_imm) loop
            -- T-doposud všechny operandy konstantní, ne v důsledku optimalizace
            all_const and nf_const in er^.nflags;

            -- vypočítat
            case expr^.oper
              -- sjednocení množin
              when op_union do imm_union(curr,pexpimm(node)^.imm,pexpimm(er)^.imm);

              -- rozdíl množin
              when op_diff  do imm_diff(pexpimm(node)^.imm,pexpimm(er)^.imm);

              -- průnik množin
              when op_isect do unimplemented({UNIMP=}000146);

              when others   do verify({VERIFY=}000452,true);
              end case;

            -- další uzel
            er:=er^.next;
            end loop;

          -- příznak konstantnosti nového uzlu podle všech operandů sekvence
          if all_const
            then node^.nflags+nodeflagset:[nf_const];
            else node^.nflags-nodeflagset:[nf_const];
            end if;
          end declare;

        -- vytvořit nový uzel

        {%%X Tímto příkazem se nastaví pozice NODE na celý EXPR. }
        --x_addui(pexpimm(node),expr,a,info);

        -- zařadit
        if ep<>nil
          then ep^.next:=node
          else expr^.sub:=node;
          end if;
        node^.next:=er;
        el:=node;
        end if;

      --- jednostranná optimalizace ---
      node:=nil; all:=false;
      if first
        -- typ [] + S
        then
          if (el<>nil) and (er<>nil) then
            -- pro komutativní operátory přehodit operandy
            if expoperinfo[expr^.oper].com=eoc_full
              then opt(er,el,false,node,all)
              else opt(el,er,true,node,all);
              end if;
            end if;

        -- typ S + []
        else
          if (ep<>nil) and (el<>nil) then opt(ep,el,false,node,all); end if;
          end if;

      -- zařadit nový uzel
      if node<>nil then
        if all
          -- nahradit celý výraz
          then
            -- není to zkrácené přiřazení ?
            if expr^.assign

              -- ano => změnit na normální přiřazení
              then
                -- změnit na přiřazení
                expr^.oper:=op_assign;
                expr^.arity:=eoa_2;

                -- doplnit pravý operand
                expr^.sub^.next:=node;

                -- a konec (provést finalizaci)
                break;

              -- ne => nahradit celý výraz
              else
                -- nahradit
                pexpnode(expr):=node;

                -- a konec (finalizaci neprovádět)
                goto k1;
                end if;

          -- zařadit
          else
            if first then expr^.sub:=node
            elsif epp<>nil then epp^.next:=node
            else expr^.sub:=node;
            end if;
            node^.next:=er;
            end if;
        end if;
      end if;

    -- další operand
    epp:=ep;
    ep:=el;
    el:=er{el^.next};
    first:=false;
    end loop;

  -- optimalizováno
  a_opt_finalize_sequence(expr);

k1:
  end a_opt_oper_set;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_set_rel : toperopt =
-- Množinové relační operace.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  vysl             : t_logical;                  -- výsledek porovnání

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní --------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    -- vypočítat
    imm_cmp(pexpimm(el)^.imm,pexpimm(er)^.imm,expoperinfo[expr^.oper].cmp,vysl,nil,nil);

    -- uložit konstantu
    x_addul(pexpimm(newexpr),expr,logical_to_unilogical(vysl),info,nf_const in el^.nflags and nf_const in er^.nflags);

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    {%%X dodělat }

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_set_rel;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_in_set : toperopt =
-- Množinové operace.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ----- oba operandy konstantní --------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    {%%X dodělat }

  ----- levý operand konstantní --------------------------------------------------------------------
  elsif (el^.ntype=nt_imm) then
    {%%X dodělat }

  ----- pravý operand konstantní -------------------------------------------------------------------
  elsif (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_in_set;



----------------------------------------------------------------------------------------------------
procedure a_opt_oper_compare_partial : toperopt =
-- Porovnání operandů s Partial view na jejich typy.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  ---- oba operandy konstantní ---------------------------------------------------------------------
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    {%%X dodělat }
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el,er)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_oper_compare_partial;



----------------------------------------------------------------------------------------------------
procedure a_opt_operator (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpoper;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace operátoru.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  m                : poperopt;                   -- optimalizační metoda
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  all              : t_logical;

begin
  -- operandy
  expr^.get(el,er);

  -- speciální případ: porovnání typů
  if (el^.nclass=nc_type) and (er^.nclass=nc_type) then
    unimplemented({UNIMP=}000156);

  -- speciální případ: Výraz IN Jméno typu
  elsif (expr^.oper in expopertypeset:[op_in,op_notin]) and (er^.nclass=nc_type) then
    unimplemented({UNIMP=}000157);

  -- speciální případ: porovnání s Partial view na typy operandů
  elsif (expr^.oper in expopertypeset:[op_eq,op_ne]) and (el^.t.tview=tview_partial)
  and (er^.t.tview=tview_partial) then
    a_opt_oper_compare_partial(curr,expr,info);

  -- ostatní případy: podle pohledu na typ výsledky
  else
    case expr^.t.tview
      -- Full view
      when tview_full      do
          -- zvolit optimalizační metodu
          m:=opertab[expr^.oper,x_resolve_opdtype(expr,false){expr^.t.stype}];
          verify({VERIFY=}000131,m=nil);

          -- optimalizovat
          m^(curr,expr,info);

      -- Partial view, Unchecked view
      when tview_partial, tview_unchecked do
          -- optimalizovat operandy
          a_opt_sequence(curr,expr,all,info);
          if not all then return; end if;

          {%%X co se s tím dá jiného dělat ??? }

          -- optimalizace úspěšně dokončena
          expr^.zprac:=ep_opt;

      when others do verify({VERIFY=}000184,true);
      end case;
    end if;
  end a_opt_operator;



----------------------------------------------------------------------------------------------------
procedure a_opt_unary_iaritm : tunaryopt =
-- Celočíselné unární aritmetické operace.
----------------------------------------------------------------------------------------------------
var
  a                : tuniint;                    -- hodnota operadu

begin
  -- předpoklad, uzel se nezmění
  result:=nil;

  ----- operand konstantní -------------------------------------------------------------------------
  if el^.ntype=nt_imm then
    -- načíst hodnotu podvýrazu
    load_uniint(pexpimm(el)^.imm,a);

    -- vypočítat
    case expr^.oper
      when un_plus   do { nic nedělat };
      {%%X a co v případě $80..00 ? }
      when un_minus  do -a;
      {%%X a co v případě $80..00 ? }
      when un_abs    do abs a;
      when un_succ   do succ a;
      when un_pred   do pred a;
      {%%X kolik bitů se má invertovat, když je číslo záporné ? }
      when un_bitnot do not a;
      when others    do verify({VERIFY=}000045,true);
      end case;

    -- uložit hodnotu
    store_ordinal(pexpimm(el)^.imm,a);

    -- typ výsledeku
    el^.t:=expr^.t;

    -- předat výsledek
    result:=el;

  ----- operand nekonstantní -----------------------------------------------------------------------
  else
    case expr^.oper
      when un_plus   do result:=el;
      when un_minus  do { nic nedělat };
      when un_not    do { nic nedělat };
      when un_abs    do { nic nedělat };
      when un_succ   do { nic nedělat };
      when un_pred   do { nic nedělat };
      when un_bitnot do { nic nedělat };
      when others    do verify({VERIFY=}000044,true);
      end case;
    end if;
  end a_opt_unary_iaritm;



----------------------------------------------------------------------------------------------------
procedure a_opt_unary_logical : tunaryopt =
-- Logické unární operace.
----------------------------------------------------------------------------------------------------
label
  k1;                                            -- konec

var
  a                : tuniint;                    -- hodnota operadu

begin
  -- předpoklad, uzel se nezmění
  result:=nil;

  ----- operand konstantní -------------------------------------------------------------------------
  if el^.ntype=nt_imm then
    -- načíst hodnotu podvýrazu
    load_uniint(pexpimm(el)^.imm,a);

    -- vypočítat
    case expr^.oper
      -- negace
      when un_not    do
          if a=ui_0
            then a:=ui_1;
            else a:=ui_0;
            end if;

      -- následník
      when un_succ   do
          -- následníka lze vypočítat jen z False => ukončit optimalizaci,
          -- chyba bude hlášena ve fázi finalizace
          if a<>ui_0 then
            goto k1;
            end if;

          -- provést operaci
          a:=ui_1;

      -- předchůdce
      when un_pred   do
          -- předchůdce lze vypočítat jen z False => ukončit optimalizaci,
          -- chyba bude hlášena ve fázi finalizace
          if a<>ui_1 then
            goto k1;
            end if;

          -- provést operaci
          a:=ui_0;

      when others do verify({VERIFY=}000537,true);
      end case;

    -- uložit hodnotu
    store_ordinal(pexpimm(el)^.imm,a);

    -- typ výsledeku
    el^.t:=expr^.t;

    -- předat výsledek
    result:=el;

  ----- operand nekonstantní -----------------------------------------------------------------------
  else
    case expr^.oper
      when un_not    do { nic nedělat };
      when un_succ   do { nic nedělat };
      when un_pred   do { nic nedělat };
      when others do verify({VERIFY=}000536,true);
      end case;
    end if;
k1:
  end a_opt_unary_logical;



----------------------------------------------------------------------------------------------------
procedure a_opt_unary (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpunary;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace unárního operátoru.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  el               : pexpnode;                   -- podvýraz
  newexpr          : pexpnode;                   -- nový výraz
  m                : punaryopt;                  -- optimalizační metoda

begin
  -- rozdělit podvýrazy
  expr^.split(el);

  -- optimalizace podvýrazu
  a_opt(curr,el,info);

  -- povedla se optimalizace podvýrazu
  if el^.zprac<ep_opt then goto k1; end if;

  -- zvolit optimalizační metodu
  m:=unarytab[expr^.oper,expr^.t.stype];

  -- optimalizovat
  if m<>nil then
    m^(curr,expr,el,newexpr,info);
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy (nezměnil-li se nadřazený uzel)
    then expr^.join(el)
    -- převzít nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_unary;



----------------------------------------------------------------------------------------------------
procedure a_opt_component (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpcomponent;       -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace komponenty.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  change           : t_logical;                  -- T-změnila se reprezentace konstanty
  x                : pexpnode;

begin
  -- optimalizace podvýrazu
  if expr^.sub<>nil then
    -- optimalizace podvýrazu
    a_opt(curr,expr^.sub,info);

    -- povedla se optimalizace podvýrazu ?
    if expr^.sub^.zprac<ep_opt then goto k1; end if;
    end if;

  -- zjistit o symbolu různé zajímavé údaje
  verify({VERIFY=}000068,expr^.s.psym=nil);
  case expr^.s.psym^.etype
    -- proměnná
    when et_var do
        -- selektor konstantní složky
        if (expr^.sub<>nil) and (expr^.sub^.ntype=nt_imm) then
          unimplemented({UNIMP=}000147);
          end if;

    -- konstanta
    when et_const do
        -- odvodit nový uzel
        derivenode(x,expr,info,nt_imm,true);

        -- převzít hodnotu konstanty
        store_imm(pexpimm(x)^.imm,pentity_const(expr^.s.psym)^.init.getimm()^);
        --verifyx({VERIFY=}000532,(pexpimm(x)^.imm.ic=ic_set and pexpimm(x)^.imm.sitems^.lcount>pexpimm(x)^.imm.sitems^.lsize)
        --         or (pexpimm(x)^.imm.ic=ic_array and pexpimm(x)^.imm.aitems^.lcount>pexpimm(x)^.imm.aitems^.lsize)
        --         or (pexpimm(x)^.imm.ic=ic_record and pexpimm(x)^.imm.ritems^.lcount>pexpimm(x)^.imm.ritems^.lsize),pexpimm(x)^.pos);

        -- při typové kontrole mohlo dojít ke změně typu, promítnout
        {%%X Opravdu ? Vždyť typy neměním ! }
        --imm_settype(curr,pexpimm(x)^.imm,pdefconst(expr^.s.psym)^.typ.getctype,x^.t,change);

        -- třída uzlu: hodnota
        x^.nclass:=nc_value;

        -- předat ven;
        pexpnode(expr):=x;


    -- prvek výčtového typu
    when et_enum do
        -- odvodit nový uzel
        derivenode(x,expr,info,nt_imm,true);

        -- hodnota konstanty
        store_ordinal(pexpimm(x)^.imm,pentity_enum(expr^.s.psym)^.ordinal);

        -- při typové kontrole mohlo dojít ke změně typu, promítnout
        {%%X Opravdu ? Vždyť typy neměním ! }
        --imm_settype(pexpimm(x)^.imm,pdefenum(expr^.s.psym)^.typ,x^.t.typ,change);

        -- třída uzlu: hodnota
        x^.nclass:=nc_value;

        pexpnode(expr):=x;

    -- typ/třída
    when et_type, et_class do { nic nedělat };

    -- procedura
    when et_procedure do { nic nedělat };

    -- statická metoda
    when et_static do { nic nedělat };

    -- virtuální metoda
    when et_virtual do { nic nedělat };

    -- task
    when et_task do { nic nedělat };

    -- zpráva
    when et_message do { nic nedělat };

    -- modul
    when et_module do { nic nedělat };

    -- program
    when et_program do { nic nedělat };

    -- parametr procedury
    when et_param do { nic nedělat };

    when others do verify({VERIFY=}000021,true);
    end case;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  end a_opt_component;



----------------------------------------------------------------------------------------------------
procedure a_opt_imm (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpimm;             -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace přímé hodnoty.
----------------------------------------------------------------------------------------------------
label
  k1;

begin
  -- nastavit příznak [nf_const] přímé hodnoty
  expr^.nflags+nodeflagset:[nf_const];

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  end a_opt_imm;



----------------------------------------------------------------------------------------------------
procedure a_opt_list (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace prefixu a seznamu argumentů.
----------------------------------------------------------------------------------------------------
label k1;

var
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny argumenty
  el               : pexpnode;                   -- prefix
  arglist          : pexpitem;                   -- seznam skutečné parametry
  arg              : pexpitem;                   -- skutečný parametr

begin
  -- oddělit prefix a argumenty
  expr^.split(el,arglist);

  ----- %%TECH -------------------------------------------------------------------------------------
  -- Optimalizaci mohu provést nezávisle pro prefix i pro všechny argumenty,
  -- takže se případné nevyhodnocení detekuje až po zpracování všech
  -- podvýrazů.
  -- Srovnej s CX_TYPE.A_TYPE_CALL, CX_FORM.A_FORM_LIST.
  --------------------------------------------------------------------------------------------------

  -- optimalizace jména procedury
  a_opt(curr,el,info);
  vyhodnoceno:=el^.zprac=ep_opt;

  -- optimalizace skutečných parametrů
  arg:=arglist;
  while arg<>nil loop
    -- optimalizovat
    if arg^.zprac=pred ep_opt then
      verify({VERIFY=}001007,arg^.sub=nil);

      -- optimalizovat
      a_opt(curr,arg^.sub,info);

      -- označit za optimalizovaný
      if arg^.sub^.zprac>=ep_opt then
        arg^.zprac:=ep_opt;
        end if;
      end if;

    -- započítat do vyhodnocení všech parametrů
    vyhodnoceno and arg^.zprac>=ep_opt;

    -- kontrola na shodu s implicitní hodnotou parametru
    if arg^.zprac>=ep_opt and then ch_par_is_default in curr.entity^.compv.hints
    -- formální parametr typu in
    and then pentity_param(arg^.getsymbol)^.mode=pm_in
    -- skutečný parametr je konstanta
    and then arg^.sub^.ntype=nt_imm
    -- je definována implicitní hodnota parametru
    and then pentity_param(arg^.getsymbol)^.init.isset then
      declare var
        atyp           : typeview;           -- typ parametru
        dtyp           : typeview;           -- typ implicitní hodnoty parametru
        equal          : t_logical;          -- výsledek porovnání skutečného parametru
                                             -- a implicitní hodnoty formálního parametru
      begin
        -- konstrukce pohledu na typ implicitní hodnoty parametru; pro účely porovnání
        dtyp.init(curr,pentity_param(arg^.getsymbol)^.typ.getctype);

        -- odvodit typ parametru z typu skutečného parametru a typu impl. hodnoty parametru;
        -- pro účely porovnání
        x_resolve(arg^.sub^.t,dtyp,false,atyp);

        -- porovnat skutečný parametr a implicitní hodnotu formálního parametru
        imm_cmp(pexpimm(arg^.sub)^.imm,pentity_param(arg^.getsymbol)^.init.getimm^,cmp_eq,equal,atyp,arg^.sym^.context);

        -- skutečný parametr odpovídá implicitní hodnotě formálního parametru
        if equal then
          -- vypsat hint
          ce^.sethint({arg^.sym^.context}curr,{CCERR=}000541,ch_par_is_default);
          arg^.errpos;
          end if;
        end declare;
      end if;

    -- další parametr
    arg:=pexpitem(arg^.next);
    end loop;

  -- podařilo se optimalizovat jméno procedury a skutečné parametry ?
  if not vyhodnoceno then goto k1; end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit prefix a argumenty
  expr^.join(el,arglist);
  end a_opt_list;



----------------------------------------------------------------------------------------------------
procedure a_opt_call (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace volání procedury.
----------------------------------------------------------------------------------------------------
begin
  -- volání se chová jako prefix se seznamem argumentů
  a_opt_list(curr,expr,info);
  end a_opt_call;



----------------------------------------------------------------------------------------------------
procedure a_opt_range (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexprange;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace rozsahu.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  a                : tuniint;                    -- hodnoty operandů
  b                : tuniint;                    -- hodnoty operandů

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  -- načíst hodnotu levého podvýrazu
  if el^.ntype=nt_imm then
    load_uniint(pexpimm(el)^.imm,a);
    end if;

  -- načíst hodnotu pravého podvýrazu
  if er^.ntype=nt_imm then
    load_uniint(pexpimm(er)^.imm,b);
    end if;

  -- oba operandy konstantní
  if (el^.ntype=nt_imm) and (er^.ntype=nt_imm) then
    -- A > B => Null range
    if a>b then expr^.rkind:=erk_null

    -- A = B =>
    elsif a=b then expr^.rkind:=erk_single

    -- nelze nic říct
    else expr^.rkind:=erk_static;
    end if;

  -- levý operand konstantní
  elsif el^.ntype=nt_imm then
    -- A > ER:LAST => Null range
    if a>er^.t.gethval then expr^.rkind:=erk_null end if;

  -- pravý operand konstantní
  elsif er^.ntype=nt_imm then
    -- B < EL:FIRST => Null range
    if b<el^.t.getlval then expr^.rkind:=erk_null end if;

  -- oba operandy proměnné
  else
    -- EL:FIRST > ER:LAST => Null range
    if el^.t.getlval>er^.t.gethval then expr^.rkind:=erk_null end if;
    end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit podvýrazy
  expr^.join(el,er)
  end a_opt_range;



----------------------------------------------------------------------------------------------------
procedure a_opt_index (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpindex;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace indexu pole.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if (el^.zprac<ep_opt) or (er^.zprac<ep_opt) then goto k1; end if;

  -- finalizovat index
--  a_final();

  -- konstantní index
  if er^.ntype=nt_imm then
    {%%X};
    -- vybrat prvek konstantního pole
    if el^.ntype=nt_imm then
{
    -- vybrat prvek konstruktoru agregátu s konstantními pozicemi parametrů
    elsif ... then

    -- vyházet z konstruktoru agregátu irelevantní prvky
    elsif ... then
      end if;
}
    end if;

  -- rozsah
  elsif er^.ntype=nt_range then
    case pexprange(er)^.rkind
      -- nulový rozsah
      when erk_null     do
          ce^.setwarning(curr,{CCERR=}000482,cw_null_slice);
          er^.errpos;
      end case;

  -- typ
  elsif er^.nclass=nc_type then
    end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit podvýrazy
  expr^.join(el,er)
  end a_opt_index;



----------------------------------------------------------------------------------------------------
procedure a_opt_ref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpref;             -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace reference.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- podvýraz

begin
  -- rozdělit podvýrazy
  expr^.split(el);

  -- optimalizace podvýrazu
  a_opt(curr,el,info);

  -- povedla se optimalizace podvýrazů ?
  if el^.zprac<ep_opt then goto k1; end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit podvýrazy
  expr^.join(el)
  end a_opt_ref;



----------------------------------------------------------------------------------------------------
procedure a_opt_deref (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpderef;           -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace dereference.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- podvýraz

begin
  -- rozdělit podvýrazy
  expr^.split(el);

  -- optimalizace podvýrazu
  a_opt(curr,el,info);

  -- povedla se optimalizace podvýrazů ?
  if el^.zprac<ep_opt then goto k1; end if;

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;

k1:
  -- sloučit podvýrazy
  expr^.join(el)
  end a_opt_deref;



----------------------------------------------------------------------------------------------------
procedure a_opt_attrib (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpattrib;          -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace atributu.
----------------------------------------------------------------------------------------------------
with
  cc_attr;

label k1;

var
  el               : pexpnode;                   -- podvýraz
  arglist          : pexpitem;                   -- argumenty
  newexpr          : pexpnode;                   -- nový výraz
--range            : typeview;                   -- typ rozsahu
  -- %%X Pozor, řetězec by měl být správně neomezený
  s                : t_char32str;
  ui               : tuniint;

begin
  -- rozdělit podvýrazy
  expr^.split(el,arglist);

  -- optimalizace podvýrazu
  a_opt(curr,el,info);

  -- optimalizace argumentů
  while arglist<>nil loop
    unimplemented({UNIMP=}000052);
    end loop;

  -- povedla se optimalizace podvýrazů ?
  if el^.zprac<ep_opt then goto k1; end if;

  if expr^.atf=atf_none

    -- uživatelem definovaný atribut
    then
      unimplemented({UNIMP=}000053);

    -- jazykem definovaný atribut
    else
      -- vyhodnotit statický atribut
      if expr^.aclass=atc_static then
        case expr^.ata
          -- :size
          when ata_type_size do
              x_addui(pexpimm(newexpr),expr,unidata_size_to_uniint(el^.t.getsize),info);

          -- :position
          when ata_var_position  do
              x_addui(pexpimm(newexpr),expr,unidata_addr_to_uniint(pentity_var(pexpcomponent(el)^.s.psym)^.addr),info);

          -- :true
          when ata_logical_true  do x_addul(pexpimm(newexpr),expr,ul_true ,info);

          -- :false
          when ata_logical_false do x_addul(pexpimm(newexpr),expr,ul_false,info);

          -- :length
          when ata_array_length  do x_addui(pexpimm(newexpr),expr,el^.t.getrange(curr).getlength,info);
          when ata_string_length do 
              verify({VERIFY=}000541,el^.ntype<>nt_imm);
              imm_get_length(pexpimm(el)^.imm,ui);
              x_addui(pexpimm(newexpr),expr,ui,info);

          -- :first
          when ata_string_first, ata_array_first do x_addui(pexpimm(newexpr),expr,el^.t.getrange(curr).getlval,info);
          when ata_ord_first     do x_addui(pexpimm(newexpr),expr,el^.t.getlval,info);

          -- :last
          when ata_string_last, ata_array_last do x_addui(pexpimm(newexpr),expr,el^.t.getrange(curr).gethval,info);
          when ata_ord_last      do x_addui(pexpimm(newexpr),expr,el^.t.gethval,info);

          -- :ord
          when ata_ord_ord       do
              load_uniint(pexpimm(el)^.imm,ui);
              x_addui(pexpimm(newexpr),expr,ui,info);

          -- :bits
          when ata_ord_bits      do
              x_addui(pexpimm(newexpr),expr,unidata_bitsize_to_uniint(el^.t.getbits),info);

          -- :type
          when ata_type_type     do { ponechat beze změny };

          -- :base
          when ata_type_base     do { ponechat beze změny };

          -- :tag
          when ata_type_tag      do { ponechat beze změny };
          when ata_message_tag   do { ponechat beze změny };

          -- :range
          when ata_array_range   do { ponechat beze změny };
          when ata_string_range  do { ponechat beze změny };

          -- :ancestor
          when ata_type_ancestor do { ponechat beze změny };
          when ata_module_ancestor do { ponechat beze změny };

          -- :root_ancestor
          when ata_type_root_ancestor do { ponechat beze změny };
          when ata_module_root_ancestor do { ponechat beze změny };

          -- :image
          when ata_imm_ord_image do
              load_image(pexpimm(el)^.imm,el^.t,s);
              x_addsysstr(pexpimm(newexpr),expr,s,info);

          -- :full
          when ata_set_full do
              x_add_imm(pexpimm(newexpr),expr,info);
              store_set(pexpimm(newexpr)^.imm);
              store_set_items_range(pexpimm(newexpr)^.imm,expr^.t.getbase(curr).getlval,expr^.t.getbase(curr).gethval);

          -- :unchecked
       -- when ata_var_unchecked do { ponechat beze změny };

          when others do verify({VERIFY=}000115,true);
          end case;
        end if;
      end if;

  -- optimalizace úspěšně dokončena
  if newexpr=nil
    then expr^.zprac:=ep_opt;
    else newexpr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr=nil
    -- sloučit podvýrazy
    then expr^.join(el,arglist)
    -- nový výraz
    else pexpnode(expr):=newexpr;
    end if;
  end a_opt_attrib;



----------------------------------------------------------------------------------------------------
procedure a_opt_typecast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace přetypování.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  arg              : pexpitem;                   -- argument
  newexpr          : pexpnode;                   -- nový výraz
  change           : t_logical;                  -- T-změnila se interní reprezentace

begin
  -- rozdělit podvýrazy
  expr^.split(el,arg);

  -- optimalizace podvýrazů
  a_opt(curr,el,info);
  a_opt(curr,arg^.sub,info);

  -- povedla se optimalizace podvýrazů ?
  if el^.zprac<ep_opt or arg^.sub^.zprac<ep_opt then goto k1; end if;

  -- skutečný pravý podvýraz
  er:=arg^.sub;

  -- konstantní výraz
  if er^.ntype=nt_imm then
    -- odvodit nový uzel
    derivenode(newexpr,expr,info,nt_imm,nf_const in er^.nflags);

    -- třída uzlu
    newexpr^.nclass:=nc_value;

    -- hodnota
    pexpimm(newexpr)^.imm:=pexpimm(er)^.imm;

    -- konvertovat
    imm_settype(curr,pexpimm(newexpr)^.imm,er^.t,newexpr^.t,change);
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr<>nil
    then newexpr^.zprac:=ep_opt
    else expr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr<>nil
    -- předat nový výraz
    then pexpnode(expr):=newexpr
    -- sloučit podvýrazy
    else expr^.join(el,arg);
    end if;
  end a_opt_typecast;



----------------------------------------------------------------------------------------------------
procedure a_opt_interface_cast (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpinterfacecast;   -- výraz
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace interface castu.
----------------------------------------------------------------------------------------------------
label k1;

var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newexpr          : pexpnode;                   -- nový výraz

begin
  -- rozdělit podvýrazy
  expr^.split(el,er);

  -- optimalizace levého podvýrazu
  a_opt(curr,el,info);

  -- optimalizace pravého podvýrazu
  a_opt(curr,er,info);

  -- povedla se optimalizace podvýrazů ?
  if el^.zprac<ep_opt or er^.zprac<ep_opt then goto k1; end if;

  ----- interface je přímo exposován, můžeme ho nahradit proměnnou ---------------------------------
  if er^.t.getctype^.interfaces^.is_exposed_interface(el^.t.getctype) then
    declare var
      interface    : p_class_interface;          -- interface třídy

    begin
      -- najít interface
      interface:=er^.t.getctype^.interfaces^.find_interface(el^.t.getctype);

      -- odvodit nový uzel
      derivenode(newexpr,expr,info,nt_component);

      -- doplnit údaje
      pexpcomponent(newexpr)^.nclass:=nc_var;
      pexpcomponent(newexpr)^.s.set_entity(interface^.instance.getcentity);

      -- od teď je zajímavý jen pravý podvýraz
      pexpcomponent(newexpr)^.join(er);
      end declare;

  ----- interface je roven některému z předků, můžeme ho nahradit přetypováním ---------------------
  elsif er^.t.getctype^.interfaces^.is_native_interface(el^.t.getctype) then
    -- dát na vědomí uživateli, může to být užitečná diagnostická informace
    ce^.setdiag(curr,{CCERR=}000563,cd_native_interface_cast);
    expr^.errpos;

    {%%X Doplnit konverzi na type cast. }
    unimplemented({UNIMP=}000266);

  ----- interface nebyl přímo nalezen, jedná se dynamický interface cast ---------------------------
  else
    -- dát na vědomí uživateli, může to být užitečná diagnostická informace
    ce^.setdiag(curr,{CCERR=}000561,cd_dynamic_interface_cast);
    expr^.errpos;

    {%%X Musí se implementovat v generátoru kódu. }
    unimplemented({UNIMP=}000267);
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr<>nil
    then newexpr^.zprac:=ep_opt
    else expr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr<>nil
    -- předat nový výraz
    then pexpnode(expr):=newexpr
    -- sloučit podvýrazy
    else expr^.join(el,er);
    end if;
  end a_opt_interface_cast;



----------------------------------------------------------------------------------------------------
procedure a_opt_aggregate (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpaggregate;       -- agregát
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace agregátu.
----------------------------------------------------------------------------------------------------
with
  cx_phase;

label k1;

var
  arglist          : pexpitem;                   -- složky
  vyhodnoceno      : t_logical;                  -- T-vyhodnoceny složky
  xtyp             : typeview;                   -- typ složky
  ctyp             : typeview;                   -- typ výběru

    ------------------------------------------------------------------------------------------------
    procedure finalize_items (
        immcount   : out t_unsigned) =           -- počet konstantních složek
    -- Optimalizace a finalizace všech složek agregátu.
    ------------------------------------------------------------------------------------------------
    var
      xel          : pexpnode;                   -- podvýrazy složky
      xer          : pexpnode;                   -- podvýrazy složky
      cexp         : pexpitem;                   -- aktuální složka

    begin
      cexp:=arglist;
      vyhodnoceno:=true;
      while cexp<>nil loop
        -- rozdělit podvýrazy
        cexp^.split(xel,xer);

        -- optimalizovat výběr
        if cexp^.itype=ei_choice then
          x_phase_next(curr,xer,ctyp,eu_use,ep_final,info);
          vyhodnoceno:=vyhodnoceno and (xer^.zprac>=ep_final);
          end if;

        -- optimalizovat složku
        x_phase_next(curr,xel,xtyp,eu_use,ep_final,info);
        vyhodnoceno:=vyhodnoceno and (xel^.zprac>=ep_final);

        -- sloučit podvýrazy
        cexp^.join(xel,xer);

        -- započítat konstantní složku
        if ((cexp^.itype=ei_expr) and (xel^.ntype=nt_imm))
        or ((cexp^.itype=ei_choice) and (xel^.ntype=nt_imm) and (xer^.ntype=nt_imm)) then
          succ immcount;
          end if;

        -- další složka
        cexp:=pexpitem(cexp^.next);
        end loop;
      end finalize_items;

var
  el               : pexpnode;                   -- prefix
  xel              : pexpnode;                   -- podvýrazy složky
  xer              : pexpnode;                   -- podvýrazy složky
  newexpr          : pexpnode;                   -- nový výraz
  pexp             : pexpitem;                   -- předchozí složka
  cexp             : pexpitem;                   -- aktuální složka
  nexp             : pexpitem;                   -- následující složka
  index            : tuniint;                    -- index poziční složky
  ui1              : tuniint;                    -- hodnota agregátu množiny
  ui2              : tuniint;                    -- hodnota agregátu množiny
  immcount         : t_unsigned;                 -- počet konstantních složek agregátu
  all_const        : t_logical := true;          -- T-žádná z konstantních složek není konstantní
                                                 -- z důvodu optimalizace

begin
  -- rozdělit podvýrazy
  expr^.split(el,arglist);

  -- optimalizovat prefix
  if el<>nil then
    -- optimalizovat
    a_opt(curr,el,info);

    -- podařilo se optimalizovat podvýraz ?
    if not (el^.zprac>=ep_opt) then goto k1; end if;
    end if;

  -- optimalizovat složky a transformovat agregát v závislosti na jeho typu
  case expr^.t.stype
    -- record
    when dt_record do
        -- optimalizovat a finalizovat všechny složky
        cexp:=arglist;
        vyhodnoceno:=true;
        while cexp<>nil loop
          -- rozdělit podvýrazy
          cexp^.split(xel,xer);

          -- typ složky
          if cexp^.sym=nil
            then xtyp:=nulltype
            else xtyp.init(curr,pentity_var(cexp^.sym)^.typ.getctype);
            end if;

          -- optimalizovat složku
          x_phase_next(curr,xel,xtyp,eu_use,ep_final,info);
          vyhodnoceno:=vyhodnoceno and (xel^.zprac>=ep_final);

          -- sloučit podvýrazy
          cexp^.join(xel,xer);

          -- další složka
          cexp:=pexpitem(cexp^.next);
          end loop;
        if not vyhodnoceno then goto k1; end if;

        -- vytvořit statickou šablonu agregátu pole
        store_record(expr^.imm);

        -- zpracovat všechny složky
        pexp:=nil;
        cexp:=arglist;
        while cexp<>nil loop
          -- připravit si další složku
          nexp:=pexpitem(cexp^.next);

          -- podvýrazy
          cexp^.get(xel,xer);

          -- optimalizovat složku
          case cexp^.itype
            -- poziční nebo klíčová
            when ei_expr,ei_ident do
                -- přímá hodnota
                if xel^.ntype=nt_imm then
                  -- T-složka je konstantní, ne v důsledku optimalizace
                  all_const and nf_const in xel^.nflags;

                  -- zahrnout do agregátu
                  store_record_item(curr,expr^.imm,pentity_var(cexp^.sym),pexpimm(xel)^.imm);

                  -- složku vyhodit z agregátu
                  cexp:=nil;
                  end if;

            -- OTHERS
            when ei_others do
                -- přímá hodnota
                if xel^.ntype=nt_imm then
                  -- T-složka je konstantní, ne v důsledku optimalizace
                  all_const and nf_const in xel^.nflags;

                  -- zahrnout do agregátu
                  store_record_others(expr^.imm,pexpimm(xel)^.imm);

                  -- složku vyhodit z agregátu
                  cexp:=nil;
                  end if;

            when others do verify({VERIFY=}000448,true);
            end case;

          -- složka mohla zmizet nebo se jinak změnit => poskládat zpět
          if cexp=nil
            then
              if pexp<>nil
                then pexp^.next:=nexp
                else arglist:=nexp;
                end if;
            else
              cexp^.next:=nexp;
              if pexp<>nil
                then pexp^.next:=cexp
                else arglist:=cexp;
                end if;
              pexp:=cexp;
              end if;

          -- další složka
          cexp:=nexp;
          end loop;

    -- pole, řetězec
    when dt_array,dt_uarray,dt_string,dt_ustring do
        -- vypočítat typ složky
        xtyp:=expr^.t.getbase(curr);

        -- vypočítat typ výběru
        ctyp:=expr^.t.getrange(curr);

        -- optimalizovat a finalizovat všechny složky
        finalize_items(immcount);
        if not vyhodnoceno then goto k1; end if;

        -- vytvořit statickou šablonu agregátu pole
        store_array(expr^.imm,immcount);

        -- naplnit počáteční index poziční složky
        index:=ctyp.getlval;

        -- zpracovat všechny složky
        pexp:=nil;
        cexp:=arglist;
        while cexp<>nil loop
          -- připravit si další složku
          nexp:=pexpitem(cexp^.next);

          -- podvýrazy
          cexp^.get(xel,xer);

          -- optimalizovat složku
          case cexp^.itype
            -- poziční
            when ei_expr   do
                -- přímá hodnota
                if xel^.ntype=nt_imm then
                  -- T-složka je konstantní, ne v důsledku optimalizace
                  all_const and nf_const in xel^.nflags;

                  -- zahrnout do agregátu
                  store_array_item(curr,expr^.imm,index,pexpimm(xel)^.imm);

                  -- složku vyhodit z agregátu
                  cexp:=nil;
                  end if;

                -- inkrementovat index poziční složky
                index+ui_1;

            -- klíčová
            when ei_choice do
                -- výraz je přímá hodnota, ok, co výběr ?
                if xel^.ntype=nt_imm then
                  -- T-výraz je konstantní, ne v důsledku optimalizace
                  all_const and nf_const in xel^.nflags;

                  -- přímá hodnota
                  if xer^.ntype=nt_imm then
                    -- T-pozice je konstantní, ne v důsledku optimalizace
                    all_const and nf_const in xer^.nflags;

                    -- zahrnout do agregátu
                    load_uniint(pexpimm(xer)^.imm,ui1);
                    store_array_item(curr,expr^.imm,ui1,pexpimm(xel)^.imm);

                    -- složku vyhodit z agregátu
                    cexp:=nil;

                  -- rozsah, jaký ?
                  elsif xer^.ntype=nt_range then
                    -- konstantní singulární rozsah
                    if pexprange(xer)^.rkind=erk_single then
                      verify({VERIFY=}000456,(xer^.sub=nil) or (xer^.sub^.ntype<>nt_imm) or (xer^.sub^.next=nil) or (xer^.sub^.next^.ntype<>nt_imm));

                      -- zahrnout do agregátu
                      load_uniint(pexpimm(xer^.sub)^.imm,ui1);
                      store_array_item(curr,expr^.imm,ui1,pexpimm(xel)^.imm);

                      -- složku vyhodit z agregátu
                      cexp:=nil;

                    -- konstantní rozsah
                    elsif pexprange(xer)^.rkind=erk_static then
                      verify({VERIFY=}000457,(xer^.sub=nil) or (xer^.sub^.ntype<>nt_imm) or (xer^.sub^.next=nil) or (xer^.sub^.next^.ntype<>nt_imm));

                      -- zahrnout do agregátu
                      load_uniint(pexpimm(xer^.sub)^.imm,ui1);
                      load_uniint(pexpimm(xer^.sub^.next)^.imm,ui2);
                      store_array_items_range(expr^.imm,ui1,ui2,pexpimm(xel)^.imm);

                      -- složku vyhodit z agregátu
                      cexp:=nil;

                    -- prázdný rozsah
                    elsif pexprange(xer)^.rkind=erk_null then
                      -- nic nedělat, jen vyhodit složku z agregátu
                      cexp:=nil;
                      end if;

                    -- T-rozsah je konstantní, ne v důsledku optimalizace
                    all_const and nf_const in xer^.sub^.nflags and nf_const in xer^.sub^.next^.nflags;
                    end if;
                  end if;
                --unimplemented({UNIMP=}000095);

            -- OTHERS
            when ei_others do
                -- přímá hodnota
                if xel^.ntype=nt_imm then
                  -- T-složka je konstantní, ne v důsledku optimalizace
                  all_const and nf_const in xel^.nflags;

                  -- zahrnout do agregátu
                  store_array_others(expr^.imm,pexpimm(xel)^.imm);

                  -- složku vyhodit z agregátu
                  cexp:=nil;
                  end if;

            when others do verify({VERIFY=}000256,true);
            end case;

          -- složka mohla zmizet nebo se jinak změnit => poskládat zpět
          if cexp=nil
            then
              if pexp<>nil
                then pexp^.next:=nexp
                else arglist:=nexp;
                end if;
            else
              cexp^.next:=nexp;
              if pexp<>nil
                then pexp^.next:=cexp
                else arglist:=cexp;
                end if;
              pexp:=cexp;
              end if;

          -- další složka
          cexp:=nexp;
          end loop;

    -- množina
    when dt_set do
        -- vypočítat typ složky
        xtyp:=expr^.t.getbase(curr);

        -- optimalizovat a finalizovat všechny složky
        finalize_items(immcount);
        if not vyhodnoceno then goto k1; end if;

        -- vytvořit statickou šablonu agregátu množiny
        store_set(expr^.imm);

        -- zpracovat všechny složky
        pexp:=nil;
        cexp:=arglist;
        while cexp<>nil loop
          -- připravit si další složku
          nexp:=pexpitem(cexp^.next);

          -- podvýrazy
          cexp^.get(xel,xer);

          -- optimalizovat složku
          verify({VERIFY=}000435,cexp^.itype<>ei_expr);

          -- přímá hodnota
          if xel^.ntype=nt_imm then
            -- T-složka je konstantní, ne v důsledku optimalizace
            all_const and nf_const in xel^.nflags;

            -- uložit hodnotu
            load_uniint(pexpimm(xel)^.imm,ui1);
            store_set_item(curr,expr^.imm,ui1);

            -- složku vynechat z agregátu
            cexp:=nil;

          -- konstantní rozsah
          elsif (xel^.ntype=nt_range) and (pexprange(xel)^.rkind in erks_const) then
            verify({VERIFY=}000437,(xel^.sub=nil) or (xel^.sub^.next=nil) or (xel^.sub^.ntype<>nt_imm) or (xel^.sub^.next^.ntype<>nt_imm));

            -- T-rozsah je konstantní, ne v důsledku optimalizace
            all_const and nf_const in xel^.sub^.nflags and nf_const in xel^.sub^.next^.nflags;

            -- uložit hodnotu
            load_uniint(pexpimm(xel^.sub)^.imm,ui1);
            load_uniint(pexpimm(xel^.sub^.next)^.imm,ui2);
            store_set_items_range(expr^.imm,ui1,ui2);

            -- složku vynechat z agregátu
            cexp:=nil;

          -- nulový rozsah
          elsif (xel^.ntype=nt_range) and (pexprange(xel)^.rkind=erk_null) then
            -- T-rozsah je konstantní, ne v důsledku optimalizace
            all_const and nf_const in xel^.sub^.nflags and nf_const in xel^.sub^.next^.nflags;

            -- složku prostě vynechat
            cexp:=nil;

          -- typ
          elsif xel^.nclass=nc_type then
            -- uložit hodnotu
            store_set_items_range(expr^.imm,xel^.t.getlval,xel^.t.gethval);

            -- složku vynechat z agregátu
            cexp:=nil;
            end if;

          -- složka mohla zmizet nebo se jinak změnit => poskládat zpět
          if cexp=nil
            then
              if pexp<>nil
                then pexp^.next:=nexp
                else arglist:=nexp;
                end if;
            else
              cexp^.next:=nexp;
              if pexp<>nil
                then pexp^.next:=cexp
                else arglist:=cexp;
                end if;
              pexp:=cexp;
              end if;

          -- další složka
          cexp:=nexp;
          end loop;

        --unimplemented({UNIMP=}000091);

    when others do verify({VERIFY=}000255,true);
    end case;

  -- v agregátu nic nezbylo => je konstantní
  if arglist=nil then
    -- odvodit nový uzel
    derivenode(newexpr,expr,info,nt_imm,all_const);

    -- třída uzlu
    newexpr^.nclass:=nc_value;

    -- hodnota
    pexpimm(newexpr)^.imm:=expr^.imm;
    end if;

  -- optimalizace úspěšně dokončena
  if newexpr<>nil
    then newexpr^.zprac:=ep_opt
    else expr^.zprac:=ep_opt;
    end if;

k1:
  if newexpr<>nil
    -- předat nový výraz
    then pexpnode(expr):=newexpr
    -- sloučit podvýrazy
    else expr^.join(el,arglist);
    end if;
  end a_opt_aggregate;



----------------------------------------------------------------------------------------------------
procedure a_opt_message (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexplist;            -- zpráva
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace odeslání/přijetí zprávy.
----------------------------------------------------------------------------------------------------
begin
  -- odeslání/přijetí zprávy se chová jako prefix se seznamem argumentů
  a_opt_list(curr,expr,info);
  end a_opt_message;



----------------------------------------------------------------------------------------------------
procedure a_opt_this (
    curr           : in tcontext;                -- překládaný prvek
    expr           : in out pexpthis;            -- zpráva
    info           : in expinfo) =               -- informace o průběhu analýzy
-- Optimalizace THIS.
----------------------------------------------------------------------------------------------------
begin
  -- není co optimalizovat

  -- optimalizace úspěšně dokončena
  expr^.zprac:=ep_opt;
  end a_opt_this;



----------------------------------------------------------------------------------------------------
procedure a_opt =
-- Optimalizace výrazu.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000006,expr=nil);

  -- zpracovávat jen výrazy z bezprostředně předchozí fáze
  if expr^.zprac<>pred ep_opt then return end if;

  -- pokud je uzel chybný, nezpracovávat
  if expr^.erroneous then return end if;

  -- optimalizovat výraz
  case expr^.ntype
    -- operátor
    when nt_operator  do a_opt_operator(curr,pexpoper(expr),info);

    -- unární operátor
    when nt_unary     do a_opt_unary(curr,pexpunary(expr),info);

    -- komponenta
    when nt_component do a_opt_component(curr,pexpcomponent(expr),info);

    -- přímá hodnota
    when nt_imm       do a_opt_imm(curr,pexpimm(expr),info);

    -- volání procedury
    when nt_call      do a_opt_call(curr,pexplist(expr),info);

    -- rozsah
    when nt_range     do a_opt_range(curr,pexprange(expr),info);

    -- index pole
    when nt_index     do a_opt_index(curr,pexpindex(expr),info);

    -- reference
    when nt_ref       do a_opt_ref(curr,pexpref(expr),info);

    -- dereference
    when nt_deref     do a_opt_deref(curr,pexpderef(expr),info);

    -- atribut
    when nt_attrib    do a_opt_attrib(curr,pexpattrib(expr),info);

    -- přetypování
    when nt_typecast  do a_opt_typecast(curr,pexplist(expr),info);

    -- interface cast
    when nt_interface_cast do a_opt_interface_cast(curr,pexpinterfacecast(expr),info);

    -- agregát
    when nt_aggregate do a_opt_aggregate(curr,pexpaggregate(expr),info);

    -- odeslání zprávy
    when nt_send      do a_opt_message(curr,pexplist(expr),info);

    -- přijetí zprávy
    when nt_accept    do a_opt_message(curr,pexplist(expr),info);

    -- THIS
    when nt_this      do a_opt_this(curr,pexpthis(expr),info);

    -- jiné symboly tu nemají co dělat
    when others       do verify({VERIFY=}000007,true);
    end case;
  end a_opt;



----------------------------------------------------------------------------------------------------
procedure initopertab =
-- Inicializace řídící tabulky optimalizace binárních operátorů.
----------------------------------------------------------------------------------------------------
begin
  -- celočíselné aritmetické operace
  --oset1s(opertab,op_add,sts_u_integer,^a_opt_oper_iaritm_add);
  osetss(opertab,expopertypeset:[op_add,op_sub,op_mul,op_div,op_idiv,op_imod,op_shl,op_shr,op_bitand,op_bitor,op_bitxor],dts_u_integer,^a_opt_oper_iaritm);

  -- ordinální relační operace
  osetss(opertab,expopertypeset:[op_eq,op_ne,op_lt,op_le,op_gt,op_ge],dts_u_ordinal,^a_opt_oper_ordinal_rel);

  -- logické operace
  osetss(opertab,expopertypeset:[op_and,op_or,op_and_then,op_or_else],dts_u_logical,^a_opt_oper_logical);
  oset1s(opertab,op_xor,dts_u_logical,^a_opt_oper_logical_xor);

  -- přiřazení
  oset1s(opertab,op_assign,dts_all,^a_opt_oper_assign);

  -- řetězcové relační operace
  osetss(opertab,expopertypeset:[op_eq,op_ne,op_lt,op_le,op_gt,op_ge],dts_u_string+dts_u_array,^a_opt_oper_string_rel);

  -- spojování řetězců
  osetss(opertab,expopertypeset:[op_concat],dts_u_string+dts_u_array,^a_opt_oper_string_concat);

  -- porovnání pointerů
  osetss(opertab,expopertypeset:[op_eq,op_ne{,op_lt,op_le,op_gt,op_ge}],dts_pointer,^a_opt_oper_pointer_rel);

  -- porovnání tagů
  osetss(opertab,expopertypeset:[op_eq,op_ne,op_lt,op_le,op_gt,op_ge],dts_tag,^a_opt_oper_tag_rel);

  -- množinové operace
  osetss(opertab,expopertypeset:[op_union,op_diff,op_isect],dts_u_set,^a_opt_oper_set);

  -- množinové relační operace
  osetss(opertab,expopertypeset:[op_eq,op_ne,op_lt,op_le,op_gt,op_ge],dts_u_set,^a_opt_oper_set_rel);

  -- porovnání recordů
  osets1(opertab,expopertypeset:[op_eq,op_ne],dt_record,^a_opt_oper_record_rel);

  -- operátory IN a NOT IN
  osetss(opertab,expopertypeset:[op_in,op_notin],dts_u_set,^a_opt_oper_in_set);
  end initopertab;



----------------------------------------------------------------------------------------------------
procedure initunarytab =
-- Inicializace řídící tabulky optimalizace unárních operátorů.
----------------------------------------------------------------------------------------------------
begin
  -- celočíselné aritmetické operace
  usetss(unarytab,expunarytypeset:[un_plus,un_minus,un_succ,un_pred,un_not,un_bitnot,un_abs],dts_u_integer,^a_opt_unary_iaritm);

  -- výčtové unární operace
  usetss(unarytab,expunarytypeset:[un_succ,un_pred],dts_enum,^a_opt_unary_iaritm);

  -- logické operace
  usetss(unarytab,expunarytypeset:[un_succ,un_pred,un_not],dts_u_logical,^a_opt_unary_logical);
  end initunarytab;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace
----------------------------------------------------------------------------------------------------
begin
  initopertab;
  initunarytab;
  end entry;



end cx_opt;
