----------------------------------------------------------------------------------------------------
module private cb_parse =
-- Překladač Flexu.
-- Syntaktická analýza bloku příkazů.
----------------------------------------------------------------------------------------------------
-- Ondra : 21.09.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_base,
  cc_base.cc_sym,
  cc_base.cc_type,
  cc_lex;

----------------------------------------------------------------------------------------------------
procedure b_sequence (
    curr           : in tcontext;                -- překládaný prvek
    list           : in out bllist;              -- příkaz
    info           : in blinfo);                 -- informace o průběhu analýzy
-- Překlad sekvence příkazů.
----------------------------------------------------------------------------------------------------
procedure b_body_sequence (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in pblblock;                -- blok příkazů
    info           : in blinfo);                 -- informace o průběhu analýzy
-- Překlad sekvence příkazů uvnitř bloku příkazů.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure b_label (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pbllabel;               -- příkaz
    id             : in tentityident;            -- identifikátor návěští
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad návěští.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  srch             : tentitysearch;              -- hledátko
  pos              : lexposblock;                -- pozice

begin
  -- %%TECH Toto je jedno z mála míst, kde se při syntaktické analýze 
  -- manipuluje přímo se symbolem a ne jen s identifikátorem.
  --   Mohu si to dovolit, protože návěští je čistě lokální symbol
  -- a nehrozí, že by bylo generické.
  -- %%LANG Nehledě k tomu, že bez toho bych nerozpoznal o jakou      
  -- syntaktickou konstrukci se jedná

  -- zkusit vyhledat
  srch.find_local(curr,id,tentityvisibleset:[etv_private]);
  if srch.psym=nil then return; end if;
  if srch.psym^.etype<>et_label then return; end if;

  -- teď je to již jistě návěští, musí následovat dvojtečka
  if followlex(curr,lex_col) then
    ce^.seterror({CCERR=}000020,ce_x_col);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nebylo již návěští umístěno
  if pentity_label(srch.psym)^.placed then
    ce^.seterror({CCERR=}000021,ce_duplabel);
    ce^.setparam(entityident_to_string(id));
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- pozice
  getlexpos(pos.b,ll_prev,false);
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici symbolu
  entity_set_position(srch.psym^,etp_def,pos);

  -- označit návěští za umístěné
  pentity_label(srch.psym)^.placed:=true;

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_label);

  -- navzájem provázat entitu a příkaz
  pbllabel(bl)^.plabel:=pentity_label(srch.psym);
  pentity_label(srch.psym)^.bl.setblock(bl);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_label;



----------------------------------------------------------------------------------------------------
procedure b_cmd (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblcmd;                 -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad přiřazovacího příkazu.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_cmd);

  -- příkaz
  x_vyraz(curr,bl^.expr,es_cmd);

  {%%X}

  -- vyhodnotit

  -- provést makra

  -- pozice
  bl^.expr^.getpos(pos);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_cmd;



----------------------------------------------------------------------------------------------------
procedure b_if (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblif;                  -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu IF.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  last             : pblif_cond;                 -- větev IF
  pos              : lexposblock;                -- pozice

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_if);

  -- vznikla nová větev IF
  newnode(pblnode(last),info,bt_if_cond);
  bl^.sub.first:=last;
  bl^.sub.last:=last;

  loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- podmínka
    x_vyraz(curr,last^.cond,es_expr);

    -- THEN
    if followlex(curr,lex_then) then
      ce^.seterror({CCERR=}000022,ce_x_then);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence příkazů
    b_sequence(curr,last^.sub,info);

    -- další symbol
    getlex(curr,lex);

    -- založit novou větev
    if lex in lexsymset:[lex_else,lex_elsif] then
      newnode(pblnode(last),info,bt_if_cond);
      bl^.sub.last^.next:=last;
      bl^.sub.last:=last;
      end if;

    until lex<>lex_elsif;

  -- větev ELSE
  if lex=lex_else
    -- sekvence příkazů
    then b_sequence(curr,last^.sub,info)

    -- cokoliv jiného
    else
      ungetlex
      end if;

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END IF
  if followendkw(curr,lex_if) then
    ce^.seterror({CCERR=}000023,ce_x_end_if);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_if;



----------------------------------------------------------------------------------------------------
procedure b_loop (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblloop;                -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu LOOP ... END LOOP / LOOP .. UNTIL
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_loop);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_sequence(curr,bl^.sub,info);

  -- další symbol
  getlex(curr,lex);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  case lex
    -- END
    when lex_end do
        -- END LOOP
        ungetlex;
        if followendkw(curr,lex_loop) then
          ce^.seterror({CCERR=}000024,ce_x_end_loop);
          ce^.loadpos2;
          {%%RESUME ce^.raiseerror;}
          end if;

    -- UNTIL
    when lex_until do
        -- podmínka
        x_vyraz(curr,bl^.cond,es_expr);

    -- cokoliv jiného je chyba
    when others do
        ce^.seterror({CCERR=}000025,ce_x_end_loop_until);
        ce^.loadpos2;
        {%%RESUME ce^.raiseerror;}
        resumelex(curr,lex,lex_scol,rl_leave,lex_end,rt_leave);
    end case;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_loop;



----------------------------------------------------------------------------------------------------
procedure b_for (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblfor;                 -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu FOR LOOP ... END FOR
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

use
  cd_decl.cd_eval;

var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  pos              : lexposblock;                -- pozice
  for_context      : tcontext;                   -- kontext FOR cyklu
  for_var_context  : tcontext;                   -- kontext řídící proměnné cyklu
  for_var_pos      : lexposblock;                -- pozice řídící proměnné cyklu
  for_type         : pentity_type;               -- typ řídící proměnné cyklu
  e                : tentityeval;

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_for);

  -- vznikl nový deklarativní region
  d_create_region(curr,bl^.for_region,for_context);

  -- začátek deklarace řídící proměnné cyklu
  d_create(for_context,pentity(bl^.for_var),for_var_context,et_var,for_var_pos);

  -- doplnit základní vlastnosti proměnné
  bl^.for_var^.mclass:=mc_auto;
  bl^.for_var^.vmode:=vm_direct;
  bl^.for_var^.vaccess:=va_const;

  -- IN
  if followlex(for_context,lex_in) then
    ce^.seterror({CCERR=}000026,ce_x_in);
    ce^.loadpos;
    end if;

  -- determinace pořadí
  getlex(for_context,lex);
  case lex
    -- REVERSE
    when lex_reverse    do bl^.order:=bfo_reverse;

    -- CONCURRENT
    when lex_concurrent do bl^.order:=bfo_concurrent;

    when others do
        bl^.order:=bfo_normal;
        ungetlex;
    end case;

  -- rozsah
  x_vyraz(for_context,bl^.xrange,es_range);
  x_evaluate(for_context,bl^.xrange,ek_range,nil,eu_read,true,e);
  if not cd_decl.cd_eval.e_is_evaluated(e) then return; end if;

  -- určit typ proměnné
  x_get_type(for_context,bl^.xrange,for_type,{for native use true,}for derive_uni use true);
  bl^.for_var^.typ.settype(for_type);

  -- konec deklarace řídící proměnné cyklu
  d_end(bl^.for_var^,for_var_pos);

  -- zjistit, zda čistě náhodou někdo nepoužil konstrukci ve tvaru for i in 0..<x>-<y> loop
  if bl^.xrange^.ntype=nt_range then
    declare var
      erange       : pexprange;                  -- rozsah
      el           : pexpnode;                   -- levý operand rozsaru
      er           : pexpnode;                   -- pravý operand rozsahu

    begin
      -- zjistit rozsah
      erange:=bl^.xrange;
      erange^.get(el,er);

      -- pokud je pravá část rozsahu ve tvaru <x>-<y> a je levý operand rozsahu ordinální konstanta
      if erange^.rkind=erk_dynamic and then er^.ntype=nt_operator and then pexpoper(er)^.oper=op_sub 
         and then el^.ntype=nt_imm and then pexpimm(el)^.imm.ic=ic_ordinal 
      then
        -- Pokud je dolní hranice rozsahu řídící proměnné rovna dolní hranici rozsahu for cyklu,
        -- nahlásit hint
        if bl^.for_var^.typ.getctype^.lval=pexpimm(el)^.imm.ui then
          ce^.sethint(for_context,{CCERR=}000573,ch_unsafe_range);
          ce^.loadpos;
          end if;
        end if;
      end declare;
    end if;

  -- LOOP
  if followlex(for_context,lex_loop) then
    ce^.seterror({CCERR=}000027,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

{ Ondra 5.12.2002 : Původní verze bez implicitní deklarace proměnné:

  -- jméno proměnné
  x_vyraz(for_context,bl^.xvar,es_name);

  -- další symbol
  getlex(for_context,lex);
  case lex
    -- IN
    when lex_in do
        -- determinace pořadí
        getlex(for_context,lex);
        case lex
          -- REVERSE
          when lex_reverse    do bl^.order:=bfo_reverse;

          -- CONCURRENT
          when lex_concurrent do bl^.order:=bfo_concurrent;

          when others do
              bl^.order:=bfo_normal;
              ungetlex;
          end case;

        -- rozsah
        x_vyraz(for_context,bl^.xrange,es_range);

    -- REVERSE
    when lex_reverse    do bl^.order:=bfo_reverse;

    -- CONCURRENT
    when lex_concurrent do bl^.order:=bfo_concurrent;

    -- LOOP
    when lex_loop do
        bl^.order:=bfo_normal;

        -- cyklus přes rozsah proměnné, nic nedělat
        ungetlex;

    -- cokoliv jiného je chyba
    when others do
        ce^.seterror({CCERR=}000028,ce_x_in);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
    end case;

  -- LOOP
  if followlex(for_context,lex_loop) then
    ce^.seterror({CCERR=}000029,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
}
  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_sequence(for_context,bl^.sub,info);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END LOOP
  if followendkw(for_context,lex_loop) then
    ce^.seterror({CCERR=}000030,ce_x_end_loop);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzli
  bl^.setpos(bp_end,pos);
  end b_for;



----------------------------------------------------------------------------------------------------
procedure b_while (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblwhile;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu WHILE ... END WHILE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_while);

  -- podmínka
  x_vyraz(curr,bl^.cond,es_expr);

  -- LOOP
  if followlex(curr,lex_loop) then
    ce^.seterror({CCERR=}000031,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_sequence(curr,bl^.sub,info);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END LOOP
  if followendkw(curr,lex_loop) then
    ce^.seterror({CCERR=}000032,ce_x_end_loop);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_while;



----------------------------------------------------------------------------------------------------
procedure b_case (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblcase;                -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu CASE ... END CASE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  last             : pblwhen_c;                  -- poslední větev
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_case);

  -- výraz
  x_vyraz(curr,bl^.expr,es_expr);

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- WHEN první větve
  if followlex(curr,lex_when) then
    ce^.seterror({CCERR=}000566,ce_x_when);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- větve CASE
  -- %%X Při přepisování do Flexu sjednotit s B_CATCH, tam už to díky TAG půjde
  bl^.sub.first:=nil;
  bl^.sub.last:=nil;
  last:=nil;
  --while (last=nil or last^.ctype<>bct_others) and checklex(curr,lex_when) loop
  loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikla nová větev
    newnode(pblnode(last),info,bt_when_c);
    if bl^.sub.first=nil
      then bl^.sub.first:=last;
      else bl^.sub.last^.next:=last;
      end if;
    bl^.sub.last:=last;

    -- výběr nebo OTHERS
    if checklex(curr,lex_others)

      -- OTHERS
      then
        last^.ctype:=bct_others;

      -- seznam výběrů
      else
        last^.ctype:=bct_choice;
        x_select(curr,last^.list,es_choice);
        end if;

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000033,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence příkazů
    b_sequence(curr,last^.sub,info);
    until last^.ctype=bct_others or else not checklex(curr,lex_when);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END CASE
  if followendkw(curr,lex_case) then
    ce^.seterror({CCERR=}000034,ce_x_end_case);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_case;



----------------------------------------------------------------------------------------------------
procedure b_accept (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblaccept;              -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu ACCEPT ... END ACCEPT
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  last             : pblwhen_m;                  -- poslední větev
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_accept);

  -- režim příkazu
  if checklex(curr,lex_delay)

    -- DELAY
    then
      -- další symbol
      looklex(curr,lex);
      if lex in lex_expr_start

        -- čekání s timeoutem
        then
          bl^.mode:=bam_delay;

          -- výraz
          x_vyraz(curr,bl^.expr,es_expr);

        -- neomezené čekání
        else
          bl^.mode:=bam_infinite
          end if;

    -- jednorázové čtení zprávy
    else
      bl^.mode:=bam_check
      end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- větve ACCEPT
  bl^.sub.first:=nil;
  bl^.sub.last:=nil;
  while checklex(curr,lex_when) loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikla nová větev
    newnode(pblnode(last),info,bt_when_m);
    if bl^.sub.first=nil
      then bl^.sub.first:=last;
      else bl^.sub.last^.next:=last;
      end if;
    bl^.sub.last:=last;

    -- výběr nebo OTHERS nebo DELAY
    {%%X}

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000035,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence příkazů
    b_sequence(curr,last^.sub,info);
    end loop;

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END ACCEPT
  if followendkw(curr,lex_accept) then
    ce^.seterror({CCERR=}000036,ce_x_end_accept);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_accept;



----------------------------------------------------------------------------------------------------
procedure b_begin (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblblock;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu BEGIN ... END
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- přeložit blok
  b_body(curr,bl,info);

  -- END
  if followlex(curr,lex_end) then
    ce^.seterror({CCERR=}000037,ce_x_end);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_begin;



----------------------------------------------------------------------------------------------------
procedure b_protected (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblblock;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu PROTECTED ... END PROTECTED
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_protected);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_sequence(curr,bl^.sub,info);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);

  -- END PROTECTED declare_context
  if followendkw(curr,lex_protected) then
    ce^.seterror({CCERR=}000038,ce_x_end_protected);
    ce^.loadpos;
    end if;
  end b_protected;



----------------------------------------------------------------------------------------------------
procedure b_sequential (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblblock;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu SEQUENTIAL ... END SEQUENTIAL
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_sequential);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_sequence(curr,bl^.sub,info);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);

  -- END SEQUENTIAL declare_context
  if followendkw(curr,lex_sequential) then
    ce^.seterror({CCERR=}000039,ce_x_end_sequential);
    ce^.loadpos;
    end if;
  end b_sequential;



----------------------------------------------------------------------------------------------------
procedure b_declare (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pbldeclare;             -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu DECLARE ... BEGIN ... END
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_unit,
  cd_decl.cd_create;

use
  cd_decl.cd_eval;

var
  pos              : lexposblock;                -- pozice
  declare_context  : tcontext;                   -- kontext DECLARE bloku
  e                : tentityeval;

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_declare);

  -- vznikl nový deklarativní region
  d_create_region(curr,bl^.declare_region,declare_context);

  -- deklarace
  p_declare(declare_context);

  -- BEGIN
  if followlex(declare_context,lex_begin) then
    ce^.seterror({CCERR=}000040,ce_x_begin);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_body_sequence(declare_context,bl,info);

  -- END DECLARE declare_context
  if followendkw(declare_context,lex_declare) then
    ce^.seterror({CCERR=}000041,ce_x_end_declare);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_declare;



----------------------------------------------------------------------------------------------------
procedure b_raise (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblraise;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu RAISE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_raise);

  -- jméno zprávy
  looklex(curr,lex);
  if lex in lex_expr_start then
    x_vyraz(curr,bl^.msg,es_name);
    end if;

  -- IN
  if checklex(curr,lex_in) then
    x_vyraz(curr,bl^.dest,es_name);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_raise;



----------------------------------------------------------------------------------------------------
procedure b_send (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblsend;                -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu SEND
----------------------------------------------------------------------------------------------------
label
  opak;

var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_send);

  -- jméno výjimky
  looklex(curr,lex);
  if lex in lex_expr_start then
    -- výraz
    x_vyraz(curr,bl^.msg,es_name);
    end if;

  -- TO
  if checklex(curr,lex_to) then
    -- výraz
    x_vyraz(curr,bl^.dest,es_name);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- determinace životnosti
  getlex(curr,lex);
  case lex
    -- DELAY
    when lex_delay do
        looklex(curr,lex);
        if lex in lex_expr_start

          -- výraz
          then
            -- životnost timeoutem
            bl^.lifetime:=blt_timeout;

            -- výraz
            x_vyraz(curr,bl^.time,es_expr);

          -- bez výrazu, blokující SEND
          else
            bl^.lifetime:=blt_blocking
            end if;

    -- DO
    when lex_do do
        -- životnost sekvencí příkazů
        bl^.lifetime:=blt_sequence;

        -- sekvence příkazů
        b_sequence(curr,bl^.xdo,info);

    -- symbol se nás netýkal
    when others do
        -- životnost neomezena
        bl^.lifetime:=blt_infinite;

        ungetlex;
    end case;

opak:
  -- WHEN ACCEPT/DELAY DO
  if checklex(curr,lex_when) then
    getlex(curr,lex);
    case lex
      -- ACCEPT
      when lex_accept do
          -- již byl uveden
          if bsp_accept in bl^.parts then
            ce^.seterror({CCERR=}000042,ce_x_accept);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- DO
          if followlex(curr,lex_do) then
            ce^.seterror({CCERR=}000043,ce_x_do);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- je uvedena část WHEN ACCEPT DO
          bl^.parts+blsendpartset:[bsp_accept];

          -- posloupnost příkazů
          b_sequence(curr,bl^.xaccept,info);

          -- ještě může následovat WHEN DELAY DO
          goto opak;

      -- DELAY
      when lex_delay do
          -- DO
          if followlex(curr,lex_do) then
            ce^.seterror({CCERR=}000044,ce_x_do);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- je uvedena část WHEN DELAY DO
          bl^.parts+blsendpartset:[bsp_accept];

          -- posloupnost příkazů
          b_sequence(curr,bl^.xdelay,info);

      -- cokoliv jiného je chyba
      when others do
          ce^.seterror({CCERR=}000045,ce_x_accept_delay);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
      end case;
    end if;

  -- END SEND
  if followendkw(curr,lex_send) then
    ce^.seterror({CCERR=}000046,ce_x_end_send);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_send;



----------------------------------------------------------------------------------------------------
procedure b_new (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblnew;                 -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu NEW
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_new);

  -- jméno proměnné
  x_vyraz(curr,bl^.xvar,es_name);

  -- %%X Nemůže být současně uvedeno RANGE i TAG ?

  -- TAG
  if checklex(curr,lex_tag) then
    x_vyraz(curr,bl^.xtag,es_expr);
    end if;

  -- RANGE
  if checklex(curr,lex_range) then
    x_vyraz(curr,bl^.xrange,es_expr);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_new;



----------------------------------------------------------------------------------------------------
procedure b_discard (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pbldiscard;             -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu DISCARD
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_discard);

  -- jméno proměnné
  x_vyraz(curr,bl^.xvar,es_name);

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_discard;



----------------------------------------------------------------------------------------------------
procedure b_adjust (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pbladjust;              -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu ADJUST
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_adjust);

  -- jméno proměnné
  x_vyraz(curr,bl^.xvar,es_name);

  -- LOOP
  if followlex(curr,lex_range) then
    ce^.seterror({CCERR=}000047,ce_x_rozsah);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- RANGE
  x_vyraz(curr,bl^.xrange,es_expr);

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_adjust;




----------------------------------------------------------------------------------------------------
procedure b_break (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblbreak;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu BREAK
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_break);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_break;



----------------------------------------------------------------------------------------------------
procedure b_return (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblreturn;              -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu RETURN
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_return);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_return;



----------------------------------------------------------------------------------------------------
procedure b_goto (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblgoto;                -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu GOTO
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  id               : pentityident;               -- identifikátor návěští
  srch             : tentitysearch;              -- hledátko
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_goto);

  -- identifikátor návěští
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000048,ce_x_name_label);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- %%TECH Toto je jedno z mála míst, kde se při syntaktické analýze
  -- manipuluje přímo se symbolem a ne jen s identifikátorem.
  --   Mohu si to dovolit, protože návěští je čistě lokální symbol
  -- a nehrozí, že by bylo generické.

  -- vyhledat
  srch.find_local(curr,id^,tentityvisibleset:[etv_private]);
  if srch.psym=nil then
    ce^.seterror({CCERR=}000049,ce_undeclared);
    ce^.setparam(entityident_to_string(id^));
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  if srch.psym^.etype<>et_label then
    ce^.seterror({CCERR=}000050,ce_x_name_label);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- poznamenat
  bl^.plabel:=pentity_label(srch.psym);

  -- zvýšit počet použití
  succ bl^.plabel^.stat_usage;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_goto;



----------------------------------------------------------------------------------------------------
procedure b_delay (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pbldelay;               -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad příkazu DELAY
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexikální symbol
  expr             : pexpnode;                   -- výraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_delay);

  -- výraz
  x_vyraz(curr,bl^.expr,es_expr);

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_delay;



----------------------------------------------------------------------------------------------------
procedure b_asm (
    curr           : in tcontext;                -- překládaný prvek
    bl             : out pblasm;                 -- příkaz
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad bloku v assembleru (konstrukce #SYNTAX ASM; ... #END ASM);
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

var
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice
  asm_context      : tcontext;                   -- kontext bloku v assembleru

begin
  -- bezpečnostní kontroly
  check_security_level({CCERR=}000654,curr,sl_inline_assembly{%%TODO(SECURITY),ce^.loadpos});

  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_asm);
  bl^.ifirst:=nil;
  bl^.ilast:=nil;

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- vznikl nový deklarativní region
  d_create_region(curr,bl^.asm_region,asm_context);

  -- zpracovat instrukce procesoru
  cpu^.p_asm(asm_context,p_flex_class(bl)^);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);

  -- %%X ZÁPLATA - podstrčit právě sežranej středník
  setlex(lex_scol);
  ungetlex;
  end b_asm;



----------------------------------------------------------------------------------------------------
procedure b_sequence =
-- Překlad sekvence příkazů.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  lex              : lexsym;                     -- lexikální symbol
  node             : pblnode;                    -- uzel stromu

begin
  list.first:=nil;
  list.last:=nil;
  loop
    begin
      -- zpracovat návěští
      begin
        loop
          -- přečíst ze vstupu lexikální symbol
          getlex(curr,lex);
          if lex<>lex_id then break; end if;

          -- zkusit přeložit identifikátor jako návěští
          node:=nil;
          b_label(curr,pbllabel(node),getlexid()^,info);

          if node<>nil
            -- bylo to návěští
            then
              if list.first=nil
                then list.first:=node;
                else list.last^.next:=node;
                end if;
              list.last:=node;

            -- nebylo to návěští, nejspíš to bude příkaz
            else
              break
              end if;
          end loop;
      catch
        when resume_error do ;
        end;

      -- přeložit příkaz
      node:=nil;
      if lex in lex_expr_start
        -- přiřazovací příkaz nebo volání
        then
          -- vrátit do vstupu, aby byl příkaz zase pohromadě
          ungetlex;
          b_cmd(curr,pblcmd(node),info);

        -- jiný příkaz
        else 
          case lex
            when lex_if         do b_if(curr,pblif(node),info);
            when lex_loop       do b_loop(curr,pblloop(node),info);
            when lex_for        do b_for(curr,pblfor(node),info);
            when lex_while      do b_while(curr,pblwhile(node),info);
            when lex_case       do b_case(curr,pblcase(node),info);
            when lex_accept     do b_accept(curr,pblaccept(node),info);
            when lex_begin      do b_begin(curr,pblblock(node),info);
            when lex_protected  do b_protected(curr,pblblock(node),info);
            when lex_sequential do b_sequential(curr,pblblock(node),info);
            when lex_declare    do b_declare(curr,pbldeclare(node),info);
            when lex_raise      do b_raise(curr,pblraise(node),info);
            when lex_send       do b_send(curr,pblsend(node),info);
            when lex_new        do b_new(curr,pblnew(node),info);
            when lex_discard    do b_discard(curr,pbldiscard(node),info);
            when lex_adjust     do b_adjust(curr,pbladjust(node),info);
            when lex_break      do b_break(curr,pblbreak(node),info);
            when lex_return     do b_return(curr,pblreturn(node),info);
            when lex_goto       do b_goto(curr,pblgoto(node),info);
            when lex_delay      do b_delay(curr,pbldelay(node),info);
            when lex_asm        do b_asm(curr,pblasm(node),info);
            when lex_scol       do ungetlex;
            when others         do break;
            end case;
          end if;

      -- nově vzniklý uzel zařadit
      if node<>nil then
        if list.first=nil
          then list.first:=node;
          else list.last^.next:=node;
          end if;
        list.last:=node;
        end if;

      -- další symbol
      getlex(curr,lex);

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
      end;

    until lex<>lex_scol;

  -- naposledy přečtený symbol vrátit do vstupu
  ungetlex;
k1:
  end b_sequence;



----------------------------------------------------------------------------------------------------
procedure b_catch (
    curr           : in tcontext;                -- překládaný prvek
    list           : out bllist;                 -- seznam příkazů
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Překlad části CATCH.
----------------------------------------------------------------------------------------------------
var
  last             : pblwhen_m;                  -- poslední uzel
  lex              : lexsym;                     -- lexikální symbol
  pos              : lexposblock;                -- pozice

begin
  -- %%X Při přepisování do Flexu sjednotit s B_CASE, tam už to díky TAG půjde
  list.first:=nil;
  list.last:=nil;
  last:=nil;
  while ((last=nil) or (last^.ctype<>bct_others)) and checklex(curr,lex_when) loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikl nový uzel
    newnode(pblnode(last),info,bt_when_m);
    if list.first=nil
      then list.first:=last;
      else list.last^.next:=last;
      end if;
    list.last:=last;

    -- výběr nebo OTHERS
    if checklex(curr,lex_others)

      -- OTHERS
      then
        last^.ctype:=bct_others;

      -- seznam jmen
      else
        last^.ctype:=bct_choice;
        x_select(curr,last^.list,es_name);
        end if;

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000051,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- posloupnost příkazů
    b_sequence(curr,last^.sub,info);
    end loop;
  end b_catch;



----------------------------------------------------------------------------------------------------
procedure b_body_sequence =
-- Překlad sekvence příkazů uvnitř bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- sekvence příkazů
  b_sequence(curr,bl^.sub,info);

  -- část CATCH
  if checklex(curr,lex_catch) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bcatch_pos,ll_curr);

    -- a přeložit sekvenci
    b_catch(curr,bl^.bcatch,info)
    end if;

  -- část ROLLBACK
  if checklex(curr,lex_rollback) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.brollback_pos,ll_curr);

    -- a přeložit sekvenci
    b_sequence(curr,bl^.brollback,info)
    end if;

  -- část COMMIT
  if checklex(curr,lex_commit) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bcommit_pos,ll_curr);

    -- a přeložit sekvenci
    b_sequence(curr,bl^.bcommit,info)
    end if;

  -- část LEAVE
  if checklex(curr,lex_leave) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bleave_pos,ll_curr);

    -- a přeložit sekvenci
    b_sequence(curr,bl^.bleave,info);

    declare var lex : lexsym; begin looklex(curr,lex) end declare;
    end if;

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_body_sequence;



----------------------------------------------------------------------------------------------------
procedure b_body =
-- Překlad bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice
  lex              : lexsym;                     -- lexikální symbol

begin
  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl nový uzel
  newnode(pblnode(bl),info,bt_block);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence příkazů
  b_body_sequence(curr,bl,info);
  end b_body;



end cb_parse;
