----------------------------------------------------------------------------------------------------
module private cb_parse =
-- P©ekladaá Flexu.
-- Syntaktick† analòza bloku p©°kazñ.
----------------------------------------------------------------------------------------------------
-- Ondra : 21.09.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cc_base,
  cc_base.cc_sym,
  cc_lex;

----------------------------------------------------------------------------------------------------
procedure b_sequence (
    curr           : in tcontext;                -- p©ekl†danò prvek
    list           : in out bllist;              -- p©°kaz
    info           : in blinfo);                 -- informace o prñbàhu analòzy
-- P©eklad sekvence p©°kazñ.
----------------------------------------------------------------------------------------------------
procedure b_body_sequence (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : in pblblock;                -- blok p©°kazñ
    info           : in blinfo);                 -- informace o prñbàhu analòzy
-- P©eklad sekvence p©°kazñ uvnit© bloku p©°kazñ.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure b_label (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pbllabel;               -- p©°kaz
    id             : in tentityident;            -- identifik†tor n†và®t°
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad n†và®t°.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  srch             : tentitysearch;              -- hled†tko
  pos              : lexposblock;                -- pozice

begin
  -- %%TECH Toto je jedno z m†la m°st, kde se p©i syntaktickÇ analòze 
  -- manipuluje p©°mo se symbolem a ne jen s identifik†torem.
  --   Mohu si to dovolit, protoëe n†và®t° je áistà lok†ln° symbol
  -- a nehroz°, ëe by bylo generickÇ.
  -- %%LANG Nehledà k tomu, ëe bez toho bych nerozpoznal o jakou      
  -- syntaktickou konstrukci se jedn†

  -- zkusit vyhledat
  srch.find_local(curr,id,tentityvisibleset:[etv_private]);
  if srch.psym=nil then return; end if;
  if srch.psym^.etype<>et_label then return; end if;

  -- teÉ je to jië jistà n†và®t°, mus° n†sledovat dvojteáka
  if followlex(curr,lex_col) then
    ce^.seterror({CCERR=}000128,ce_x_col);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- nebylo jië n†và®t° um°stàno
  if pentity_label(srch.psym)^.placed then
    ce^.seterror({CCERR=}000129,ce_duplabel);
    ce^.setparam(entityident_to_string(id));
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- pozice
  getlexpos(pos.b,ll_prev,false);
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici symbolu
  entity_set_position(srch.psym^,etp_def,pos);

  -- oznaáit n†và®t° za um°stànÇ
  pentity_label(srch.psym)^.placed:=true;

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_label);

  -- poznamenat
  pbllabel(bl)^.plabel:=pentity_label(srch.psym);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_label;



----------------------------------------------------------------------------------------------------
procedure b_cmd (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblcmd;                 -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©i©azovac°ho p©°kazu.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_cmd);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- p©°kaz
  x_vyraz(curr,bl^.expr,es_cmd);

  {%%X}

  -- vyhodnotit

  -- provÇst makra

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_cmd;



----------------------------------------------------------------------------------------------------
procedure b_if (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblif;                  -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu IF.
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  last             : pblif_cond;                 -- vàtev IF
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_if);

  -- vznikla nov† vàtev IF
  newnode(pblnode(last),info,bt_if_cond);
  bl^.sub.first:=last;
  bl^.sub.last:=last;

  loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- podm°nka
    x_vyraz(curr,last^.cond,es_expr);

    -- THEN
    if followlex(curr,lex_then) then
      ce^.seterror({CCERR=}000130,ce_x_then);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence p©°kazñ
    b_sequence(curr,last^.sub,info);

    -- dal®° symbol
    getlex(curr,lex);

    -- zaloëit novou vàtev
    if lex in lexsymset:[lex_else,lex_elsif] then
      newnode(pblnode(last),info,bt_if_cond);
      bl^.sub.last^.next:=last;
      bl^.sub.last:=last;
      end if;

    until lex<>lex_elsif;

  -- vàtev ELSE
  if lex=lex_else
    -- sekvence p©°kazñ
    then b_sequence(curr,last^.sub,info)

    -- cokoliv jinÇho
    else
      ungetlex
      end if;

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END IF
  if followendkw(curr,lex_if) then
    ce^.seterror({CCERR=}000131,ce_x_end_if);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_if;



----------------------------------------------------------------------------------------------------
procedure b_loop (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblloop;                -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu LOOP ... END LOOP / LOOP .. UNTIL
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_loop);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_sequence(curr,bl^.sub,info);

  -- dal®° symbol
  getlex(curr,lex);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  case lex
    -- END
    when lex_end do
        -- END LOOP
        ungetlex;
        if followendkw(curr,lex_loop) then
          ce^.seterror({CCERR=}000132,ce_x_end_loop);
          ce^.loadpos2;
          {%%RESUME ce^.raiseerror;}
          end if;

    -- UNTIL
    when lex_until do
        -- podm°nka
        x_vyraz(curr,bl^.cond,es_expr);

    -- cokoliv jinÇho je chyba
    when others do
        ce^.seterror({CCERR=}000133,ce_x_end_loop_until);
        ce^.loadpos2;
        {%%RESUME ce^.raiseerror;}
        resumelex(curr,lex,lex_scol,rl_leave,lex_end,rt_leave);
    end case;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_loop;



----------------------------------------------------------------------------------------------------
procedure b_for (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblfor;                 -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu FOR LOOP ... END FOR
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

use
  cd_decl.cd_eval;

var
  lex              : lexsym;                     -- lexik†ln° symbol
  expr             : pexpnode;                   -- vòraz
  pos              : lexposblock;                -- pozice
  for_context      : tcontext;                   -- kontext FOR cyklu
  for_var_context  : tcontext;                   -- kontext ©°d°c° promànnÇ cyklu
  for_var_pos      : lexposblock;                -- pozice ©°d°c° promànnÇ cyklu
  for_type         : pentity_type;               -- typ ©°d°c° promànnÇ cyklu
  e                : tentityeval;

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_for);

  -- vznikl novò deklarativn° region
  d_create_region(curr,bl^.for_region,for_context);

  -- zaá†tek deklarace ©°d°c° promànnÇ cyklu
  d_create(for_context,pentity(bl^.for_var),for_var_context,et_var,for_var_pos);

  -- doplnit z†kladn° vlastnosti promànnÇ
  bl^.for_var^.mclass:=mc_auto;
  bl^.for_var^.vmode:=vm_direct;
  bl^.for_var^.vaccess:=va_const;

  -- IN
  if followlex(for_context,lex_in) then
    ce^.seterror({CCERR=}000000,ce_x_in);
    ce^.loadpos;
    end if;

  -- determinace po©ad°
  getlex(for_context,lex);
  case lex
    -- REVERSE
    when lex_reverse    do bl^.order:=bfo_reverse;

    -- CONCURRENT
    when lex_concurrent do bl^.order:=bfo_concurrent;

    when others do
        bl^.order:=bfo_normal;
        ungetlex;
    end case;

  -- rozsah
  x_vyraz(for_context,bl^.xrange,es_range);
  x_evaluate(for_context,bl^.xrange,ek_range,nil,eu_read,true,e);
  if not cd_decl.cd_eval.e_is_evaluated(e) then return; end if;

  -- uráit typ promànnÇ
  x_get_type(for_context,bl^.xrange,for_type);
  bl^.for_var^.typ.settype(for_type);

  -- konec deklarace ©°d°c° promànnÇ cyklu
  d_end(bl^.for_var^,for_var_pos);

  -- LOOP
  if followlex(for_context,lex_loop) then
    ce^.seterror({CCERR=}000135,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

{ Ondra 5.12.2002 : Pñvodn° verze bez implicitn° deklarace promànnÇ:

  -- jmÇno promànnÇ
  x_vyraz(for_context,bl^.xvar,es_name);

  -- dal®° symbol
  getlex(for_context,lex);
  case lex
    -- IN
    when lex_in do
        -- determinace po©ad°
        getlex(for_context,lex);
        case lex
          -- REVERSE
          when lex_reverse    do bl^.order:=bfo_reverse;

          -- CONCURRENT
          when lex_concurrent do bl^.order:=bfo_concurrent;

          when others do
              bl^.order:=bfo_normal;
              ungetlex;
          end case;

        -- rozsah
        x_vyraz(for_context,bl^.xrange,es_range);

    -- REVERSE
    when lex_reverse    do bl^.order:=bfo_reverse;

    -- CONCURRENT
    when lex_concurrent do bl^.order:=bfo_concurrent;

    -- LOOP
    when lex_loop do
        bl^.order:=bfo_normal;

        -- cyklus p©es rozsah promànnÇ, nic nedàlat
        ungetlex;

    -- cokoliv jinÇho je chyba
    when others do
        ce^.seterror({CCERR=}000134,ce_x_in);
        ce^.loadpos;
        {%%RESUME ce^.raiseerror;}
    end case;

  -- LOOP
  if followlex(for_context,lex_loop) then
    ce^.seterror({CCERR=}000135,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
}
  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_sequence(for_context,bl^.sub,info);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END LOOP
  if followendkw(for_context,lex_loop) then
    ce^.seterror({CCERR=}000136,ce_x_end_loop);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzli
  bl^.setpos(bp_end,pos);
  end b_for;



----------------------------------------------------------------------------------------------------
procedure b_while (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblwhile;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu WHILE ... END WHILE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_while);

  -- podm°nka
  x_vyraz(curr,bl^.cond,es_expr);

  -- LOOP
  if followlex(curr,lex_loop) then
    ce^.seterror({CCERR=}000137,ce_x_loop);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_sequence(curr,bl^.sub,info);

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END LOOP
  if followendkw(curr,lex_loop) then
    ce^.seterror({CCERR=}000138,ce_x_end_loop);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_while;



----------------------------------------------------------------------------------------------------
procedure b_case (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblcase;                -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu CASE ... END CASE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  last             : pblwhen_c;                  -- posledn° vàtev
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_case);

  -- vòraz
  x_vyraz(curr,bl^.expr,es_expr);

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- vàtve CASE
  -- %%X P©i p©episov†n° do Flexu sjednotit s B_CATCH, tam uë to d°ky TAG pñjde
  bl^.sub.first:=nil;
  bl^.sub.last:=nil;
  last:=nil;
  while ((last=nil) or (last^.ctype<>bct_others)) and checklex(curr,lex_when) loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikla nov† vàtev
    newnode(pblnode(last),info,bt_when_c);
    if bl^.sub.first=nil
      then bl^.sub.first:=last;
      else bl^.sub.last^.next:=last;
      end if;
    bl^.sub.last:=last;

    -- vòbàr nebo OTHERS
    if checklex(curr,lex_others)

      -- OTHERS
      then
        last^.ctype:=bct_others;

      -- seznam vòbàrñ
      else
        last^.ctype:=bct_choice;
        x_select(curr,last^.list,es_choice);
        end if;

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000139,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence p©°kazñ
    b_sequence(curr,last^.sub,info);
    end loop;

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END CASE
  if followendkw(curr,lex_case) then
    ce^.seterror({CCERR=}000140,ce_x_end_case);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_case;



----------------------------------------------------------------------------------------------------
procedure b_accept (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblaccept;              -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu ACCEPT ... END ACCEPT
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  last             : pblwhen_m;                  -- posledn° vàtev
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_accept);

  -- reëim p©°kazu
  if checklex(curr,lex_delay)

    -- DELAY
    then
      -- dal®° symbol
      looklex(curr,lex);
      if lex in lex_expr_start

        -- áek†n° s timeoutem
        then
          bl^.mode:=bam_delay;

          -- vòraz
          x_vyraz(curr,bl^.expr,es_expr);

        -- neomezenÇ áek†n°
        else
          bl^.mode:=bam_infinite
          end if;

    -- jednor†zovÇ áten° zpr†vy
    else
      bl^.mode:=bam_check
      end if;

  -- pozice
  getlexpos(pos.e,ll_curr,false);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- vàtve ACCEPT
  bl^.sub.first:=nil;
  bl^.sub.last:=nil;
  while checklex(curr,lex_when) loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikla nov† vàtev
    newnode(pblnode(last),info,bt_when_m);
    if bl^.sub.first=nil
      then bl^.sub.first:=last;
      else bl^.sub.last^.next:=last;
      end if;
    bl^.sub.last:=last;

    -- vòbàr nebo OTHERS nebo DELAY
    {%%X}

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000141,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- sekvence p©°kazñ
    b_sequence(curr,last^.sub,info);
    end loop;

  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- END ACCEPT
  if followendkw(curr,lex_accept) then
    ce^.seterror({CCERR=}000142,ce_x_end_accept);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_accept;



----------------------------------------------------------------------------------------------------
procedure b_begin (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblblock;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu BEGIN ... END
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- p©eloëit blok
  b_body(curr,bl,info);

  -- END
  if followlex(curr,lex_end) then
    ce^.seterror({CCERR=}000143,ce_x_end);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_begin;



----------------------------------------------------------------------------------------------------
procedure b_sequential (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblblock;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu SEQUENTIAL ... END SEQUENTIAL
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_sequential);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_sequence(curr,bl^.sub,info);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);

  -- END SEQUENTIAL declare_context
  if followendkw(curr,lex_sequential) then
    ce^.seterror({CCERR=}000000,ce_x_end_sequential);
    ce^.loadpos;
    end if;
  end b_sequential;



----------------------------------------------------------------------------------------------------
procedure b_declare (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pbldeclare;             -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu DECLARE ... BEGIN ... END
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_unit,
  cd_decl.cd_create;

use
  cd_decl.cd_eval;

var
  pos              : lexposblock;                -- pozice
  declare_context  : tcontext;                   -- kontext DECLARE bloku
  e                : tentityeval;

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_declare);

  -- vznikl novò deklarativn° region
  d_create_region(curr,bl^.declare_region,declare_context);

  -- deklarace
  p_declare(declare_context);

  -- BEGIN
  if followlex(declare_context,lex_begin) then
    ce^.seterror({CCERR=}000000,ce_x_begin);
    ce^.loadpos;
    ce^.resumeerror;
    end if;

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_body_sequence(declare_context,bl,info);

  -- END DECLARE declare_context
  if followendkw(declare_context,lex_declare) then
    ce^.seterror({CCERR=}000000,ce_x_end_declare);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_declare;



----------------------------------------------------------------------------------------------------
procedure b_raise (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblraise;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu RAISE
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  expr             : pexpnode;                   -- vòraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_raise);

  -- jmÇno zpr†vy
  looklex(curr,lex);
  if lex in lex_expr_start then
    x_vyraz(curr,bl^.msg,es_name);
    end if;

  -- IN
  if checklex(curr,lex_in) then
    x_vyraz(curr,bl^.dest,es_name);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_raise;



----------------------------------------------------------------------------------------------------
procedure b_send (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblsend;                -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu SEND
----------------------------------------------------------------------------------------------------
label
  opak;

var
  lex              : lexsym;                     -- lexik†ln° symbol
  expr             : pexpnode;                   -- vòraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_send);

  -- jmÇno vòjimky
  looklex(curr,lex);
  if lex in lex_expr_start then
    -- vòraz
    x_vyraz(curr,bl^.msg,es_name);
    end if;

  -- TO
  if checklex(curr,lex_to) then
    -- vòraz
    x_vyraz(curr,bl^.dest,es_name);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- determinace ëivotnosti
  getlex(curr,lex);
  case lex
    -- DELAY
    when lex_delay do
        looklex(curr,lex);
        if lex in lex_expr_start

          -- vòraz
          then
            -- ëivotnost timeoutem
            bl^.lifetime:=blt_timeout;

            -- vòraz
            x_vyraz(curr,bl^.time,es_expr);

          -- bez vòrazu, blokuj°c° SEND
          else
            bl^.lifetime:=blt_blocking
            end if;

    -- DO
    when lex_do do
        -- ëivotnost sekvenc° p©°kazñ
        bl^.lifetime:=blt_sequence;

        -- sekvence p©°kazñ
        b_sequence(curr,bl^.xdo,info);

    -- symbol se n†s netòkal
    when others do
        -- ëivotnost neomezena
        bl^.lifetime:=blt_infinite;

        ungetlex;
    end case;

opak:
  -- WHEN ACCEPT/DELAY DO
  if checklex(curr,lex_when) then
    getlex(curr,lex);
    case lex
      -- ACCEPT
      when lex_accept do
          -- jië byl uveden
          if bsp_accept in bl^.parts then
            ce^.seterror({CCERR=}000144,ce_x_accept);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            ce^.resumeerror;
            end if;

          -- DO
          if followlex(curr,lex_do) then
            ce^.seterror({CCERR=}000145,ce_x_do);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- je uvedena á†st WHEN ACCEPT DO
          bl^.parts+blsendpartset:[bsp_accept];

          -- posloupnost p©°kazñ
          b_sequence(curr,bl^.xaccept,info);

          -- je®tà mñëe n†sledovat WHEN DELAY DO
          goto opak;

      -- DELAY
      when lex_delay do
          -- DO
          if followlex(curr,lex_do) then
            ce^.seterror({CCERR=}000146,ce_x_do);
            ce^.loadpos;
            {%%RESUME ce^.raiseerror;}
            end if;

          -- je uvedena á†st WHEN DELAY DO
          bl^.parts+blsendpartset:[bsp_accept];

          -- posloupnost p©°kazñ
          b_sequence(curr,bl^.xdelay,info);

      -- cokoliv jinÇho je chyba
      when others do
          ce^.seterror({CCERR=}000147,ce_x_accept_delay);
          ce^.loadpos;
          {%%RESUME ce^.raiseerror;}
          ce^.resumeerror;
      end case;
    end if;

  -- END SEND
  if followendkw(curr,lex_send) then
    ce^.seterror({CCERR=}000148,ce_x_end_send);
    ce^.loadpos2;
    {%%RESUME ce^.raiseerror;}
    end if;
  end b_send;



----------------------------------------------------------------------------------------------------
procedure b_new (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblnew;                 -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu NEW
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_new);

  -- jmÇno promànnÇ
  x_vyraz(curr,bl^.xvar,es_name);

  -- %%X Nemñëe bòt souáasnà uvedeno RANGE i TAG ?

  -- TAG
  if checklex(curr,lex_tag) then
    x_vyraz(curr,bl^.xtag,es_expr);
    end if;

  -- RANGE
  if checklex(curr,lex_range) then
    x_vyraz(curr,bl^.xrange,es_expr);
    end if;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_new;



----------------------------------------------------------------------------------------------------
procedure b_discard (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pbldiscard;             -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu DISCARD
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_discard);

  -- jmÇno promànnÇ
  x_vyraz(curr,bl^.xvar,es_name);

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_discard;



----------------------------------------------------------------------------------------------------
procedure b_break (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblbreak;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu BREAK
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_break);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_break;



----------------------------------------------------------------------------------------------------
procedure b_return (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblreturn;              -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu RETURN
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_return);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_return;



----------------------------------------------------------------------------------------------------
procedure b_goto (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblgoto;                -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu GOTO
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  id               : pentityident;               -- identifik†tor n†và®t°
  srch             : tentitysearch;              -- hled†tko
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_goto);

  -- identifik†tor n†và®t°
  if followlex(curr,lex_id) then
    ce^.seterror({CCERR=}000149,ce_x_name_label);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  id:=getlexid;

  -- %%TECH Toto je jedno z m†la m°st, kde se p©i syntaktickÇ analòze
  -- manipuluje p©°mo se symbolem a ne jen s identifik†torem.
  --   Mohu si to dovolit, protoëe n†và®t° je áistà lok†ln° symbol
  -- a nehroz°, ëe by bylo generickÇ.

  -- vyhledat
  srch.find_local(curr,id^,tentityvisibleset:[etv_private]);
  if srch.psym=nil then
    ce^.seterror({CCERR=}000150,ce_undeclared);
    ce^.setparam(entityident_to_string(id^));
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;
  if srch.psym^.etype<>et_label then
    ce^.seterror({CCERR=}000151,ce_x_name_label);
    ce^.loadpos;
    {%%RESUME ce^.raiseerror;}
    ce^.resumeerror;
    end if;

  -- poznamenat
  bl^.plabel:=pentity_label(srch.psym);

  -- zvò®it poáet pouëit°
  succ bl^.plabel^.stat_usage;

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_goto;



----------------------------------------------------------------------------------------------------
procedure b_delay (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pbldelay;               -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad p©°kazu DELAY
----------------------------------------------------------------------------------------------------
var
  lex              : lexsym;                     -- lexik†ln° symbol
  expr             : pexpnode;                   -- vòraz
  pos              : lexposblock;                -- pozice

begin
  -- pozice
  getlexpos(pos.b,ll_curr,false);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_delay);

  -- vòraz
  x_vyraz(curr,bl^.expr,es_expr);

  -- pozice
  getlexpos(pos.e,ll_curr,true);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);
  end b_delay;



----------------------------------------------------------------------------------------------------
procedure b_asm (
    curr           : in tcontext;                -- p©ekl†danò prvek
    bl             : out pblasm;                 -- p©°kaz
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad bloku v assembleru (konstrukce #SYNTAX ASM; ... #END ASM);
----------------------------------------------------------------------------------------------------
with
  cd_decl,
  cd_decl.cd_create;

var
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice
  asm_context      : tcontext;                   -- kontext bloku v assembleru

begin
  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_asm);
  bl^.ifirst:=nil;
  bl^.ilast:=nil;

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- vznikl novò deklarativn° region
  d_create_region(curr,bl^.asm_region,asm_context);

  -- zpracovat instrukce procesoru
  cpu^.p_asm(asm_context,p_flex_class(bl)^);

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);

  -- %%X ZèPLATA - podstráit pr†và seëranej st©edn°k
  setlex(lex_scol);
  ungetlex;
  end b_asm;



----------------------------------------------------------------------------------------------------
procedure b_sequence =
-- P©eklad sekvence p©°kazñ.
----------------------------------------------------------------------------------------------------
label
  k1;

var
  lex              : lexsym;                     -- lexik†ln° symbol
  node             : pblnode;                    -- uzel stromu

begin
  list.first:=nil;
  list.last:=nil;
  loop
    begin
      -- zpracovat n†và®t°
      begin
        loop
          -- p©eá°st ze vstupu lexik†ln° symbol
          getlex(curr,lex);
          if lex<>lex_id then break; end if;

          -- zkusit p©eloëit identifik†tor jako n†và®t°
          node:=nil;
          b_label(curr,pbllabel(node),getlexid()^,info);

          if node<>nil
            -- bylo to n†và®t°
            then
              if list.first=nil
                then list.first:=node;
                else list.last^.next:=node;
                end if;
              list.last:=node;

            -- nebylo to n†và®t°, nejsp°® to bude p©°kaz
            else
              break
              end if;
          end loop;
      catch
        when resume_error do ;
        end;

      -- p©eloëit p©°kaz
      node:=nil;
      if lex in lex_expr_start
        -- p©i©azovac° p©°kaz nebo vol†n°
        then
          -- vr†tit do vstupu, aby byl p©°kaz zase pohromadà
          ungetlex;
          b_cmd(curr,pblcmd(node),info);

        -- jinò p©°kaz
        else 
          case lex
            when lex_if         do b_if(curr,pblif(node),info);
            when lex_loop       do b_loop(curr,pblloop(node),info);
            when lex_for        do b_for(curr,pblfor(node),info);
            when lex_while      do b_while(curr,pblwhile(node),info);
            when lex_case       do b_case(curr,pblcase(node),info);
            when lex_accept     do b_accept(curr,pblaccept(node),info);
            when lex_begin      do b_begin(curr,pblblock(node),info);
            when lex_sequential do b_sequential(curr,pblblock(node),info);
            when lex_declare    do b_declare(curr,pbldeclare(node),info);
            when lex_raise      do b_raise(curr,pblraise(node),info);
            when lex_send       do b_send(curr,pblsend(node),info);
            when lex_new        do b_new(curr,pblnew(node),info);
            when lex_discard    do b_discard(curr,pbldiscard(node),info);
            when lex_break      do b_break(curr,pblbreak(node),info);
            when lex_return     do b_return(curr,pblreturn(node),info);
            when lex_goto       do b_goto(curr,pblgoto(node),info);
            when lex_delay      do b_delay(curr,pbldelay(node),info);
            when lex_asm        do b_asm(curr,pblasm(node),info);
            when lex_scol       do ungetlex;
            when others         do break;
            end case;
          end if;

      -- novà vzniklò uzel za©adit
      if node<>nil then
        if list.first=nil
          then list.first:=node;
          else list.last^.next:=node;
          end if;
        list.last:=node;
        end if;

      -- dal®° symbol
      getlex(curr,lex);

    catch
      when resume_error do resumelex(curr,lex,lex_scol,rl_skip,lex_end,rt_leave);
      end;

    until lex<>lex_scol;

  -- naposledy p©eátenò symbol vr†tit do vstupu
  ungetlex;
k1:
  end b_sequence;



----------------------------------------------------------------------------------------------------
procedure b_catch (
    curr           : in tcontext;                -- p©ekl†danò prvek
    list           : out bllist;                 -- seznam p©°kazñ
    info           : in blinfo) =                -- informace o prñbàhu analòzy
-- P©eklad á†sti CATCH.
----------------------------------------------------------------------------------------------------
var
  last             : pblwhen_m;                  -- posledn° uzel
  lex              : lexsym;                     -- lexik†ln° symbol
  pos              : lexposblock;                -- pozice

begin
  -- %%X P©i p©episov†n° do Flexu sjednotit s B_CASE, tam uë to d°ky TAG pñjde
  list.first:=nil;
  list.last:=nil;
  last:=nil;
  while ((last=nil) or (last^.ctype<>bct_others)) and checklex(curr,lex_when) loop
    -- pozice
    getlexpos(pos.b,ll_curr,false);

    -- vznikl novò uzel
    newnode(pblnode(last),info,bt_when_m);
    if list.first=nil
      then list.first:=last;
      else list.last^.next:=last;
      end if;
    list.last:=last;

    -- vòbàr nebo OTHERS
    if checklex(curr,lex_others)

      -- OTHERS
      then
        last^.ctype:=bct_others;

      -- seznam jmen
      else
        last^.ctype:=bct_choice;
        x_select(curr,last^.list,es_name);
        end if;

    -- DO
    if followlex(curr,lex_do) then
      ce^.seterror({CCERR=}000152,ce_x_do);
      ce^.loadpos;
      {%%RESUME ce^.raiseerror;}
      end if;

    -- pozice
    getlexpos(pos.e,ll_curr,true);

    -- nastavit pozici uzlu
    last^.setpos(bp_begin,pos);

    -- posloupnost p©°kazñ
    b_sequence(curr,last^.sub,info);
    end loop;
  end b_catch;



----------------------------------------------------------------------------------------------------
procedure b_body_sequence =
-- P©eklad sekvence p©°kazñ uvnit© bloku p©°kazñ.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice

begin
  -- sekvence p©°kazñ
  b_sequence(curr,bl^.sub,info);

  -- á†st CATCH
  if checklex(curr,lex_catch) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bcatch_pos,ll_curr);

    -- a p©eloëit sekvenci
    b_catch(curr,bl^.bcatch,info)
    end if;

  -- á†st ROLLBACK
  if checklex(curr,lex_rollback) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.brollback_pos,ll_curr);

    -- a p©eloëit sekvenci
    b_sequence(curr,bl^.brollback,info)
    end if;

  -- á†st COMMIT
  if checklex(curr,lex_commit) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bcommit_pos,ll_curr);

    -- a p©eloëit sekvenci
    b_sequence(curr,bl^.bcommit,info)
    end if;

  -- á†st LEAVE
  if checklex(curr,lex_leave) then
    -- zapamatovat si pozici, bude se hodit pro debug informace
    getlexposall(bl^.bleave_pos,ll_curr);

    -- a p©eloëit sekvenci
    b_sequence(curr,bl^.bleave,info)
    end if;

  -- pozice
  getlexposall(pos,ll_curr);

  -- nastavit pozici uzlu
  bl^.setpos(bp_end,pos);
  end b_body_sequence;



----------------------------------------------------------------------------------------------------
procedure b_body =
-- P©eklad bloku p©°kazñ.
----------------------------------------------------------------------------------------------------
var
  pos              : lexposblock;                -- pozice
  lex              : lexsym;                     -- lexik†ln° symbol

begin
  -- pozice
  getlexposall(pos,ll_curr);

  -- vznikl novò uzel
  newnode(pblnode(bl),info,bt_block);

  -- nastavit pozici uzlu
  bl^.setpos(bp_begin,pos);

  -- sekvence p©°kazñ
  b_body_sequence(curr,bl,info);
  end b_body;



end cb_parse;