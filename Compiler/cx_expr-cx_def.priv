----------------------------------------------------------------------------------------------------
module private {cx_expr.}cx_def =
-- Překladač Flexu.
-- Definice stromového tvaru výrazu a základní operace.
----------------------------------------------------------------------------------------------------
-- Ondra : 19.06.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cc_def.cc_gc;

----------------------------------------------------------------------------------------------------
class private expinfo =
-- informace o průběhu analýzy
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static init =
    -- Inicializace.
    ------------------------------------------------------------------------------------------------
    begin
      phase:=ep_syntax;
      typ:=_typ;
    --final:=_final;
      end init;

    end expinfo;



----------------------------------------------------------------------------------------------------
procedure newnode =
-- Vytvoření nového uzlu stromu.
----------------------------------------------------------------------------------------------------
begin
  -- alokovat paměť
  case ntype
    when nt_operator       do 
        new pexpoper(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_unary          do 
        new pexpunary(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_component      do 
        new pexpcomponent(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_imm            do 
        new pexpimm(node);
        c_garbage_collector.get_instance^.register_class(node);
        
    when nt_range          do 
        new pexprange(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_list           do 
        new pexplist(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_item           do 
        new pexpitem(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_index          do 
        new pexpindex(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_ref            do 
        new pexpref(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_deref          do 
        new pexpderef(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_attrib         do 
        new pexpattrib(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_aggregate      do 
        new pexpaggregate(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_callspec       do 
        new pexpcallspec(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_this           do 
        new pexpthis(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_interface_cast do 
        new pexpinterfacecast(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_current        do 
        new pexpcurrent(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_call           do 
        new pexplist(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_typecast       do 
        new pexplist(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_send           do 
        new pexplist(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_fake_tag       do 
        new pexpfaketag(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_call_rtl       do 
        new pexpcallrtl(node);
        c_garbage_collector.get_instance^.register_class(node);

    when nt_task_var_slot  do 
        new pexptaskvarslot(node);
        c_garbage_collector.get_instance^.register_class(node);

    --%%TECH NT_NONE se používá pro reprezentaci nezparsovatelných výrazů
    when nt_none           do 
        new pexpnode(node);
        c_garbage_collector.get_instance^.register_class(node);

    when others            do verify({VERIFY=}000012);
    end case;

  -- inicializovat
  node^.ntype:=ntype;
  node^.org:=info.phase;
  node^.zprac:=info.phase;
  end newnode;



----------------------------------------------------------------------------------------------------
procedure newnodex =
-- Jako NEWNODE, ale úroveň zpracování uzlu (EXPNODE.ZPRAC) nastaví na
-- minimum.
----------------------------------------------------------------------------------------------------
begin
  newnode(node,info,ntype);
  node^.zprac:=node^.zprac:first;
  end newnodex;



----------------------------------------------------------------------------------------------------
procedure newtree =
-- Vytvoření nového podstromu.
----------------------------------------------------------------------------------------------------
var
  p                : pexpnode;                   -- nový uzel

begin
  -- vytvořit uzel
  newnode(p,info,ntype);

  -- zařadit do stromu
  p^.sub:=node;
  node:=p;
  end newtree;



----------------------------------------------------------------------------------------------------
procedure derivenode =
-- Podle dodaného uzlu odvodí nový uzel.                                  
-- Převezme typ, druh zřetězení, pozici a příznaky. Dynamické atributy se nepřebírají.                                                               }
----------------------------------------------------------------------------------------------------
begin
  -- vytvořit uzel 
  newnode(node,info,ntype);

  -- převzít některé atributy 
  node^.t:=srcnode^.t;
  node^.concatkind:=srcnode^.concatkind;
  node^.nflags:=srcnode^.nflags;

  -- konstantní/nekonstantní, resp. konstanta v důsledku optimalizace
  if is_const
    then node^.nflags+nodeflagset:[nf_const];
    else node^.nflags-nodeflagset:[nf_const];
    end if;

  verify({VERIFY=}000833,node^.ntype<>nt_imm and nf_const in node^.nflags);

  -- převzít pozici                          
  srcnode^.getpos(node^.pos);
  end derivenode;
  


----------------------------------------------------------------------------------------------------
procedure lextobinaryoper =
-- Převede lexikální symbol na binární operátor
----------------------------------------------------------------------------------------------------
begin
  case lex
    -- přiřazení
    when lex_assign     do result:=op_assign;

    -- multiplikační operátory
    when lex_mul        do result:=op_mul;
    when lex_div        do result:=op_div;
    when lex_idiv       do result:=op_idiv;
    when lex_imod       do result:=op_imod;
    when lex_shl        do result:=op_shl;
    when lex_shr        do result:=op_shr;

    -- adiční operátory
    when lex_add        do result:=op_add;
    when lex_sub        do result:=op_sub;
    when lex_concat     do result:=op_concat;

    -- relační operátory
    when lex_eq         do result:=op_eq;
    when lex_ne         do result:=op_ne;
    when lex_lt         do result:=op_lt;
    when lex_le         do result:=op_le;
    when lex_gt         do result:=op_gt;
    when lex_ge         do result:=op_ge;
    when lex_in         do result:=op_in;
    when lex_not        do result:=op_notin;

    -- logické operátory
    when lex_and        do result:=op_and;
    when lex_or         do result:=op_or;
    when lex_xor        do result:=op_xor;
    when lex_then       do result:=op_and_then;
    when lex_else       do result:=op_or_else;

    -- jiné operátory neznám
    when others         do result:=op_none;
    end case;
  end lextobinaryoper;



----------------------------------------------------------------------------------------------------
procedure lextounaryoper =
-- Převede lexikální symbol na unární operátor.
----------------------------------------------------------------------------------------------------
begin
  case lex
    -- unární operátory s nejvyšší prioritou
    when lex_not        do result:=un_not;
    when lex_abs        do result:=un_abs;
    when lex_succ       do result:=un_succ;
    when lex_pred       do result:=un_pred;

    -- unární adiční operátory
    when lex_add        do result:=un_plus;
    when lex_sub        do result:=un_minus;

    -- jiné operátory neznám
    when others         do result:=un_none;
    end case;
  end lextounaryoper;



----------------------------------------------------------------------------------------------------
procedure setid (
    id             : out pentityident;           -- nově vytvořený identifikátor
    _id            : in tentityident) =          -- přiřazovaný identifikátor
-- Dosadí identifikátor.
----------------------------------------------------------------------------------------------------
begin
  -- alokovat paměť
  new id range _id:length;

  -- zaregistruj do globalniho gc
  c_garbage_collector.get_instance^.register_memblock(id);

  -- přiřadit identifikátor
  id^:=_id;
  end setid;



----------------------------------------------------------------------------------------------------
class private expnode =
-- Uzel
----------------------------------------------------------------------------------------------------
    
    var
      -- pozadovane runtime kontroly
      rchecks_required     : array t_runtime_check_class of t_runtime_check_set; 
      
      -- %%HYNEK - pouzit [rchecks_performed] pro nejake sikovne verify
      -- jiz provedene (vygenerovane) runtime kontroly
      -- rchecks_performed : array t_runtime_check_class of t_runtime_check_set; 
      
      -- typ proti kteremu je treba provest kontrolu mezi
      rcheck_range_type  : array t_runtime_check_class of typeview; 

    ------------------------------------------------------------------------------------------------
    static newtype =
    -- Vytvoří dočasný typ a doplní do něj implicitní hodnoty.
    ------------------------------------------------------------------------------------------------
    with
      cd_decl,cd_decl.cd_create;

    var
      p            : pentity_type;               -- typ
      p_context    : tcontext;                   -- kontext 

    begin
      -- vytvořit dočasný typ
      d_create_temporary_type(curr,p,p_context,stype,size);

      -- konec deklarace
      d_end_temporary_type(p^);

      -- a pohled na něj
      t.init(curr,p);
      end newtype;



    ------------------------------------------------------------------------------------------------
    static settype =
    -- Přiřadí výrazu typ.
    ------------------------------------------------------------------------------------------------
    begin
      t.init(curr,ptyp);
      end settype;



    ------------------------------------------------------------------------------------------------
    static settypeunchecked =
    -- Přiřadí výrazu Unchecked view typu.
    ------------------------------------------------------------------------------------------------
    begin
      t.initunchecked(ptyp);
      end settypeunchecked;



    ------------------------------------------------------------------------------------------------
    static setunchecked =
    -- Přiřadí typ výrazu UNCHECKED.
    ------------------------------------------------------------------------------------------------
    begin
      t:=ptyp;
      t.setunchecked;
      end setunchecked;



    ------------------------------------------------------------------------------------------------
    virtual gettype =
    -- INDEX-tý typ uzlu
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}000287,index<>0);
      typ:=^t;
      end gettype;



    ------------------------------------------------------------------------------------------------
    virtual gettypecount =
    -- Počet typů uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=1;
      end gettypecount;



    ------------------------------------------------------------------------------------------------
    virtual getsymbol =
    -- Symbol související s uzlem (je-li nějaký).
    ------------------------------------------------------------------------------------------------
    begin
      result:=nil;
      end getsymbol;



    ------------------------------------------------------------------------------------------------
    static loadpos =
    -- Nastaví pozici uzlu podle pozice posledního symbolu.
    ------------------------------------------------------------------------------------------------
    use
      cc_lex;

    begin
      if np_begin in npos then cc_lex.getlexpos(pos.b,level,false); end if;
      if np_end in npos then cc_lex.getlexpos(pos.e,level,true); end if;
      end loadpos;



    ------------------------------------------------------------------------------------------------
    static setpos =
    -- Nastaví pozici uzlu podle dodané pozice.
    ------------------------------------------------------------------------------------------------
    begin
      pos:=_pos;
      end setpos;



    ------------------------------------------------------------------------------------------------
    static setpospart =
    -- Nastaví pozici uzlu podle dodané pozice symbolu.
    ------------------------------------------------------------------------------------------------
    begin
      if np_begin in npos then pos.b:=_pos; end if;
      if np_end in npos then pos.e:=_pos; end if;
      end setpospart;



    ------------------------------------------------------------------------------------------------
    static getpos =
    -- Zjistí pozici výrazu.
    ------------------------------------------------------------------------------------------------
    use
      cc_lex;

    var
      p                : pexpnode;
      __pos            : lexposblock;

    begin
      -- %%X Nešlo by tenhle algoritmus nějak optimalizovat ?
      -- Například vědět, že nemá smysl prohledávat nějaké podstromy ?
      _pos.b:=pos.b;
      _pos.e:=pos.e;
      p:=sub;
      while p<>nil loop
        p^.getpos(__pos);
        if cc_lex.cmplexposb(__pos.b,_pos.b) then _pos.b:=__pos.b; end if;
        if cc_lex.cmplexposa(__pos.e,_pos.e) then _pos.e:=__pos.e; end if;
        p:=p^.next;
        end loop;
      end getpos;



    ------------------------------------------------------------------------------------------------
    override errpos =
    -- Dosadí pozici výrazu do posledního chybového hlášení.
    ------------------------------------------------------------------------------------------------
    with
      cc_def.cc_var;
      
    var
      _pos             : lexposblock;

    begin
      getpos(_pos);
      ce^.setpos(_pos);
      end errpos;



    ------------------------------------------------------------------------------------------------
    virtual dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if concatkind<>nck_unknown
        then result:="<" & nodeconcatkindtxt[concatkind] & ">";
        else result:='';
        end if;
      if rta_avail<>rtattribset:[] then
        result & "<";
        for rta in rtattrib loop
          if rta in rta_avail then
            if rta in rta_used
              then result & '+:' & rtattribtxt[rta] & ",";
              else result & '-:' & rtattribtxt[rta] & ",";
              end if;
            end if;
          end loop;
        result[result:length]:=">";
        end if;
      end dump;



    ------------------------------------------------------------------------------------------------
    static set_run_check =
    -- nastavi behovou kontrolu [check] na vyrazu
    -- zpusobi interni chybu pokud takova kontrola jiz nastavena
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}000715,rcheck in rchecks_required[rcheck_class]);
      
      -- %%TODO(SET) generovani kodu pridani promenne do mnoziny neni implementovano
      case rcheck 
        when rch_ordinal_overflow do rchecks_required[rcheck_class]+t_runtime_check_set:[rch_ordinal_overflow];
        when rch_ordinal_range    do rchecks_required[rcheck_class]+t_runtime_check_set:[rch_ordinal_range];
        when rch_index_string     do rchecks_required[rcheck_class]+t_runtime_check_set:[rch_index_string];
        when rch_index_array      do rchecks_required[rcheck_class]+t_runtime_check_set:[rch_index_array];
        when others do verify({VERIFY=}000716,true);
        end case;
      
      end set_run_check;



    ------------------------------------------------------------------------------------------------
    static get_run_checks =
    -- vrati mnozinu behovych kontrol vyrazu
    ------------------------------------------------------------------------------------------------
    begin
      result:=rchecks_required[rcheck_class];
      end get_run_checks;


    
    ------------------------------------------------------------------------------------------------
    static get_rangecheck_type =
    -- vrati typ kontroly mezi
    ------------------------------------------------------------------------------------------------
    begin
      result:=rcheck_range_type[rcheck_class];
      end get_rangecheck_type;



    ------------------------------------------------------------------------------------------------
    static set_rangecheck_type =              
    -- nastavi typ kontroly mezi
    ------------------------------------------------------------------------------------------------
    begin
      rcheck_range_type[rcheck_class]:=typ;
      end set_rangecheck_type;


    end expnode;



----------------------------------------------------------------------------------------------------
class private abstract expunary0 = 
-- Uzel s jedním podvýrazem.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýraz od uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýraz s uzlem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      sub^.next:=nil;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýraz uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      end get;

    end expunary0;



----------------------------------------------------------------------------------------------------
class private abstract expbinary0 = 
-- Uzel se dvěma podvýrazy.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýrazy od uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      el^.next:=nil;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s uzlem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      el^.next:=er;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýrazy uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      end get;

    end expbinary0;



----------------------------------------------------------------------------------------------------
class private expambiguous =
-- Uzel s nejednoznačně určeným typem
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static addtype =
    -- Do tabulku typů přidá zadaný typ (i kdyby byl redundantní).
    ------------------------------------------------------------------------------------------------
    type
      p_machine_pointer = ^unchecked for machine_pointer use true;

    var
      _tlist       : tlist:type;
      x            : ^tlist^:base;

    begin
      if not set0 {tlist=nil or else tlist^:length=0}

        -- nultý typ se ukládá jinak
        then
          t:=typ;
          el0:=el;
          er0:=er;
          psym0:=psym;
          set0:=true;

        -- ostatní typy do pole
        else
          -- realokovat paměť
          if tlist=nil then
            new tlist range tlistinit;
          elsif tlist^:length=tlist^:last then
            --%%TODO(ADJUST) adjust tlist range tlist^:last+tlistdelta;
            new _tlist range tlist^:last+tlistdelta;
            _tlist^:=tlist^;
            discard tlist;
            tlist:=_tlist;
            end if;

          -- doplnit údaje %%TODO(AGGREGATE) %%TODO(STRING_ADJUST)        
          new x;
          x^.t:=typ;
          x^.el:=el;
          x^.er:=er;
          x^.psym:=psym;
          tlist^ & x^;
          discard p_machine_pointer(x);
          end if;
      end addtype;



    ------------------------------------------------------------------------------------------------
    procedure checktype =
    -- True, má-li výraz přiřazen typ, se kterým souvisí zadaný symbol.
    ------------------------------------------------------------------------------------------------
    begin
      result:=false;

      -- odpovídá hned pro nultý typ
      if set0 and psym0=psym then
        result:=true;

      -- zkoumat dál
      elsif tlist<>nil then
        for i in tlist^:range loop
          if tlist^[i].psym=psym then
            result:=true;
            return;
            end if;
          end loop;
        end if;
      end checktype;



    ------------------------------------------------------------------------------------------------
    override gettype =
    -- INDEX-tý typ uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if index=0
        then typ:=^t
        else 
          verify({VERIFY=}000286,(tlist=nil) or else (index>tlist^:length));
          typ:=^tlist^[index].t;
          end if;
      end gettype;



    ------------------------------------------------------------------------------------------------
    static gettypeinfo =
    -- INDEX-tý typ uzlu včetně doplňkových informací.
    ------------------------------------------------------------------------------------------------
    begin
      if index=0
        then
          typ:=^t;
          eli:=el0;
          eri:=er0;
          psym:=psym0;
        else
          verify({VERIFY=}000295,(tlist=nil) or else (index>tlist^:length));
          typ:=^tlist^[index].t;
          eli:=tlist^[index].el;
          eri:=tlist^[index].er;
          psym:=tlist^[index].psym;
          end if;
      end gettypeinfo;



    ------------------------------------------------------------------------------------------------
    static gettypesym =
    -- Symbol související s INDEX-tým typem uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if index=0
        then psym:=psym0
        else
          verify({VERIFY=}000298,(tlist=nil) or else (index>tlist^:length));
          psym:=tlist^[index].psym;
          end if;
      end gettypesym;



    ------------------------------------------------------------------------------------------------
    static gettypeorigin =
    -- Zdrojové typy související s INDEX-tým typem uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if index=0
        then
          eli:=el0;
          eri:=er0;
        else
          verify({VERIFY=}000300,(tlist=nil) or else (index>tlist^:length));
          eli:=tlist^[index].el;
          eri:=tlist^[index].er;
          end if;
      end gettypeorigin;



    ------------------------------------------------------------------------------------------------
    override gettypecount =
    -- Počet typů uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=(set0=true):ord;
      if tlist<>nil then
        result+tlist^:length;
        end if;
      end gettypecount;



    ------------------------------------------------------------------------------------------------
    static resolve =
    -- Zvolí INDEX-tý typ jako definitivní.
    ------------------------------------------------------------------------------------------------
    begin
      verify({VERIFY=}000288,index>0 and then (tlist=nil or else index>tlist^:length));

      -- zkopírovat
      if index>0 then
        t:=tlist^[index].t;
        el0:=tlist^[index].el;
        er0:=tlist^[index].er;
        psym0:=tlist^[index].psym;
        end if;

      -- zrušit seznam typů
      discard tlist;

      -- vyhodnoceno
      resolved:=true;
      end resolve;



    ------------------------------------------------------------------------------------------------
    static isresolved =
    -- True, má-li uzel přiřazen definitivní typ.
    ------------------------------------------------------------------------------------------------
    begin
      result:=resolved;
      end isresolved;

    end expambiguous;



----------------------------------------------------------------------------------------------------
class private expnoper =
-- Obecný operátor
----------------------------------------------------------------------------------------------------

    end expnoper;



----------------------------------------------------------------------------------------------------
class private expoper =
-- Operátor
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static setoper =
    -- Dosadí do uzlu operátor.
    ------------------------------------------------------------------------------------------------
    begin
      oper:=_oper;
      assign:=_assign;
      end setoper;



    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      el^.next:=nil;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      el^.next:=er;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      -- operátor
      result & expopertxt[oper];
      if assign then 
        result & ' (:=)'; 
        end if;
      end dump;



    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializace
    ------------------------------------------------------------------------------------------------
    begin
      arity:=eoa_2;
      end entry;

    end expoper;



----------------------------------------------------------------------------------------------------
class private expunary =
-- Unární operátor
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static setoper =
    -- Dosadí do uzlu operátor.
    ------------------------------------------------------------------------------------------------
    begin
      oper:=_oper;
      assign:=_assign;
      end setoper;



    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      sub^.next:=nil;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      -- operátor
      result & expunarytxt[oper];
      if assign then result & ' (:=)'; end if;
      end dump;



    ------------------------------------------------------------------------------------------------
    entry =
    -- Inicializace
    ------------------------------------------------------------------------------------------------
    begin
      arity:=eoa_1;
      end entry;

    end expunary;



----------------------------------------------------------------------------------------------------
class private expcomponent =
-- Komponenta
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static setid =
    -- Dosadí do komponenty její identifikátor.
    ------------------------------------------------------------------------------------------------
    begin
      current module.setid(id,_id);
      end setid;



    ------------------------------------------------------------------------------------------------
    override getsymbol =
    -- Symbol související s uzlem (je-li nějaký).
    ------------------------------------------------------------------------------------------------
    begin
      result:=s.psym;
      end getsymbol;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- komponenta
      if id=nil
        then result:='?'
        else
          result:=this:as_ancestor.dump;
          if sub=nil
            then result & entityident_to_string(id^);
            else result & "." & entityident_to_string(id^);
            end if;
          end if;
      end dump;

    end expcomponent;



----------------------------------------------------------------------------------------------------
class private expimm =
-- Přímá hodnota (konstanta)
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    with
      cx_imm;

    var
   {%%TODO(LIB)
      x                : treal;
   }
      s                : t_char32str;

    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      case imm.ic
        -- ordinalni hodnota
        when ic_ordinal   do {%%TODO(LIB) result & linttostr(imm.ui,luniint)};

        -- realne cislo
        when ic_real      do
          {%%TODO(LIB)
            urtox(imm.ur,x);
            result & floattostr(x);
          }
        -- kondenzované pole
        when ic_condensed do
            load_sysstr(imm,s);
            result & "'" & s & "'";

        -- agregát pole
        when ic_array     do result & '<array>';

        -- agregát recordu
        when ic_record    do result & '<record>';

        -- agregát množiny
        when ic_set       do result & '<set>';

        -- NIL
        when ic_nil       do result & 'NIL';

    --  -- bin
    --  when ic_bin       do result & '<binary>';

    --  -- relo
    --  when ic_relo      do result & '<symbol>';

        when others       do verify({VERIFY=}000258,true);
        end case;
      end dump;

    end expimm;



----------------------------------------------------------------------------------------------------
class private exprange =
-- Rozsah
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      el^.next:=nil;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      el^.next:=er;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      -- rozsah
      result & '..';
      end dump;

    end exprange;



----------------------------------------------------------------------------------------------------
class private explist =
-- Seznam výrazů
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    begin
      if qualified
        then
          el:=sub;
          arglist:=pexpitem(sub^.next);
          el^.next:=nil;
          sub:=nil;
        else
          el:=nil;
          arglist:=pexpitem(sub);
          sub:=nil;
          end if;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    begin
      if qualified
        then
          sub:=el;
          el^.next:=arglist;
        else
          verify({VERIFY=}000218,el<>nil);
          sub:=arglist;
          end if;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí prefix a argumenty.
    ------------------------------------------------------------------------------------------------
    begin
      if qualified
        then
          el:=sub;
          arglist:=pexpitem(sub^.next);
        else
          el:=nil;
          arglist:=pexpitem(sub);
          end if;
      end get;



    ------------------------------------------------------------------------------------------------
    static getarglist =
    -- Vrátí argumenty.
    ------------------------------------------------------------------------------------------------
    begin
      if qualified
        then arglist:=pexpitem(sub^.next)
        else arglist:=pexpitem(sub);
        end if;
      end getarglist;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:=this:as_ancestor.dump;
      if qualified
        then result & ': ( )';
        else result & '( )';
        end if;
      end dump;

    end explist;


----------------------------------------------------------------------------------------------------
class private exptaskvarslot =
-- Taskova promenna
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:='task var slot';
      end dump;
    
    end exptaskvarslot;


----------------------------------------------------------------------------------------------------
class private expitem =
-- Položka seznamu výrazů
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static setid =
    -- Dosadí do položky její identifikátor.
    ------------------------------------------------------------------------------------------------
    begin
      current module.setid(id,_id);
      end setid;



    ------------------------------------------------------------------------------------------------
    override getsymbol =
    -- Symbol související s uzlem (je-li nějaký).
    ------------------------------------------------------------------------------------------------
    begin
      result:=sym;
      end getsymbol;



    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      el^.next:=nil;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      el^.next:=er;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      end get;



    ----------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ----------------------------------------------------------------------------------------------------
    begin
      result:=this:as_ancestor.dump;
      case itype
        when ei_empty  do result & '<implicitni>';
        when ei_expr   do ;
        when ei_ident  do result & 'for ' & entityident_to_string(id^) & ' use';
        when ei_choice do result & 'for .. use';
        when ei_others do result & 'for others use';
        when others    do verify({VERIFY=}000217,true);
        end case;
      end dump;

    end expitem;



----------------------------------------------------------------------------------------------------
class private expindex =
-- Selektor pole
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýrazy od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      el^.next:=nil;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      el^.next:=er;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýrazy operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      er:=sub^.next;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    -------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump & '[ ]';
      end dump;

    end expindex;



----------------------------------------------------------------------------------------------------
class private expref =
-- Reference
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      sub^.next:=nil;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      -- operátor
      result:='(ref) ^' & result;
      end dump;

    end expref;



----------------------------------------------------------------------------------------------------
class private expderef =
-- Dereference
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static split =
    -- Oddělí podvýraz od operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      sub:=nil;
      end split;



    ------------------------------------------------------------------------------------------------
    static join =
    -- Sloučí podvýrazy s operátorem.
    ------------------------------------------------------------------------------------------------
    begin
      sub:=el;
      sub^.next:=nil;
      end join;



    ------------------------------------------------------------------------------------------------
    static get =
    -- Vrátí podvýraz operátoru.
    ------------------------------------------------------------------------------------------------
    begin
      el:=sub;
      end get;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      -- dump předka
      result:=this:as_ancestor.dump;

      -- operátor
      result & '^ (deref)';
      end dump;

    end expderef;



----------------------------------------------------------------------------------------------------
class private expattrib =
-- Atribut
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    static setid =
    -- Dosadí identifikátor atributu.
    ------------------------------------------------------------------------------------------------
    begin
      current module.setid(id,_id);
      end setid;



    ------------------------------------------------------------------------------------------------
    override getsymbol =
    -- Symbol související s uzlem (je-li nějaký).
    ------------------------------------------------------------------------------------------------
    begin
      result:=xsym;
      end getsymbol;



    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if id=nil
        then result:=':?';
        else result:=":" & entityident_to_string(id^);
        end if;
      result & ' (' & tattrclasstxt[aclass] & ")";
      end dump;

    end expattrib;



----------------------------------------------------------------------------------------------------
class private expaggregate =
-- Agregát
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      if qualified
        then result:='type : [ ]'
        else result:='anonymous : [ ]';
        end if;
      end dump;

    end expaggregate;



----------------------------------------------------------------------------------------------------
class private expinterfacecast =
-- Přetypování na interface.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:='interface : ( )'
      end dump;

    end expinterfacecast;



----------------------------------------------------------------------------------------------------
class private expcallspec =
-- Volání speciální metody
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:='call ' & entityident_to_string(tspectypetxt[spectype]);
      end dump;

    end expcallspec;



----------------------------------------------------------------------------------------------------
class private expcallrtl =
-- Přímé volání funkce RTL.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    var
      id           : pentityident;

    begin
      cc_base.cc_rtl.rtl_get_entity_id(rtl_proc,id);
      result:='call ' & entityident_to_string(id^);
      end dump;

    end expcallrtl;



----------------------------------------------------------------------------------------------------
class private expthis =
-- THIS
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:='THIS';
      end dump;

    end expthis;



----------------------------------------------------------------------------------------------------
class private expcurrent =
-- CURRENT
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    override dump =
    -- Dump uzlu.
    ------------------------------------------------------------------------------------------------
    begin
      result:='CURRENT';
      end dump;

    end expcurrent;



----------------------------------------------------------------------------------------------------
class private expfaketag =
-- Fake tag interfacu třídy.
----------------------------------------------------------------------------------------------------

    end expfaketag;



----------------------------------------------------------------------------------------------------
procedure dumptree =
-- Dump stromu na obrazovku.                                                  
----------------------------------------------------------------------------------------------------
with
  standard.conversions;

use
  cc_debug;

var
  cont             : set of t_unsigned8;         -- pro které urovně kreslit pokračovací čáry

    ------------------------------------------------------------------------------------------------
    procedure dump (
        level      : in t_unsigned8;             -- uroven vnoreni
        _expr      : in pexpnode) =              -- vyraz
    -- Vypis rozlozeneho vyrazu.
    ------------------------------------------------------------------------------------------------
    with
      advanced,
      advanced.low_level,
      advanced.low_level.bit_operations;

        --------------------------------------------------------------------------------------------
        procedure gettypedesc (
            t      : in typeview;
            eli    : in typeindex;
            eri    : in typeindex;
            psym   : in pentity)
            return t_char32str =
        --------------------------------------------------------------------------------------------
        var
          p            : pentity_type;

        begin
          case t.tview
            when tview_null       do result:='';
            when tview_aggregate  do result:='(aggregate)';
            when tview_incomplete do result:='(incomplete)';
            when tview_partial    do result:='(partial)';
            when tview_full       do
                result:='';
                if t.stype<>dt_undef then
                  -- jméno typu
                  p:=t.getutype;
                  if (p<>nil) and (p^.id<>nil)
                    then result:=entityident_to_string(p^.id^)
                    else
                      result:=tdatatypetxt[t.stype];
                      if t.stype in dts_ordinal then
                        result & " " & unsigned_to_string(unidata_bitsize_to_unsigned(t.getbits));
                      elsif t.stype=dt_string then
                        result & " " & unsigned_to_string(uniint_to_unsigned(t.getctype()^.srange.getctype()^.hval));
                        end if;
                      end if;
                  end if;
            when tview_unchecked  do result:=':unchecked';
            when others           do result:='';
            end case;

          if (eli<>0) or (eri<>0) then
            result & ', [' & unsigned_to_string(eli) & "," & unsigned_to_string(eri) & "]";
            end if;

          if (psym<>nil) and (psym^.id<>nil) then
            result & ', ' & entityident_to_string(psym^.id^);
            end if;
          end gettypedesc;

    var
      s            : t_char32str;
      prefix       : t_char32str;
      pt           : ptypeview;
      eli          : typeindex;
      eri          : typeindex;
      psym         : pentity;
      expr         : pexpnode;

    begin
      expr:=_expr;
      while expr<>nil loop
        s:='';
        -- zobrazit hrany grafu 
        if level>0 then
          for i in 1..level-1 loop
            if i in cont
              then s & '| '
              else s & '  ';
              end if;
            end loop;
          end if;

        if level>0
          then prefix:=s & ' '
          else prefix:=s;
          end if;
        if expr^.sub<>nil
          then prefix & '+- '
          else prefix & '   ';
          end if;

        if level>0 then
          if expr^.next<>nil
            then
              s & '+-';
              --%%TODO(UNION) sjednocení množin pro T:size>4 ještě neumíme
              --cont+cont:type:[level];
              bit_set(cont,t_bit_index(level));
            else
              s & '+-';
              --%%TODO(UNION) rozdíl množin pro T:size>4 ještě neumíme
              --cont-cont:type:[level];
              bit_reset(cont,t_bit_index(level));
              end if;
          end if;
        s & 'o ';

        -- zobrazit základ uzel
        s & expr^.dump;

        -- uzel s jednoznačným typem
        if expr^.ntype not in nts_ambiguous then
          s & ', ' & gettypedesc(expr^.t,0,0,nil);

        -- potenciálně nejednoznačný uzel s jedním typem
        elsif pexpambiguous(expr)^.gettypecount=1 then
          pexpambiguous(expr)^.gettypeinfo(0,pt,eli,eri,psym);
          s & ', ' & gettypedesc(pt^,eli,eri,psym);
          end if;

        cc_debug.debug_dump(s);

        -- uzel s nejednoznačným typem
        if (expr^.ntype in nts_ambiguous) and (pexpambiguous(expr)^.gettypecount>1) then
          for i in 0..pexpambiguous(expr)^.gettypecount-1 loop
            pexpambiguous(expr)^.gettypeinfo(i,pt,eli,eri,psym);
            cc_debug.debug_dump(prefix & unsigned_to_string(i) & ': ' & gettypedesc(pt^,eli,eri,psym));
            end loop;
          end if;

        -- zobrazit podgraf 
        dump(level+1,expr^.sub);

        -- prejit na sousedni uzel 
        expr:=expr^.next;
        end loop;
      end dump;

begin
  cont:=cont:full;
  dump(0,expr_);
  dumptree_xml(expr_);
  end dumptree;



----------------------------------------------------------------------------------------------------
procedure dumptree_xml =
-- Dump stromu na obrazovku ve tvaru XML.
----------------------------------------------------------------------------------------------------
{
with
  standard.console,
  cc_io.cc_xml.cc_expr;

var
  xml              : aliased c_expr_dumper;      -- XML zapisovač
}
begin
{
  -- připravit XML zapisovač
  xml.init_2_temporary_name(console_output,-1);

  -- dumpnout
  dump_expression_to_xml(expr,^xml);
}
  end dumptree_xml;



----------------------------------------------------------------------------------------------------
procedure node_catch_resume_error =
-- Vrátí, zda zachytávat výjimky typu resume_error v uzlu
----------------------------------------------------------------------------------------------------
begin
  -- zpracovat vyjímku
  case catch_mode
    -- vyjímka se má zachytit
    when catch_mode_catch do result:=true;

    -- vyjímka se má znovu vyvolat
    when catch_mode_raise do result:=false;

    -- znovuvyvolání výjimky závisí na typu uzlu
    when catch_mode_implicit do result:=node_type in nodetypeset:[];
    end case;    
  end node_catch_resume_error;



----------------------------------------------------------------------------------------------------
#separate private c_expr_iterator;
-- Iterátor
----------------------------------------------------------------------------------------------------

end cx_def;
