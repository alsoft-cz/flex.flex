----------------------------------------------------------------------------------------------------
module private ci_fragment =
-- Překladač Flexu.
-- Metody na generování různých fragmentů kódu.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.01.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  ci_code,
  ci_code.ci_operand,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_reg,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_32.cp_util;

----------------------------------------------------------------------------------------------------
#separate private ci_rta;
-- Manipulace s run-time atributy.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure new_address_register (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    op             : in c_operand;               -- původní operand
    vysl           : out c_operand;              -- alokovaný registr
    pref_reg       : in iunireg;                 -- preferovaný registr
    no_dependance  : in t_logical := false) =    -- zvolit registr nezávislý na původním operandu
-- Alokuje nový registr. Pokud je nastaven preferovaný registr, použije přednostně ten, jinak se
-- při vypnutém [no_dependance] aspoň pokusí recyklovat registr ze zdrojového operandu. Elementární 
-- datový typ nastaví na [edt_address], velikost na 4.
----------------------------------------------------------------------------------------------------
begin
  -- %%X Hnusná záplata: Tato procedura v nejnevhodnějších situacích při zřetězování řetězců žrala 
  -- registr ESI a pak to padalo někde v alokátoru registrů, protože ho nedokázal přemapovat, 
  -- přestože byl registr mezi tím odswapován na stack. Vyřešil jsem to tak, že se registr alokuje
  -- jakoby datový uvedením elementárního datového typu [edt_unsigned] (resp. jakéhokoliv jiného než
  -- [edt_address]) a na závěr se změní na správný [edt_address].

  -- použít konkrétní preferovaný registr
  if pref_reg<>in_none then 
    vysl.create_use_register(inst,info,context,edt_unsigned,iunitoreg[pref_reg,4]);

  -- registr nezávislý na původním operandu
  elsif no_dependance then
    vysl.create_new_register(inst,info,context,edt_unsigned,4);
    verify({VERIFY=}001066,vysl.depends_on(op));

  -- registr s možností recyklace
  else 
    vysl.create_new_register_from_operand(inst,info,context,edt_unsigned,4,op);
    end if;

  -- %% Konec hnusné záplaty: Zde se nastaví skutečný elementární datový typ operandu.
  vysl.adjust_edtype(edt_address);
  end new_address_register;



----------------------------------------------------------------------------------------------------
-- Primitiva pro výběr adresy nebo hodnoty.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_ensure_address =
-- Zajistí, že operand reprezentuje adresu hodnoty uložené v paměti.
----------------------------------------------------------------------------------------------------
begin
  -- operand již reprezentuje absolutní adresu => nedělat nic
  if op.edtype=edt_address then
    -- kontrola konzistence (absolutní adresa může být uložena v registru, jako přímá hodnota
    -- nebo dokonce jako adresa v paměti například v případě proměnných s módem [vm_ref])
    verify({VERIFY=}000863,op.optype not in t_operand_type_set:[io_imm,io_reg,io_mem]);

  -- operand reprezentuje hodnotu => zjistit, jestli není potřeba použít pracovní proměnnou
  elsif op.edtype in edts_value then
    case op.optype
      -- adresa hodnoty => načíst adresu do registru
      when io_mem do
          -- načíst adresu do registru
          i_gen_load_address_to_register(inst,info,context,op);

      -- přímo uvedená hodnota => přiřadit do pracovní proměnné
      when io_reg, io_imm, io_cc do
          -- alokovat pracovní proměnnou
          i_gen_load_value_to_temporary(inst,info,context,op);
          verify({VERIFY=}000875,op.optype<>io_mem);

          -- načíst adresu do registru
          i_gen_load_address_to_register(inst,info,context,op);

      -- %%X a co [io_stack] ? asi naprogramovat, až to bude poprvé potřeba

      -- nic jiného tu nemá co dělat
      when others do verify({VERIFY=}000864,true);
      end case;

  -- nic jiného tu nemá co dělat
  else
    verify({VERIFY=}000865,true);
    end if;
  end i_ensure_address;



----------------------------------------------------------------------------------------------------
procedure i_ensure_value =
-- Zajistí, že operand reprezentuje hodnotu.
----------------------------------------------------------------------------------------------------
begin
{ Jestliže procedura generující podvýraz předala ven adresu, měla pro to určitě dobrý důvod
  a tudíž se to do nějakého zpracování hodnoty nemělo vůbec dostat, ne?

  -- operand reprezentuje absolutní adresu => převést na adresní operand reprezentující hodnotu
  if op.edtype=edt_address then
    case op.optype
      -- přímá hodnota => převést na paměťovou adresu
      when io_imm do op.transform_imm_to_mem();

      -- registr => převést na paměťovou adresu
      when io_reg do op.transform_reg_to_mem();

      -- nic jiného tu nemá co dělat
      when others do verify({VERIFY=}000866,true);
      end case;
}
  -- operand již reprezentuje hodnotu => zjistit, jestli není potřeba použít pracovní proměnnou
  if op.edtype in edts_value then
    -- kontrola konzistence
    verify({VERIFY=}000867,op.optype not in t_operand_type_set:[io_imm,io_reg,io_mem,io_cc,io_stack]);

  -- nic jiného tu nemá co dělat
  else
    verify({VERIFY=}000868,true);
    end if;
  end i_ensure_value;



----------------------------------------------------------------------------------------------------
procedure do_dereference (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    op             : in out c_operand;           -- operand
    pref_reg       : in iunireg := in_none;      -- preferovaný registr
    no_dependance  : in t_logical := false) =    -- zvolit registr nezávislý na původním operandu
-- Provede dereferenci. Očekává, že dodaný operand reprezentuje adresu ([io_mem]) reference/pointeru.
-- Načtenou adresu uloží do registru, který vrátí v [op]. Původní operand je zrušen.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek

begin
  -- alokovat registr
  new_address_register(inst,info,context,op,vysl,pref_reg,for no_dependance use no_dependance);

  -- z celého pointeru nás zajímá jen a pouze adresa
  op.adjust_size(4);

  -- načíst adresu do registru
  addii(inst,info,ii_mov,vysl,op,op0);

  -- předat výsledek
  op.replace(info,context,vysl);

leave
  -- uvolnit pracovní operand
  vysl.free(info,context);
  end do_dereference;



----------------------------------------------------------------------------------------------------
procedure i_choose_reference_or_value =
-- Podle módu načtení výrazu zajistí správný pohled na objekt: buď coby jeho adresu (resp. adresu
-- reference na něj) s případnými run-time atributy, nebo jako hodnotu. Jestliže je požadována 
-- hodnota a je nastaveno [deref] na True, provede se dereference, přičemž se run-time atributy 
-- stanou nedostupnými.
--   Pokud je požadována hodnota, nastaví se elementární datový typ operandu a jeho velikost podle
-- dodaného parametru [value_edtype] resp. [value_size].
----------------------------------------------------------------------------------------------------
with
  ci_fragment.ci_rta;

begin
  -- co chceme?
  if context.mode in lms_addr

    -- adresu => započítat run-time atributy
    then
      -- doplnit informace o run-time atributech
      for rta in rta_modes:range loop
        op.set_rta_mode(rta,rta_modes[rta]);
        end loop;

      -- z operandu se odteď bude vyšší vrstva snažit odvodit adresu hodnoty, takže případný
      -- dereferencovatelný pointer již normalizovat na adresu, ať jí usnadníme práci
      if deref then
        if op.edtype=edt_pointer then
          op.adjust_edtype(edt_address);
          end if;
        verify({VERIFY=}000960,op.edtype<>edt_address);
        end if;

    -- hodnotu nebo přirozený tvar
    else
      -- znamená to, že máme provést dereferenci ?
      if deref
        
        -- ano, dereferencovat
        then         
          -- uživatel jistě dodal elementární datový typ hodnoty
          verify({VERIFY=}000965,value_edtype=edt_none);

          -- když máme dereferencovat, musí být samozřejmě co
          verify({VERIFY=}000883,op.edtype not in edts_pointer);

          -- provést vlastní dereferenci
          do_dereference(inst,info,context,op);

          -- zkonvertovat registr na adresní operand
          op.transform_reg_to_mem(value_edtype,value_size);

        -- ne, již to je hodnota, ještě opravit její typ a velikost
        else
          -- jestliže uživatel typ a velikost nedodal, necháme to tak, už si je zřejmě vyplnil dříve
          if value_edtype<>edt_none then
            op.adjust_edtype(value_edtype);
            op.adjust_size(value_size);
            end if;
          end if;

      -- z dodaných informací o run-time atributech nás zajímají jen ty, které nejsou efektivně
      -- uložené v adrese
      for rta in rta_modes:range loop      
        if i_rta_get_effective_mode(rta,rta_modes)<>rtm_stored_in_address
          -- atribut efektivně uložený mimo adresu => ok, použít dodaný mód
          then op.set_rta_mode(rta,rta_modes[rta]);
          -- něco jiného => atribut nelze zjistit
          else op.set_rta_mode(rta,rtm_invalid);
          end if;
        end loop;
      end if;
  end i_choose_reference_or_value;


{
----------------------------------------------------------------------------------------------------
procedure i_perform_dereference =
-- Je-li dodaný registr adresa reference na hodnotu, ta provede dereferenci. Reference se pozná tak,
-- že operand je typu [io_mem] a má nastaven elementární datový typ [edt_address]. Ve všech 
-- ostatních případech ponechá operand beze změny.
----------------------------------------------------------------------------------------------------
begin
  if op.edtype=edt_address and op.optype=io_mem then
    do_dereference(inst,info,context,op,value_edtype,value_size);
    end if;
  end i_perform_dereference;
}


----------------------------------------------------------------------------------------------------
-- Mid-level primitiva pro ukládání hodnot a adres.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure get_destination_rta_set (
    context        : in iexprcontext;            -- kontext generování výrazu
    out_rta        : out rtattribset;            -- cílová množina run-time atributů
    out_size       : out t_unsigned) =           -- velikost cílového pointeru/adresy
-- Podle kontextu zvolí cílovou množinu run-time atributů a určí velikost pointeru
-- Pro režimy načtení hodnoty musí být typ výsledku pointer a použijí se v něm uložené run-time
-- atributy, pro režimy načtení adresy se použije množina [context.rta].
----------------------------------------------------------------------------------------------------
begin
  -- režimy načtení adresy
  if context.mode in lms_addr then
    -- zvolit atributy
    out_rta:=context.rta;

    -- velikost
    declare var
      i            : timm32;

    begin
      -- určit velikost atributů
      getrtattribsetsize(out_rta,i);

      -- celkovou velikost tvoří velikost pointeru a run-time atributů
      out_size:=imm32_to_unsigned(i)+4;
      end declare;

  -- režimy načtení hodnoty
  elsif context.mode in lms_value+iexprloadmodeset:[lm_gen] then
    verify({VERIFY=}001069,context.outtyp.stype<>dt_pointer);
    
    -- zvolit atributy
    out_rta:=context.outtyp.pattrib;

    -- velikost
    out_size:=unidata_size_to_imm32(context.outtyp.size);

  -- jiné režimy na tomto místě nepodporujeme
  else
    verify({VERIFY=}001068);
    end if;
  end get_destination_rta_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_store_address =
-- Uloží adresu do zadaného cíle. [op] na výstupu reprezentuje cíl.
----------------------------------------------------------------------------------------------------
with
  ci_rta;

var
  vysl             : c_operand;                  -- operand reprezentující výsledek
  out_rta          : rtattribset;                -- cílová množina run-time atributů
  out_size         : t_unsigned;                 -- velikost cílového bloku

begin
  -- zvolit cílovou množinu run-time atributů
  get_destination_rta_set(context,out_rta,out_size);

  case destination
    -- uložení adresy (pointeru) na stack
    when tsd_stack     do 
        -- směrem odzadu budeme pushovat na stack run-time atributy
        for rta in reverse rtattrib loop
          if rta in out_rta{context.outtyp.pattrib} then
            i_rta_push(inst,info,context,op,rta);
            end if;
          end loop;

        -- na závěr pushnout vlastní adresu
        declare var
          opaddr   : c_operand;                  -- pomocný registr

        begin
          -- připravit si alias k adrese zahrnující pouze adresu
          opaddr.clone(inst,info,context,op);
          opaddr.adjust_size(4);

          -- uložit na stack
          addii(inst,info,ii_push,opaddr,op0,op0);

        leave
          -- uvolnit pomocné operandy
          opaddr.free(info,context);
          end declare;

        -- zkonstruovat výsledek
        vysl.create_on_stack(edt_address,out_size{unidata_size_to_unsigned(context.outtyp.size)});

    -- uložení adresy (pointeru) do temporary proměnné
    when tsd_temporary do
        -- alokovat temporary proměnnou
        vysl.create_temporary(inst,info,op.edtype,out_size{unidata_size_to_unsigned(context.outtyp.size)}{op.size});

        -- uložit pointer
        i_gen_store_pointer(inst,info,context,op,vysl);
    end case;
  
  -- nahradit zdrojový operand výsledkem
  op.replace(info,context,vysl);

leave
  -- uvolnit již nepotřebný výsledek
  vysl.free(info,context);
  end i_gen_store_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_store_value =
-- Uloží hodnotu do zadaného cíle. [op] na výstupu reprezentuje cíl.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}001067,op.edtype not in edts_value);

  -- věci, které patří na stack i již na něm jsou, se nemusí nikam kopírovat
  if destination=tsd_stack and op.optype=io_stack then
    --if op.edtype=edt_pointer
    return;
    end if;

  if op.edtype=edt_pointer

    -- pointer se kvůli run-time atributům musí řešit zvlášť
    then 
      i_gen_store_address(inst,info,context,op,destination);
{
      declare var
        optemp     : c_operand;                  -- pracovní paměť

      begin
        -- připravit paměť pro pointer
        case destination
          -- na stack
          when tsd_stack     do i_gen_stack_top_alloc(inst,info,context,edt_pointer,unidata_size_to_unsigned(context.outtyp.size),optemp);
          
          -- do dočasné proměnné
          when tsd_temporary do optemp.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(context.outtyp.size));
          end case;

        -- uložit do připravené paměti
        i_gen_store_pointer(inst,info,context,op,optemp);

        -- jestliže je cílem pracovní proměnná, tak předat ven
        if destination=tsd_temporary then
          op.replace(info,context,optemp);
          end if;

      leave
        -- uvolnit pracovní operand
        optemp.free(info,context);
        end declare;
}
    -- všechny ostatní druhy hodnot standardním způsobem
    else
      -- konverze hodnoty, je-li to potřeba
      if destination in t_store_destination_set:[tsd_stack,tsd_temporary] and then context.rsize<>op.size then
        i_gen_load_value_to_register(inst,info,context,orgtyp,op);
        end if;

      -- uložit do cíle
      case destination
        when tsd_stack        do i_gen_push_value(inst,info,context,op);
        when tsd_temporary    do i_gen_load_value_to_temporary(inst,info,context,op);
    {
    --     when tsd_stack     do i_gen_pushstack(inst,info,context,op);
    --     when tsd_temporary do i_gen_loadtemp(inst,info,context,op);
    }
        end case;
      end if;
  end i_gen_store_value;



----------------------------------------------------------------------------------------------------
#template generate_store_pointer (
    out_rta,                                     -- cílová množina run-time atributů
    opsrc,                                       -- zdrojový operand (například pointer)
    opdst,                                       -- cílový pointer
    copy_address_fragment);                      -- fragment kódu pro zkopírování adresy
-- Schéma pro sestavení pointeru.
----------------------------------------------------------------------------------------------------
  declare var
    oppart           : c_operand;                  -- složka cílového pointeru

  begin
    -- s cílem budeme pracovat po 4bytových složkách
    oppart.clone(inst,info,context,opdst);
    oppart.adjust_size(4);

    -- zkopírovat adresu
    copy_address_fragment

    -- uložit run-time atributy
    for rta in rtattrib loop
      if rta in out_rta{context.outtyp.pattrib} then
        -- zase o kousek posunout ukazatel do temporary proměnné
        oppart.shift_displacement(4);
        
        -- uložit run-time atribut
        i_rta_store(inst,info,context,opsrc,rta,oppart);
        end if;
      end loop;

  leave
    -- uvolnit složku cílového pointeru
    oppart.free(info,context);
    end declare;

  #end generate_store_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_store_pointer =
-- Uloží pointer [opsrc] do zadaného cíle [opdst]. Množina run-time atributů cílového pointeru je
-- dána kontextem generování výrazu.
----------------------------------------------------------------------------------------------------
with
  ci_rta;

var
  out_rta          : rtattribset;                -- cílová množina run-time atributů
  out_size         : t_unsigned;                 -- velikost cílového bloku

begin
  -- zvolit cílovou množinu run-time atributů
  get_destination_rta_set(context,out_rta,out_size);
  verify({VERIFY=}001070,opdst.size<>out_size);

  #expand generate_store_pointer;
    -- cílová množina run-time atributů
    #for out_rta use; out_rta

    -- operandy
    #for opsrc use; opsrc
    #for opdst use; opdst

    -- fragment kódu pro zkopírování adresy
    #for copy_address_fragment use;
        declare var
          opaddr   : c_operand;                  -- registr s adresní složkou zdrojového pointeru

        begin
          -- načíst adresní složku zdrojového pointeru do registru
          i_gen_load_pointer_address(inst,info,context,opsrc,opaddr{,for no_memory use true});

          -- uložit do cílového pointeru
          i_gen_simple_assign(inst,info,context,oppart,opaddr);
          --addii(inst,info,ii_mov,oppart,opaddr,op0);

        leave
          -- uvolnit operandy
          opaddr.free(info,context);
          end declare;
    #end generate_store_pointer;
  end i_gen_store_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_pointer_address =
-- Sestaví operand reprezentující adresní složku pointeru. Jestliže je [no_memory] rovno True, 
-- nikdy nevrátí odkaz na adresu v paměti, ale načte ho v takovém případě do registru.
----------------------------------------------------------------------------------------------------
begin
  -- připravit si alias ke zdrojovému pointeru zahrnující pouze adresu
  vysl.clone(inst,info,context,op);
  vysl.adjust_edtype(edt_address);
  vysl.adjust_size(4);
{
  -- je-li to potřeba, tak zkopírovat adresu do registru
  if no_memory and vysl.optype=io_mem then
    i_gen_load_address_to_register(inst,info,context,vysl,for force_reg use true);
    end if;
}
  end i_gen_load_pointer_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_compose_pointer =
-- Sestaví operand reprezentující pointer na uvedenou hodnotu.
----------------------------------------------------------------------------------------------------
with
  ci_rta;

    ------------------------------------------------------------------------------------------------
    procedure all_static return t_logical =
    -- True, jestliže jsou všechny run-time atributy požadované v kontextu staticky zjistitelné.
    ------------------------------------------------------------------------------------------------
    begin
      result:=true;
      for rta in rtattrib loop 
        if rta in context.outtyp.pattrib then
          result and op.rta_info[rta].mode=rtm_static;
          end if;
        end loop;
      end all_static;

begin
  verify({VERIFY=}000992,context.outtyp.stype<>dt_pointer);
  --verify({VERIFY=}000994,op.edtype not in edts_value);

  -- nepotřebujeme žádné run-time atributy
  if context.outtyp.pattrib=rtattribset:[] 
  -- nebo se všechny určí staticky => stačí předat adresu
  or else all_static then
    -- zduplikovat operand
    vysl.clone(inst,info,context,op);

    -- načíst adresu
    i_gen_load_address_to_register_with_dereference(inst,info,context,vysl);

    -- výsledek je určitě pointer obsahující pouze adresní složku
    vysl.adjust_edtype(edt_pointer);
    vysl.adjust_size(4);
    
  -- nějaké run-time atributy jsou potřeba a musejí se počítat => zkonstruovat dočasný pointer
  else
    verify({VERIFY=}000993,op.optype<>io_mem);

    -- založit dočasnou proměnnou
    vysl.create_temporary(inst,info,edt_pointer,unidata_size_to_unsigned(context.outtyp.size));

    #expand generate_store_pointer;
      -- cílová množina run-time atributů
      #for out_rta use; context.outtyp.pattrib

      -- operandy
      #for opsrc use; op
      #for opdst use; vysl

      -- fragment kódu pro zkopírování adresy
      #for copy_address_fragment use;
          declare var
            opaddr : c_operand;                  -- adresa hodnoty

          begin
            -- naklonovat operand
            opaddr.clone(inst,info,context,op);

            -- načíst adresu
            i_gen_load_address_to_register_with_dereference(inst,info,context,opaddr,for no_dependance use true);

            -- uložit do cílového pointeru
            addii(inst,info,ii_mov,oppart,opaddr,op0);

          leave
            -- uvolnit operandy
            opaddr.free(info,context);
            end declare;
      #end generate_store_pointer;
    end if;
  end i_gen_compose_pointer;



----------------------------------------------------------------------------------------------------
-- Low-level primitiva pro ukládání adres.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_gen_load_address_to_register = 
-- Načte adresu paměťového bloku reprezentovaného operandem do registru. Operand musí být typu
-- [io_imm], [io_reg] nebo [io_mem]. Pro [io_mem] se chová jako instrukce LEA, v ostatních případech
-- jako přiřazení. 
--   Je-li uveden preferovaný registr, adresa se načte do něj. Pokud není nastaveno [force_reg], 
-- tak operand typu [io_imm] ponechá v původním tvaru.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure load_direct =
    -- Dodaný operand přímo načte do registru.
    ------------------------------------------------------------------------------------------------
    var
      vysl         : c_operand;                  -- výsledek

    begin
      -- alokovat registr
      new_address_register(inst,info,context,op,vysl,pref_reg,for no_dependance use no_dependance);

      -- přesunout
      addii(inst,info,ii_mov,vysl,op,op0);

      -- předat výsledek
      op.replace(info,context,vysl);

    leave
      -- uvolnit pracovní operand
      vysl.free(info,context);
      end load_direct;



    ------------------------------------------------------------------------------------------------
    #template add_lea;
    -- doplní LEA <vysl>,<op>.
    ------------------------------------------------------------------------------------------------
      addii(inst,info,ii_lea,vysl,op,op0);
      #end add_lea;



    ------------------------------------------------------------------------------------------------
    procedure use_displacement (
        vysl       : in out c_operand;           -- alokovaný registr
        ii         : in iinstr) =                -- operace (ADD nebo MOV)
    -- K cílovému operandu přičte displacement ze zdrojového se zohledněním relokace.
    ------------------------------------------------------------------------------------------------
    begin
      -- nula bez relokace se přičítat nemusí
      if ii=ii_add and then op.disp=0 and then op.relo_info.rtype=irt_none then
        return;
        end if;

      declare var
        opdisp     : c_operand;                  -- operand pro umístění displacementu

      begin
        -- připravit displacement do samostatného operandu
        opdisp.create_imm(edt_offset,4,op.disp);

        -- zkopírovat relokační informace
        opdisp.copy_relo(op);

        -- <ii>-nout k výslednému registru
        addii(inst,info,ii,vysl,opdisp,op0);

      leave
        -- uvolnit pracovní operand
        opdisp.free(info,context);
        end declare;
      end use_displacement;



    ------------------------------------------------------------------------------------------------
    procedure add_lea_or_add_displacement (
        vysl       : in out c_operand;           -- alokovaný registr
        reg        : in ireg) =                  -- registr, který by se mohl shodovat s cílovým
    -- Jestliže se cílový registr shoduje s dodaným, přičte k cílovému registr displacement, jinak
    -- použije plnohodnotné LEA nebo při nulovém posunutí MOV.
    ------------------------------------------------------------------------------------------------
    begin
      -- shodují se => posunutí stačí k cílovému registru přičíst
      if iregtouni[reg]=iregtouni[vysl.reg.reg] then
        use_displacement(vysl,ii_add);
    {
      -- neshodují se a displacement je nulový bez relokace => stačí MOV
      elsif op.disp=0 and op.relo_info.rtype=irt_none then
        %%TODO(LEA)
    }    
      -- neshodují se a displacement je nenulový nebo s relokací => musí se použít LEA
      else
        add_lea;
        end if;
      end add_lea_or_add_displacement;


    
    ------------------------------------------------------------------------------------------------
    procedure add_lea_or_shl_scale (
        vysl       : in out c_operand;           -- alokovaný registr
        reg        : in ireg) =                  -- registr, který by se mohl shodovat s cílovým 
    -- Jestliže se cílový registr shoduje s dodaným a displacement je nulový bez relokace, cílový
    -- registr shiftne vlevo o scale původního operandu, jinak použije plnohodnotné LEA.
    ------------------------------------------------------------------------------------------------
    begin
    {
      -- shodují se a posunutí je nulové bez relokace => stačí SHL
      if iunireg[reg]=iunireg[vysl.reg] and op.disp=0 and op.relo_info.rtype=irt_none then
        %%TODO(LEA)

      -- neshodují se nebo je posunutí nenulové nebo s relokací => musí se použít LEA
      else
    }   add_lea;
      { end if; }
      end add_lea_or_shl_scale;     


begin
  case op.optype

    -- registr
    when io_reg do
        -- je-li zadán preferovaný registr a liší se od již použitého, musí se přesunout
        if pref_reg<>in_none and then pref_reg<>iregtouni[op.reg.reg] then
          load_direct;
          end if;

    -- přímá hodnota
    when io_imm do
        -- do registru načítat jen je-li to vyžadováno
        if force_reg then
          -- normalizovat velikost
          op.adjust_size(4);

          -- načíst do registru
          load_direct;
          end if;

    -- paměťová adresa
    when io_mem do
        -- není náhodou adresa tvořena jen displacementem?
        if not force_reg and op.base.reg=ir_none and op.index.reg=ir_none

          -- potom není-li vynuceno načtení do registru, můžeme ji rovnou předat ven
          then
            op.transform_mem_to_imm;
            
          -- v ostatních situacích je to mnohem složitější
          else
            declare var
              vysl     : c_operand;                  -- výsledek

            begin
              -- alokovat registr
              new_address_register(inst,info,context,op,vysl,pref_reg,for no_dependance use no_dependance);

              -- pouze displacement => prosté přiřazení
              if op.base.reg=ir_none and op.index.reg=ir_none then
                use_displacement(vysl,ii_mov);

              -- index*1 + displacement => LEA, ADD nebo MOV podle shody s cílovým registrem
              elsif op.base.reg=ir_none and op.scale=1 then
                add_lea_or_add_displacement(vysl,op.index.reg);

              -- index*(scale>1) + displacement => LEA nebo SHL podle shody s cílovým registrem
              elsif op.base.reg=ir_none and op.scale>1 then
                add_lea_or_shl_scale(vysl,op.index.reg);

              -- báze + displacement => LEA, ADD nebo MOV podle shody s cílovým registrem
              elsif op.index.reg=ir_none then
                add_lea_or_add_displacement(vysl,op.base.reg);
              
              -- ostatní případy => LEA
              else
                add_lea;
                end if;

              -- předat výsledek
              op.replace(info,context,vysl);

            leave
              -- uvolnit pracovní operand
              vysl.free(info,context);
              end declare;
            end if;

    -- operand na vrcholu stacku
    when io_stack do
        declare var
          vysl     : c_operand;                  -- výsledek

        begin
          -- alokovat registr
          new_address_register(inst,info,context,op,vysl,pref_reg,for no_dependance use no_dependance);

          -- nacpat do něj stack pointer
          addii(inst,info,ii_mov,vysl,op_esp,op0);

          -- předat výsledek
          op.replace(info,context,vysl);

        leave
          -- uvolnit pracovní operand
          vysl.free(info,context);
          end declare;

    -- %%TODO(LEA) ještě asi a [io_rel] (?co s tím?)

    -- nic jiného nepodporujeme
    when others do verify({VERIFY=}001057);
    end case;
  end i_gen_load_address_to_register;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_address_to_register_with_dereference = 
-- Načte adresu paměťového bloku reprezentovaného operandem do registru. 
--  Je-li dodaný operand adresa reference na hodnotu, tak provede dereferenci a do registru uloží 
-- adresu cílového objektu. Reference se pozná tak, že operand je typu [io_mem] a má nastaven 
-- elementární datový typ [edt_address]. 
--   Ostatní vlastnosti jsou shodné s procedurou [i_gen_load_address_to_register].
----------------------------------------------------------------------------------------------------
begin
  if op.edtype=edt_address and op.optype=io_mem
    -- je-li dodaný operand reference na hodnotu, stačí provést dereferenci
    then do_dereference(inst,info,context,op,for pref_reg use pref_reg,for no_dependance use no_dependance);
    -- jinak načíst adresu
    else i_gen_load_address_to_register(inst,info,context,op,for force_reg use force_reg,for no_dependance use no_dependance,for pref_reg use pref_reg);
    end if;
  end i_gen_load_address_to_register_with_dereference;



----------------------------------------------------------------------------------------------------
-- Low-level primitiva pro ukládání hodnot.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_gen_load_value_to_register =
-- Načte hodnotu reprezentovanou operandem do registru. Operand musí být typu [io_imm], [io_reg],
-- [io_mem] nebo [io_cc] a mít velikost nejvýše 4 B. Pro operandy s elementárním datovým typem
-- z množiny [edts_ordinal] generuje kód pro rozšíření/zúžení operandu s příslušným run-time
-- checkem podle velikosti požadovaného datového typu daného kontextem ([context.rsize]).
--   Je-li uveden preferovaný registr, adresa se načte do něj. Pokud není nastaveno [force_reg], 
-- tak operandy typu [io_imm] a [io_cc] ponechá v původním tvaru.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure new_register (
        vysl       : out c_operand;              -- alokovaný registr
        size       : in t_unsigned) =            -- požadovaná velikost registru
    -- Alokuje nový registr. Pokud je nastaven preferovaný registr, použije přednostně ten, jinak se
    -- aspoň pokusí recyklovat registr ze zdrojového operandu. Elementární datový typ převezme od
    -- operandu, velikost z kontextu.
    ------------------------------------------------------------------------------------------------
    begin
      if pref_reg<>in_none
        then vysl.create_use_register(inst,info,context,op.edtype,iunitoreg[pref_reg,size]);
        else vysl.create_new_register_from_operand(inst,info,context,op.edtype,size,op);
        end if;
      end new_register;



    ------------------------------------------------------------------------------------------------
    procedure mov_no8bit (
        vysl       : in out c_operand) =         -- alokovaný registr
    -- Zkopíruje registr [op] bez 8bitové části do 8bitového výsledku [vysl].
    ------------------------------------------------------------------------------------------------
    begin
      -- pro účely přiřazení se budou oba operandy chápat jako 32bitové (SI --> ESI, DI --> EDI)
      vysl.adjust_size(4);
      op.adjust_size(4);

      -- movenout
      addii(inst,info,ii_mov,vysl,op,op0);

      -- změnit velikost výsledku zpět na 8 bitů
      vysl.adjust_size(1);
      end mov_no8bit;



    ------------------------------------------------------------------------------------------------
    procedure load_with_adjust =
    -- Načte operand do registru a případně vygeneruje run-time check.
    ------------------------------------------------------------------------------------------------
    var
      vysl         : c_operand;                  -- výsledek

    begin
      -- alokovat registr
      new_register(vysl,context.rsize);

      -- velikosti souhlasí nebo na ní nezáleží => stačí prosté přiřazení
      if context.rsize=op.size or op.size=0 then
        addii(inst,info,ii_mov,vysl,op,op0)

      -- rozšíření operandu
      elsif context.rsize>op.size then
        verify({VERIFY=}001049,op.edtype not in edts_ordinal);
        verify({VERIFY=}001051,context.rsign and orgtyp=nil);
        
        -- provést rozšíření
        if context.rsign and then orgtyp^.stype=dt_signed
          -- znaménkově
          then addii(inst,info,ii_movsx,vysl,op,op0)
          -- neznaménkově
          else addii(inst,info,ii_movzx,vysl,op,op0)
          end if;

      -- zúžení operandu
      elsif context.rsize<op.size then
        verify({VERIFY=}001050,op.edtype not in edts_ordinal and (op.edtype<>edt_pointer or else context.rsize<>4));

        if context.rsize=1 and then op.optype=io_reg and then op.reg.reg in ir_no8bit 

          -- při 8bitovém výsledku se registry bez 8bitové části se musí řešit zvlášť
          then
            mov_no8bit(vysl);

          -- pro ostatní registry je to triviální
          else
            -- pro účely přiřazení změnit velikost operandu
            op.adjust_size(vysl.size);

            -- přiřadit
            addii(inst,info,ii_mov{zx},vysl,op,op0);
            end if;
        end if;

      -- předat výsledek
      op.replace(info,context,vysl);

    leave
      -- uvolnit pracovní operand
      vysl.free(info,context);
      end load_with_adjust;

begin
  verify({VERIFY=}001042,op.edtype not in edts_value);
  verify({VERIFY=}001047,context.rsize=0);

  case op.optype
    -- registr
    when io_reg do
        if pref_reg<>in_none and then pref_reg<>iregtouni[op.reg.reg] 

          -- je-li zadán preferovaný registr a liší se od již použitého, musí se přesunout
          then 
            load_with_adjust;

          -- jinak stačí provést rozšíření/zúžení
          else
            -- rozšíření operandu
            if context.rsize>op.size then
              verify({VERIFY=}001052,op.edtype not in edts_ordinal);
              verify({VERIFY=}001053,context.rsign and orgtyp=nil);

              declare var
               vysl : c_operand;                  -- výsledek

              begin
                -- výsledek
                vysl.clone(inst,info,context,op);
                vysl.adjust_size(context.rsize);

                -- rozšířit
                if context.rsign and then orgtyp^.stype=dt_signed
                  -- znaménkově
                  then addii(inst,info,ii_movsx,vysl,op,op0)
                  -- neznaménkově
                  else addii(inst,info,ii_movzx,vysl,op,op0);
                  end if;
                -- %%X šlo by použít CBW/CWD ?

                -- předat výsledek
                op.replace(info,context,vysl);

              leave
                -- uvolnit pracovní operand
                vysl.free(info,context);
                end declare;

            -- zúžení operandu
            elsif context.rsize<op.size then
              verify({VERIFY=}001058,op.edtype not in edts_ordinal);

              if context.rsize=1 and op.reg.reg in ir_no8bit 

                -- při 8bitovém výsledku se registry bez 8bitové části se musí řešit zvlášť
                then
                  declare var
                   vysl : c_operand;                  -- výsledek

                  begin
                    -- alokovat registr
                    new_register(vysl,context.rsize);

                    -- provést vlastní přiřazení
                    mov_no8bit(vysl);

                    -- předat výsledek
                    op.replace(info,context,vysl);

                  leave
                    -- uvolnit pracovní operand
                    vysl.free(info,context);
                    end declare;

                -- pro ostatní registry je to triviální
                else
                  op.adjust_size(context.rsize);
                  end if;
              end if;
            end if;

    -- paměť
    when io_mem do load_with_adjust;

    -- přímá hodnota
    when io_imm do
        -- do registru načítat jen je-li to vyžadováno
        if force_reg then
          -- velikost je úplně nezajímavá, zresetovat
          op.adjust_size(0);

          -- načíst
          load_with_adjust;

        -- liší-li se velikost konstanty, tak upravit alespoň tu
        elsif op.size<>0 and then context.rsize<>op.size then
          verify({VERIFY=}001059,op.edtype not in edts_ordinal);
          op.adjust_size(context.rsize);
          end if;

    -- podmínka
    when io_cc do 
        -- do registru načítat jen je-li to vyžadováno
        if force_reg then
          declare var
            vysl   : c_operand;                  -- výsledek

          begin
            -- alokovat registr
            new_register(vysl,4);

            -- nastavit
            addset(inst,info,context,op.cc,vysl);

            -- upravit velikost na požadovanou
            vysl.adjust_size(context.rsize);

            -- předat výsledek
            op.replace(info,context,vysl);

          leave
            -- uvolnit mezivýsledek
            vysl.free(info,context);
            end declare;
          end if;

    -- nic jiného neumíme
    when others do verify({VERIFY=}001048);
    end case;
  end i_gen_load_value_to_register;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_value_to_eax =
-- Načte hodnotu reprezentovanou operandem do registru. Pokud je hodnota již uložena v AL, AX, EAX,
-- tak ponechá operand beze změny. Registr AH kopíruje do AL. Předpokládá, že velikost operandu
-- odpovídá požadované velistki datového typu daného kontextem ([context.rsize]).
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}001041,op.edtype not in edts_value);
  verify({VERIFY=}001046,op.optype not in t_operand_type_set:[io_mem,io_reg,io_imm]);

  -- kromě případu hodnoty již v AL, AX, EAX; (AH se musí kopírovat do AL)
  if op.optype=io_reg and then op.reg.reg in iregset:[ir_al,ir_ax,ir_eax] then
    return;
    end if;

  declare var
    vysl           : c_operand;                  -- výsledek
    eax            : ireg;                       -- zvolený registr
    value_size     : t_unsigned;                 -- velikost registru

  begin
    -- velikost registru
    if op.size=0
      then value_size:=context.rsize;
      else value_size:=op.size;
      end if;
    
    -- interní kontrola - velikost musí souhlasit s požadovanou velikostí datového typu uvedenou
    -- v kontextu; nicméně není problém dodělat konverzi stejně jako v [i_gen_load_value_to_register]
    verify({VERIFY=}001044,value_size<>context.rsize);

    -- vybrat variantu registru
    case value_size
      when 0 do eax:=ir_eax;
      when 1 do eax:=ir_al;
      when 2 do eax:=ir_ax;
      when 4 do eax:=ir_eax;
      when others do verify({VERIFY=}001045,true);
      end case;

    -- připravit EAX
    vysl.create_use_register(inst,info,context,op.edtype,eax);

    -- přiřadit
    if op.optype=io_reg and then op.reg.reg=ir_ah

      -- pro případ AH -> AL použít SHR EAX,8
      then
        vysl.adjust_size(4);
        addii(inst,info,ii_shr,vysl,op_8,op0);
        vysl.adjust_size(1);

      -- ve všech ostatních případech standardní přiřazení
      else
        addii(inst,info,ii_mov,vysl,op,op0);
        end if;

    -- předat výsledek
    op.replace(info,context,vysl);

  leave
    -- uvolnit mezivýsledek
    vysl.free(info,context);
    end declare;
  end i_gen_load_value_to_eax;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_value_to_imm8_cl =
-- Načte hodnotu reprezentovanou operandem do registru CL nebo ho ponechá konstantní ([io_imm]).
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}001040,op.edtype not in edts_value);

  case op.optype
    -- registr
    when io_reg do 
        if op.reg.reg in iregset:[ir_cl,ir_cx,ir_ecx]

          -- triviální případ hodnoty již v CL, CX, ECX; (CH se musí kopírovat do CL)
          then
            -- zúžením operandu změnit na CL
            op.adjust_size(1);

          -- ostatní případy, kdy je to nějaký jiný registr (včetně CH)
          else
            declare var
              vysl         : c_operand;                  -- výsledek

            begin
              -- výsledek
              vysl.create_use_register(inst,info,context,op.edtype,ir_ecx);

              -- %%TECH Kdyby mělo ESI a EDI 8-bitové části, tak by
              -- šlo vše movat 8-bitově... (a kdyby SHL/SHR nebylo
              -- tak debilně vymyšlený, tak to tu nemuselo bejt vůbec)

              -- je to v CH, udělat SHR
              if op.reg.reg=ir_ch then
                -- shiftnout
                addii(inst,info,ii_shr,vysl,op_8,op0);

              -- již má správnou velikost
              elsif op.size=1 then
                -- změnit ECX na CL (provést tedy osmibitově, zabrání se tak nežádoucím prodlevám 
                -- na některých procesorech)
                vysl.adjust_size(1);

                -- stačí movenout
                addii(inst,info,ii_mov,vysl,op,op0);

              -- 2 nebo 4 byty, provést 32-bitově (co kdyby to bylo (E)SI nebo (E)DI)
              else
                -- udělat z obou operandů 32 bitů
                op.adjust_size(4);

                -- movenout
                addii(inst,info,ii_mov,vysl,op,op0);
                end if;

              -- změnit ECX na CL (nestalo-li se tak již dříve)
              vysl.adjust_size(1);

              -- předat výsledek
              op.replace(info,context,vysl);

            leave
              -- uvolnit mezivýsledek
              vysl.free(info,context);
              end declare;
            end if;

    -- konstanta
    when io_imm do
        -- zúžit na 8 bitů
        op.adjust_size(1);

    -- paměť
    when io_mem do
        declare var
          vysl     : c_operand;                  -- výsledek

        begin
          -- výsledek
          vysl.create_use_register(inst,info,context,op.edtype,ir_cl);

          -- udělat z toho 8 bitů
          op.adjust_size(1);

          -- movenout
          addii(inst,info,ii_mov,vysl,op,op0);

          -- předat výsledek
          op.replace(info,context,vysl);

        leave
          -- uvolnit mezivýsledek
          vysl.free(info,context);
          end declare;

    -- nic jiného obsloužit neumíme
    when others do verify({VERIFY=}001043);
    end case;
  end i_gen_load_value_to_imm8_cl;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_value_to_temporary =
-- Uloží hodnotu reprezentovanou operandem do temporary proměnné nebo ho ponechá konstantní 
-- ([io_imm]). Předpokládá, že velikost hodnoty je 1, 2 nebo 4 B.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}001036,op.optype<>io_imm and then (op.size<>1 and op.size<>2 and op.size<>4));
  verify({VERIFY=}001039,op.edtype not in edts_value);

  case op.optype
    -- přímá hodnota
    when io_imm do -- nic nedělat

    -- registr
    when io_reg do
        declare var
          optemp   : c_operand;                  -- temporary proměnná

        begin
          -- alokovat temporary proměnnou
          optemp.create_temporary(inst,info,op.edtype,op.size);

          -- přesunout
          addii(inst,info,ii_mov,optemp,op,op0);

          -- předat výsledek
          op.replace(info,context,optemp);

        leave
          -- uvolnit mezivýsledek
          optemp.free(info,context);
          end declare;

    -- paměť
    when io_mem do
        declare var
          optemp   : c_operand;                  -- temporary proměnná
          opreg    : c_operand;                  -- pomocný registr

        begin
          -- alokovat temporary proměnnou
          optemp.create_temporary(inst,info,op.edtype,op.size);

          -- pomocný registr
          opreg.create_new_register(inst,info,context,op.edtype,op.size);

          -- přesunout
          addii(inst,info,ii_mov,opreg,op,op0);
          addii(inst,info,ii_mov,optemp,opreg,op0);

          -- předat výsledek
          op.replace(info,context,optemp);

        leave
          -- uvolnit mezivýsledek
          optemp.free(info,context);
          opreg.free(info,context);
          end declare;

    when others do verify({VERIFY=}001037,true);
    end case;
  end i_gen_load_value_to_temporary;



----------------------------------------------------------------------------------------------------
procedure i_gen_push_value =
-- Uloží operand na stack.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    #template push_mem (load_mem,do_push);
    -- Schéma uložení operandu typu [io_mem] na stack. [load_mem] reprezentuje konverzi operandu do 
    -- pracovního, [do_push] je vlastní mechanismus pro uložení na stack.
    ------------------------------------------------------------------------------------------------
      declare var
        op1 : c_operand;                 -- pracovní kopie operandu

      begin
        -- naklonovat operand
        op1.clone(inst,info,context,op);

        -- načíst
        load_mem

        -- normalizovat na 32 bitů
        op1.adjust_size(4);

        -- pushnout
        do_push

      leave
        -- uvolnit pracovní operand
        op1.free(info,context);
        end declare;
      #end push_mem;



    ------------------------------------------------------------------------------------------------
    procedure push_with_adjust =
    -- Operand uloží na stack. Jeho velikost nejdříve normalizuje na 4 B.
    ------------------------------------------------------------------------------------------------
    var
      old_size     : t_unsigned;                 -- původní velikost operandu

    begin
      -- normalizovat na 32 bitů
      old_size:=op.size;
      op.adjust_size(4);

      -- pushnout
      addii(inst,info,ii_push,op,op0,op0);

      -- vrátit zpět původní velikost
      op.adjust_size(old_size);
      end push_with_adjust;

begin
  verify({VERIFY=}001038,op.edtype not in edts_value);

  case op.optype
    -- někdo už ho pro nás na stack uložil
    when io_stack do -- nic nedělat

    -- přímá hodnota
    when io_imm do
        verify({VERIFY=}001032,op.size<>0 and op.size<>1 and op.size<>2 and op.size<>4);
        push_with_adjust;

    -- registr
    when io_reg do
        verify({VERIFY=}001035,op.reg.reg in ir_r8h);
        push_with_adjust;

    -- operand v paměti
    when io_mem do
        case op.size
          -- zvlášť příznivá velikost
          when 4 do addii(inst,info,ii_push,op,op0,op0);

          -- příznivá velikost
          when 1,2 do
              #expand push_mem;
                #for load_mem use; 
                    -- načíst hodnotu do registru
                    i_gen_load_value_to_register(inst,info,context,nil,op1);
                #for do_push  use; 
                    -- uložit na stack
                    addii(inst,info,ii_push,op1,op0,op0);
                #end push_mem;

          -- slabě příznivá velikost
          when 8,12,16 do
              #expand push_mem;
                #for do_push  use;
                    -- posunout operand na konec
                    op1.shift_displacement(t_signed(op.size-4));

                    -- n-krát pushnout
                    for i in reverse 1..op.size div 4 loop
                      addii(inst,info,ii_push,op1,op0,op0);
                      op1.unshift_displacement(4);
                      end loop;
                #end push_mem;

          when others do unimplemented({UNIMP=}000271);
          end case;

    -- výsledek porovnání
    when io_cc do
        declare var
          op1      : c_operand;                  -- pracovní kopie operandu

        begin
          -- budeme potřebovat registr
          op1.create_new_register(inst,info,context,edt_unsigned,4);

          -- nastavit
          addset(inst,info,context,op.cc,op1);

          -- uložit na stack
          addii(inst,info,ii_push,op1,op0,op0);

        leave
          -- uvolnit pracovní operand
          op1.free(info,context);
          end declare;

    when others do verify({VERIFY=}001033,true);
    end case;
  end i_gen_push_value;



----------------------------------------------------------------------------------------------------
procedure i_gen_push_nil =
-- Uloží NIL v požadované velikosti [size] na stack.
----------------------------------------------------------------------------------------------------
var
  nsize            : t_unsigned;                 -- normalizovaná velikosti NILu v násobcích 4 B

begin
  -- normalizovat velikost na násobek 4
  nsize:=(unidata_size_to_imm32(size)+3) div 4;

  -- kolic moc nul budeme pushovat ?
  if nsize<=8

    -- je toho málo => pushnout přímo
    then
      -- n-krát pushnout 0
      while nsize>0 loop
        addii(inst,info,ii_push,op_0_32bit,op0,op0);
        pred nsize;
        end loop;

    -- je toho hodně => vzít to cyklem
    else
      unimplemented({UNIMP=}000270);
      end if;
  end i_gen_push_nil;



----------------------------------------------------------------------------------------------------
procedure i_load_this_address =
-- Adresa THIS pointeru na instanci třídy resp. složky v rámci třídy.
----------------------------------------------------------------------------------------------------
begin
  -- načíst pointer na třídu
  i_gen_this_address(inst,op);
  i_gen_load_address_to_register_with_dereference(inst,info,context,op);

  -- udělat z registru adresu
  op.transform_reg_to_mem(_edtype,_size);

  -- přičíst offset složky
  op.shift_displacement(imm32_to_signed{%%X}(unidata_addr_to_imm32(ofs)));
  end i_load_this_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_this_address =
-- Sestaví adresu THIS pointeru na instanci třídy.
----------------------------------------------------------------------------------------------------
begin
  op.create_memory_address_on_stack(inst,edt_address,lpointer32,signed_to_imm32(inst.profile.thisofs));
  end i_gen_this_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_logical_jump =
-- Generování skoku podle výsledku porovnání.
----------------------------------------------------------------------------------------------------
begin
  -- definovány oba skoky
  if ttarget<>tgfallthru and ftarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,icondneg[cc],ttarget);
      else addjump(inst,info,context,cc,ttarget);
      end if;
    addjump(inst,info,context,ic_ucond,ftarget);

  -- skok pouze při True
  elsif ttarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,icondneg[cc],ttarget);
      else addjump(inst,info,context,cc,ttarget);
      end if;

  -- skok pouze při False
  elsif ftarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,cc,ftarget);
      else addjump(inst,info,context,icondneg[cc],ftarget);
      end if;

  -- žádný skok
  else
    if and_then
      then vysl.create_condition(icondneg[cc]);
      else vysl.create_condition(cc);
      end if;
    end if;
  end i_gen_logical_jump;



----------------------------------------------------------------------------------------------------
procedure i_gen_mul_reg =
-- Násobení registru konstantou.
-- Tato procedura nemá vliv na Zero Flag.
----------------------------------------------------------------------------------------------------
var
  n                : t_unsigned32;               -- shift
  op2              : c_operand;                  -- pracovní operand

begin
  verify({VERIFY=}000341,imm=timm32(0) or op1.optype<>io_reg or op1.reg.reg not in ir_r32);

  -- je čím násobit ?
  if imm=timm32(1) then return; end if;

  -- násobení 2^n
  if imm32_is_power_of_2(imm,n) then
    -- připravit druhý operand
    op2.create_imm(edt_unsigned,1,unsigned_to_imm32(n));

    -- přidat instrukci
    addii(inst,info,ii_shl,op1,op2,op0);

  -- násobení 3,5,9
  elsif imm=timm32(3) or imm=timm32(5) or imm=timm32(9) then
    -- připravit druhý operand
    op2.create_memory_address(inst,info,context,edt_binary,0,op1.reg.reg,0);
    op2.shift_by_index(inst,info,context,op1.reg.reg,imm32_to_unsigned(imm)-1);

    -- přidat instrukci
    addii(inst,info,ii_lea,op1,op2,op0);

  -- normální násobení
  else
    -- připravit druhý operand
    op2.create_imm(edt_unsigned,4,imm);

    -- přidat instrukci
    addii(inst,info,ii_imul,op1,op2,op0);
    end if;

  -- první operand neuvolňovat (registr se používá dál ve volající rutině)

leave
  -- uvolnit operand
  op2.free(info,context);
  end i_gen_mul_reg;



----------------------------------------------------------------------------------------------------
procedure i_gen_div_reg =
-- Dělení registru konstantou.
-- OP1 musí být 32-bitový registr.
----------------------------------------------------------------------------------------------------
var
  n                : t_unsigned32;               -- shift

begin
  verify({VERIFY=}000346,imm=timm32(0) or (op1.optype<>io_reg) or not (op1.reg.reg in ir_r32));

  -- je čím dělit ?
  if imm=timm32(1) then return; end if;

  -- dělení 2^n
  if imm32_is_power_of_2(imm,n) then
    declare var
      op2          : c_operand;                  -- operandy

    begin
      -- připravit druhý operand
      op2.create_imm(edt_unsigned,1,unsigned_to_imm32(n));

      -- přidat instrukci
      addii(inst,info,ii_shr,op1,op2,op0);

    leave
      -- uvolnit druhý operand
      op2.free(info,context);
      end declare;

  -- normální dělení
  else
    unimplemented({UNIMP=}000117);
{
    -- na Intelu nelze dělit konstantou, jen násobit...

    -- rezervovat EDX
    newopuse(inst,info,opedx,4,ir_edx);

    -- vynulovat
    addii(inst,info,ii_mov,opedx,op_0,op0);

    -- registr pro dělení
    newopreg(inst,info,context,op2,4,irm_int,op0);

    -- nacpat do něj konstantu

    -- vydělit

    -- uvolnit EDX
    freeop(info,opedx);
}
    end if;

  -- první operand neuvolňovat (registr se používá dál ve volající rutině)
  end i_gen_div_reg;



----------------------------------------------------------------------------------------------------
procedure i_gen_simple_assign =
-- Vygeneruje jednoduché přiřazení "mov <op1>,<op2>". Jestliže [op2] je [io_mem], hodnotu přiřadí
-- přes pracovní registr. Zvládne i přiřazení [io_cc].
----------------------------------------------------------------------------------------------------
begin
  if op2.optype=io_cc

    -- podmínka => SET
    then 
      addset(inst,info,context,op2.cc,op1);

    -- všechno ostatní standardně
    else
      i_gen_simple_op(inst,info,context,ii_mov,op1,op2);
      end if;
  end i_gen_simple_assign;



----------------------------------------------------------------------------------------------------
procedure i_gen_simple_op =
-- Vygeneruje jednoduchou instrukci "<ii> <op1>,<op2>". Jestliže [op2] je [io_mem], hodnotu přiřadí
-- přes pracovní registr.
----------------------------------------------------------------------------------------------------
begin
  if op1.optype=io_mem and op2.optype=io_mem

    -- paměť => vzít přes registr
    then
      declare var
        optemp   : c_operand;                  -- pracovní registr

      begin
        -- alokovat pracovní registr
        optemp.create_new_register(inst,info,context,op2.edtype,op2.size);

        -- provést operaci
        addii(inst,info,ii_mov,optemp,op2,op0);
        addii(inst,info,ii,op1,optemp,op0);

      leave
        -- uvolnit pracovní operand
        optemp.free(info,context);
        end declare;

    -- všechno ostatní přímo
    else
      addii(inst,info,ii,op1,op2,op0);
      end if;
  end i_gen_simple_op;



----------------------------------------------------------------------------------------------------
procedure i_gen_stack_top_reserve =
-- Alokuje na vrcholu stacku prostor pro [size] bytů.
----------------------------------------------------------------------------------------------------
begin
  -- alokovat prostor
  addopimm(inst,info,context,ii_sub,op_esp,value_size);
  end i_gen_stack_top_reserve;



----------------------------------------------------------------------------------------------------
procedure i_gen_stack_top_alloc =
-- Alokuje na vrcholu stacku prostor pro [size] bytů a sestaví odpovídající operand.
----------------------------------------------------------------------------------------------------
begin
  -- alokovat prostor na vrcholu stacku
  i_gen_stack_top_reserve(inst,info,context,value_size);

  -- sestavit odpovídající operand
  vysl.create_memory_address_on_stack(inst,value_edtype,value_size,0,for use_stack_ptr use true);
  end i_gen_stack_top_alloc;



----------------------------------------------------------------------------------------------------
procedure copyblock (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    opdst0         : in c_operand;               -- cílový operand
    opsrc0         : in c_operand;               -- zdrojový operand
    availregs      : in iuniregset;              -- volné registry
    bytes          : in t_unsigned) =            -- kolic bytů
-- Zkopíruje jeden blok dat délky BYTES z adresy OPDST na adresu OPSRC.
-- Pro kopírování využívá registry z množiny AVAILREGS.
----------------------------------------------------------------------------------------------------
with
  standard.console;

var
  opsrc            : c_operand;                  -- cílový operand
  opdst            : c_operand;                  -- zdrojový operand

    ------------------------------------------------------------------------------------------------
    procedure copysubblock (
              count      : in t_unsigned;        -- počet kopírovaných slov
              n          : in t_unsigned) =      -- velikost slova v bytech
    -- Jedna část kopírování.
    ------------------------------------------------------------------------------------------------
    var
      uni          : iunireg;
      reg          : ireg;

        --------------------------------------------------------------------------------------------
        procedure firstreg =
        -- První registr mezi AVAILREGS.
        --------------------------------------------------------------------------------------------
        begin
          uni:=in_first;
          while uni not in availregs or iunitoreg[uni,n]=ir_none loop succ uni; end loop;
          reg:=iunitoreg[uni,n];
          end firstreg;



        --------------------------------------------------------------------------------------------
        procedure nextreg =
        -- Další registr v AVAILREGS.
        --------------------------------------------------------------------------------------------
        begin
          loop
            if uni=in_last
              then uni:=in_first;
              else succ uni;
              end if;
            until uni in availregs and iunitoreg[uni,n]<>ir_none;
          reg:=iunitoreg[uni,n];
          end nextreg;

    begin
      -- %%TECH I když se zde manipuluje s registry, nepoužívá se standardní CREATE_NEW_REGISTER, 
      -- ale CREATE_NEW_REGISTER_LOW_LEVEL, protože se předpokládá, že pracovní registry byly již
      -- dříve rezervovány.

      -- %%FLEX Nešlo by to nějak čistěji?

      -- nacpat z paměti do registrů
      firstreg;
      for i in 1..count loop
        declare var
          optemp   : c_operand;

        begin
          -- nacpat do registru
          optemp.create_use_register_low_level(edt_unsigned,reg);
          optemp.adjust_size(n);
          addii(inst,info,ii_mov,optemp,opsrc,op0);
          end declare;

        -- další slovo
        opsrc.shift_displacement(imm32_to_signed{%%X}(timm32(n)));

        -- další registr
        nextreg;
        end loop;

      -- nacpat z registrů do paměti
      firstreg;
      for i in 1..count loop
        declare var
          optemp   : c_operand;

        begin
          -- nacpat do paměti
          optemp.create_use_register_low_level(edt_unsigned,reg);
          optemp.adjust_size(n);
          addii(inst,info,ii_mov,opdst,optemp,op0);
          end declare;

        -- další slovo
        opdst.shift_displacement(imm32_to_signed{%%X}(timm32(n)));

        -- další registr
        nextreg;
        end loop;
      end copysubblock;



    ------------------------------------------------------------------------------------------------
    procedure copywords (
        total_words: in t_unsigned;              -- počet slov
        n          : in t_unsigned) =            -- velikost slova v bytech
    -- Zkopíruje zadaný počet slov zadané velikosti.
    ------------------------------------------------------------------------------------------------
    with
      standard.numerics;

    var
      regs         : t_unsigned;                 -- počet n-bytových registrů
      part         : t_unsigned;                 -- velikost části ve slovech
      copy_words   : t_unsigned;                 -- počet zbývajících slov ke zkopírování
      uni          : iunireg;

    begin
      -- velikost operandů
      opsrc.adjust_size(n);
      opdst.adjust_size(n);

      -- kolik máme n-bytových registrů ?
      regs:=i_reg_get_count(availregs,n);

      -- zkopírovat
      copy_words:=total_words;
      while copy_words>0 loop
        -- kolik slov se bude kopírovat
        part:=min_unsigned(regs,copy_words);

        -- zkopírovat
        copysubblock(part,n);

        -- zase jsme se kousku zbavili
        copy_words-part;
        end loop;
      end copywords;

begin
  -- připravit operandy
  opsrc.clone(inst,info,context,opsrc0);
  opdst.clone(inst,info,context,opdst0);

  -- zkopírovat čtyřbytová slova
  copywords(bytes div 4,4);

  -- zkopírovat jednobytová slova
  copywords(bytes mod 4,1);

{ Funguje to i takhle:

  -- zkopírovat dvoubytová slova
  copywords((bytes mod 4) div 2,2);

  -- zkopírovat jednobytová slova
  copywords((bytes mod 4) mod 2,1);
}
leave
  -- uvolnit pracovní operandy
  opsrc.free(info,context);
  opdst.free(info,context);
  end copyblock;



----------------------------------------------------------------------------------------------------
procedure i_gen_move_static =
-- Přesun pole velikosti SIZE bytů z OPSRC do OPDST.
-- Předpokládá se, že se pole nepřekrývají.
-- Předpokládá se (kvůli optimalizaci), že jsou pole zarovnána na hranici 4B.
-- OPSRC a OPDST musí být typu IO_MEM s redukovaným počtem registrů (= <=1).
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  availregs        : iuniregset;                 -- volné registry použitelné pro movaní

begin
  verify({VERIFY=}000489,(opsrc.optype<>io_mem) or (opdst.optype<>io_mem));

  ----- %%TECH Kopírování bloku pevné velikosti --------------------------
  -- Pokud je pole dostatečně malé, kopíruje se přímo, negeneruje se žádný
  -- cyklus. Rozhoduje se podle aktuálního množství volných registrů, nejvýše
  -- se však za malý blok považuje ISMALLOBJECT bytů.
  --   Delší bloky se kopírují po 8 nebo 12 bytech, podle počtu volných
  -- registrů. Když je volný jen jeden registr, použije se dvakrát za
  -- iteraci.
  --   Zbytek modulo 8 resp. 12 se kopíruje jako v případě malého bloku.
  --
  -- Příklad: Blok z [ESI] do [EDI] o velikosti 27 bytů, 3 volné registry.
  --
  --         -- jeden registr se spotřebuje jako čítač
  --         mov    eax,16
  --         -- zkopírovat v délce dělitelné 8
  --     @1: mov    ebx,[esi+eax+0]
  --         mov    ecx,[esi+eax+4]
  --         mov    [edi+eax+0],ebx
  --         mov    [edi+eax+4],ecx
  --         sub    eax,8
  --         jns    @1
  --         -- zkopírovat zbytek
  --         mov    bl,[esi+24]
  --         mov    cl,[esi+25]
  --         mov    [edi+24],bl
  --         mov    [edi+25],bl
  --         mov    bl,[esi+26]
  --         mov    [edi+26],bl
  --
  --------------------------------------------------------------------------------------------------

  -- kolik je asi tak volných registrů ?
  i_reg_get_available(context,availregs);

  -- algoritmus se volí podle počtu (skutečně) volných registrů
  if size<=min_unsigned(ismallobject,max_unsigned(1,i_reg_get_count(availregs,4))*4*2-1)

    -- pokud máme dost registrů, nemusíme se zatěžovat s cyklem
    then
      -- rezervovat volné registry (nebo aspoň jeden)
      i_reg_reserve_available(inst,info,context,opsrc.get_all_uni_registers+opdst.get_all_uni_registers,availregs,1,size mod 4>0);

      -- zkopírovat blok
      copyblock(inst,info,context,opdst,opsrc,availregs,size);

      -- uvolnit použité registry
      i_reg_free_available(info,context,availregs);

    -- jinak cyklit
    else
      declare var
        opindex    : c_operand;                  -- čítač průchodů cyklem
        incr       : t_unsigned;                 -- inkrement offsetu po jedné iteraci cyklu
        wcount     : t_unsigned;                 -- počet slov kopírovaných během jedné iterace

      begin
        -- alokovat indexní registr
        opindex.create_new_register(inst,info,context,edt_unsigned,4);

        -- rezervovat volné registry (nebo aspoň jeden)
        declare

          ------------------------------------------------------------------------------------------
          procedure get_set return iuniregset =
          -- Ondra 28.04.2003 20:38 : Historicky první procedura ve Flexu vnořená v DECLARE bloku.
          ------------------------------------------------------------------------------------------
          with
            advanced,
            advanced.low_level,
            advanced.low_level.bit_operations;

          begin
            for xuni in iunireg loop
              if xuni in opsrc.get_all_uni_registers 
              or xuni in opdst.get_all_uni_registers 
              or xuni=iregtouni[opindex.reg.reg] then
                bit_set(result,t_bit_index(xuni:ord));
                end if;
              end loop;
            end get_set;

        begin
          i_reg_reserve_available(inst,info,context,get_set{%%TODO(SET)getopregs(opsrc)+getopregs(opdst)+iuniregset:[iregtouni[opindex.reg.reg]]},availregs,1,size mod 4>0);
          end declare;

        -- spočítat inkrement v jednom průchodu
        declare var
          i        : t_unsigned;
        begin
          i:=i_reg_get_count(availregs,4);
          if (i=1) or (size div {incr=}(3*4)<2)
            -- jen jeden registr nebo malý blok => dvě slova za iteraci
            then wcount:=2
            -- více registrů => nejvýše 3 slova za iteraci
            else wcount:=min_unsigned(i,3);
            end if;
          incr:=wcount*4;
          end declare;

        -- hodnota indexního registru
        verify({VERIFY=}000339,size div incr<2);
        addopimm(inst,info,context,ii_mov,opindex,incr*((size div incr)-1));

        declare var
          opsrcl   : c_operand;                  -- operandy během iterace cyklu
          opdstl   : c_operand;                  -- operandy během iterace cyklu
          tg_start : itarget;                    -- návěští začátku cyklu

        begin
          -- do operandů přidat indexní registr
          opsrcl.clone(inst,info,context,opsrc);
          opsrcl.shift_by_base_or_index(inst,info,context,opindex.reg.reg);
          opdstl.clone(inst,info,context,opdst);
          opdstl.shift_by_base_or_index(inst,info,context,opindex.reg.reg);

          -- začátek cyklu
          newtarget(info,tg_start);
          settarget(info,tg_start,getaddr(inst));

          -- zkopírovat WCOUNT slov
          copyblock(inst,info,context,opdstl,opsrcl,availregs,incr);

          -- posunout index
          addopimm(inst,info,context,ii_sub,opindex,incr);

          -- skok na začátek
          addjump(inst,info,context,ic_ns,tg_start);

        leave
          -- uvolnit pozměněné operandy
          opsrcl.free(info,context);
          opdstl.free(info,context);
          end declare;

        declare var
          opsrcl   : c_operand;                  -- operandy během iterace cyklu
          opdstl   : c_operand;                  -- operandy během iterace cyklu

        begin
          -- pointer na zbytek
          -- %%TECH Nedělá se CLONEOP, manipuluje se jen s DISP
          opsrcl.clone(inst,info,context,opsrc);
          opsrcl.shift_displacement(imm32_to_signed{%%X}(unsigned_to_imm32(incr*(size div incr))));
          opdstl.clone(inst,info,context,opdst);
          opdstl.shift_displacement(imm32_to_signed{%%X}(unsigned_to_imm32(incr*(size div incr))));

          -- %%X Zde bych už mohl používat registr z OPINDEX - co když má
          -- 8bitovou část a v AVAILREGS takových moc ? Musel bych ale
          -- ručně přidat OPINDEX.REG.REG do AVAILREGS a nedělat pak FREEOP

          -- dojet zbytek
          copyblock(inst,info,context,opdstl,opsrcl,availregs,size mod incr);

        leave
          -- uvolnit pozměněné operandy
          opsrcl.free(info,context);
          opdstl.free(info,context);
          end declare;

        -- uvolnit použité registry
        i_reg_free_available(info,context,availregs);

      leave
        -- uvolnit čítač
        opindex.free(info,context);
        end declare;
      end if;
  end i_gen_move_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_pop_static =
-- Jako předchozí procedura, ale předpokládá, že zdrojová data jsou uložena
-- na stacku, odkud je odstraní.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_util;

begin
  if size<=ismallobject and size mod 4=0

    -- pro malé objekty použijeme POP
    then
      declare var
        optemp     : c_operand;                  -- pracovní kopie cílového operandu

      begin
        -- připravit si pracovní kopii cílového operandu, kterou budeme moci zničit
        optemp.clone(inst,info,context,opdst);
        optemp.adjust_size(4);
        verify({VERIFY=}001094,optemp.optype<>io_mem);

        -- vygenerovat příslušný počet POPů
        for i in 1..size div 4 loop
          addii(inst,info,ii_pop,optemp,op0,op0);
          optemp.shift_displacement(4);
          end loop;

      leave
        -- uvolnit pracovní operand
        optemp.free(info,context);
        end declare;

    -- větší objekty standardním přesuneme
    else
      declare var
        opesi            : c_operand;                  -- zdrojový operand
        opedi            : c_operand;                  -- cílový operand
        aligned_size   : t_unsigned32;               -- zarovnaná velikost báze

      begin
        -- vytvořit si zdrojový operand
        opesi.create_on_stack(edt_binary,size);--newopstack(inst,info,context,opesi,size);

        -- odvodit nový cílový operand
        opedi.clone(inst,info,context,opdst);

        -- načíst adresy operandů do EDI a ESI
        i_gen_load_address_to_register(inst,info,context,opesi,for pref_reg use in_esi);
        i_gen_load_address_to_register(inst,info,context,opedi,for pref_reg use in_edi);
    {
    --     i_gen_lea(inst,info,context,opesi,in_esi);
    --     i_gen_lea(inst,info,context,opedi,in_edi);
    }
        -- přesunout
        i_gen_movsd_static(inst,info,context,opesi,opedi,size);

        -- zarovnat na 4 a získat tak použitou velikost prostoru na stacku
        addalign(aligned_size,0,size,4);

        -- odstranit zdrojový operand ze stacku
        addaddimm(inst,info,context,op_esp,aligned_size);

      leave
        -- uvolnit operandy
        opesi.free(info,context);
        opedi.free(info,context);
        end declare;
      end if;
  end i_gen_pop_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_move_array =
-- Přesun pole OPLENGTH prvků velikosti BASESIZE z OPSRC do OPDST.
-- Předpokládá se, že se pole nepřekrývají.
-- Předpokládá se (kvůli optimalizaci), že jsou pole zarovnána na hranici 4B.
-- OPSRC a OPDST musí být typu IO_MEM s redukovaným počtem registrů (= <=1),
-- a OPLENGTH musí být registr s počtem prvků pole OPDST.
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  availregs        : iuniregset;                 -- volné pracovní registry
  iter             : t_unsigned;                 -- kolik bytů se zkopíruje v jedné iteraci

begin
  verify({VERIFY=}000342,(opsrc.optype<>io_mem) or (opdst.optype<>io_mem) or (oplength.optype<>io_reg));

  ----- %%TECH Kopírování pole proměnné délky ----------------------------
  -- Na IA32 budou v průměru k dispozici tak 3 registry (celkem jich je 6,
  -- každý z operandů zabere jeden registr). Nikdy jich nebude více než 5.
  --   V jedné iteraci zkusíme použít maximum registrů - hledáme K takové,
  -- že K*4 | basesize => v jedné iteraci zkopírujeme K*4 bytů a nezbyde nic
  -- (K je kongruentní s BASESIZE).
  --   Pokud se nevyhneme přetečení, preferujeme kopírování po osmicích.
  --
  -- Příklad: Kopírujeme EAX prvků z [ESI] do [EDI]. Máme k dispozici
  -- 3 registry.
  --
  --   Případ 1: BASESIZE je dělitelné 12
  --
  --           -- převést počet prvků na počet bytů
  --           mul   eax,BASESIZE
  --           -- EAX je dělitelné 12
  --       @1: sub   eax,12
  --           js    @2
  --           mov   ebx,[esi+eax+0]
  --           mov   ecx,[esi+eax+4]
  --           mov   edx,[esi+eax+8]
  --           mov   [edi+eax+0],ebx
  --           mov   [edi+eax+4],ecx
  --           mov   [edi+eax+8],edx
  --           jmp   @1
  --       @2: ...
  --
  --   Případ 2: BASESIZE není dělitelné ani 12 ani 8, ale je dělitelné 2.
  --
  --           -- převést počet prvků na počet bytů
  --           mul   eax,BASESIZE
  --           -- zarovnat velikost na hranici 8
  --       @3: test  eax,2$111
  --           jz    @1
  --           sub   eax,2
  --           mov   bx,[esi+eax+0]
  --           mov   [edi+eax+0],bx
  --           jmp   @3
  --           -- nyní je EAX dělitelné 8
  --       @1: sub   eax,8
  --           js    @2
  --           mov   ebx,[esi+eax+0]
  --           mov   ecx,[esi+eax+4]
  --           mov   [edi+eax+0],ebx
  --           mov   [edi+eax+4],ecx
  --           jmp   @1
  --       @2: ...
  --
  --------------------------------------------------------------------------------------------------

  -- budou potřeba nějaké pracovní registry ?
  -- 8mi bitový bude potřeba, pokud je velikost báze nedělitelná 2 (=lichá)
  i_reg_reserve_available(inst,info,context,opsrc.get_all_uni_registers+opdst.get_all_uni_registers+oplength.get_all_uni_registers,availregs,1,is_odd_unsigned(basesize){imm32odd(basesize)});

  declare var
    rcount         : t_unsigned;                 -- počet 32bitových registrů v AVAILREGS

  begin
    -- kolik je volných registrů ?
    rcount:=i_reg_get_count(availregs,4);

    -- nemá báze příhodou velikost ? (K*4 | basesize, K in 3..RCOUNT)
    while rcount>2 loop
      if basesize mod (rcount*4)=0 then break; end if;
      pred rcount;
      end loop;

    -- kolik bytů se tedy zkopíruje za jednu iteraci ?
    iter:=min_unsigned(2,rcount)*4;
    end declare;

  -- převést :length na :length*basesize
  i_gen_mul_reg(inst,info,context,oplength,unsigned_to_imm32(basesize));

  declare var
    opsrcl         : c_operand;                  -- operandy během iterace cyklu
    opdstl         : c_operand;                  -- operandy během iterace cyklu

  begin
    -- do operandů přidat indexní registr
    opsrcl.clone(inst,info,context,opsrc);
    opsrcl.shift_by_base_or_index(inst,info,context,oplength.reg.reg);
    opdstl.clone(inst,info,context,opdst);
    opdstl.shift_by_base_or_index(inst,info,context,oplength.reg.reg);

    ---- vygenerovat kód na obsluhu nekongruentních bytů ----
    if basesize mod iter<>0 then
      declare var
        tg_start   : itarget;                    -- začátek cyklu
        tg_end     : itarget;                    -- konec cyklu
        rsize      : t_unsigned;                 -- zvolená velikost registru pro kopírování

      begin
        -- připravit návěští
        newtarget(info,tg_start);
        newtarget(info,tg_end);

        -- začátek cyklu
        settarget(info,tg_start,getaddr(inst));

        -- po jakých kusech budeme kopírovat ?
        if basesize mod 4=0 then rsize:=4
        elsif basesize mod 2=0 then rsize:=2
        else rsize:=1
        end if;

        -- testovat dělitelnost osmi
        addii(inst,info,ii_test,oplength,op_7,op0);

        -- není už konec ?
        addjump(inst,info,context,ic_z,tg_end);

        -- připravit index
        addsubimm(inst,info,context,oplength,rsize);

        -- zkopírovat
        copyblock(inst,info,context,opdstl,opsrcl,availregs,rsize);

        -- další iterace (je-li RSIZE=4, není proč cyklit)
        if rsize<>4 then 
          addjump(inst,info,context,ic_ucond,tg_start); 
          end if;

        -- adresa skoku na toto místo
        settarget(info,tg_end,getaddr(inst));
        end declare;
      end if;

    ---- vygenerovat hlavní kopírovací cyklus ----
    declare var
      tg_start     : itarget;                    -- začátek cyklu
      tg_end       : itarget;                    -- konec cyklu

    begin
      -- připravit návěští
      newtarget(info,tg_start);
      newtarget(info,tg_end);

      -- začátek cyklu
      settarget(info,tg_start,getaddr(inst));

      -- bude se kopírovat dalších ITER bytů
      addopimm(inst,info,context,ii_sub,oplength,iter);

      -- není už konec ?
      addjump(inst,info,context,ic_s,tg_end);

      -- jedna iterace kopírování
      copyblock(inst,info,context,opdstl,opsrcl,availregs,iter);

      -- další iterace
      addjump(inst,info,context,ic_ucond,tg_start);

      -- adresa skoku na toto místo
      settarget(info,tg_end,getaddr(inst));
      end declare;

  leave
    -- uvolnit pozměněné operandy
    opsrcl.free(info,context);
    opdstl.free(info,context);
    end declare;

leave
  -- uvolnit pracovní registry
  i_reg_free_available(info,context,availregs);
  end i_gen_move_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_movsd_static =
-- Kopírování pole velikosti SIZE bytů pomocí REP MOVSD.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000377,(opsrc.optype<>io_reg) or (opsrc.reg.reg<>ir_esi)
          or (opdst.optype<>io_reg) or (opdst.reg.reg<>ir_edi));

  if size div 4<=4

    -- dost malé na to, aby bylo REP neefektivní
    then
      for i in 1..size div 4 loop 
        addii(inst,info,ii_movsd,op0,op0,op0); 
        end loop;

    -- dostatečně dlouhý blok
    else
      declare var
        opecx      : c_operand;                  -- ECX

      begin
        -- alokovat ECX
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- do ECX dát počet čtyřslov
        addopimm(inst,info,context,ii_mov,opecx,size div 4);

        -- REP MOVSD
        addip(inst,info,ip_rep);
        addii(inst,info,ii_movsd,op0,op0,op0);

      leave
        -- uvolnit ECX
        opecx.free(info,context);
        end declare;
      end if;

  -- dojet zbytek modulo 4
  case size mod 4
    when 0 do -- beze zbytku, nic nedělat

    -- jeden MOVSB
    when 1 do addii(inst,info,ii_movsb,op0,op0,op0);

    -- jeden MOVSW
    when 2 do addii(inst,info,ii_movsw,op0,op0,op0);

    -- jeden MOVSW a jeden MOVSB
    when 3 do
        addii(inst,info,ii_movsw,op0,op0,op0);
        addii(inst,info,ii_movsb,op0,op0,op0);
    end case;
  end i_gen_movsd_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_movsd_array =
-- Kopírování pole pomocí REP MOVSD.
----------------------------------------------------------------------------------------------------
var
  optemp           : c_operand;

begin
  verify({VERIFY=}000362,(opecx.optype<>io_reg) or (opecx.reg.reg<>ir_ecx)
          or (opsrc.optype<>io_reg) or (opsrc.reg.reg<>ir_esi)
          or (opdst.optype<>io_reg) or (opdst.reg.reg<>ir_edi));

  -- je velikost báze dělitelná čtyřmi ?
  if basesize mod 4=0

    -- je => nemusíme se starat o nějaký zbytek
    then
      -- vynásobit ECX
      i_gen_mul_reg(inst,info,context,opecx,unsigned_to_imm32(basesize div 4));

    -- není, bude to trochu složitější
    else
      -- vynásobit ECX
      i_gen_mul_reg(inst,info,context,opecx,unsigned_to_imm32(basesize));

      -- schovat ECX na stack
      optemp.create_temporary(inst,info,edt_unsigned,idefregsize);
      addii(inst,info,ii_mov,optemp,opecx,op0);

      -- vydělit čtyřmi
      addii(inst,info,ii_shr,opecx,op_2,op0);
      end if;

  -- OK, teď obsahuje ECX počet čtyřslov, můžeme REP MOVSD
  addip(inst,info,ip_rep);
  addii(inst,info,ii_movsd,op0,op0,op0);

  -- dojet zbytek
  if basesize mod 4>0 then
    -- na stacku máme ECX
    addii(inst,info,ii_mov,opecx,optemp,op0);

    -- vymaskovat
    addii(inst,info,ii_and,opecx,op_3,op0);

    -- dojet
    if basesize mod 2=0
      -- stačí jeden MOVSW
      then
        addii(inst,info,ii_movsw,op0,op0,op0);

      -- přes MOVSB
      else
        -- %%X Na to, že přesouvám 1 až 3 byty je tohle dost luxus
        addip(inst,info,ip_rep);
        addii(inst,info,ii_movsb,op0,op0,op0);
        end if;
    end if;

leave
  -- uvolnit pracovní operand
  optemp.free(info,context);
  end i_gen_movsd_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_fillz_static =
-- Vypnění pole nulou.
----------------------------------------------------------------------------------------------------

var
  remaining_size   : t_unsigned32;               -- zbývající, dosud nefillznutá část pole

    ------------------------------------------------------------------------------------------------
    procedure fillzsmall (
        opdst      : in out c_operand) =
    -- Fillzování malého objektu.
    ------------------------------------------------------------------------------------------------
    begin
      -- zbavit se čtveřic
      opdst.adjust_size(4);
      while remaining_size div 4>0 loop
        addii(inst,info,ii_mov,opdst,op_0,op0);
        opdst.shift_displacement(4);
        remaining_size-4;
        end loop;

      -- zbavit se dvojic
      if remaining_size div 2>0 then
        opdst.adjust_size(2);
        addii(inst,info,ii_mov,opdst,op_0,op0);
        opdst.shift_displacement(2);
        end if;

      -- zbavit se posledního bytu
      if remaining_size mod 2>0 then
        opdst.adjust_size(1);
        addii(inst,info,ii_mov,opdst,op_0,op0);
        end if;
      end fillzsmall;
begin
  -- zbývá zkopírovat celé pole
  remaining_size:=size;

  if {%%TODO(AGGREGATE) remaining_size in [1..ismallobject]} remaining_size>=1 and remaining_size<=ismallobject

    -- malý objekt => nacpat tam přes MOV
    then
      fillzsmall(opdst);

    -- velký objekt => použít STOSD
    else
      declare var
        opeax      : c_operand;                  -- nula pro STOSD
        opecx      : c_operand;                  -- počet prvků

      begin
        -- načíst adresu do EDI
        i_gen_load_address_to_register(inst,info,context,opdst,for pref_reg use in_edi,for force_reg use true);

        -- shodit Direction Flag
        addii(inst,info,ii_cld,op0,op0,op0);

        -- potřebujeme EAX a ECX
        opeax.create_use_register(inst,info,context,edt_unsigned,ir_eax);
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- do EAX dát nulu
        addii(inst,info,ii_mov,opeax,op_0,op0);

        -- do ECX dát počet čtveřic
        declare var
          optemp   : c_operand;                  -- pomocný operand
        begin
          optemp.create_imm(edt_unsigned,0,unsigned_to_imm32(remaining_size div 4{size-size mod 4}));
          addii(inst,info,ii_mov,opecx,optemp,op0);
        leave
          optemp.free(info,context);
          end declare;

        -- REP STOSD
        addip(inst,info,ip_rep);
        addii(inst,info,ii_stosd,op0,op0,op0);

        -- dojet zbytek
        if remaining_size mod 4>0 then
          declare var
            opmem  : c_operand;                  -- cílový operand ve tvaru [EDI+ofs]

          begin
            -- sestavit [EDI]
            opmem.clone(inst,info,context,opdst);
            opmem.transform_reg_to_mem(edt_binary,0);
            -- Ondra 12.9.2002 : REP STOSD už nastavil EDI na začátek zbytku
            -- opmem.disp:=timm32(0{remaining_size-remaining_size mod 4});

            -- vyfillzovat zbytek
            remaining_size:=remaining_size mod 4;
            fillzsmall(opmem);

          leave
            -- uvolnit [EDI]
            opmem.free(info,context);
            end declare;
          end if;

      leave
        -- uvolnit pomocné operandy
        opeax.free(info,context);
        opecx.free(info,context);
        end declare;
      end if;
  end i_gen_fillz_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_fillz_dynamic =
-- Vypnění pole dynamické velikosti nulou.
-- OPDST musí být typu IO_MEM a měl by preferovaně používat EDI (pro STOSD).
-- OPSIZE musí být registr ECX.
----------------------------------------------------------------------------------------------------
var
  opeax            : c_operand;                  -- nula pro STOSD
  tg_3             : itarget;                    -- cíl skoku na dojetí zbývajících bytíků
  tg_end           : itarget;                    -- cíl skoku na konec

begin
  verify({VERIFY=}000472,(opsize.optype<>io_reg) or (opsize.reg.reg<>ir_ecx));

  -- alokovat cíle skoků
  newtarget(info,tg_3);
  newtarget(info,tg_end);

  -- načíst adresu do EDI
  i_gen_load_address_to_register(inst,info,context,opdst,for pref_reg use in_edi);

  -- shodit Direction Flag
  addii(inst,info,ii_cld,op0,op0,op0);

  -- potřebujeme EAX
  opeax.create_use_register(inst,info,context,edt_unsigned,ir_eax);

  -- do EAX dát nulu
  addii(inst,info,ii_mov,opeax,op_0,op0);

  -- není velikost příznivě malá ?
  addii(inst,info,ii_cmp,opsize,op_3,op0);
  addjump(inst,info,context,ic_be,tg_3);

  -- schovat si ECX
  addii(inst,info,ii_push,opsize,op0,op0);

  -- do ECX dát počet čtveřic
  addii(inst,info,ii_shr,opsize,op_2,op0);

  -- REP STOSD
  addip(inst,info,ip_rep);
  addii(inst,info,ii_stosd,op0,op0,op0);

  -- obnovit ECX
  addii(inst,info,ii_pop,opsize,op0,op0);

  -- cíl skoku na toto místo
  settarget(info,tg_3,getaddr(inst));

  -- vzít poslední 2 bity
  addii(inst,info,ii_and,opsize,op_3,op0);

  -- není to nula ? (nemusí se porovnávat, flagy nastaví AND)
  addjump(inst,info,context,ic_e,tg_end);

  -- dojet zbytek
  addip(inst,info,ip_rep);
  addii(inst,info,ii_stosb,op0,op0,op0);

  -- cíl skoku na toto místo
  settarget(info,tg_end,getaddr(inst));

leave
  -- uvolnit pomocné operandy
  opeax.free(info,context);
  end i_gen_fillz_dynamic;



----------------------------------------------------------------------------------------------------
procedure i_gen_subprogram_address =
-- Vygeneruje adresu podprogramu.
----------------------------------------------------------------------------------------------------
begin
  if psubprog^.etype=et_procedure and pentity_procedure(psubprog)^.import_info<>nil
    then vysl.create_memory_address(inst,info,context,edt_address,4,ir_none,0);
    else
      if relative
        then vysl.create_relative_address(4);
        else vysl.create_imm(edt_address,4,0);
        end if;
      end if;
  vysl.set_relo_entity(psubprog);
  end i_gen_subprogram_address;



end ci_fragment;