----------------------------------------------------------------------------------------------------
module private ci_fragment =
-- Překladač Flexu.
-- Metody na generování různých fragmentů kódu.
----------------------------------------------------------------------------------------------------
-- Ondra : 17.01.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  ci_code,
  ci_code.ci_operand,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_reg,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_32.cp_util;

----------------------------------------------------------------------------------------------------
procedure i_ensure_address =
-- Zajistí, že operand reprezentuje adresu hodnoty uložené v paměti.
----------------------------------------------------------------------------------------------------
begin
  -- operand již reprezentuje absolutní adresu => nedělat nic
  if op.edtype=edt_address then
    -- kontrola konzistence (absolutní adresa může být uložena v registru, jako přímá hodnota
    -- nebo dokonce jako adresa v paměti například v případě proměnných s módem [vm_ref])
    verify({VERIFY=}000863,op.optype not in t_operand_type_set:[io_imm,io_reg,io_mem]);

  -- operand reprezentuje hodnotu => zjistit, jestli není potřeba použít pracovní proměnnou
  elsif op.edtype in edts_value then
    case op.optype
      -- adresa hodnoty => nedělat nic
      when io_mem do

      -- přímo uvedená hodnota => přiřadit do pracovní proměnné
      when io_reg, io_imm, io_cc do
          -- alokovat pracovní proměnnou
          i_gen_loadtemp(inst,info,context,op);
          verify({VERIFY=}000875,op.optype<>io_mem);

      -- %%X a co [io_stack] ? asi naprogramovat, až to bude poprvé potřeba

      -- nic jiného tu nemá co dělat
      when others do verify({VERIFY=}000864,true);
      end case;

  -- nic jiného tu nemá co dělat
  else
    verify({VERIFY=}000865,true);
    end if;
  end i_ensure_address;



----------------------------------------------------------------------------------------------------
procedure i_ensure_value =
-- Zajistí, že operand reprezentuje hodnotu.
----------------------------------------------------------------------------------------------------
begin
{ Jestliže procedura generující podvýraz předala ven adresu, měla pro to určitě dobrý důvod
  a tudíž se to do nějakého zpracování hodnoty nemělo vůbec dostat, ne?

  -- operand reprezentuje absolutní adresu => převést na adresní operand reprezentující hodnotu
  if op.edtype=edt_address then
    case op.optype
      -- přímá hodnota => převést na paměťovou adresu
      when io_imm do op.transform_imm_to_mem();

      -- registr => převést na paměťovou adresu
      when io_reg do op.transform_reg_to_mem();

      -- nic jiného tu nemá co dělat
      when others do verify({VERIFY=}000866,true);
      end case;
}
  -- operand již reprezentuje hodnotu => zjistit, jestli není potřeba použít pracovní proměnnou
  if op.edtype in edts_value then
    -- kontrola konzistence
    verify({VERIFY=}000867,op.optype not in t_operand_type_set:[io_imm,io_reg,io_mem,io_cc,io_stack]);

  -- nic jiného tu nemá co dělat
  else
    verify({VERIFY=}000868,true);
    end if;
  end i_ensure_value;



----------------------------------------------------------------------------------------------------
procedure i_gen_loadreg =
-- Načte operand do registru.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek

begin
  verify({VERIFY=}000323,context.rsize=0);

  -- načíst do registru
  if op.optype=io_mem or (all and op.optype=io_imm) then
    -- operand
    vysl.create_new_register_from_operand(inst,info,context,edt_unsigned,context.rsize,op);

    -- konstanty se konvertujou samy
    if op.optype=io_imm then op.adjust_size(0); end if;

    -- přiřadit
    -- bez konverze velikosti operandu
    if context.rsize=op.size or op.size=0 then
      vysl.adjust_size(context.rsize);  -- %%FLEX Proč, když se v této velikosti již vytváří?
      addii(inst,info,ii_mov,vysl,op,op0)

    -- rozšíření operandu
    elsif context.rsize>op.size then
      if {%%CONTEXT ptyp^.stype=dt_signed} context.rsign and then orgtyp^.stype=dt_signed
        -- znaménkově
        then addii(inst,info,ii_movsx,vysl,op,op0)
        -- neznaménkově
        else addii(inst,info,ii_movzx,vysl,op,op0)
        end if;

    -- zúžení operandu
    else
      -- %%X generovat Overflow-check
      -- %%X nahradit dvojicí XOR MOV
      -- cože ? ^^^^^^^
      op.adjust_size(vysl.size);
      addii(inst,info,ii_mov{zx},vysl,op,op0);
      -- %%X Tady bylo II_MOVZX, co to mělo znamenat ?
      end if;

    -- předat výsledek
    op.replace(info,context,vysl);

  -- operand už je v registru
  elsif op.optype=io_reg then
    -- rozšíření operandu
    if context.rsize>op.size then
      -- výsledek
      vysl.create_use_register(inst,info,context,edt_unsigned,op.reg.reg);
      vysl.adjust_size(context.rsize);

      -- rozšířit
      if context.rsign and then orgtyp^.stype=dt_signed
        -- znaménkově
        then addii(inst,info,ii_movsx,vysl,op,op0)
        -- neznaménkově
        else addii(inst,info,ii_movzx,vysl,op,op0);
        end if;
      -- %%X šlo by použít CBW/CWD ?

      -- předat výsledek
      op.replace(info,context,vysl);

    -- zúžení operandu
    elsif context.rsize<op.size then
      -- ESI/EDI se musí řešit zvlášť
      if context.rsize=1 and op.reg.reg in iregset:[ir_si,ir_di,ir_esi,ir_edi] then
        -- alokovat registr
        vysl.create_new_register(inst,info,context,edt_unsigned,context.rsize);

        -- pro účely přiřazení se budou oba operandy chápat jako 32bitové (SI --> ESI, DI --> EDI)
        vysl.adjust_size(idefregsize);
        op.adjust_size(idefregsize);

        -- movenout
        addii(inst,info,ii_mov,vysl,op,op0);

        -- změnit velikost výsledku zpět na požadovanou
        vysl.adjust_size(context.rsize);

        -- předat výsledek
        op.replace(info,context,vysl);

      -- pro ostatní registry je to triviální
      else
        op.adjust_size(context.rsize);
        end if;
      end if;

  -- konstanta, aspoň upravit velikost
  elsif op.optype=io_imm then
    op.adjust_size(context.rsize);

  -- podmínka
  elsif op.optype=io_cc and all then
    -- operand
    vysl.create_new_register(inst,info,context,edt_unsigned,context.rsize);

    -- nastavit hodnotu
    addset(inst,info,context,op.cc,vysl);

    -- předat výsledek
    op.replace(info,context,vysl);

  -- všechno kromě OP_IMM a OP_CC, které se ponechávají v původním tvaru, neumíme zpracovat
  else
    verify({VERIFY=}000523,op.optype not in t_operand_type_set:[io_imm,io_cc]);
    end if;

leave
  -- uvolnit mezivýsledek
  vysl.free(info,context);
  end i_gen_loadreg;



----------------------------------------------------------------------------------------------------
procedure i_gen_compute_rtattrib =
-- Vypočte chybějící run-time atribut a uloží ho do cílového pointeru.
----------------------------------------------------------------------------------------------------
var
  oppart           : c_operand;

begin
  -- přiravit operand
  oppart.create_imm(edt_unsigned,4,0);

  -- určit jeho hodnotu
  case rta
    -- vymyslet :size
    when rta_size do
        if oldbase=nil
          then oppart.set_imm(timm32(0));
          else oppart.set_imm(unidata_size_to_imm32(oldbase^.size));
          end if;
      {%%TODO(CODEGEN) Tohle zase obnovit, až někdo předělá I_GEN_REF (viz Chyba [20030226115311])
        verify({VERIFY=}000505,oldbase=nil);
        oppart.imm:=unidata_size_to_imm32(oldbase^.size);
      }

    -- vymyslet do :last
    when rta_last do
        -- pointery na pole/stringy s bázemi stejné velikosti
        if oldbase<>nil and outbase<>nil
        and (((oldbase^.stype=dt_string) and (outbase^.stype in dts_string))
        or ((oldbase^.stype=dt_array) and (outbase^.stype in dts_array)))
        and oldbase^.base.getctype^.size=outbase^.base.getctype^.size
        then
          oppart.set_imm(uniint_to_imm32(uniint_length(oldbase^.lval,oldbase^.hval)));

        -- jiné varianty zatím ošetřit neumíme
        else
          unimplemented({UNIMP=}000173)
          end if;

    -- atribut :tag
    when rta_tag do
        -- tagy se vyhodnocují až při linkování
        oppart.set_relo_entity(oldbase);

    when others do verify({VERIFY=}000504,true);
    end case;

  -- přiřadit
  addii(inst,info,ii_mov,optemppart,oppart,op0);

leave
  -- uvolnit operand
  oppart.free(info,context);
  end i_gen_compute_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_loadpointer =
-- Normalizuje (=přidá/odstraní/přepočítá v něm uložené dynamické atributy)
-- operand podle typu uloženého v CONTEXTu a načte ho:
--   -- do registru, lze-li to a je-li REG=True,
--   -- ponechá v původním tvaru, pokud ho není třeba měnit,
--   -- načte do pracovní proměnné.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000486,(context.outtyp{^}.stype<>dt_pointer) or (oldtyp^.stype<>dt_pointer));

  ----- načíst do registru -----
  if reg and context.outtyp{^}.size=uds_4 then
    -- normalizovat velikost pointeru
    if op.optype=io_mem then
      op.adjust_size(4);
      end if;

    -- načíst do registru
    i_gen_loadreg(inst,info,context,oldtyp,op,false,irm_addr);

  ----- normalizovat uložené dynamické atributy -----
  elsif context.outtyp{^}.pattrib<>oldtyp^.pattrib then
    -- výsledkem má být pouze adresa
    if context.outtyp{^}.pattrib=rtattribset:[] then
      -- normalizovat velikost pointeru
      if op.optype=io_mem then
        op.adjust_size(4);
        end if;

      -- načíst do registru
      i_gen_loadreg(inst,info,context,oldtyp,op,false,irm_addr);

    -- výsledek má obsahovat i nějaké atributy
    else
      declare var
        outsize    : t_unsigned;                 -- velikost výsledného pointeru
        outbase    : pentity_type;               -- báze výsledného pointeru
        oldbase    : pentity_type;               -- báze původního pointeru
        optemp     : c_operand;                  -- pracovní proměnná

      begin
        -- velikost výsledného pointeru
        outsize:=unidata_size_to_unsigned(context.outtyp{^}.size);

        -- báze obou pointerů
        oldbase:=oldtyp^.base.getutype;
        outbase:=context.outtyp{^}.base{.getutype};

        -- alokovat pracovní proměnnou
        optemp.create_temporary(inst,info,edt_binary,outsize);

        -- kde máme zdrojový pointer ?
        case op.optype
          -- v paměti
          when io_mem     do
              declare var
                opreg      : c_operand;          -- pracovní registr
                oppart     : c_operand;          -- část původního operandu
                optemppart : c_operand;          -- část pracovní proměnné

              begin
                -- budeme potřebovat pracovní registr
                opreg.create_new_register(inst,info,context,edt_unsigned,4);

                -- zkopírovat adresu
                oppart.clone(inst,info,context,op);
                oppart.adjust_size(4);
                optemppart.clone(inst,info,context,optemp);
                optemppart.adjust_size(4);
                addii(inst,info,ii_mov,opreg,oppart,op0);
                addii(inst,info,ii_mov,optemppart,opreg,op0);

                -- zkopírovat jednotlivé atributy
                for rta in rtattrib loop
                  if rta in context.outtyp{^}.pattrib then
                    -- vypočítat umístění atributu v cílovém pointeru
                    i_gen_load_rtattrib_addr(inst,info,context,context.outtyp{^}.pattrib,optemp,rta,optemppart);

                    -- je k dispozici v původním pointeru ?
                    if rta in oldtyp^.pattrib

                      -- ano => zkopírovat
                      then
                        -- načíst do registru
                        i_gen_load_rtattrib_value(inst,info,context,oldtyp^.pattrib,op,rta,opreg);

                        -- je-li to :last, tak je možná nutný ještě nějaký přepočet
                        if rta=rta_last then
                          -- mají-li různé báze, tak zkoumat dál
                          if context.outtyp.base<>oldtyp^.base.getutype then
                            unimplemented({UNIMP=}000175);
                            end if;
                          end if;

                        -- přesunout
                        addii(inst,info,ii_mov,optemppart,opreg,op0);

                      -- není => vymyslet
                      else
                        i_gen_compute_rtattrib(inst,info,context,optemppart,rta,oldbase,outbase);
                        end if;
                    end if;
                  end loop;

              leave
                -- uvolnit pracovní operandy
                opreg.free(info,context);
                oppart.free(info,context);
                optemppart.free(info,context);
                end declare;

          -- v registru či přímá hodnota
          when io_reg, io_imm do
              i_gen_compose_pointer(inst,info,context,op,oldbase,outbase,context.outtyp{^}.pattrib,optemp);
          {
              -- %%X oldtyp^.pattrib<>[] nastává u reference, ale nikde jinde by
              -- pokud vím nemělo, takže by se to mělo v podmínce ověřovat.
              --verify({VERIFY=}000811,(op.optype=io_reg) and (oldtyp^.pattrib<>[]));
              verify({VERIFY=}000812,(op.optype=io_imm) and (op.size<>4));

              -- zkopírovat adresu
              optemppart:=optemp;
              optemppart.size:=4;
              addii(inst,info,ii_mov,optemppart,op,op0);

              -- vymyslet všechny atributy
              for rta in rta:first..rta:last loop
                if rta in context.outtyp^.pattrib then
                  -- vypočítat umístění atributu v cílovém pointeru
                  i_gen_load_rtattrib_addr(inst,info,context,context.outtyp^.pattrib,optemp,rta,optemppart);

                  -- vymyslet atribut
                  computertattrib(rta);
                  end if;
                end loop;
          }

          when others do unimplemented({UNIMP=}000164);
          end case;

        -- převzít výsledek
        op.replace(info,context,optemp);

      leave
        -- uvolnit operandy
        optemp.free(info,context);
        end declare;
      end if;

  ----- ponechat v původním stavu -----
  else
    verify({VERIFY=}000487,context.outtyp{^}.size<>oldtyp^.size);
    -- jinak nic nedělat
    end if;
  end i_gen_loadpointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_compose_pointer =
-- Ze zadaného operandu sestaví pointer. Operand musí být registr nebo přímá
-- hodnota. Všechny dynamické atributy jsou dopočítány. Výsledný pointer je
-- uložen do pracovní proměnné.
----------------------------------------------------------------------------------------------------
var
  opoutpart        : c_operand;                  -- část pracovní proměnné

begin
  -- %%X oldtyp^.pattrib<>[] nastává u reference, ale nikde jinde by
  -- pokud vím nemělo, takže by se to mělo v podmínce ověřovat.
  --verify({VERIFY=}000813,(op.optype=io_reg) and (oldtyp^.pattrib<>[]));
  verify({VERIFY=}000508,op.optype not in t_operand_type_set:[io_reg,io_imm] or opout.optype<>io_mem);
  verify({VERIFY=}000814,op.optype=io_imm and op.size<>4);

  -- zkopírovat adresu
  opoutpart.clone(inst,info,context,opout);
  opoutpart.adjust_size(4);
  addii(inst,info,ii_mov,opoutpart,op,op0);

  -- vymyslet všechny atributy
  for rta in rtattrib loop
    if rta in outrta then
      -- vypočítat umístění atributu v cílovém pointeru
      i_gen_load_rtattrib_addr(inst,info,context,outrta,opout,rta,opoutpart);

      -- vymyslet atribut
      i_gen_compute_rtattrib(inst,info,context,opoutpart,rta,oldbase,outbase);
      end if;
    end loop;

leave
  -- uvoltit operandy
  opoutpart.free(info,context);
  end i_gen_compose_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_lea =
-- Načte adresu danou operandem do registru.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure movreg (
        vysl       : in c_operand;
        reg        : in ireg) =
    ------------------------------------------------------------------------------------------------
    begin
      -- není to náhodou ten samý registr ?
      if iregtouni[reg]<>rpref then
        declare var
          optemp   : c_operand;                  -- pomocný operand

        begin
          -- připravit operand
          optemp.create_use_register(inst,info,context,edt_unsigned,reg);

          -- zkopírovat
          addii(inst,info,ii_mov,vysl,optemp,op0);

        leave
          -- uvolnit pomocný operand
          optemp.free(info,context);
          end declare;
        end if;
      end movreg;

begin
  if rpref<>in_none

    -- je určen preferovaný registr => načíst do něj
    then
      declare var
        vysl       : c_operand;                  -- výsledek

      begin
        -- vytvořit operand
        vysl.create_use_register(inst,info,context,edt_unsigned,iunitoreg[rpref,idefregsize]{%%FLEX rpref});

        case op.optype
          -- registr
          when io_reg     do movreg(vysl,op.reg.reg);

          -- adresa v paměti
          when io_mem     do
              -- jen displacement, použít MOV
              if op.base.reg=ir_none and op.index.reg=ir_none then
                declare var
                  optemp : c_operand;              -- pomocný operand

                begin
                  -- připravit operand
                  optemp.create_imm(edt_unsigned,idefregsize,op.disp);
                  optemp.copy_relo(op);

                  -- přiřadit
                  addii(inst,info,ii_mov,vysl,optemp,op0);

                leave
                  -- uvolnit pomocný operand
                  optemp.free(info,context);
                  end declare;

              -- jen báze, použít MOV
              elsif op.base.reg<>ir_none and op.index.reg=ir_none and op.disp=timm32(0) then
                movreg(vysl,op.base.reg);

              -- jen index*1, použít MOV
              elsif op.base.reg=ir_none and op.index.reg<>ir_none and op.disp=timm32(0) and op.relo_info.rtype=irt_none and op.scale=1 then
                movreg(vysl,op.index.reg);

              -- %%X a co případ RPREF+10 ? => přes ADD

              -- složitější, použít LEA
              else
                addii(inst,info,ii_lea,vysl,op,op0);
                end if;

          -- data na stacku
          when io_stack do
              -- data jsou přímo na vrcholu stacku a máme jistotu, že nikdo neudělal nějaký
              -- PUSH, který by s nimi pohnul (ani NEWOPUSE - viz CI_CODE.I_USEUNI)
              addii(inst,info,ii_mov,vysl,op_esp,op0);

          when others do verify({VERIFY=}000361,true);
          end case;

        -- předat výsledek
        op.replace(info,context,vysl);

      leave
        -- uvolnit mezivýsledek
        vysl.free(info,context);
        end declare

    -- není určen preferovaný registr => načíst do libovolného
    else
      case op.optype
        -- přímá hodnota
        when io_imm     do
            -- normalizovat velikost
            op.adjust_size(4);

        -- registr
        when io_reg     do -- nic nedělat

        -- odkaz na paměť
        when io_mem     do
            -- jen displacement, předat jako přímou hodnotu
            if op.base.reg=ir_none and op.index.reg=ir_none then
              op.transform_mem_to_imm;

            -- jen bázový registr
            elsif ((op.base.reg<>ir_none and op.index.reg=ir_none)
            -- nebo jen indexní registr
            or (op.base.reg=ir_none and op.index.reg<>ir_none and op.scale=1))
            -- a nulové posunutí
            and op.disp=timm32(0) and op.relo_info.rtype=irt_none then
              declare var
                vysl : c_operand;                -- výsledek

              begin
                -- jen alokovat operand
                vysl.create_new_register_from_operand(inst,info,context,edt_address,4,op);

                -- jistě se vybere ten správný registr
                verify({VERIFY=}000326,not (((op.base.reg<>ir_none) and (vysl.reg.reg=op.base.reg)) or ((op.index.reg<>ir_none) and (vysl.reg.reg=op.index.reg))));

                -- předat výsledek
                op.replace(info,context,vysl);

              leave
                -- uvolnit mezivýsledek
                vysl.free(info,context);
                end declare;

            -- %%X Případ "EAX+10" dělat přes ADD a ne pomocí LEA

            -- v ostatních případech je opravdu nutné LEA
            else
              declare var
                vysl : c_operand;                -- výsledek

              begin
                -- operand
                vysl.create_new_register(inst,info,context,edt_address,4);

                -- načíst adresu
                addii(inst,info,ii_lea,vysl,op,op0);

                -- předat výsledek
                op.replace(info,context,vysl);

              leave
                -- uvolnit mezivýsledek
                vysl.free(info,context);
                end declare;
              end if;

        -- relativní adresa
        when io_rel     do -- %%X co s tím ?

        -- data na stacku
        when io_stack   do
            declare var
              vysl : c_operand;                -- výsledek

            begin
              -- operand
              vysl.create_new_register(inst,info,context,edt_address,4);

              -- data jsou přímo na vrcholu stacku a máme jistotu, že nikdo neudělal nějaký
              -- PUSH, který by s nimi pohnul (ani NEWOPUSE - viz CI_CODE.I_USEUNI)
              addii(inst,info,ii_mov,vysl,op_esp,op0);

              -- předat výsledek
              op.replace(info,context,vysl);

            leave
              -- uvolnit mezivýsledek
              vysl.free(info,context);
              end declare;

        when others do verify({VERIFY=}000074,true);
        end case;
      end if;
  end i_gen_lea;



----------------------------------------------------------------------------------------------------
procedure i_gen_loadeax =
-- Načte operand do EAX.
----------------------------------------------------------------------------------------------------
var
  vysl             : c_operand;                  -- výsledek
  eax              : ireg;                       -- zvolený registr
  i                : t_unsigned;

begin
  -- kromě případu hodnoty již v AL, AX, EAX; (AH se musí kopírovat do AL)
  if op.optype=io_reg and then op.reg.reg in iregset:[ir_al,ir_ax,ir_eax] then
    return;
    end if;

  -- velikost registru
  if op.size=0
    then i:=context.rsize;
    else i:=op.size;
    end if;
  -- %%X Mám dojem, že požadovaná velikost může být i jiná, než je skutečná
  -- velikost operandu. V takovém případě ale v této proceduře chybí
  -- kód na konverzi operandu.
  verify({VERIFY=}000324,i<>context.rsize);

  -- vybrat variantu registru
  case i
    when 0 do eax:=ir_eax;
    when 1 do eax:=ir_al;
    when 2 do eax:=ir_ax;
    when 4 do eax:=ir_eax;
    when others do verify({VERIFY=}000030,true);
    end case;

  -- operand
  vysl.create_use_register(inst,info,context,op.edtype,eax);

  -- %%X Pro případ MOV AL,AH použít SHR EAX,8
  -- (Pentiu se to bude určitě líbit víc)

  -- přiřadit
  addii(inst,info,ii_mov,vysl,op,op0);

  -- předat výsledek
  op.replace(info,context,vysl);

leave
  -- uvolnit mezivýsledek
  vysl.free(info,context);
  end i_gen_loadeax;



----------------------------------------------------------------------------------------------------
procedure i_gen_loadimm8cl =
-- Načte operand do CL nebo ho ponechá const.
----------------------------------------------------------------------------------------------------
begin
  -- kromě případu hodnoty již v CL, CX, ECX; (CH se musí kopírovat do CL)
  if op.optype=io_reg and then op.reg.reg in iregset:[ir_cl,ir_cx,ir_ecx] then
    -- změnit na CL (a případně zúžit)
    op.adjust_size(1);

  -- je v registru, ale nějakém jiném
  elsif op.optype=io_reg then
    declare var
      vysl         : c_operand;                  -- výsledek

    begin
      -- výsledek
      vysl.create_use_register(inst,info,context,op.edtype,ir_cl);

      -- %%TECH Kdyby mělo ESI a EDI 8-bitové části, tak by
      -- šlo vše movat 8-bitově... (a kdyby SHL/SHR nebylo
      -- tak debilně vymyšlený, tak to tu nemuselo bejt vůbec)

      -- je to v CH, udělat SHR
      if op.reg.reg=ir_ch then
        -- změnit CL na ECX 
        vysl.adjust_size(4);

        -- shiftnout
        addii(inst,info,ii_shr,vysl,op_8,op0);

        -- a zase zpět na CL
        vysl.adjust_size(1);

      -- již má správnou velikost
      elsif op.size=1 then
        -- stačí movenout
        addii(inst,info,ii_mov,vysl,op,op0);

      -- 2 nebo 4 byty, provést 32-bitově (co kdyby to bylo (E)SI nebo (E)DI)
      else
        -- udělat z obou operandů 32 bitů
        op.adjust_size(4);
        vysl.adjust_size(4);

        -- movenout
        addii(inst,info,ii_mov,vysl,op,op0);

        -- a výsledek opět zúžit na 8 bitů
        vysl.adjust_size(1);
        end if;

    -- předat výsledek
    op.replace(info,context,vysl);

  leave
    -- uvolnit mezivýsledek
    vysl.free(info,context);
    end declare;

  -- konstanta
  elsif op.optype=io_imm then
    -- zúžit na 8 bitů
    op.adjust_size(1);

  -- je v paměti
  else
    declare var
      vysl         : c_operand;                  -- výsledek

    begin
      -- výsledek
      vysl.create_use_register(inst,info,context,op.edtype,ir_cl);

      -- udělat z toho 8 bitů
      op.adjust_size(1);

      -- movenout
      addii(inst,info,ii_mov,vysl,op,op0);

      -- předat výsledek
      op.replace(info,context,vysl);

    leave
      -- uvolnit mezivýsledek
      vysl.free(info,context);
      end declare;
    end if;
  end i_gen_loadimm8cl;



----------------------------------------------------------------------------------------------------
procedure i_gen_loadtemp =
-- Načte operand do temporary proměnné nebo ho ponechá const.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000417,op.size<>1 and op.size<>2 and op.size<>4);

  case op.optype
    -- přímá hodnota
    when io_imm do -- nic nedělat

    -- registr
    when io_reg do
        declare var
          optemp   : c_operand;                  -- temporary proměnná

        begin
          -- alokovat temporary proměnnou
          optemp.create_temporary(inst,info,op.edtype,op.size);

          -- přesunout
          addii(inst,info,ii_mov,optemp,op,op0);

          -- předat výsledek
          op.replace(info,context,optemp);

        leave
          -- uvolnit mezivýsledek
          optemp.free(info,context);
          end declare;

    -- paměť
    when io_mem do
        declare var
          optemp   : c_operand;                  -- temporary proměnná
          opreg    : c_operand;                  -- pomocný registr

        begin
          -- alokovat temporary proměnnou
          optemp.create_temporary(inst,info,op.edtype,op.size);

          -- pomocný registr
          opreg.create_new_register(inst,info,context,op.edtype,op.size);

          -- přesunout
          addii(inst,info,ii_mov,opreg,op,op0);
          addii(inst,info,ii_mov,optemp,opreg,op0);

          -- předat výsledek
          op.replace(info,context,optemp);

        leave
          -- uvolnit mezivýsledek
          optemp.free(info,context);
          opreg.free(info,context);
          end declare;

    when others do verify({VERIFY=}000416,true);
    end case;
  end i_gen_loadtemp;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_rtattrib_addr =
-- Podle EXPR/OP určí adresu dynamického atributu RTA.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure get_set return rtattribset =
    ------------------------------------------------------------------------------------------------
    with
      advanced,
      advanced.low_level,
      advanced.low_level.bit_operations;

    begin
      for xrta in rta:first..pred rta loop
        if xrta in rtaset then
          bit_set(result,t_bit_index(xrta:ord));
          end if;
        end loop;
      end get_set;

var
  x                : timm32;

begin
  verify({VERIFY=}000551,op.optype<>io_mem);

  -- základ operandu se shodný s původním operandem
  oprta.clone(inst,info,context,op);

  -- upravit velikost
  oprta.adjust_size(unidata_size_to_unsigned(cpu32_rtattribsize[rta]));

  -- offset run-time atributu v rámci původního operandu
  if rta>rta:first then
    getrtattribsetsize(get_set{%%TODO(SET)rtaset*rtattribset:[rta:first..pred rta]},x);
    end if;
  oprta.shift_displacement(imm32_to_signed{%%X}(imm32_lpointer32+x));
  end i_gen_load_rtattrib_addr;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_rtattrib_value =
-- Podle EXPR/OP načte dynamický atribut RTA.
----------------------------------------------------------------------------------------------------
var
  oprta            : c_operand;

begin
  -- načíst adresu dynamického atributu
  i_gen_load_rtattrib_addr(inst,info,context,rtaset,op,rta,oprta);

  -- načíst hodnotu do registru
  addii(inst,info,ii_mov,opreg,oprta,op0);

leave
  -- uvolnit operand
  oprta.free(info,context);
  end i_gen_load_rtattrib_value;



----------------------------------------------------------------------------------------------------
procedure i_load_this_address =
-- Adresa THIS pointeru na instanci třídy resp. složky v rámci třídy.
----------------------------------------------------------------------------------------------------
begin
  -- načíst pointer na třídu
  i_gen_this_address(inst,op);
  i_gen_loadreg(inst,info,context,nil,op,true,irm_addr);

  -- udělat z registru adresu
  op.transform_reg_to_mem(_edtype,_size);

  -- přičíst offset složky
  op.shift_displacement(imm32_to_signed{%%X}(unidata_addr_to_imm32(ofs)));
  end i_load_this_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_this_address =
-- Sestaví adresu THIS pointeru na instanci třídy.
----------------------------------------------------------------------------------------------------
begin
  op.create_memory_address_on_stack(inst,edt_address,lpointer32,signed_to_imm32(inst.profile.thisofs));
  end i_gen_this_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_pushstack =
-- Uloží operand na stack.
----------------------------------------------------------------------------------------------------
begin
  case op.optype
    -- někdo už ho pro nás na stack uložil
    when io_stack do -- nic nedělat

    -- přímá hodnota
    when io_imm do
        verify({VERIFY=}000557,op.size<>0 and op.size<>1 and op.size<>2 and op.size<>4);

        declare var
          old_size : t_unsigned;                 -- původní velikost operandu

        begin
          -- normalizovat na 32 bitů
          old_size:=op.size;
          op.adjust_size(4);

          -- pushnout
          addii(inst,info,ii_push,op,op0,op0);

          -- vrátit zpět původní velikost
          op.adjust_size(old_size);
          end declare;

    -- registr
    when io_reg do
        declare var
          old_size : t_unsigned;                 -- původní velikost operandu

        begin
          -- normalizovat na 32 bitů
          old_size:=op.size;
          op.adjust_size(4);

          -- pushnout
          addii(inst,info,ii_push,op,op0,op0);

          -- vrátit zpět původní velikost
          op.adjust_size(old_size);
          end declare;

    -- operand v paměti
    when io_mem do
        case op.size
          -- zvlášť příznivá velikost
          when 4 do addii(inst,info,ii_push,op,op0,op0);

          -- příznivá velikost
          when 1,2 do
              declare var
                op1 : c_operand;                 -- pracovní kopie operandu

              begin
                -- naklonovat operand
                op1.clone(inst,info,context,op);

                -- načíst do registru
                i_gen_loadreg(inst,info,context,nil,{%%CONTEXT nil,}op1,true,irm_int);

                -- normalizovat na 32 bitů
                op1.adjust_size(4);

                -- pushnout
                addii(inst,info,ii_push,op1,op0,op0);

              leave
                -- uvolnit pracovní operand
                op1.free(info,context);
                end declare;

          -- slabě příznivá velikost
          when 8,12,16 do
              declare var
                op1 : c_operand;                 -- pracovní kopie operandu

              begin
                -- naklonovat operand
                op1.clone(inst,info,context,op);

                -- normalizovat na 32 bitů
                op1.adjust_size(4);

                -- posunout operand na konec
                op1.shift_displacement(t_signed(op.size-4));

                -- n-krát pushnout
                for i in reverse 1..op.size div 4 loop
                  addii(inst,info,ii_push,op1,op0,op0);
                  op1.unshift_displacement(4);
                  end loop;

              leave
                -- uvolnit pracovní operand
                op1.free(info,context);
                end declare;

          when others do unimplemented({UNIMP=}000060);
          end case;

    -- výsledek porovnání
    when io_cc do
        declare var
          op1      : c_operand;                  -- pracovní kopie operandu

        begin
          -- budeme potřebovat registr
          op1.create_new_register(inst,info,context,edt_unsigned,4);

          -- nastavit
          addset(inst,info,context,op.cc,op1);

          -- uložit na stack
          addii(inst,info,ii_push,op1,op0,op0);

        leave
          -- uvolnit pracovní operand
          op1.free(info,context);
          end declare;

    when others do verify({VERIFY=}000150,true);
    end case;
  end i_gen_pushstack;



----------------------------------------------------------------------------------------------------
procedure i_gen_pushnil =
-- Uloží NIL na stack.
----------------------------------------------------------------------------------------------------
var
  nsize            : t_unsigned;                 -- normalizovaná velikosti NILu v násobcích 4 B

begin
  -- normalizovat velikost na násobek 4
  nsize:=(unidata_size_to_imm32(size)+3) div 4;

  -- kolic moc nul budeme pushovat ?
  if nsize<=8

    -- jen toho málo => pushnout přímo
    then
      -- n-krát pushnout 0
      while nsize>0 loop
        addii(inst,info,ii_push,op_0_32bit,op0,op0);
        pred nsize;
        end loop;

    -- je toho hodně => vzít to cyklem
    else
      unimplemented({UNIMP=}000192);
      end if;
  end i_gen_pushnil;



----------------------------------------------------------------------------------------------------
procedure i_gen_logical_jump =
-- Generování skoku podle výsledku porovnání.
----------------------------------------------------------------------------------------------------
begin
  -- definovány oba skoky
  if ttarget<>tgfallthru and ftarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,icondneg[cc],ttarget);
      else addjump(inst,info,context,cc,ttarget);
      end if;
    addjump(inst,info,context,ic_ucond,ftarget);

  -- skok pouze při True
  elsif ttarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,icondneg[cc],ttarget);
      else addjump(inst,info,context,cc,ttarget);
      end if;

  -- skok pouze při False
  elsif ftarget<>tgfallthru then
    if and_then
      then addjump(inst,info,context,cc,ftarget);
      else addjump(inst,info,context,icondneg[cc],ftarget);
      end if;

  -- žádný skok
  else
    if and_then
      then vysl.create_condition(icondneg[cc]);
      else vysl.create_condition(cc);
      end if;
    end if;
  end i_gen_logical_jump;



----------------------------------------------------------------------------------------------------
procedure i_gen_mul_reg =
-- Násobení registru konstantou.
-- Tato procedura nemá vliv na Zero Flag.
----------------------------------------------------------------------------------------------------
var
  n                : t_unsigned32;               -- shift
  op2              : c_operand;                  -- pracovní operand

begin
  verify({VERIFY=}000341,imm=timm32(0) or op1.optype<>io_reg or op1.reg.reg not in ir_r32);

  -- je čím násobit ?
  if imm=timm32(1) then return; end if;

  -- násobení 2^n
  if imm32_is_power_of_2(imm,n) then
    -- připravit druhý operand
    op2.create_imm(edt_unsigned,1,unsigned_to_imm32(n));

    -- přidat instrukci
    addii(inst,info,ii_shl,op1,op2,op0);

  -- násobení 3,5,9
  elsif imm=timm32(3) or imm=timm32(5) or imm=timm32(9) then
    -- připravit druhý operand
    op2.create_memory_address(inst,info,context,edt_binary,0,op1.reg.reg,0);
    op2.shift_by_index(inst,info,context,op1.reg.reg,imm32_to_unsigned(imm)-1);

    -- přidat instrukci
    addii(inst,info,ii_lea,op1,op2,op0);

  -- normální násobení
  else
    -- připravit druhý operand
    op2.create_imm(edt_unsigned,4,imm);

    -- přidat instrukci
    addii(inst,info,ii_imul,op1,op2,op0);
    end if;

  -- první operand neuvolňovat (registr se používá dál ve volající rutině)

leave
  -- uvolnit operand
  op2.free(info,context);
  end i_gen_mul_reg;



----------------------------------------------------------------------------------------------------
procedure i_gen_div_reg =
-- Dělení registru konstantou.
-- OP1 musí být 32-bitový registr.
----------------------------------------------------------------------------------------------------
var
  n                : t_unsigned32;               -- shift

begin
  verify({VERIFY=}000346,imm=timm32(0) or (op1.optype<>io_reg) or not (op1.reg.reg in ir_r32));

  -- je čím dělit ?
  if imm=timm32(1) then return; end if;

  -- dělení 2^n
  if imm32_is_power_of_2(imm,n) then
    declare var
      op2          : c_operand;                  -- operandy

    begin
      -- připravit druhý operand
      op2.create_imm(edt_unsigned,1,unsigned_to_imm32(n));

      -- přidat instrukci
      addii(inst,info,ii_shr,op1,op2,op0);

    leave
      -- uvolnit druhý operand
      op2.free(info,context);
      end declare;

  -- normální dělení
  else
    unimplemented({UNIMP=}000117);
{
    -- na Intelu nelze dělit konstantou, jen násobit...

    -- rezervovat EDX
    newopuse(inst,info,opedx,4,ir_edx);

    -- vynulovat
    addii(inst,info,ii_mov,opedx,op_0,op0);

    -- registr pro dělení
    newopreg(inst,info,context,op2,4,irm_int,op0);

    -- nacpat do něj konstantu

    -- vydělit

    -- uvolnit EDX
    freeop(info,opedx);
}
    end if;

  -- první operand neuvolňovat (registr se používá dál ve volající rutině)
  end i_gen_div_reg;



----------------------------------------------------------------------------------------------------
procedure i_gen_reduceop =
-- Pokud operand používá moc registrů (=dva), vylepší to (na jeden).
-- Operand musí být typu IO_MEM, IO_STACK nebo IO_IMM.
----------------------------------------------------------------------------------------------------
begin
  case op.optype
    -- přímá hodnota
    when io_imm   do -- nic nedělat

    -- operand na stacku
    when io_stack do -- nic nedělat

    -- operand v paměti
    when io_mem   do
        -- jsou použity dva registry ?
        if op.base.reg<>ir_none and op.index.reg<>ir_none then
          declare var
            org_edtype : t_elementary_data_type;
            org_size   : t_unsigned;
            
          begin
            -- shovat si elementární datový typ a velikost operandu
            org_edtype:=op.edtype;
            org_size:=op.size;

            -- načíst výslednou adresu
            i_gen_lea(inst,info,context,op,in_none);
            verify({VERIFY=}000491,op.optype<>io_reg);

            -- změnit zpět z registru na paměť
            op.transform_reg_to_mem(org_edtype,org_size);
            end declare;
          end if;

    when others do verify({VERIFY=}000338,true{op.optype<>io_mem});
    end case;
  end i_gen_reduceop;



----------------------------------------------------------------------------------------------------
procedure copyblock (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o průběhu generování
    context        : in out iexprcontext;        -- kontext generování výrazu
    opdst0         : in c_operand;               -- cílový operand
    opsrc0         : in c_operand;               -- zdrojový operand
    availregs      : in iuniregset;              -- volné registry
    bytes          : in t_unsigned) =            -- kolic bytů
-- Zkopíruje jeden blok dat délky BYTES z adresy OPDST na adresu OPSRC.
-- Pro kopírování využívá registry z množiny AVAILREGS.
----------------------------------------------------------------------------------------------------
with
  standard.console;

var
  opsrc            : c_operand;                  -- cílový operand
  opdst            : c_operand;                  -- zdrojový operand

    ------------------------------------------------------------------------------------------------
    procedure copysubblock (
              count      : in t_unsigned;        -- počet kopírovaných slov
              n          : in t_unsigned) =      -- velikost slova v bytech
    -- Jedna část kopírování.
    ------------------------------------------------------------------------------------------------
    var
      uni          : iunireg;
      reg          : ireg;

        --------------------------------------------------------------------------------------------
        procedure firstreg =
        -- První registr mezi AVAILREGS.
        --------------------------------------------------------------------------------------------
        begin
          uni:=in_first;
          while uni not in availregs or iunitoreg[uni,n]=ir_none loop succ uni; end loop;
          reg:=iunitoreg[uni,n];
          end firstreg;



        --------------------------------------------------------------------------------------------
        procedure nextreg =
        -- Další registr v AVAILREGS.
        --------------------------------------------------------------------------------------------
        begin
          loop
            if uni=in_last
              then uni:=in_first;
              else succ uni;
              end if;
            until uni in availregs and iunitoreg[uni,n]<>ir_none;
          reg:=iunitoreg[uni,n];
          end nextreg;

    begin
      -- %%TECH I když se zde manipuluje s registry, nepoužívá se standardní CREATE_NEW_REGISTER, 
      -- ale CREATE_NEW_REGISTER_LOW_LEVEL, protože se předpokládá, že pracovní registry byly již
      -- dříve rezervovány.

      -- %%FLEX Nešlo by to nějak čistěji?

      -- nacpat z paměti do registrů
      firstreg;
      for i in 1..count loop
        declare var
          optemp   : c_operand;

        begin
          -- nacpat do registru
          optemp.create_use_register_low_level(edt_unsigned,reg);
          optemp.adjust_size(n);
          addii(inst,info,ii_mov,optemp,opsrc,op0);
          end declare;

        -- další slovo
        opsrc.shift_displacement(imm32_to_signed{%%X}(timm32(n)));

        -- další registr
        nextreg;
        end loop;

      -- nacpat z registrů do paměti
      firstreg;
      for i in 1..count loop
        declare var
          optemp   : c_operand;

        begin
          -- nacpat do paměti
          optemp.create_use_register_low_level(edt_unsigned,reg);
          optemp.adjust_size(n);
          addii(inst,info,ii_mov,opdst,optemp,op0);
          end declare;

        -- další slovo
        opdst.shift_displacement(imm32_to_signed{%%X}(timm32(n)));

        -- další registr
        nextreg;
        end loop;
      end copysubblock;



    ------------------------------------------------------------------------------------------------
    procedure copywords (
        total_words: in t_unsigned;              -- počet slov
        n          : in t_unsigned) =            -- velikost slova v bytech
    -- Zkopíruje zadaný počet slov zadané velikosti.
    ------------------------------------------------------------------------------------------------
    with
      standard.numerics;

    var
      regs         : t_unsigned;                 -- počet n-bytových registrů
      part         : t_unsigned;                 -- velikost části ve slovech
      copy_words   : t_unsigned;                 -- počet zbývajících slov ke zkopírování
      uni          : iunireg;

    begin
      -- velikost operandů
      opsrc.adjust_size(n);
      opdst.adjust_size(n);

      -- kolik máme n-bytových registrů ?
      regs:=i_reg_get_count(availregs,n);

      -- zkopírovat
      copy_words:=total_words;
      while copy_words>0 loop
        -- kolik slov se bude kopírovat
        part:=min_unsigned(regs,copy_words);

        -- zkopírovat
        copysubblock(part,n);

        -- zase jsme se kousku zbavili
        copy_words-part;
        end loop;
      end copywords;

begin
  -- připravit operandy
  opsrc.clone(inst,info,context,opsrc0);
  opdst.clone(inst,info,context,opdst0);

  -- zkopírovat čtyřbytová slova
  copywords(bytes div 4,4);

  -- zkopírovat jednobytová slova
  copywords(bytes mod 4,1);

{ Funguje to i takhle:

  -- zkopírovat dvoubytová slova
  copywords((bytes mod 4) div 2,2);

  -- zkopírovat jednobytová slova
  copywords((bytes mod 4) mod 2,1);
}
leave
  -- uvolnit pracovní operandy
  opsrc.free(info,context);
  opdst.free(info,context);
  end copyblock;



----------------------------------------------------------------------------------------------------
procedure i_gen_move_static =
-- Přesun pole velikosti SIZE bytů z OPSRC do OPDST.
-- Předpokládá se, že se pole nepřekrývají.
-- Předpokládá se (kvůli optimalizaci), že jsou pole zarovnána na hranici 4B.
-- OPSRC a OPDST musí být typu IO_MEM s redukovaným počtem registrů (= <=1).
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  availregs        : iuniregset;                 -- volné registry použitelné pro movaní

begin
  verify({VERIFY=}000489,(opsrc.optype<>io_mem) or (opdst.optype<>io_mem));

  ----- %%TECH Kopírování bloku pevné velikosti --------------------------
  -- Pokud je pole dostatečně malé, kopíruje se přímo, negeneruje se žádný
  -- cyklus. Rozhoduje se podle aktuálního množství volných registrů, nejvýše
  -- se však za malý blok považuje ISMALLOBJECT bytů.
  --   Delší bloky se kopírují po 8 nebo 12 bytech, podle počtu volných
  -- registrů. Když je volný jen jeden registr, použije se dvakrát za
  -- iteraci.
  --   Zbytek modulo 8 resp. 12 se kopíruje jako v případě malého bloku.
  --
  -- Příklad: Blok z [ESI] do [EDI] o velikosti 27 bytů, 3 volné registry.
  --
  --         -- jeden registr se spotřebuje jako čítač
  --         mov    eax,16
  --         -- zkopírovat v délce dělitelné 8
  --     @1: mov    ebx,[esi+eax+0]
  --         mov    ecx,[esi+eax+4]
  --         mov    [edi+eax+0],ebx
  --         mov    [edi+eax+4],ecx
  --         sub    eax,8
  --         jns    @1
  --         -- zkopírovat zbytek
  --         mov    bl,[esi+24]
  --         mov    cl,[esi+25]
  --         mov    [edi+24],bl
  --         mov    [edi+25],bl
  --         mov    bl,[esi+26]
  --         mov    [edi+26],bl
  --
  --------------------------------------------------------------------------------------------------

  -- kolik je asi tak volných registrů ?
  i_reg_get_available(context,availregs);

  -- algoritmus se volí podle počtu (skutečně) volných registrů
  if size<=min_unsigned(ismallobject,max_unsigned(1,i_reg_get_count(availregs,4))*4*2-1)

    -- pokud máme dost registrů, nemusíme se zatěžovat s cyklem
    then
      -- rezervovat volné registry (nebo aspoň jeden)
      i_reg_reserve_available(inst,info,context,opsrc.get_all_uni_registers+opdst.get_all_uni_registers,availregs,1,size mod 4>0);

      -- zkopírovat blok
      copyblock(inst,info,context,opdst,opsrc,availregs,size);

      -- uvolnit použité registry
      i_reg_free_available(info,context,availregs);

    -- jinak cyklit
    else
      declare var
        opindex    : c_operand;                  -- čítač průchodů cyklem
        incr       : t_unsigned;                 -- inkrement offsetu po jedné iteraci cyklu
        wcount     : t_unsigned;                 -- počet slov kopírovaných během jedné iterace

      begin
        -- alokovat indexní registr
        opindex.create_new_register(inst,info,context,edt_unsigned,4);

        -- rezervovat volné registry (nebo aspoň jeden)
        declare

          ------------------------------------------------------------------------------------------
          procedure get_set return iuniregset =
          -- Ondra 28.04.2003 20:38 : Historicky první procedura ve Flexu vnořená v DECLARE bloku.
          ------------------------------------------------------------------------------------------
          with
            advanced,
            advanced.low_level,
            advanced.low_level.bit_operations;

          begin
            for xuni in iunireg loop
              if xuni in opsrc.get_all_uni_registers 
              or xuni in opdst.get_all_uni_registers 
              or xuni=iregtouni[opindex.reg.reg] then
                bit_set(result,t_bit_index(xuni:ord));
                end if;
              end loop;
            end get_set;

        begin
          i_reg_reserve_available(inst,info,context,get_set{%%TODO(SET)getopregs(opsrc)+getopregs(opdst)+iuniregset:[iregtouni[opindex.reg.reg]]},availregs,1,size mod 4>0);
          end declare;

        -- spočítat inkrement v jednom průchodu
        declare var
          i        : t_unsigned;
        begin
          i:=i_reg_get_count(availregs,4);
          if (i=1) or (size div {incr=}(3*4)<2)
            -- jen jeden registr nebo malý blok => dvě slova za iteraci
            then wcount:=2
            -- více registrů => nejvýše 3 slova za iteraci
            else wcount:=min_unsigned(i,3);
            end if;
          incr:=wcount*4;
          end declare;

        -- hodnota indexního registru
        verify({VERIFY=}000339,size div incr<2);
        addopimm(inst,info,context,ii_mov,opindex,incr*((size div incr)-1));

        declare var
          opsrcl   : c_operand;                  -- operandy během iterace cyklu
          opdstl   : c_operand;                  -- operandy během iterace cyklu
          tg_start : itarget;                    -- návěští začátku cyklu

        begin
          -- do operandů přidat indexní registr
          opsrcl.clone(inst,info,context,opsrc);
          opsrcl.shift_by_base_or_index(inst,info,context,opindex.reg.reg);
          opdstl.clone(inst,info,context,opdst);
          opdstl.shift_by_base_or_index(inst,info,context,opindex.reg.reg);

          -- začátek cyklu
          newtarget(info,tg_start);
          settarget(info,tg_start,getaddr(inst));

          -- zkopírovat WCOUNT slov
          copyblock(inst,info,context,opdstl,opsrcl,availregs,incr);

          -- posunout index
          addopimm(inst,info,context,ii_sub,opindex,incr);

          -- skok na začátek
          addjump(inst,info,context,ic_ns,tg_start);

        leave
          -- uvolnit pozměněné operandy
          opsrcl.free(info,context);
          opdstl.free(info,context);
          end declare;

        declare var
          opsrcl   : c_operand;                  -- operandy během iterace cyklu
          opdstl   : c_operand;                  -- operandy během iterace cyklu

        begin
          -- pointer na zbytek
          -- %%TECH Nedělá se CLONEOP, manipuluje se jen s DISP
          opsrcl.clone(inst,info,context,opsrc);
          opsrcl.shift_displacement(imm32_to_signed{%%X}(unsigned_to_imm32(incr*(size div incr))));
          opdstl.clone(inst,info,context,opdst);
          opdstl.shift_displacement(imm32_to_signed{%%X}(unsigned_to_imm32(incr*(size div incr))));

          -- %%X Zde bych už mohl používat registr z OPINDEX - co když má
          -- 8bitovou část a v AVAILREGS takových moc ? Musel bych ale
          -- ručně přidat OPINDEX.REG.REG do AVAILREGS a nedělat pak FREEOP

          -- dojet zbytek
          copyblock(inst,info,context,opdstl,opsrcl,availregs,size mod incr);

        leave
          -- uvolnit pozměněné operandy
          opsrcl.free(info,context);
          opdstl.free(info,context);
          end declare;

        -- uvolnit použité registry
        i_reg_free_available(info,context,availregs);

      leave
        -- uvolnit čítač
        opindex.free(info,context);
        end declare;
      end if;
  end i_gen_move_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_pop_static =
-- Jako předchozí procedura, ale předpokládá, že zdrojová data jsou uložena
-- na stacku, odkud je odstraní.
----------------------------------------------------------------------------------------------------
with
  cc_base,cc_base.cc_util;

begin
  declare var
    opesi            : c_operand;                  -- zdrojový operand
    opedi            : c_operand;                  -- cílový operand

  begin
    -- vytvořit si zdrojový operand
    opesi.create_on_stack(edt_binary,size);--newopstack(inst,info,context,opesi,size);

    -- odvodit nový cílový operand
    opedi.clone(inst,info,context,opdst);

    -- načíst adresy operandů do EDI a ESI
    i_gen_lea(inst,info,context,opesi,in_esi);
    i_gen_lea(inst,info,context,opedi,in_edi);

    -- přesunout
    i_gen_movsd_static(inst,info,context,opesi,opedi,size);

  leave
    -- uvolnit operandy
    opesi.free(info,context);
    opedi.free(info,context);
    end declare;

  declare var
    aligned_size   : t_unsigned32;               -- zarovnaná velikost báze

  begin
    -- zarovnat na 4 a získat tak použitou velikost prostoru na stacku
    addalign(aligned_size,0,size,4);

    -- odstranit zdrojový operand ze stacku
    addaddimm(inst,info,context,op_esp,aligned_size);
    end declare;
  end i_gen_pop_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_move_array =
-- Přesun pole OPLENGTH prvků velikosti BASESIZE z OPSRC do OPDST.
-- Předpokládá se, že se pole nepřekrývají.
-- Předpokládá se (kvůli optimalizaci), že jsou pole zarovnána na hranici 4B.
-- OPSRC a OPDST musí být typu IO_MEM s redukovaným počtem registrů (= <=1),
-- a OPLENGTH musí být registr s počtem prvků pole OPDST.
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  availregs        : iuniregset;                 -- volné pracovní registry
  iter             : t_unsigned;                 -- kolik bytů se zkopíruje v jedné iteraci

begin
  verify({VERIFY=}000342,(opsrc.optype<>io_mem) or (opdst.optype<>io_mem) or (oplength.optype<>io_reg));

  ----- %%TECH Kopírování pole proměnné délky ----------------------------
  -- Na IA32 budou v průměru k dispozici tak 3 registry (celkem jich je 6,
  -- každý z operandů zabere jeden registr). Nikdy jich nebude více než 5.
  --   V jedné iteraci zkusíme použít maximum registrů - hledáme K takové,
  -- že K*4 | basesize => v jedné iteraci zkopírujeme K*4 bytů a nezbyde nic
  -- (K je kongruentní s BASESIZE).
  --   Pokud se nevyhneme přetečení, preferujeme kopírování po osmicích.
  --
  -- Příklad: Kopírujeme EAX prvků z [ESI] do [EDI]. Máme k dispozici
  -- 3 registry.
  --
  --   Případ 1: BASESIZE je dělitelné 12
  --
  --           -- převést počet prvků na počet bytů
  --           mul   eax,BASESIZE
  --           -- EAX je dělitelné 12
  --       @1: sub   eax,12
  --           js    @2
  --           mov   ebx,[esi+eax+0]
  --           mov   ecx,[esi+eax+4]
  --           mov   edx,[esi+eax+8]
  --           mov   [edi+eax+0],ebx
  --           mov   [edi+eax+4],ecx
  --           mov   [edi+eax+8],edx
  --           jmp   @1
  --       @2: ...
  --
  --   Případ 2: BASESIZE není dělitelné ani 12 ani 8, ale je dělitelné 2.
  --
  --           -- převést počet prvků na počet bytů
  --           mul   eax,BASESIZE
  --           -- zarovnat velikost na hranici 8
  --       @3: test  eax,2$111
  --           jz    @1
  --           sub   eax,2
  --           mov   bx,[esi+eax+0]
  --           mov   [edi+eax+0],bx
  --           jmp   @3
  --           -- nyní je EAX dělitelné 8
  --       @1: sub   eax,8
  --           js    @2
  --           mov   ebx,[esi+eax+0]
  --           mov   ecx,[esi+eax+4]
  --           mov   [edi+eax+0],ebx
  --           mov   [edi+eax+4],ecx
  --           jmp   @1
  --       @2: ...
  --
  --------------------------------------------------------------------------------------------------

  -- budou potřeba nějaké pracovní registry ?
  -- 8mi bitový bude potřeba, pokud je velikost báze nedělitelná 2 (=lichá)
  i_reg_reserve_available(inst,info,context,opsrc.get_all_uni_registers+opdst.get_all_uni_registers+oplength.get_all_uni_registers,availregs,1,is_odd_unsigned(basesize){imm32odd(basesize)});

  declare var
    rcount         : t_unsigned;                 -- počet 32bitových registrů v AVAILREGS

  begin
    -- kolik je volných registrů ?
    rcount:=i_reg_get_count(availregs,4);

    -- nemá báze příhodou velikost ? (K*4 | basesize, K in 3..RCOUNT)
    while rcount>2 loop
      if basesize mod (rcount*4)=0 then break; end if;
      pred rcount;
      end loop;

    -- kolik bytů se tedy zkopíruje za jednu iteraci ?
    iter:=min_unsigned(2,rcount)*4;
    end declare;

  -- převést :length na :length*basesize
  i_gen_mul_reg(inst,info,context,oplength,unsigned_to_imm32(basesize));

  declare var
    opsrcl         : c_operand;                  -- operandy během iterace cyklu
    opdstl         : c_operand;                  -- operandy během iterace cyklu

  begin
    -- do operandů přidat indexní registr
    opsrcl.clone(inst,info,context,opsrc);
    opsrcl.shift_by_base_or_index(inst,info,context,oplength.reg.reg);
    opdstl.clone(inst,info,context,opdst);
    opdstl.shift_by_base_or_index(inst,info,context,oplength.reg.reg);

    ---- vygenerovat kód na obsluhu nekongruentních bytů ----
    if basesize mod iter<>0 then
      declare var
        tg_start   : itarget;                    -- začátek cyklu
        tg_end     : itarget;                    -- konec cyklu
        rsize      : t_unsigned;                 -- zvolená velikost registru pro kopírování

      begin
        -- připravit návěští
        newtarget(info,tg_start);
        newtarget(info,tg_end);

        -- začátek cyklu
        settarget(info,tg_start,getaddr(inst));

        -- po jakých kusech budeme kopírovat ?
        if basesize mod 4=0 then rsize:=4
        elsif basesize mod 2=0 then rsize:=2
        else rsize:=1
        end if;

        -- testovat dělitelnost osmi
        addii(inst,info,ii_test,oplength,op_7,op0);

        -- není už konec ?
        addjump(inst,info,context,ic_z,tg_end);

        -- připravit index
        addsubimm(inst,info,context,oplength,rsize);

        -- zkopírovat
        copyblock(inst,info,context,opdstl,opsrcl,availregs,rsize);

        -- další iterace (je-li RSIZE=4, není proč cyklit)
        if rsize<>4 then 
          addjump(inst,info,context,ic_ucond,tg_start); 
          end if;

        -- adresa skoku na toto místo
        settarget(info,tg_end,getaddr(inst));
        end declare;
      end if;

    ---- vygenerovat hlavní kopírovací cyklus ----
    declare var
      tg_start     : itarget;                    -- začátek cyklu
      tg_end       : itarget;                    -- konec cyklu

    begin
      -- připravit návěští
      newtarget(info,tg_start);
      newtarget(info,tg_end);

      -- začátek cyklu
      settarget(info,tg_start,getaddr(inst));

      -- bude se kopírovat dalších ITER bytů
      addopimm(inst,info,context,ii_sub,oplength,iter);

      -- není už konec ?
      addjump(inst,info,context,ic_s,tg_end);

      -- jedna iterace kopírování
      copyblock(inst,info,context,opdstl,opsrcl,availregs,iter);

      -- další iterace
      addjump(inst,info,context,ic_ucond,tg_start);

      -- adresa skoku na toto místo
      settarget(info,tg_end,getaddr(inst));
      end declare;

  leave
    -- uvolnit pozměněné operandy
    opsrcl.free(info,context);
    opdstl.free(info,context);
    end declare;

leave
  -- uvolnit pracovní registry
  i_reg_free_available(info,context,availregs);
  end i_gen_move_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_movsd_static =
-- Kopírování pole velikosti SIZE bytů pomocí REP MOVSD.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000377,(opsrc.optype<>io_reg) or (opsrc.reg.reg<>ir_esi)
          or (opdst.optype<>io_reg) or (opdst.reg.reg<>ir_edi));

  if size div 4<=4

    -- dost malé na to, aby bylo REP neefektivní
    then
      for i in 1..size div 4 loop 
        addii(inst,info,ii_movsd,op0,op0,op0); 
        end loop;

    -- dostatečně dlouhý blok
    else
      declare var
        opecx      : c_operand;                  -- ECX

      begin
        -- alokovat ECX
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- do ECX dát počet čtyřslov
        addopimm(inst,info,context,ii_mov,opecx,size div 4);

        -- REP MOVSD
        addip(inst,info,ip_rep);
        addii(inst,info,ii_movsd,op0,op0,op0);

      leave
        -- uvolnit ECX
        opecx.free(info,context);
        end declare;
      end if;

  -- dojet zbytek modulo 4
  case size mod 4
    when 0 do -- beze zbytku, nic nedělat

    -- jeden MOVSB
    when 1 do addii(inst,info,ii_movsb,op0,op0,op0);

    -- jeden MOVSW
    when 2 do addii(inst,info,ii_movsw,op0,op0,op0);

    -- jeden MOVSW a jeden MOVSB
    when 3 do
        addii(inst,info,ii_movsw,op0,op0,op0);
        addii(inst,info,ii_movsb,op0,op0,op0);
    end case;
  end i_gen_movsd_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_movsd_array =
-- Kopírování pole pomocí REP MOVSD.
----------------------------------------------------------------------------------------------------
var
  optemp           : c_operand;

begin
  verify({VERIFY=}000362,(opecx.optype<>io_reg) or (opecx.reg.reg<>ir_ecx)
          or (opsrc.optype<>io_reg) or (opsrc.reg.reg<>ir_esi)
          or (opdst.optype<>io_reg) or (opdst.reg.reg<>ir_edi));

  -- je velikost báze dělitelná čtyřmi ?
  if basesize mod 4=0

    -- je => nemusíme se starat o nějaký zbytek
    then
      -- vynásobit ECX
      i_gen_mul_reg(inst,info,context,opecx,unsigned_to_imm32(basesize div 4));

    -- není, bude to trochu složitější
    else
      -- vynásobit ECX
      i_gen_mul_reg(inst,info,context,opecx,unsigned_to_imm32(basesize));

      -- schovat ECX na stack
      optemp.create_temporary(inst,info,edt_unsigned,idefregsize);
      addii(inst,info,ii_mov,optemp,opecx,op0);

      -- vydělit čtyřmi
      addii(inst,info,ii_shr,opecx,op_2,op0);
      end if;

  -- OK, teď obsahuje ECX počet čtyřslov, můžeme REP MOVSD
  addip(inst,info,ip_rep);
  addii(inst,info,ii_movsd,op0,op0,op0);

  -- dojet zbytek
  if basesize mod 4>0 then
    -- na stacku máme ECX
    addii(inst,info,ii_mov,opecx,optemp,op0);

    -- vymaskovat
    addii(inst,info,ii_and,opecx,op_3,op0);

    -- dojet
    if basesize mod 2=0
      -- stačí jeden MOVSW
      then
        addii(inst,info,ii_movsw,op0,op0,op0);

      -- přes MOVSB
      else
        -- %%X Na to, že přesouvám 1 až 3 byty je tohle dost luxus
        addip(inst,info,ip_rep);
        addii(inst,info,ii_movsb,op0,op0,op0);
        end if;
    end if;

leave
  -- uvolnit pracovní operand
  optemp.free(info,context);
  end i_gen_movsd_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_fillz_static =
-- Vypnění pole nulou.
----------------------------------------------------------------------------------------------------

var
  remaining_size   : t_unsigned32;               -- zbývající, dosud nefillznutá část pole

    ------------------------------------------------------------------------------------------------
    procedure fillzsmall (
        opdst      : in out c_operand) =
    -- Fillzování malého objektu.
    ------------------------------------------------------------------------------------------------
    begin
      -- zbavit se čtveřic
      opdst.adjust_size(4);
      while remaining_size div 4>0 loop
        addii(inst,info,ii_mov,opdst,op_0,op0);
        opdst.shift_displacement(4);
        remaining_size-4;
        end loop;

      -- zbavit se dvojic
      if remaining_size div 2>0 then
        opdst.adjust_size(2);
        addii(inst,info,ii_mov,opdst,op_0,op0);
        opdst.shift_displacement(2);
        end if;

      -- zbavit se posledního bytu
      if remaining_size mod 2>0 then
        opdst.adjust_size(1);
        addii(inst,info,ii_mov,opdst,op_0,op0);
        end if;
      end fillzsmall;
begin
  -- zbývá zkopírovat celé pole
  remaining_size:=size;

  if {%%TODO(AGGREGATE) remaining_size in [1..ismallobject]} remaining_size>=1 and remaining_size<=ismallobject

    -- malý objekt => nacpat tam přes MOV
    then
      fillzsmall(opdst);

    -- velký objekt => použít STOSD
    else
      declare var
        opeax      : c_operand;                  -- nula pro STOSD
        opecx      : c_operand;                  -- počet prvků

      begin
        -- načíst adresu do EDI
        i_gen_lea(inst,info,context,opdst,in_edi);

        -- shodit Direction Flag
        addii(inst,info,ii_cld,op0,op0,op0);

        -- potřebujeme EAX a ECX
        opeax.create_use_register(inst,info,context,edt_unsigned,ir_eax);
        opecx.create_use_register(inst,info,context,edt_unsigned,ir_ecx);

        -- do EAX dát nulu
        addii(inst,info,ii_mov,opeax,op_0,op0);

        -- do ECX dát počet čtveřic
        declare var
          optemp   : c_operand;                  -- pomocný operand
        begin
          optemp.create_imm(edt_unsigned,0,unsigned_to_imm32(remaining_size div 4{size-size mod 4}));
          addii(inst,info,ii_mov,opecx,optemp,op0);
        leave
          optemp.free(info,context);
          end declare;

        -- REP STOSD
        addip(inst,info,ip_rep);
        addii(inst,info,ii_stosd,op0,op0,op0);

        -- dojet zbytek
        if remaining_size mod 4>0 then
          declare var
            opmem  : c_operand;                  -- cílový operand ve tvaru [EDI+ofs]

          begin
            -- sestavit [EDI]
            opmem.clone(inst,info,context,opdst);
            opmem.transform_reg_to_mem(edt_binary,0);
            -- Ondra 12.9.2002 : REP STOSD už nastavil EDI na začátek zbytku
            -- opmem.disp:=timm32(0{remaining_size-remaining_size mod 4});

            -- vyfillzovat zbytek
            remaining_size:=remaining_size mod 4;
            fillzsmall(opmem);

          leave
            -- uvolnit [EDI]
            opmem.free(info,context);
            end declare;
          end if;

      leave
        -- uvolnit pomocné operandy
        opeax.free(info,context);
        opecx.free(info,context);
        end declare;
      end if;
  end i_gen_fillz_static;



----------------------------------------------------------------------------------------------------
procedure i_gen_fillz_dynamic =
-- Vypnění pole dynamické velikosti nulou.
-- OPDST musí být typu IO_MEM a měl by preferovaně používat EDI (pro STOSD).
-- OPSIZE musí být registr ECX.
----------------------------------------------------------------------------------------------------
var
  opeax            : c_operand;                  -- nula pro STOSD
  tg_3             : itarget;                    -- cíl skoku na dojetí zbývajících bytíků
  tg_end           : itarget;                    -- cíl skoku na konec

begin
  verify({VERIFY=}000472,(opsize.optype<>io_reg) or (opsize.reg.reg<>ir_ecx));

  -- alokovat cíle skoků
  newtarget(info,tg_3);
  newtarget(info,tg_end);

  -- načíst adresu do EDI
  i_gen_lea(inst,info,context,opdst,in_edi);

  -- shodit Direction Flag
  addii(inst,info,ii_cld,op0,op0,op0);

  -- potřebujeme EAX
  opeax.create_use_register(inst,info,context,edt_unsigned,ir_eax);

  -- do EAX dát nulu
  addii(inst,info,ii_mov,opeax,op_0,op0);

  -- není velikost příznivě malá ?
  addii(inst,info,ii_cmp,opsize,op_3,op0);
  addjump(inst,info,context,ic_be,tg_3);

  -- schovat si ECX
  addii(inst,info,ii_push,opsize,op0,op0);

  -- do ECX dát počet čtveřic
  addii(inst,info,ii_shr,opsize,op_2,op0);

  -- REP STOSD
  addip(inst,info,ip_rep);
  addii(inst,info,ii_stosd,op0,op0,op0);

  -- obnovit ECX
  addii(inst,info,ii_pop,opsize,op0,op0);

  -- cíl skoku na toto místo
  settarget(info,tg_3,getaddr(inst));

  -- vzít poslední 2 bity
  addii(inst,info,ii_and,opsize,op_3,op0);

  -- není to nula ? (nemusí se porovnávat, flagy nastaví AND)
  addjump(inst,info,context,ic_e,tg_end);

  -- dojet zbytek
  addip(inst,info,ip_rep);
  addii(inst,info,ii_stosb,op0,op0,op0);

  -- cíl skoku na toto místo
  settarget(info,tg_end,getaddr(inst));

leave
  -- uvolnit pomocné operandy
  opeax.free(info,context);
  end i_gen_fillz_dynamic;



----------------------------------------------------------------------------------------------------
procedure i_gen_subprogram_address =
-- Vygeneruje adresu podprogramu.
----------------------------------------------------------------------------------------------------
begin
  if psubprog^.etype=et_procedure and pentity_procedure(psubprog)^.import_info<>nil
    then vysl.create_memory_address(inst,info,context,edt_address,4,ir_none,0);
    else
      if relative
        then vysl.create_relative_address(4);
        else vysl.create_imm(edt_address,4,0);
        end if;
      end if;
  vysl.set_relo_entity(psubprog);
  end i_gen_subprogram_address;



----------------------------------------------------------------------------------------------------
procedure i_gen_adjust_rta_position =
-- Operand IO_MEM upraví tak, aby ukazoval na zadaný run-time atribut.
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure get_set return rtattribset =
    ------------------------------------------------------------------------------------------------
    with
      advanced,
      advanced.low_level,
      advanced.low_level.bit_operations;

    begin
      for xrta in rta:first..pred rta loop
        if xrta in expr^.rta_used then
          bit_set(result,t_bit_index(xrta:ord));
          end if;
        end loop;
      end get_set;

var
  x                : timm32;

begin
  verify({VERIFY=}000321,vysl.optype<>io_mem);
  vysl.adjust_size(unidata_size_to_imm32(cpu32_rtattribsize[rta]));
  if rta>rta:first then
    getrtattribsetsize(get_set{%%TODO(SET)expr^.rta_used{%%ATTR}*rtattribset:[rta:first..pred rta]},x);
    end if;
  vysl.shift_displacement(imm32_to_signed{%%X}(imm32_lpointer32+x));
  end i_gen_adjust_rta_position;



end ci_fragment;
