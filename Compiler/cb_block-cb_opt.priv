----------------------------------------------------------------------------------------------------
module private cb_opt =
-- P©eklada‡ Flexu.
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.10.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cx_expr.cx_imm,
  cx_expr.cx_util;

type
  -- kontext p©¡kazu
  blcontext        = record
      loop_end     : pentity_label;              -- n vˆ¨t¡ pro [break] (pro optimalizaci
                                                 -- jednopr–chodov˜ch cykl–, viz %%TECH pozn mka)
      end record;

------ %%TECH --------------------------------------------------------------------------------------
-- V˜sledkem optimalizace konkr‚tn¡ho uzlu m–‘e b˜t:
--     - ten sam˜ uzel,
--     - jin˜ uzel,
--     - ‘ dn˜ uzel (uzel se zcela vynech ),
--     - s‚rie nˆkolika uzl–.
--
-- V˜sledkem optimalizace jednopr–chodov‚ho cyklu je jeho tˆlo (p©¡p. declare blok pro for cyklus).
-- V tomto p©¡padˆ je nutn‚ vytvo©it n vˆ¨t¡ konce tˆla cyklu, zmˆnit [break] p©¡kazy cyklu
-- na [goto] a dodat jim toto n vˆ¨t¡ pomoc¡ parametru [context] optimaliza‡n¡ch procedur.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure b_opt_node (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblnode;             -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo;                  -- informace o pr–bˆhu anal˜zy
    catch_mode     : in t_catch_mode:=catch_mode_implicit); -- zp–sob, jak zachyt vat chyby resume_error
-- Optimalizace jednoho uzlu.
----------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------
procedure b_opt_sequence (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    list           : in out bllist;              -- prvn¡ uzel sekvence
    all            : out t_logical;              -- T-v¨echny p©¡kazy zkontrolov ny
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace posloupnosti p©¡kaz–.
----------------------------------------------------------------------------------------------------
var
  pbl              : pblnode;                    -- p©edchoz¡ p©¡kaz
  cbl              : pblnode;                    -- aktu ln¡ p©¡kaz
  nbl              : pblnode;                    -- n sleduj¡c¡ p©¡kaz
  labels_only      : t_logical :=true;           -- T-optimalizovan  sekvence je pr zdn ,
                                                 -- nebo obsahuje pouze nev˜znamn˜ k¢d (n vˆ¨t¡)
begin
  -- optimistick˜ p©edpoklad
  all:=true;

  -- optimaliazce v¨ech p©¡kaz–
  pbl:=nil;
  cbl:=list.first;
  while cbl<>nil loop
    -- poznamenat si n sleduj¡c¡ blok
    nbl:=cbl^.next;

    -- rozpojit
    cbl^.next:=nil;

    -- optimalizace p©¡kazu
    b_opt_node(curr,cbl,context,info);

    if cbl<>nil

      -- spojit zpˆt
      then
        -- spojit (1)
        if pbl<>nil
          then pbl^.next:=cbl;
          else list.first:=cbl;
          end if;

        -- optimalizac¡ mohlo vzniknout nˆkolik p©¡kaz–
        while cbl^.next<>nil loop cbl:=cbl^.next; end loop;

        -- spojit (2)
        cbl^.next:=nbl;
        if nbl=nil then list.last:=cbl; end if;

        -- povedla se optimalizace ?
        if cbl^.zprac<bp_opt then all:=false; end if;

        -- nov˜ p©edchoz¡ uzel
        pbl:=cbl;

      -- p©¡kaz se optimalizoval a optimalizoval a‘ £plnˆ zmizel
      else
        -- spojit
        if pbl<>nil
          then pbl^.next:=nbl;
          else list.first:=nbl;
          end if;
        if nbl=nil then list.last:=pbl; end if;

        -- optimalizace se tot lnˆ povedla
        end if;

    -- dal¨¡ p©¡kaz
    cbl:=nbl;
    end loop;
  
  -- optimalizace skok– v r mci sekvence
  pbl:=nil;
  cbl:=list.first;
  while cbl<>nil loop
    -- poznamenat si n sleduj¡c¡ blok
    nbl:=cbl^.next;

    -- optimalizovat sekvenci [goto]/[break] ... [label]/konec bloku
    case cbl^.btype
      -- [goto], [break]
      when bt_break,bt_goto do
          declare var
            -- prvn¡ a posledn¡ uzel se subsekvence, kter  bude ze sekvence vypu¨tˆna
            -- pouze pro hl ¨en¡ pozice hintu
            skip_first : pblnode;                -- prvn¡ uzel
            skip_last  : pblnode :=nil;          -- posledn¡ uzel
          begin
            skip_first:=nbl;

            -- naj¡t nejbli‘¨¡ [label], pop©. konec bloku
            while nbl<>nil and then nbl^.btype<>bt_label loop
              skip_last:=nbl;
              nbl:=nbl^.next;
              end loop;
      
            -- vypsat hint
            if skip_first<>nil and then skip_last<>nil
            and then ch_unreachable_code in curr.entity^.compv.hints then
              ce^.sethint(curr,{CCERR=}000529,ch_unreachable_code);
              sequence_errpos(skip_first,skip_last);
              end if;
            end declare;

          -- zkontrolovat, zda je pozice toto‘n  s c¡lem skoku
          if nbl<>nil and then cbl^.btype=bt_goto and then pblgoto(cbl)^.plabel=pbllabel(nbl)^.plabel
            -- odstranit i [goto]
            then
              cbl:=pbl;

            -- k¢d
            else
              labels_only:=false;
              end if;

          -- odstranit p©esko‡en‚ bloky ze sekvence
          if cbl<>nil
            then cbl^.next:=nbl;
            else list.first:=nbl;
            end if;

          -- posunout se za eventu ln¡ [label]
          if nbl<>nil
            then
              cbl:=nbl;
              nbl:=nbl^.next;
            else
              -- konec seznamu
              list.last:=cbl;
              end if;

      -- [label]
      when bt_label do
          -- nedˆlat nic

      -- funk‡n¡ k¢d
      when others do
          labels_only:=false;
        end case;
          
    -- dal¨¡ blok sekvence
    pbl:=cbl;
    cbl:=nbl;
    end loop;

  -- sekvence neobsahuje funk‡n¡ k¢d => odstranit celou sekvenci
  if labels_only then
    list.first:=nil;
    list.last:=nil;
    end if;
  end b_opt_sequence;



----------------------------------------------------------------------------------------------------
procedure b_opt_cmd (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcmd;              -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©i©azovac¡ho p©¡kazu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- nen¡ co optimalizovat (%%X nebo ano ?)

  -- nezmizel n hodou cel˜ p©¡kaz vlivem optimalizace p©¡kazu ? (nap©. X+0)
  if bl^.expr=nil then
    bl:=nil;
    return;
    end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_cmd;



----------------------------------------------------------------------------------------------------
procedure b_opt_break (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblbreak;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu [break].
----------------------------------------------------------------------------------------------------
begin
  -- v d–sledku optimalizace jednopr–chodov‚ho cyklu je pot©eba zmˆnit [break] v [goto]
  if context.loop_end<>nil then
    declare var
      pbg          : pblgoto;                    -- uzel [goto]
    begin
      -- vytvo©it nov˜ uzel [goto] skoku
      derivenode(pbg,bl,info,bt_goto);
      pbg^.plabel:=context.loop_end;

      -- nahradit uzel [break] za uzel [goto]
      bl:=pblnode(pbg);
      end declare;
    end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_break;



----------------------------------------------------------------------------------------------------
procedure b_opt_return (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblreturn;           -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu RETURN.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_return;



----------------------------------------------------------------------------------------------------
procedure b_opt_raise (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblraise;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu RAISE.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_raise;



----------------------------------------------------------------------------------------------------
procedure b_opt_send (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblsend;             -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kaz– SEND.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_send;



----------------------------------------------------------------------------------------------------
procedure b_opt_goto (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblgoto;             -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu GOTO.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_goto;



----------------------------------------------------------------------------------------------------
procedure b_opt_new (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblnew;              -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu NEW.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_new;



----------------------------------------------------------------------------------------------------
procedure b_opt_discard (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldiscard;          -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu DISCARD.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_discard;



----------------------------------------------------------------------------------------------------
procedure b_opt_adjust (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbladjust;           -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu ADJUST.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_adjust;



----------------------------------------------------------------------------------------------------
procedure b_opt_delay (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldelay;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu DELAY.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_delay;



----------------------------------------------------------------------------------------------------
procedure b_opt_if (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblif;               -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu IF.
----------------------------------------------------------------------------------------------------
var
  psub             : pblif_cond;                 -- p©edchoz¡ vˆtev if
  sub              : pblif_cond;                 -- aktu ln¡ vˆtev if
  all              : t_logical;                  -- vyhodnocen¡ bloku
  allx             : t_logical;                  -- vyhodnocen¡ bloku


  
    ------------------------------------------------------------------------------------------------
    procedure opt_const_cond =
    -- Optimalizace vˆtv¡ s konstantn¡ podm¡nkou.
    ------------------------------------------------------------------------------------------------
    var
      ul           : tunilogical;                -- hodnota konst. podm¡nky
    
    begin
      -- optimalizace v¨ech vˆtv¡ podle typu podm¡nky
      psub:=nil;
      sub:=pblif_cond(bl^.sub.first);
      while sub<>nil loop
        -- zpracovat vˆtev podle typu podm¡nky
        if sub^.cond<>nil and x_is_constant(sub^.cond)
          -- podm¡nka je konstantn¡
          then
            -- generovat hint
            if ch_constant_condition in curr.entity^.compv.hints then
              ce^.sethint(curr,{CCERR=}000530,ch_constant_condition);
              sub^.cond^.errpos;
              end if;

            -- na‡¡st log. hodnotu podm¡nky
            x_const_logical(sub^.cond,ul);

            -- podle log. hodnoty podm¡nky upravit seznam vˆtv¡ ifu
            if unilogical_to_logical(not ul)
              -- false => zahodit vˆtev
              then
                -- generovat hint
                if ch_unreachable_code in curr.entity^.compv.hints then
                  ce^.sethint(curr,{CCERR=}000531,ch_unreachable_code);
                  node_errpos(sub);
                  end if;

                if psub<>nil
                  then psub^.next:=sub^.next;
                  else bl^.sub.first:=sub^.next;
                  end if;
                if sub^.next=nil then
                  bl^.sub.last:=psub;
                  end if;
          
              -- true => u‡init tuto vˆtev posledn¡ (else) vˆtv¡ ifu
              else
                -- generovat hint pro v¨echny p©¡padn‚ dal¨¡ vˆtve
                if ch_unreachable_code in curr.entity^.compv.hints then
                  declare var
                    usub   : pblif_cond;         -- nedosa‘iteln  vˆtev ifu
                  begin
                    usub:=sub^.next;
                    while usub<>nil loop
                      -- generovat hint
                      ce^.sethint(curr,{CCERR=}000532,ch_unreachable_code);
                      node_errpos(usub);

                      usub:=usub^.next;
                      end loop;
                    end declare;
                  end if;

                if sub^.sub.first<>nil
                  -- vˆtev je nepr zdn  => bude posledn¡ vˆtv¡ ifu
                  then
                    sub^.next:=nil;
                    bl^.sub.last:=sub;
                    sub^.cond:=nil;

                  -- vˆtev je pr zdn  => odstranit i ji samotnou
                  else
                    if psub<>nil
                      then psub^.next:=nil;
                      else bl^.sub.first:=nil;
                      end if;
                    bl^.sub.last:=psub;
                    end if;
                end if;

          -- podm¡nka nen¡ konstantn¡
          else
            psub:=sub;
          end if;

        -- dal¨¡ vˆtev
        sub:=sub^.next;
        end loop;
      end opt_const_cond;

    

    ------------------------------------------------------------------------------------------------
    procedure opt_empty_tail =
    -- Optimalizace pr zdn˜ch vˆtv¡ na konci ifu. Takov‚ vˆtve jsou zahazov ny.
    -- POZOR! Tuto optimalizaci je mo‘no povolit jen za p©edpokladu, ‘e vyhodnocen¡
    -- podm¡nky vˆtve je bez side-efekt–.
    -- Prozat¡m zak z no.
    ------------------------------------------------------------------------------------------------
    begin
      -- naj¡t posledn¡ nepr zdnou vˆtev
      psub:=nil;
      sub:=pblif_cond(bl^.sub.first);
      while sub<>nil loop
        if sub^.sub.first<>nil then
          psub:=sub;
          end if;
        sub:=sub^.next;
        end loop;

      -- v ifu jsou nˆjak‚ nepr zdn‚ vˆtve a na konci je alespo¤ jedna pr zdn  vˆtev
      if psub<>nil and then psub^.next<>nil then
        -- pro odstra¤ovan‚ vˆtve vypsat warning (kv–li mo‘n˜m side-efekt–m vol n¡ v podm¡nk ch)
        if cw_cond_removed in curr.entity^.compv.warns then
          -- generovat warning
          ce^.setwarning(curr,{CCERR=}000533,cw_cond_removed);
          sequence_errpos(psub^.next,pblif(bl)^.sub.last);
          end if;

        -- odstranit pr zdn‚ vˆtve z konce seznamu
        psub^.next:=nil;
        pblif(bl)^.sub.last:=psub;

      -- v ifu jsou pouze pr zdn‚ vˆtve
      elsif psub=nil and pblif(bl)^.sub.first<>nil then
        -- pro odstra¤ovan‚ vˆtve vypsat warning (kv–li mo‘n˜m side-efekt–m vol n¡ v podm¡nk ch)
        if cw_cond_removed in curr.entity^.compv.warns then
          -- generovat warning
          ce^.setwarning(curr,{CCERR=}000542,cw_cond_removed);
          sequence_errpos(pblif(bl)^.sub.first,pblif(bl)^.sub.last);
          end if;

        -- odstranit v¨echny vˆtve
        pblif(bl)^.sub.first:=nil;
        end if;
      end opt_empty_tail;



    ------------------------------------------------------------------------------------------------
    procedure opt_swap_and_cut =
    -- Optimalizace [if] tvaru [if <nekonst. podm¡nka> then else <tˆlo> end if;].
    -- Optimalizuje se na tvar [if <negace podm¡nky> then <tˆlo> end if;].
    ------------------------------------------------------------------------------------------------
    var
      newcond      : pexpnode;                   -- nov  podm¡nka

    begin
      -- [if] je tvaru [if <nekonst. podm¡nka> then else <tˆlo> end if;]
      if bl^.sub.first^.next=bl^.sub.last
      and pblif_cond(bl^.sub.first)^.sub.first=nil
      and pblif_cond(bl^.sub.last)^.cond=nil
        -- zmˆnit [if] na tvar [if not <podm¡nka> then <tˆlo> end if;]
        then
          -- negovat podm¡nku
          x_negate_logical(curr,newcond,pblif_cond(bl^.sub.first)^.cond);
          pblif_cond(bl^.sub.first)^.cond:=newcond;

          -- zamˆnit blok podm¡nˆn‚ vˆtve za blok [else] vˆtve a odstranit [else] vˆtev
          pblif_cond(bl^.sub.first)^.sub:=pblif_cond(bl^.sub.last)^.sub;
          bl^.sub.first^.next:=nil;
          bl^.sub.last:=bl^.sub.first;
          end if;
      end opt_swap_and_cut;


begin
  -- optimistick˜ p©edpoklad
  all:=true;

  -- form ln¡ kontrola blok– v¨ech vˆtv¡
  sub:=pblif_cond(bl^.sub.first);
  while sub<>nil loop
    verify({VERIFY=}000540,sub^.btype<>bt_if_cond);

    -- kontrola bloku
    b_opt_sequence(curr,sub^.sub,allx,context,info);
    all:=all and allx;

    -- dal¨¡ vˆtev
    sub:=sub^.next;
    end loop;
  
  -- povedla se form ln¡ kontrola blok– v¨ech vˆtv¡ ?
  if not all then return; end if;

  -- optimalizuj vˆtve s konstantn¡mi podm¡nkami
  opt_const_cond();

  -- optimalizuj pr zdn‚ vˆtve na konci [if]
  {opt_empty_tail();}

  -- nezbyla ‘ dn  vˆtev
  if bl^.sub.first=nil then
    -- generovat hint
    if ch_unreachable_code in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000534,ch_unreachable_code);
      node_errpos(bl);
      end if;

    -- vypustit cel˜ [if]
    bl:=nil;

  -- zbyla pouze [else] vˆtev
  elsif pblif_cond(bl^.sub.first)^.cond=nil then
    -- generovat hint
    if ch_if_reduced in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000535,ch_if_reduced);
      node_errpos(bl);
      end if;

    -- nahradit cel˜ [if] blokem [else] vˆtve
    bl:=pblif_cond(bl^.sub.first)^.sub.first;

  else
    -- optimalizuj [if] tvaru [if <nekonst. podm¡nka> then else <tˆlo> end if;]
    opt_swap_and_cut();

    -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
    bl^.zprac:=bp_opt;
    end if;
  end b_opt_if;



----------------------------------------------------------------------------------------------------
procedure b_opt_bypassed_loop (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcompound) =       -- p©¡kaz
-- Optimalizace bezpr–chodov‚ho cyklu. Vygeneruje hint a zahod¡ cel˜ cyklus.
----------------------------------------------------------------------------------------------------
begin
  -- generovat hint
  if ch_unreachable_code in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000536,ch_unreachable_code);
    node_errpos(bl);
    end if;

  -- zahodit cel˜ cyklus
  bl:=nil;
  end b_opt_bypassed_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_one_pass_loop (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcompound;         -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace jednopr–chodov‚ho cyklu. Vytvo©¡ n vˆ¨t¡ pro eventu ln¡ [break] (viz %%TECH)
-- a p©id  je na konec tˆla cyklu. Generuje hint.
----------------------------------------------------------------------------------------------------
with
  cd_decl.cd_create;

var
  all              : t_logical;                  -- v˜sledek optimalizace bloku
  pbllbl           : pbllabel;                   -- blok n vˆ¨t¡
  plabel           : pentity_label;              -- n vˆ¨t¡
  clabel           : tcontext;                   -- kontext n vˆ¨t¡
  newcontext       : blcontext;                  -- aktualizovan˜ kontext

begin
  -- generovat hint
  if ch_one_pass_loop in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000537,ch_one_pass_loop);
    node_errpos(bl);
    end if;

  -- vytvo©it intern¡ symbol n vˆ¨t¡, nevyhodnocovat deklaraci
  d_create_internal(curr,plabel,clabel,et_label,nil);
  plabel^.reachable:=true;                       -- n vˆ¨t¡ je pou‘iteln‚ jako c¡l skoku
  plabel^.placed:=true;                          -- n vˆ¨t¡ je um¡stˆno
  --plabel^.num:=0;                                -- ‡¡slo n vˆ¨t¡ (net©eba)
  --plabel^.level:=0;                              -- £rove¤ um¡stˆn¡ n vˆ¨t¡ (net©eba)
  d_end_internal(plabel^,false);

  -- vytvo©it uzel n vˆ¨t¡
  newnode(pbllbl,info,bt_label);
  pbllbl^.plabel:=plabel;

  -- za©adit uzel n vˆ¨t¡ na konec tˆla cyklu
  if bl^.sub.last<>nil
    then bl^.sub.last^.next:=pbllbl;
    else bl^.sub.first:=pbllbl;
    end if;
  bl^.sub.last:=pbllbl;

  -- propagovat n vˆ¨t¡ do nov‚ho kontextu
  newcontext:=context;
  newcontext.loop_end:=plabel;

  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,newcontext,info);

  -- tˆlo cyklu se optimalizac¡ vytratilo => je to v¨echno
  if bl^.sub.first=nil then return; end if;

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- nahradit cyklus blokem tˆla
  case bl^.btype
    -- for cyklus
    when bt_for do
        -- nahradit for blok declare blokem s ©¡d¡c¡ promˆnnou
        declare var
          pdbl     : pbldeclare;                 -- declare blok
        begin
          derivenode(pdbl,bl,info,bt_declare);
          pdbl^.declare_region:=pblfor(bl)^.for_region;
          pdbl^.sub:=bl^.sub;
          pdbl^.zprac:=bl^.zprac;
          bl:=pblnode(pdbl);
        end declare;
    
    -- loop cyklus
    when bt_loop do
        -- nahradit loop jeho tˆlem
        bl:=bl^.sub.first;

    -- nic jin‚ho to nemohlo b˜t
    {when others do}
    end case;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_one_pass_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_infinite_loop (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcompound;         -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace nekone‡n‚ho cyklu (nekone‡nost v d–sledku optimalizace). Vyp¡¨e hint a konvertuje
-- cyklus na konstrukci [loop ... end loop;].
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- v˜sledek optimalizace bloku

begin
  -- generovat hint
  if ch_infinite_loop in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000538,ch_infinite_loop);
    node_errpos(bl);
    end if;

  -- vytvo©it nekone‡n˜ loop
  case bl^.btype
      -- while
      when bt_while do
        declare var
          pil      : pblloop;                    -- nekone‡n˜ loop
        begin
          derivenode(pil,bl,info,bt_loop);
          pil^.sub:=bl^.sub;
          bl:=pblnode(pil);
          end declare;

      -- loop
      when bt_loop do
        pblloop(bl)^.cond:=nil;

      -- nic jin‚ho to nemohlo b˜t
      {when others do}
    end case;

  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,context,info);

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_infinite_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_loop (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblloop;             -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu LOOP.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- v˜sledek optimalizace bloku
  e                : tentityeval;                -- vyhodnocen¡ konst. podm¡nky
  ul               : tunilogical;                -- hodnota konst. podm¡nky

begin
  if (bl^.cond<>nil) and x_is_constant(bl^.cond)
    -- podm¡nka je konstantn¡
    then
      -- generovat hint
      if ch_constant_condition in curr.entity^.compv.hints then
        ce^.sethint(curr,{CCERR=}000539,ch_constant_condition);
        bl^.cond^.errpos;
        end if;

      -- na‡¡st log. hodnotu podm¡nky
      x_const_logical(bl^.cond,ul);

      -- optimalizovat loop
      if unilogical_to_logical(ul)
        -- podm¡nka je v‘dy splnˆna => jednopr–chodov˜ cyklus
        then
          -- optimalizovat jednopr–chodov˜ cyklus
          b_opt_one_pass_loop(curr,bl,context,info);

        -- podm¡nka nen¡ nikdy splnˆna
        else
          -- optimalizovat nekone‡n˜ cyklus
          b_opt_infinite_loop(curr,bl,context,info);
          end if;

    -- podm¡nka je nekonstantn¡, nebo chyb¡ (nekone‡n˜ cyklus)
    else
      -- optimalizovat blok
      b_opt_sequence(curr,bl^.sub,all,context,info);

      -- vyhodnotil se blok ?
      if not all then return; end if;

      -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
      bl^.zprac:=bp_opt;
      end if;
  end b_opt_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_for (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblfor;              -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu FOR.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;



    ------------------------------------------------------------------------------------------------
    procedure opt (
        a          : in tuniint;                 -- doln¡ mez ©¡d¡c¡ promˆnn‚
        b          : in tuniint) =               -- horn¡ mez ©¡d¡c¡ promˆnn‚
    -- Optimalizovat cyklus. Jednopr–chodov˜ cyklus je nahrazen tˆlem, 0-pr–chodov˜ je odstranˆn.
    ------------------------------------------------------------------------------------------------
    begin
      -- jeden pr–chod
      if a=b then
        -- optimalizovat jednopr–chodov˜ cyklus
        b_opt_one_pass_loop(curr,bl,context,info);

      -- ‘ dn˜ pr–chod
      elsif a>b then
        -- optimalizovat bezpr–chodov˜ cyklus
        b_opt_bypassed_loop(curr,bl);

      -- v¡ce, ne‘ jeden pr–chod => neoptimalizuje se
      {else}
        end if;
      end opt;


var
  all              : t_logical;                  -- v˜sledek optimalizace bloku

begin
  -- meze implicitn¡, nebo definov ny konstantn¡m rozsahem
  if bl^.xrange=nil
  or else (bl^.xrange^.ntype=nt_range
  and then bl^.xrange^.sub^.ntype=nt_imm
  and then bl^.xrange^.sub^.next^.ntype=nt_imm)
    then
      -- optimalizovat
      opt(bl^.for_var^.typ.getctype^.lval,bl^.for_var^.typ.getctype^.hval);

  -- meze definov ny po‡tem hodnot typu
  elsif bl^.xrange^.nclass=nc_type then
    verify({VERIFY=}000873,bl^.xrange^.t.getutype=nil);

    -- optimalizovat
    opt(bl^.xrange^.t.getctype^.lval,bl^.xrange^.t.getctype^.hval);

  -- nic jin‚ho neoptimalizovat
  {else}
    end if;

  -- st le je zapot©eb¡ optimalizovat blok
  if bl<>nil and then bl^.zprac<>bp_opt then
    -- optimalizovat blok
    b_opt_sequence(sym_build_context(curr.entity,bl^.for_region),bl^.sub,all,context,info);

    -- vyhodnotil se blok ?
    if not all then return; end if;

    -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
    bl^.zprac:=bp_opt;
    end if;
  end b_opt_for;



----------------------------------------------------------------------------------------------------
procedure b_opt_while (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblwhile;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu WHILE.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- v˜sledek optimalizace bloku
  e                : tentityeval;                -- vyhodnocen¡ konst. podm¡nky
  ul               : tunilogical;                -- hodnota konst. podm¡nky

begin
  if x_is_constant(bl^.cond)
    -- podm¡nka je konstantn¡
    then
      -- generovat hint
      if ch_constant_condition in curr.entity^.compv.hints then
        ce^.sethint(curr,{CCERR=}000540,ch_constant_condition);
        bl^.cond^.errpos;
        end if;

      -- na‡¡st log. hodnotu podm¡nky
      x_const_logical(bl^.cond,ul);

      -- optimalizovat while
      if unilogical_to_logical(ul)
        -- log. hodnota podm¡nky je true
        then
          -- optimalizovat nekone‡n˜ cyklus
          b_opt_infinite_loop(curr,bl,context,info);

        -- log. hodnota podm¡nky je false
        else
          -- optimalizovat bezpr–chodov˜ cyklus 
          b_opt_bypassed_loop(curr,bl);
          end if;

    -- podm¡nka je nekonstantn¡
    else
      -- optimalizovat blok
      b_opt_sequence(curr,bl^.sub,all,context,info);

      -- vyhodnotil se blok ?
      if not all then return; end if;

      -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
      bl^.zprac:=bp_opt;
      end if;
  end b_opt_while;



----------------------------------------------------------------------------------------------------
procedure b_opt_case (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcase;             -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu CASE.
----------------------------------------------------------------------------------------------------
with
  cb_choice;

var
  blwhen           : pblwhen_c;                  -- jedna vˆtev CASE
  pblwhen          : pblwhen_c;                  -- p©edchoz¡ vˆtec CASE
  exp              : pexpnode;                   -- jeden v˜bˆr; pro zjednodu¨en¡ z pisu
  ui1              : tuniint;                    -- v˜bˆry
  ui2              : tuniint;                    -- v˜bˆry
  hasothers        : t_logical;                  -- T-je uvedena varianta OTHERS
  all              : t_logical;                  -- vyhodnocen¡ bloku
  allx             : t_logical;                  -- vyhodnocen¡ bloku

begin
  ----- %%TECH Princip optimalizace a kontroly v˜bˆr– v CASE ---------------------------------------
  -- Pro ka‘d˜ WHEN se transformuje seznam v˜bˆr– do nov‚ho s tˆmito vlastnostmi:
  --   -- v˜bˆry jsou set©¡dˆny vzestupnˆ,
  --   -- sousedn¡ v˜bˆry jsou spojeny do jednoho rozsahu,
  --   -- pro duplicitn¡ v˜bˆry se generuje varov n¡.
  -- V˜bˆry se d le zpracov vaj¡ glob lnˆ. Pro ka‘d˜ v˜bˆr, kter˜ ji‘ byl
  -- uveden v nˆkter‚ z p©edchoz¡ch vˆtv¡ se generuje varov n¡.
  --   Pro zjednodu¨en¡ v˜po‡tu se spojuj¡ i ty intervaly, kter‚ spolu
  -- nesoused¡, ale mezera mezi nimi je pokryta p©edchoz¡mi v˜bˆry.
  --------------------------------------------------------------------------------------------------

  -- p©edpoklad: poda©¡ se optimalizovat v¨echny vˆtve
  all:=true;

  -- zpracovat v¨echny vˆtve
  hasothers:=false;
  blwhen:=pblwhen_c(bl^.sub.first);
  pblwhen:=nil;
  while blwhen<>nil loop

    case blwhen^.ctype

      -- seznam v˜bˆr–
      when bct_choice do
          verify({VERIFY=}000427,blwhen^.list=nil or else blwhen^.list^:length=0);

          -- pamˆŸ pro optimalizovan˜ seznam v˜bˆr– lze p©edalokovat p©edem,
          -- stejnˆ se vˆt¨inou nic nezoptimalizuje...
          choice_extend(blwhen^.clist,blwhen^.list^:length{lcount});

          -- zpracovat v¨echny v˜bˆry
          for i in blwhen^.list^:range loop

            -- v˜raz; pro zjednodu¨en¡ z pisu
            exp:=blwhen^.list^[i];

            -- p©¡mo jedna hodnota
            if exp^.ntype=nt_imm then
              load_uniint(pexpimm(exp)^.imm,ui1);
              choice_add_single(curr,blwhen^.clist,ui1,exp);

            -- konstantn¡ rozsah
            elsif exp^.ntype=nt_range then
              -- co je to za rozsah ?
              case pexprange(exp)^.rkind
                -- konstantn¡ rozsah
                when erk_static do
                    verify({VERIFY=}000425,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    load_uniint(pexpimm(exp^.sub^.next)^.imm,ui2);
                    choice_add_range(blwhen^.clist,ui1,ui2,exp);

                -- jeden bod
                when erk_single do
                    verify({VERIFY=}000426,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    choice_add_single(curr,blwhen^.clist,ui1,exp);

                -- pr zdn˜ rozsah
                when erk_null   do
                    ce^.setwarning(curr,{CCERR=}000019,cw_null_choice);
                    exp^.errpos;

                when others do verify({VERIFY=}000424,true);
                end case;

            -- jm‚no typu
            elsif exp^.nclass=nc_type then
              choice_add_range(blwhen^.clist,exp^.t.getlval,exp^.t.gethval,exp);

            else 
              verify({VERIFY=}000745,true);
              end if;
            end loop;

          -- vylou‡it intervaly duplicitn¡ vzhledem k p©edchoz¡m variant m
          {%%X...}

          -- nezmizely v¨echny v˜bˆry ?
          if blwhen^.clist.list^:length=0

            -- zmizely => variantu lze zru¨it £plnˆ
            then
              -- vy©adit ze seznamu
              if pblwhen=nil
                then bl^.sub.first:=blwhen^.next;
                else pblwhen^.next:=blwhen^.next;
                end if;
              if bl^.sub.last=blwhen then bl^.sub.last:=pblwhen; end if;

              -- PBLWHEN se nemˆn¡

            -- nezmizely => aspo¤ zredukovat po‡et interval–
            else
              {%%X...}

              -- nov‚ PBLWHEN
              pblwhen:=blwhen;
              end if;


      -- OTHERS
      when bct_others do
          -- jen poznamenat, ‘e existuje varianta OTHERS
          hasothers:=true;

          -- nov‚ PBLWHEN
          pblwhen:=blwhen;


      when others do verify({VERIFY=}000423,true);
      end case;

    -- optimalizovat p©¡kazy
    b_opt_sequence(curr,blwhen^.sub,allx,context,info);
    all and allx;

    -- dal¨¡ vˆtev
    blwhen:=pblwhen_c(blwhen^.next);
    end loop;

  -- jestli‘e nebylo uvedeno OTHERS, mus¡ b˜t pokryty v¨echny varianty
  if not hasothers then
    {%%X...}
    end if;

  -- povedla se form ln¡ kontrola v¨ech vˆtv¡ ?
  if not all then return end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_case;



----------------------------------------------------------------------------------------------------
procedure b_opt_accept (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblaccept;           -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu ACCEPT
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_accept;



----------------------------------------------------------------------------------------------------
procedure b_opt_catch (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out bllist;              -- p©¡kaz
    all            : out t_logical;              -- T-v¨echny p©¡kazy zkontrolov ny
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu CATCH
----------------------------------------------------------------------------------------------------
var
  blwhen           : pblwhen_m;
  allx             : t_logical;

begin
  -- optimalizovat v¨echny v˜bˆry
  blwhen:=pblwhen_m(bl.first);
  all:=true;
  while blwhen<>nil loop
    verify({VERIFY=}000312,blwhen^.ctype=bct_choice and then (blwhen^.list=nil or else blwhen^.list^:length=0));

    -- p©¡kazy
    b_opt_sequence(curr,blwhen^.sub,allx,context,info);
    allx:=allx and all;

    -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
    if all then blwhen^.zprac:=bp_opt; end if;

    -- dal¨¡ WHEN
    blwhen:=pblwhen_m(blwhen^.next);
    end loop;
  end b_opt_catch;



----------------------------------------------------------------------------------------------------
procedure b_opt_block (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
var
  all1             : t_logical;                  -- zpracov n¡ p©¡kazov‚ ‡ sti
  all2             : t_logical;                  -- zpracov n¡ ‡ sti CATCH
  all3             : t_logical;                  -- zpracov n¡ ‡ sti ROLLBACK
  all4             : t_logical;                  -- zpracov n¡ ‡ sti COMMIT
  all5             : t_logical;                  -- zpracov n¡ ‡ sti LEAVE

begin
  -- p©¡kazov  ‡ st
  b_opt_sequence(curr,bl^.sub,all1,context,info);

  -- ‡ st CATCH
  b_opt_catch{sequence}(curr,bl^.bcatch,all2,context,info);

  -- ‡ st ROLLBACK
  b_opt_sequence(curr,bl^.brollback,all3,context,info);

  -- ‡ st COMMIT
  b_opt_sequence(curr,bl^.bcommit,all4,context,info);

  -- ‡ st LEAVE
  b_opt_sequence(curr,bl^.bleave,all5,context,info);

  -- povedla se optimalizace v¨ech vˆtv¡  ?
  if not (all1 and all2 and all3 and all4 and all5) then return; end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_block;



----------------------------------------------------------------------------------------------------
procedure b_opt_protected (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace protected bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),context,info);
  end b_opt_protected;



----------------------------------------------------------------------------------------------------
procedure b_opt_sequential (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace sekven‡n¡ho bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),context,info);
  end b_opt_sequential;



----------------------------------------------------------------------------------------------------
procedure b_opt_declare (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldeclare;          -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;

begin
  b_opt_block(sym_build_context(curr.entity,bl^.declare_region),pblblock(bl),context,info);
  end b_opt_declare;



----------------------------------------------------------------------------------------------------
procedure b_opt_label (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbllabel;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace n vˆ¨t¡.
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_label;



----------------------------------------------------------------------------------------------------
procedure b_opt_asm (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbllabel;            -- p©¡kaz
    context        : in blcontext;               -- aktu ln¡ kontext
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace k¢du v assembleru
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_asm;



----------------------------------------------------------------------------------------------------
procedure b_opt_node =
-- Optimalizace jednoho uzlu.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000100,bl=nil);

  -- jednou optimalizovan‚ p©¡kazy p©esko‡it
  if bl^.zprac<>pred bp_opt then return; end if;

  -- pokud nastala chyba uzlu v minul˜ch pr–chodech, konec
  if bl^.erroneous then return; end if;

  -- zkontrolovat v˜raz
  case bl^.btype
    -- p©i©azovac¡ p©¡kaz
    when bt_cmd         do b_opt_cmd(curr,pblcmd(bl),context,info);

    -- p©¡kaz BREAK
    when bt_break       do b_opt_break(curr,pblbreak(bl),context,info);

    -- p©¡kaz RETURN
    when bt_return      do b_opt_return(curr,pblreturn(bl),context,info);

    -- p©¡kaz RAISE
    when bt_raise       do b_opt_raise(curr,pblraise(bl),context,info);

    -- p©¡kaz SEND
    when bt_send        do b_opt_send(curr,pblsend(bl),context,info);

    -- p©¡kaz GOTO
    when bt_goto        do b_opt_goto(curr,pblgoto(bl),context,info);

    -- p©¡kaz NEW
    when bt_new         do b_opt_new(curr,pblnew(bl),context,info);

    -- p©¡kaz DISCARD
    when bt_discard     do b_opt_discard(curr,pbldiscard(bl),context,info);

    -- p©¡kaz ADJUST
    when bt_adjust      do b_opt_adjust(curr,pbladjust(bl),context,info);

    -- p©¡kaz DELAY
    when bt_delay       do b_opt_delay(curr,pbldelay(bl),context,info);

    -- p©¡kaz IF
    when bt_if          do b_opt_if(curr,pblif(bl),context,info);

    -- p©¡kaz LOOP
    when bt_loop        do b_opt_loop(curr,pblloop(bl),context,info);

    -- p©¡kaz FOR
    when bt_for         do b_opt_for(curr,pblfor(bl),context,info);

    -- p©¡kaz WHILE
    when bt_while       do b_opt_while(curr,pblwhile(bl),context,info);

    -- p©¡kaz CASE
    when bt_case        do b_opt_case(curr,pblcase(bl),context,info);

    -- p©¡kaz ACCEPT
    when bt_accept      do b_opt_accept(curr,pblaccept(bl),context,info);

    -- blok p©¡kaz–
    when bt_block       do b_opt_block(curr,pblblock(bl),context,info);

    -- protected blok p©¡kazu
    when bt_protected   do b_opt_protected(curr,pblblock(bl),context,info);

    -- sekven‡n¡ blok p©¡kazu
    when bt_sequential  do b_opt_sequential(curr,pblblock(bl),context,info);

    -- blok p©¡kaz–
    when bt_declare     do b_opt_declare(curr,pbldeclare(bl),context,info);

    -- n vˆ¨t¡
    when bt_label       do b_opt_label(curr,pbllabel(bl),context,info);

    -- k¢d v assmebleru
    when bt_asm         do b_opt_asm(curr,pbllabel(bl),context,info);

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others do verify({VERIFY=}000101,true);
    end case;

  catch 
    when resume_error do
      -- kontrola
      verify({VERIFY=}000858,bl^.zprac>=bp_opt);

      -- nastavit p©¡znak, ‘e tento uzel byl chybn˜
      bl^.erroneous:=true;

      -- znovu vyvolat vyj¡mku
      if block_catch_resume_error(catch_mode,bl^.btype) then raise;end if;
  end b_opt_node;



----------------------------------------------------------------------------------------------------
procedure b_opt =
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
var
  context          : blcontext;

begin
  -- sestavit po‡ te‡n¡ kontext
  context.loop_end:=nil;

  -- prov‚st optimalizaci
  b_opt_node(curr,bl,context,info);
  end b_opt;



end cb_opt;
