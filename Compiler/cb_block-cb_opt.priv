----------------------------------------------------------------------------------------------------
module private cb_opt =
-- Překladač Flexu.
-- Optimalizace bloku příkazů.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.10.2001 : Vytvořil
----------------------------------------------------------------------------------------------------

with
  cx_expr.cx_imm,
  cx_expr.cx_util;

type
  -- kontext příkazu
  blcontext        = record
      loop_end     : pentity_label;              -- návěští pro [break] (pro optimalizaci
                                                 -- jednoprůchodových cyklů, viz %%TECH poznámka)
      end record;

------ %%TECH --------------------------------------------------------------------------------------
-- Výsledkem optimalizace konkrétního uzlu může být:
--     - ten samý uzel,
--     - jiný uzel,
--     - žádný uzel (uzel se zcela vynechá),
--     - série několika uzlů.
--
-- Výsledkem optimalizace jednoprůchodového cyklu je jeho tělo (příp. declare blok pro for cyklus).
-- V tomto případě je nutné vytvořit návěští konce těla cyklu, změnit [break] příkazy cyklu
-- na [goto] a dodat jim toto návěští pomocí parametru [context] optimalizačních procedur.
----------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------
procedure b_opt_node (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblnode;             -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo;                  -- informace o průběhu analýzy
    catch_mode     : in t_catch_mode:=catch_mode_implicit); -- způsob, jak zachytávat chyby resume_error
-- Optimalizace jednoho uzlu.
----------------------------------------------------------------------------------------------------




----------------------------------------------------------------------------------------------------
procedure b_opt_sequence (
    curr           : in tcontext;                -- překládaný prvek
    list           : in out bllist;              -- první uzel sekvence
    all            : out t_logical;              -- T-všechny příkazy zkontrolovány
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace posloupnosti příkazů.
----------------------------------------------------------------------------------------------------
var
  pbl              : pblnode;                    -- předchozí příkaz
  cbl              : pblnode;                    -- aktuální příkaz
  nbl              : pblnode;                    -- následující příkaz
  labels_only      : t_logical :=true;           -- T-optimalizovaná sekvence je prázdná,
                                                 -- nebo obsahuje pouze nevýznamný kód (návěští)
begin
  -- optimistický předpoklad
  all:=true;

  -- optimaliazce všech příkazů
  pbl:=nil;
  cbl:=list.first;
  while cbl<>nil loop
    -- poznamenat si následující blok
    nbl:=cbl^.next;

    -- rozpojit
    cbl^.next:=nil;

    -- optimalizace příkazu
    b_opt_node(curr,cbl,context,info);

    if cbl<>nil

      -- spojit zpět
      then
        -- spojit (1)
        if pbl<>nil
          then pbl^.next:=cbl;
          else list.first:=cbl;
          end if;

        -- optimalizací mohlo vzniknout několik příkazů
        while cbl^.next<>nil loop cbl:=cbl^.next; end loop;

        -- spojit (2)
        cbl^.next:=nbl;
        if nbl=nil then list.last:=cbl; end if;

        -- povedla se optimalizace ?
        if cbl^.zprac<bp_opt then all:=false; end if;

        -- nový předchozí uzel
        pbl:=cbl;

      -- příkaz se optimalizoval a optimalizoval až úplně zmizel
      else
        -- spojit
        if pbl<>nil
          then pbl^.next:=nbl;
          else list.first:=nbl;
          end if;
        if nbl=nil then list.last:=pbl; end if;

        -- optimalizace se totálně povedla
        end if;

    -- další příkaz
    cbl:=nbl;
    end loop;
  
  -- optimalizace skoků v rámci sekvence
  pbl:=nil;
  cbl:=list.first;
  while cbl<>nil loop
    -- poznamenat si následující blok
    nbl:=cbl^.next;

    -- optimalizovat sekvenci [goto]/[break] ... [label]/konec bloku
    case cbl^.btype
      -- [goto], [break]
      when bt_break,bt_goto do
          declare var
            -- první a poslední uzel se subsekvence, která bude ze sekvence vypuštěna
            -- pouze pro hlášení pozice hintu
            skip_first : pblnode;                -- první uzel
            skip_last  : pblnode :=nil;          -- poslední uzel
          begin
            skip_first:=nbl;

            -- najít nejbližší [label], popř. konec bloku
            while nbl<>nil and then nbl^.btype<>bt_label loop
              skip_last:=nbl;
              nbl:=nbl^.next;
              end loop;
      
            -- vypsat hint
            if skip_first<>nil and then skip_last<>nil
            and then ch_unreachable_code in curr.entity^.compv.hints then
              ce^.sethint(curr,{CCERR=}000529,ch_unreachable_code);
              sequence_errpos(skip_first,skip_last);
              end if;
            end declare;

          -- zkontrolovat, zda je pozice totožná s cílem skoku
          if nbl<>nil and then cbl^.btype=bt_goto and then pblgoto(cbl)^.plabel=pbllabel(nbl)^.plabel
            -- odstranit i [goto]
            then
              cbl:=pbl;

            -- kód
            else
              labels_only:=false;
              end if;

          -- odstranit přeskočené bloky ze sekvence
          if cbl<>nil
            then cbl^.next:=nbl;
            else list.first:=nbl;
            end if;

          -- posunout se za eventuální [label]
          if nbl<>nil
            then
              cbl:=nbl;
              nbl:=nbl^.next;
            else
              -- konec seznamu
              list.last:=cbl;
              end if;

      -- [label]
      when bt_label do
          -- nedělat nic

      -- funkční kód
      when others do
          labels_only:=false;
        end case;
          
    -- další blok sekvence
    pbl:=cbl;
    cbl:=nbl;
    end loop;

  -- sekvence neobsahuje funkční kód => odstranit celou sekvenci
  if labels_only then
    list.first:=nil;
    list.last:=nil;
    end if;
  end b_opt_sequence;



----------------------------------------------------------------------------------------------------
procedure b_opt_cmd (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblcmd;              -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace přiřazovacího příkazu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- není co optimalizovat (%%X nebo ano ?)

  -- nezmizel náhodou celý příkaz vlivem optimalizace příkazu ? (např. X+0)
  if bl^.expr=nil then
    bl:=nil;
    return;
    end if;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_cmd;



----------------------------------------------------------------------------------------------------
procedure b_opt_break (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblbreak;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu [break].
----------------------------------------------------------------------------------------------------
begin
  -- v důsledku optimalizace jednoprůchodového cyklu je potřeba změnit [break] v [goto]
  if context.loop_end<>nil then
    declare var
      pbg          : pblgoto;                    -- uzel [goto]
    begin
      -- vytvořit nový uzel [goto] skoku
      derivenode(pbg,bl,info,bt_goto);
      pbg^.plabel:=context.loop_end;

      -- nahradit uzel [break] za uzel [goto]
      bl:=pblnode(pbg);
      end declare;
    end if;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_break;



----------------------------------------------------------------------------------------------------
procedure b_opt_return (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblreturn;           -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu RETURN.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_return;



----------------------------------------------------------------------------------------------------
procedure b_opt_raise (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblraise;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu RAISE.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_raise;



----------------------------------------------------------------------------------------------------
procedure b_opt_send (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblsend;             -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazů SEND.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_send;



----------------------------------------------------------------------------------------------------
procedure b_opt_goto (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblgoto;             -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu GOTO.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_goto;



----------------------------------------------------------------------------------------------------
procedure b_opt_new (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblnew;              -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu NEW.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_new;



----------------------------------------------------------------------------------------------------
procedure b_opt_discard (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbldiscard;          -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu DISCARD.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_discard;



----------------------------------------------------------------------------------------------------
procedure b_opt_adjust (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbladjust;           -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu ADJUST.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_adjust;



----------------------------------------------------------------------------------------------------
procedure b_opt_delay (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbldelay;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu DELAY.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_delay;



----------------------------------------------------------------------------------------------------
procedure b_opt_if (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblif;               -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu IF.
----------------------------------------------------------------------------------------------------
var
  psub             : pblif_cond;                 -- předchozí větev if
  sub              : pblif_cond;                 -- aktuální větev if
  all              : t_logical;                  -- vyhodnocení bloku
  allx             : t_logical;                  -- vyhodnocení bloku


  
    ------------------------------------------------------------------------------------------------
    procedure opt_const_cond =
    -- Optimalizace větví s konstantní podmínkou.
    ------------------------------------------------------------------------------------------------
    var
      ul           : tunilogical;                -- hodnota konst. podmínky
    
    begin
      -- optimalizace všech větví podle typu podmínky
      psub:=nil;
      sub:=pblif_cond(bl^.sub.first);
      while sub<>nil loop
        -- zpracovat větev podle typu podmínky
        if sub^.cond<>nil and x_is_constant(sub^.cond)
          -- podmínka je konstantní
          then
            -- generovat hint
            if ch_constant_condition in curr.entity^.compv.hints then
              ce^.sethint(curr,{CCERR=}000530,ch_constant_condition);
              sub^.cond^.errpos;
              end if;

            -- načíst log. hodnotu podmínky
            x_const_logical(sub^.cond,ul);

            -- podle log. hodnoty podmínky upravit seznam větví ifu
            if unilogical_to_logical(not ul)
              -- false => zahodit větev
              then
                -- generovat hint
                if ch_unreachable_code in curr.entity^.compv.hints then
                  ce^.sethint(curr,{CCERR=}000531,ch_unreachable_code);
                  node_errpos(sub);
                  end if;

                if psub<>nil
                  then psub^.next:=sub^.next;
                  else bl^.sub.first:=sub^.next;
                  end if;
                if sub^.next=nil then
                  bl^.sub.last:=psub;
                  end if;
          
              -- true => učinit tuto větev poslední (else) větví ifu
              else
                -- generovat hint pro všechny případné další větve
                if ch_unreachable_code in curr.entity^.compv.hints then
                  declare var
                    usub   : pblif_cond;         -- nedosažitelná větev ifu
                  begin
                    usub:=sub^.next;
                    while usub<>nil loop
                      -- generovat hint
                      ce^.sethint(curr,{CCERR=}000532,ch_unreachable_code);
                      node_errpos(usub);

                      usub:=usub^.next;
                      end loop;
                    end declare;
                  end if;

                if sub^.sub.first<>nil
                  -- větev je neprázdná => bude poslední větví ifu
                  then
                    sub^.next:=nil;
                    bl^.sub.last:=sub;
                    sub^.cond:=nil;

                  -- větev je prázdná => odstranit i ji samotnou
                  else
                    if psub<>nil
                      then psub^.next:=nil;
                      else bl^.sub.first:=nil;
                      end if;
                    bl^.sub.last:=psub;
                    end if;
                end if;

          -- podmínka není konstantní
          else
            psub:=sub;
          end if;

        -- další větev
        sub:=sub^.next;
        end loop;
      end opt_const_cond;

    

    ------------------------------------------------------------------------------------------------
    procedure opt_empty_tail =
    -- Optimalizace prázdných větví na konci ifu. Takové větve jsou zahazovány.
    -- POZOR! Tuto optimalizaci je možno povolit jen za předpokladu, že vyhodnocení
    -- podmínky větve je bez side-efektů.
    -- Prozatím zakázáno.
    ------------------------------------------------------------------------------------------------
    begin
      -- najít poslední neprázdnou větev
      psub:=nil;
      sub:=pblif_cond(bl^.sub.first);
      while sub<>nil loop
        if sub^.sub.first<>nil then
          psub:=sub;
          end if;
        sub:=sub^.next;
        end loop;

      -- v ifu jsou nějaké neprázdné větve a na konci je alespoň jedna prázdná větev
      if psub<>nil and then psub^.next<>nil then
        -- pro odstraňované větve vypsat warning (kvůli možným side-efektům volání v podmínkách)
        if cw_cond_removed in curr.entity^.compv.warns then
          -- generovat warning
          ce^.setwarning(curr,{CCERR=}000533,cw_cond_removed);
          sequence_errpos(psub^.next,pblif(bl)^.sub.last);
          end if;

        -- odstranit prázdné větve z konce seznamu
        psub^.next:=nil;
        pblif(bl)^.sub.last:=psub;

      -- v ifu jsou pouze prázdné větve
      elsif psub=nil and pblif(bl)^.sub.first<>nil then
        -- pro odstraňované větve vypsat warning (kvůli možným side-efektům volání v podmínkách)
        if cw_cond_removed in curr.entity^.compv.warns then
          -- generovat warning
          ce^.setwarning(curr,{CCERR=}000542,cw_cond_removed);
          sequence_errpos(pblif(bl)^.sub.first,pblif(bl)^.sub.last);
          end if;

        -- odstranit všechny větve
        pblif(bl)^.sub.first:=nil;
        end if;
      end opt_empty_tail;



    ------------------------------------------------------------------------------------------------
    procedure opt_swap_and_cut =
    -- Optimalizace [if] tvaru [if <nekonst. podmínka> then else <tělo> end if;].
    -- Optimalizuje se na tvar [if <negace podmínky> then <tělo> end if;].
    ------------------------------------------------------------------------------------------------
    var
      newcond      : pexpnode;                   -- nová podmínka

    begin
      -- [if] je tvaru [if <nekonst. podmínka> then else <tělo> end if;]
      if bl^.sub.first^.next=bl^.sub.last
      and pblif_cond(bl^.sub.first)^.sub.first=nil
      and pblif_cond(bl^.sub.last)^.cond=nil
        -- změnit [if] na tvar [if not <podmínka> then <tělo> end if;]
        then
          -- negovat podmínku
          x_negate_logical(curr,newcond,pblif_cond(bl^.sub.first)^.cond);
          pblif_cond(bl^.sub.first)^.cond:=newcond;

          -- zaměnit blok podmíněné větve za blok [else] větve a odstranit [else] větev
          pblif_cond(bl^.sub.first)^.sub:=pblif_cond(bl^.sub.last)^.sub;
          bl^.sub.first^.next:=nil;
          bl^.sub.last:=bl^.sub.first;
          end if;
      end opt_swap_and_cut;


begin
  -- optimistický předpoklad
  all:=true;

  -- formální kontrola bloků všech větví
  sub:=pblif_cond(bl^.sub.first);
  while sub<>nil loop
    verify({VERIFY=}000540,sub^.btype<>bt_if_cond);

    -- kontrola bloku
    b_opt_sequence(curr,sub^.sub,allx,context,info);
    all:=all and allx;

    -- další větev
    sub:=sub^.next;
    end loop;
  
  -- povedla se formální kontrola bloků všech větví ?
  if not all then return; end if;

  -- optimalizuj větve s konstantními podmínkami
  opt_const_cond();

  -- optimalizuj prázdné větve na konci [if]
  {opt_empty_tail();}

  -- nezbyla žádná větev
  if bl^.sub.first=nil then
    -- generovat hint
    if ch_unreachable_code in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000534,ch_unreachable_code);
      node_errpos(bl);
      end if;

    -- vypustit celý [if]
    bl:=nil;

  -- zbyla pouze [else] větev
  elsif pblif_cond(bl^.sub.first)^.cond=nil then
    -- generovat hint
    if ch_if_reduced in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000535,ch_if_reduced);
      node_errpos(bl);
      end if;

    -- nahradit celý [if] blokem [else] větve
    bl:=pblif_cond(bl^.sub.first)^.sub.first;

  else
    -- optimalizuj [if] tvaru [if <nekonst. podmínka> then else <tělo> end if;]
    opt_swap_and_cut();

    -- optimalizace příkazu úspěšně dokončena
    bl^.zprac:=bp_opt;
    end if;
  end b_opt_if;



----------------------------------------------------------------------------------------------------
procedure b_opt_bypassed_loop (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblcompound) =       -- příkaz
-- Optimalizace bezprůchodového cyklu. Vygeneruje hint a zahodí celý cyklus.
----------------------------------------------------------------------------------------------------
begin
  -- generovat hint
  if ch_unreachable_code in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000536,ch_unreachable_code);
    node_errpos(bl);
    end if;

  -- zahodit celý cyklus
  bl:=nil;
  end b_opt_bypassed_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_one_pass_loop (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblcompound;         -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace jednoprůchodového cyklu. Vytvoří návěští pro eventuální [break] (viz %%TECH)
-- a přidá je na konec těla cyklu. Generuje hint.
----------------------------------------------------------------------------------------------------
with
  cc_base.cc_sym,
  cd_decl.cd_create;

var
  all              : t_logical;                  -- výsledek optimalizace bloku
  pbllbl           : pbllabel;                   -- blok návěští
  plabel           : pentity_label;              -- návěští
  clabel           : tcontext;                   -- kontext návěští
  newcontext       : blcontext;                  -- aktualizovaný kontext

begin
  -- generovat hint
  if ch_one_pass_loop in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000537,ch_one_pass_loop);
    node_errpos(bl);
    end if;

  -- vytvořit interní symbol návěští, nevyhodnocovat deklaraci
  d_create_internal(curr,plabel,clabel,et_label,sym_get_label_id);
  plabel^.reachable:=true;                       -- návěští je použitelné jako cíl skoku
  plabel^.placed:=true;                          -- návěští je umístěno
  --plabel^.num:=0;                                -- číslo návěští (netřeba)
  --plabel^.level:=0;                              -- úroveň umístění návěští (netřeba)
  d_end_internal(plabel^,false);

  -- vytvořit uzel návěští
  newnode(pbllbl,info,bt_label);
  pbllbl^.plabel:=plabel;

  -- zařadit uzel návěští na konec těla cyklu
  if bl^.sub.last<>nil
    then bl^.sub.last^.next:=pbllbl;
    else bl^.sub.first:=pbllbl;
    end if;
  bl^.sub.last:=pbllbl;

  -- propagovat návěští do nového kontextu
  newcontext:=context;
  newcontext.loop_end:=plabel;

  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,newcontext,info);

  -- tělo cyklu se optimalizací vytratilo => je to všechno
  if bl^.sub.first=nil then return; end if;

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- nahradit cyklus blokem těla
  case bl^.btype
    -- for cyklus
    when bt_for do
        -- nahradit for blok declare blokem s řídící proměnnou
        declare var
          pdbl     : pbldeclare;                 -- declare blok

        begin
          -- vyrobit declare blok
          derivenode(pdbl,bl,info,bt_declare);
          pdbl^.declare_region:=pblfor(bl)^.for_region;
          pdbl^.sub:=bl^.sub;
          pdbl^.zprac:=bl^.zprac;

          -- nastavit řídící proměnnou na příslušnou hodnotu (přes počáteční hodnotu proměnné)
          store_ordinal(pblfor(bl)^.for_var^.init.getuimm^,pblfor(bl)^.for_var^.typ.getctype^.lval);

          -- použít declare blok místo cyklu
          bl:=pblnode(pdbl);
        end declare;
    
    -- loop cyklus
    when bt_loop do
        -- nahradit loop jeho tělem
        bl:=bl^.sub.first;

    -- nic jiného to nemohlo být
    when others do verify({VERIFY=}001251);
    end case;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_one_pass_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_infinite_loop (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblcompound;         -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace nekonečného cyklu (nekonečnost v důsledku optimalizace). Vypíše hint a konvertuje
-- cyklus na konstrukci [loop ... end loop;].
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- výsledek optimalizace bloku

begin
  -- generovat hint
  if ch_infinite_loop in curr.entity^.compv.hints then
    ce^.sethint(curr,{CCERR=}000538,ch_infinite_loop);
    node_errpos(bl);
    end if;

  -- vytvořit nekonečný loop
  case bl^.btype
    -- while
    when bt_while do
        declare var
          pil      : pblloop;                    -- nekonečný loop
        begin
          derivenode(pil,bl,info,bt_loop);
          pil^.sub:=bl^.sub;
          bl:=pblnode(pil);
          end declare;

    -- loop
    when bt_loop do
        pblloop(bl)^.cond:=nil;

    -- nic jiného to nemohlo být
    when others do verify({VERIFY=}001252);
    end case;

  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,context,info);

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_infinite_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_loop (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblloop;             -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu LOOP.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- výsledek optimalizace bloku
  e                : tentityeval;                -- vyhodnocení konst. podmínky
  ul               : tunilogical;                -- hodnota konst. podmínky

begin
  if (bl^.cond<>nil) and x_is_constant(bl^.cond)
    -- podmínka je konstantní
    then
      -- generovat hint
      if ch_constant_condition in curr.entity^.compv.hints then
        ce^.sethint(curr,{CCERR=}000539,ch_constant_condition);
        bl^.cond^.errpos;
        end if;

      -- načíst log. hodnotu podmínky
      x_const_logical(bl^.cond,ul);

      -- optimalizovat loop
      if unilogical_to_logical(ul)
        -- podmínka je vždy splněna => jednoprůchodový cyklus
        then
          -- optimalizovat jednoprůchodový cyklus
          b_opt_one_pass_loop(curr,bl,context,info);

        -- podmínka není nikdy splněna
        else
          -- optimalizovat nekonečný cyklus
          b_opt_infinite_loop(curr,bl,context,info);
          end if;

    -- podmínka je nekonstantní, nebo chybí (nekonečný cyklus)
    else
      -- optimalizovat blok
      b_opt_sequence(curr,bl^.sub,all,context,info);

      -- vyhodnotil se blok ?
      if not all then return; end if;

      -- optimalizace příkazu úspěšně dokončena
      bl^.zprac:=bp_opt;
      end if;
  end b_opt_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_for (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblfor;              -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu FOR.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;



    ------------------------------------------------------------------------------------------------
    procedure opt (
        a          : in tuniint;                 -- dolní mez řídící proměnné
        b          : in tuniint) =               -- horní mez řídící proměnné
    -- Optimalizovat cyklus. Jednoprůchodový cyklus je nahrazen tělem, 0-průchodový je odstraněn.
    ------------------------------------------------------------------------------------------------
    begin
      -- jeden průchod
      if a=b then
        -- optimalizovat jednoprůchodový cyklus
        b_opt_one_pass_loop(curr,bl,context,info);

      -- žádný průchod
      elsif a>b then
        -- optimalizovat bezprůchodový cyklus
        b_opt_bypassed_loop(curr,bl);

      -- více, než jeden průchod => neoptimalizuje se
      {else}
        end if;
      end opt;


var
  all              : t_logical;                  -- výsledek optimalizace bloku

begin
  -- meze implicitní, nebo definovány konstantním rozsahem
  if bl^.xrange=nil
  or else (bl^.xrange^.ntype=nt_range
  and then bl^.xrange^.sub^.ntype=nt_imm
  and then bl^.xrange^.sub^.next^.ntype=nt_imm)
    then
      -- optimalizovat
      opt(bl^.for_var^.typ.getctype^.lval,bl^.for_var^.typ.getctype^.hval);

  -- meze definovány počtem hodnot typu
  elsif bl^.xrange^.nclass=nc_type then
    verify({VERIFY=}000873,bl^.xrange^.t.getutype=nil);

    -- optimalizovat
    opt(bl^.xrange^.t.getctype^.lval,bl^.xrange^.t.getctype^.hval);

  -- nic jiného neoptimalizovat
  {else}
    end if;

  -- stále je zapotřebí optimalizovat blok
  if bl<>nil and then bl^.zprac<>bp_opt then
    -- optimalizovat blok
    b_opt_sequence(sym_build_context(curr.entity,bl^.for_region),bl^.sub,all,context,info);

    -- vyhodnotil se blok ?
    if not all then return; end if;

    -- optimalizace příkazu úspěšně dokončena
    bl^.zprac:=bp_opt;
    end if;
  end b_opt_for;



----------------------------------------------------------------------------------------------------
procedure b_opt_while (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblwhile;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu WHILE.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- výsledek optimalizace bloku
  e                : tentityeval;                -- vyhodnocení konst. podmínky
  ul               : tunilogical;                -- hodnota konst. podmínky

begin
  if x_is_constant(bl^.cond)
    -- podmínka je konstantní
    then
      -- generovat hint
      if ch_constant_condition in curr.entity^.compv.hints then
        ce^.sethint(curr,{CCERR=}000540,ch_constant_condition);
        bl^.cond^.errpos;
        end if;

      -- načíst log. hodnotu podmínky
      x_const_logical(bl^.cond,ul);

      -- optimalizovat while
      if unilogical_to_logical(ul)
        -- log. hodnota podmínky je true
        then
          -- optimalizovat nekonečný cyklus
          b_opt_infinite_loop(curr,bl,context,info);

        -- log. hodnota podmínky je false
        else
          -- optimalizovat bezprůchodový cyklus 
          b_opt_bypassed_loop(curr,bl);
          end if;

    -- podmínka je nekonstantní
    else
      -- optimalizovat blok
      b_opt_sequence(curr,bl^.sub,all,context,info);

      -- vyhodnotil se blok ?
      if not all then return; end if;

      -- optimalizace příkazu úspěšně dokončena
      bl^.zprac:=bp_opt;
      end if;
  end b_opt_while;



----------------------------------------------------------------------------------------------------
procedure b_opt_case (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblcase;             -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu CASE.
----------------------------------------------------------------------------------------------------
with
  cb_choice;

var
  blwhen           : pblwhen_c;                  -- jedna větev CASE
  pblwhen          : pblwhen_c;                  -- předchozí větec CASE
  exp              : pexpnode;                   -- jeden výběr; pro zjednodušení zápisu
  ui1              : tuniint;                    -- výběry
  ui2              : tuniint;                    -- výběry
  hasothers        : t_logical;                  -- T-je uvedena varianta OTHERS
  all              : t_logical;                  -- vyhodnocení bloku
  allx             : t_logical;                  -- vyhodnocení bloku
  covered          : tchoicelist;                -- všechny pokryté varianty
  uncovered        : tchoicelist;                -- nepokryté hodnoty řídícího výrazu

begin
  ----- %%TECH Princip optimalizace a kontroly výběrů v CASE ---------------------------------------
  -- Pro každý WHEN se transformuje seznam výběrů do nového s těmito vlastnostmi:
  --   -- výběry jsou setříděny vzestupně,
  --   -- sousední výběry jsou spojeny do jednoho rozsahu,
  --   -- pro duplicitní výběry se generuje varování.
  -- Výběry se dále zpracovávají globálně. Pro každý výběr, který již byl
  -- uveden v některé z předchozích větví se generuje varování.
  --   Pro zjednodušení výpočtu se spojují i ty intervaly, které spolu
  -- nesousedí, ale mezera mezi nimi je pokryta předchozími výběry.
  --------------------------------------------------------------------------------------------------

  -- předpoklad: podaří se optimalizovat všechny větve
  all:=true;

  -- zpracovat všechny větve
  hasothers:=false;
  blwhen:=pblwhen_c(bl^.sub.first);
  pblwhen:=nil;
  while blwhen<>nil loop

    case blwhen^.ctype

      -- seznam výběrů
      when bct_choice do
          verify({VERIFY=}000427,blwhen^.list=nil or else blwhen^.list^:length=0);

          -- paměť pro optimalizovaný seznam výběrů lze předalokovat předem,
          -- stejně se většinou nic nezoptimalizuje...
          choice_extend(blwhen^.clist,blwhen^.list^:length{lcount});

          -- zpracovat všechny výběry
          for i in blwhen^.list^:range loop

            -- výraz; pro zjednodušení zápisu
            exp:=blwhen^.list^[i];

            -- přímo jedna hodnota
            if exp^.ntype=nt_imm then
              load_uniint(pexpimm(exp)^.imm,ui1);
              choice_add_single(curr,blwhen^.clist,ui1,exp);

            -- konstantní rozsah
            elsif exp^.ntype=nt_range then
              -- co je to za rozsah ?
              case pexprange(exp)^.rkind
                -- konstantní rozsah
                when erk_static do
                    verify({VERIFY=}000425,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    load_uniint(pexpimm(exp^.sub^.next)^.imm,ui2);
                    choice_add_range(curr,blwhen^.clist,ui1,ui2,exp);

                -- jeden bod
                when erk_single do
                    verify({VERIFY=}000426,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    choice_add_single(curr,blwhen^.clist,ui1,exp);

                -- prázdný rozsah
                when erk_null   do
                    ce^.setwarning(curr,{CCERR=}000019,cw_null_choice);
                    exp^.errpos;

                when others do verify({VERIFY=}000424,true);
                end case;

            -- jméno typu
            elsif exp^.nclass=nc_type then
              choice_add_range(curr,blwhen^.clist,exp^.t.getlval,exp^.t.gethval,exp);

            else 
              verify({VERIFY=}000745,true);
              end if;
            end loop;

          -- vyloučit intervaly duplicitní vzhledem k předchozím variantám
          choice_subtract(curr,exp,blwhen^.clist,covered,true);

          -- poznačit použitý interval
          choice_merge(covered,blwhen^.clist);

          -- nezmizely všechny výběry ?
          if blwhen^.clist.list^:length=0

            -- zmizely => variantu lze zrušit úplně
            then
              -- vyřadit ze seznamu
              if pblwhen=nil
                then bl^.sub.first:=blwhen^.next;
                else pblwhen^.next:=blwhen^.next;
                end if;
              if bl^.sub.last=blwhen then bl^.sub.last:=pblwhen; end if;

              -- PBLWHEN se nemění

            -- nezmizely => aspoň zredukovat počet intervalů
            else
              choice_reduce(blwhen^.clist, covered);

              -- nové PBLWHEN
              pblwhen:=blwhen;
              end if;


      -- OTHERS
      when bct_others do
          -- jen poznamenat, že existuje varianta OTHERS
          hasothers:=true;

          -- nové PBLWHEN
          pblwhen:=blwhen;


      when others do verify({VERIFY=}000423,true);
      end case;

    -- optimalizovat příkazy
    b_opt_sequence(curr,blwhen^.sub,allx,context,info);
    all and allx;

    -- další větev
    blwhen:=pblwhen_c(blwhen^.next);
    end loop;

  -- spočteme chybějící varianty (=všechny možnosti mínus pokryté možnosti)
  choice_add_range(curr,uncovered,bl^.expr^.t.getlval,bl^.expr^.t.gethval,nil,false);
  choice_subtract(curr,exp,uncovered,covered,false);

  if hasothers

    -- jestli bylo uvedeno OTHERS, mělo by něco zbývat, jinak vydáme hint
    then
      if uncovered.list^:length=0 then
        -- je tu sice WHEN OTHERS, ale nic pro nej nezbyva => vyhodit ho a vydat hint

        -- najdi OTHERS vetev s jejim predchudcem
        blwhen:=pblwhen_c(bl^.sub.first);
        pblwhen:=nil;
        while blwhen^.ctype<>bct_others loop
          pblwhen:=blwhen;
          blwhen:=pblwhen_c(blwhen^.next);
          verify({VERIFY=}001292,blwhen=nil);
          end loop;

        -- vydej hint
        if ch_unreachable_code in curr.entity^.compv.hints then
          ce^.sethint(curr,{CCERR=}000604,ch_unreachable_code);
          node_errpos(blwhen);
          end if;

        -- vyhod OTHERS vetev
        if pblwhen=nil
          then bl^.sub.first:=blwhen^.next;
          else pblwhen^.next:=blwhen^.next;
          end if;
        if bl^.sub.last=blwhen then bl^.sub.last:=pblwhen; end if;
        hasothers:=false;
        end if;

    -- jestliže nebylo uvedeno OTHERS, musí být pokryty všechny varianty
    else
      if uncovered.list^:length<>0 then
        ce^.seterror({CCERR=}000605,ce_case_incomplete);
        node_errpos(bl);
        end if;
      end if;

  -- povedla se formální kontrola všech větví ?
  if not all then return end if;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_case;



----------------------------------------------------------------------------------------------------
procedure b_opt_accept (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblaccept;           -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu ACCEPT
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_accept;



----------------------------------------------------------------------------------------------------
procedure b_opt_catch (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out bllist;              -- příkaz
    all            : out t_logical;              -- T-všechny příkazy zkontrolovány
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace příkazu CATCH
----------------------------------------------------------------------------------------------------
var
  blwhen           : pblwhen_m;
  allx             : t_logical;

begin
  -- optimalizovat všechny výběry
  blwhen:=pblwhen_m(bl.first);
  all:=true;
  while blwhen<>nil loop
    verify({VERIFY=}000312,blwhen^.ctype=bct_choice and then (blwhen^.list=nil or else blwhen^.list^:length=0));

    -- příkazy
    b_opt_sequence(curr,blwhen^.sub,allx,context,info);
    allx:=allx and all;

    -- optimalizace příkazu úspěšně dokončena
    if all then blwhen^.zprac:=bp_opt; end if;

    -- další WHEN
    blwhen:=pblwhen_m(blwhen^.next);
    end loop;
  end b_opt_catch;



----------------------------------------------------------------------------------------------------
procedure b_opt_block (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblblock;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  all1             : t_logical;                  -- zpracování příkazové části
  all2             : t_logical;                  -- zpracování části CATCH
  all3             : t_logical;                  -- zpracování části ROLLBACK
  all4             : t_logical;                  -- zpracování části COMMIT
  all5             : t_logical;                  -- zpracování části LEAVE

begin
  -- příkazová část
  b_opt_sequence(curr,bl^.sub,all1,context,info);

  -- část CATCH
  b_opt_catch{sequence}(curr,bl^.bcatch,all2,context,info);

  -- část ROLLBACK
  b_opt_sequence(curr,bl^.brollback,all3,context,info);

  -- část COMMIT
  b_opt_sequence(curr,bl^.bcommit,all4,context,info);

  -- část LEAVE
  b_opt_sequence(curr,bl^.bleave,all5,context,info);

  -- povedla se optimalizace všech větví  ?
  if not (all1 and all2 and all3 and all4 and all5) then return; end if;

  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_block;



----------------------------------------------------------------------------------------------------
procedure b_opt_protected (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblblock;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace protected bloku příkazů.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),context,info);
  end b_opt_protected;



----------------------------------------------------------------------------------------------------
procedure b_opt_sequential (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pblblock;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace sekvenčního bloku příkazů.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),context,info);
  end b_opt_sequential;



----------------------------------------------------------------------------------------------------
procedure b_opt_declare (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbldeclare;          -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace bloku příkazů.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;

begin
  b_opt_block(sym_build_context(curr.entity,bl^.declare_region),pblblock(bl),context,info);
  end b_opt_declare;



----------------------------------------------------------------------------------------------------
procedure b_opt_label (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbllabel;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace návěští.
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_label;



----------------------------------------------------------------------------------------------------
procedure b_opt_asm (
    curr           : in tcontext;                -- překládaný prvek
    bl             : in out pbllabel;            -- příkaz
    context        : in blcontext;               -- aktuální kontext
    info           : in blinfo) =                -- informace o průběhu analýzy
-- Optimalizace kódu v assembleru
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace příkazu úspěšně dokončena
  bl^.zprac:=bp_opt;
  end b_opt_asm;



----------------------------------------------------------------------------------------------------
procedure b_opt_node =
-- Optimalizace jednoho uzlu.
----------------------------------------------------------------------------------------------------
begin
  verify({VERIFY=}000100,bl=nil);

  -- jednou optimalizované příkazy přeskočit
  if bl^.zprac<>pred bp_opt then return; end if;

  -- pokud nastala chyba uzlu v minulých průchodech, konec
  if bl^.erroneous then return; end if;

  -- zkontrolovat výraz
  case bl^.btype
    -- přiřazovací příkaz
    when bt_cmd         do b_opt_cmd(curr,pblcmd(bl),context,info);

    -- příkaz BREAK
    when bt_break       do b_opt_break(curr,pblbreak(bl),context,info);

    -- příkaz RETURN
    when bt_return      do b_opt_return(curr,pblreturn(bl),context,info);

    -- příkaz RAISE
    when bt_raise       do b_opt_raise(curr,pblraise(bl),context,info);

    -- příkaz SEND
    when bt_send        do b_opt_send(curr,pblsend(bl),context,info);

    -- příkaz GOTO
    when bt_goto        do b_opt_goto(curr,pblgoto(bl),context,info);

    -- příkaz NEW
    when bt_new         do b_opt_new(curr,pblnew(bl),context,info);

    -- příkaz DISCARD
    when bt_discard     do b_opt_discard(curr,pbldiscard(bl),context,info);

    -- příkaz ADJUST
    when bt_adjust      do b_opt_adjust(curr,pbladjust(bl),context,info);

    -- příkaz DELAY
    when bt_delay       do b_opt_delay(curr,pbldelay(bl),context,info);

    -- příkaz IF
    when bt_if          do b_opt_if(curr,pblif(bl),context,info);

    -- příkaz LOOP
    when bt_loop        do b_opt_loop(curr,pblloop(bl),context,info);

    -- příkaz FOR
    when bt_for         do b_opt_for(curr,pblfor(bl),context,info);

    -- příkaz WHILE
    when bt_while       do b_opt_while(curr,pblwhile(bl),context,info);

    -- příkaz CASE
    when bt_case        do b_opt_case(curr,pblcase(bl),context,info);

    -- příkaz ACCEPT
    when bt_accept      do b_opt_accept(curr,pblaccept(bl),context,info);

    -- blok příkazů
    when bt_block       do b_opt_block(curr,pblblock(bl),context,info);

    -- protected blok příkazu
    when bt_protected   do b_opt_protected(curr,pblblock(bl),context,info);

    -- sekvenční blok příkazu
    when bt_sequential  do b_opt_sequential(curr,pblblock(bl),context,info);

    -- blok příkazů
    when bt_declare     do b_opt_declare(curr,pbldeclare(bl),context,info);

    -- návěští
    when bt_label       do b_opt_label(curr,pbllabel(bl),context,info);

    -- kód v assmebleru
    when bt_asm         do b_opt_asm(curr,pbllabel(bl),context,info);

    -- jiné symboly tu nemají co dělat
    when others do verify({VERIFY=}000101,true);
    end case;

  catch 
    when resume_error do
      -- kontrola
      verify({VERIFY=}000858,bl^.zprac>=bp_opt);

      -- nastavit příznak, že tento uzel byl chybný
      bl^.erroneous:=true;

      -- znovu vyvolat vyjímku
      if block_catch_resume_error(catch_mode,bl^.btype) then raise;end if;
  end b_opt_node;



----------------------------------------------------------------------------------------------------
procedure b_opt =
-- Optimalizace bloku příkazů.
----------------------------------------------------------------------------------------------------
var
  context          : blcontext;

begin
  -- sestavit počáteční kontext
  context.loop_end:=nil;

  -- provést optimalizaci
  b_opt_node(curr,bl,context,info);
  end b_opt;



end cb_opt;
