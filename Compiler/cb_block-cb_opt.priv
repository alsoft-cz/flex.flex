----------------------------------------------------------------------------------------------------
module private cb_opt =
-- P©eklada‡ Flexu.
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.10.2001 : Vytvo©il
----------------------------------------------------------------------------------------------------

with
  cx_expr.cx_imm,
  cx_expr.cx_util;

------ %%TECH --------------------------------------------------------------------------------------
-- V˜sledkem optimalizace konkr‚tn¡ho uzlu m–‘e b˜t:
--     - ten sam˜ uzel,
--     - jin˜ uzel,
--     - ‘ dn˜ uzel (uzel se zcela vynech ),
--     - s‚rie nˆkolika uzl–.
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure b_opt_sequence (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    list           : in out bllist;              -- prvn¡ uzel sekvence
    all            : out t_logical;              -- T-v¨echny p©¡kazy zkontrolov ny
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace posloupnosti p©¡kaz–.
----------------------------------------------------------------------------------------------------
var
  pbl              : pblnode;                    -- p©edchoz¡ p©¡kaz
  cbl              : pblnode;                    -- aktu ln¡ p©¡kaz
  nbl              : pblnode;                    -- n sleduj¡c¡ p©¡kaz

begin
  -- optimistick˜ p©edpoklad
  all:=true;

  -- optimaliazce v¨ech p©¡kaz–
  pbl:=nil;
  cbl:=list.first;
  while cbl<>nil loop
    -- poznamenat si n sleduj¡c¡ blok
    nbl:=cbl^.next;

    -- rozpojit
    cbl^.next:=nil;

    -- optimalizace p©¡kazu
    b_opt(curr,cbl,info);

    if cbl<>nil

      -- spojit zpˆt
      then
        -- spojit (1)
        if pbl<>nil
          then pbl^.next:=cbl;
          else list.first:=cbl;
          end if;

        -- optimalizac¡ mohlo vzniknout nˆkolik p©¡kaz–
        while cbl^.next<>nil loop cbl:=cbl^.next; end loop;

        -- spojit (2)
        cbl^.next:=nbl;
        if nbl=nil then list.last:=cbl; end if;

        -- povedla se optimalizace ?
        if cbl^.zprac<bp_opt then all:=false; end if;

        -- nov˜ p©edchoz¡ uzel
        pbl:=cbl;

      -- p©¡kaz se optimalizoval a optimalizoval a‘ £plnˆ zmizel
      else
        -- spojit
        if pbl<>nil
          then pbl^.next:=nbl;
          else list.first:=nbl;
          end if;
        if nbl=nil then list.last:=pbl; end if;

        -- optimalizace se tot lnˆ povedla
        end if;

    -- dal¨¡ p©¡kaz
    cbl:=nbl;
    end loop;
  end b_opt_sequence;



----------------------------------------------------------------------------------------------------
procedure b_opt_cmd (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcmd;              -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©i©azovac¡ho p©¡kazu.
----------------------------------------------------------------------------------------------------
var
  e                : tentityeval;

begin
  -- nen¡ co optimalizovat (%%X nebo ano ?)

  -- nezmizel n hodou cel˜ p©¡kaz vlivem optimalizace p©¡kazu ? (nap©. X+0)
  if bl^.expr=nil then
    bl:=nil;
    return;
    end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_cmd;



----------------------------------------------------------------------------------------------------
procedure b_opt_break (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblbreak;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu BREAK.
----------------------------------------------------------------------------------------------------
begin
  -- nen¡ co optimalizovat (%%X nebo ano ?)

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_break;



----------------------------------------------------------------------------------------------------
procedure b_opt_return (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblreturn;           -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu RETURN.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_return;



----------------------------------------------------------------------------------------------------
procedure b_opt_raise (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblraise;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu RAISE.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_raise;



----------------------------------------------------------------------------------------------------
procedure b_opt_send (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblsend;             -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kaz– SEND.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_send;



----------------------------------------------------------------------------------------------------
procedure b_opt_goto (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblgoto;             -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu GOTO.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_goto;



----------------------------------------------------------------------------------------------------
procedure b_opt_new (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblnew;              -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu NEW.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_new;



----------------------------------------------------------------------------------------------------
procedure b_opt_discard (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldiscard;          -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu DISCARD.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_discard;



----------------------------------------------------------------------------------------------------
procedure b_opt_adjust (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbladjust;           -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu ADJUST.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_adjust;



----------------------------------------------------------------------------------------------------
procedure b_opt_delay (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldelay;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu DELAY.
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_delay;



----------------------------------------------------------------------------------------------------
procedure b_opt_if (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblif;               -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu IF.
----------------------------------------------------------------------------------------------------
var
  sub              : pblif_cond;                 -- vˆtve IF
  all              : t_logical;                  -- vyhodnocen¡ bloku
  allx             : t_logical;                  -- vyhodnocen¡ bloku
{
  e                : tentityeval;
}
begin
  -- optimistick˜ p©edpoklad
  all:=true;

  -- form ln¡ kontrola v¨ech vˆtv¡
  sub:=pblif_cond(bl^.sub.first);
  while sub<>nil loop
    verify(540,sub^.btype<>bt_if_cond);

    -- nen¡ podm¡nka konstantn¡ ?
    if sub^.cond<>nil and x_is_constant(sub^.cond) then
      -- generovat hint
      if ch_constant_condition in curr.entity^.compv.hints then
        ce^.sethint(curr,{CCERR=}000000,ch_constant_condition);
        sub^.cond^.errpos;
        end if;

      {%%X za©¡dit se podle hodnoty podm¡nky}
      end if;

  {
    -- kontrola podm¡nky
    if sub^.cond<>nil then
      x_evaluate(curr,sub^.cond,ek_cond,nil,info.final,e);
      {%%X Nˆjak˜ divn˜: jeden p©¡kaz by nemˆl m¡t vliv na cel˜ blok }
      if e_part(info.eval,e) then return; end if;
      end if;
  }
    -- kontrola bloku
    b_opt_sequence(curr,sub^.sub,allx,info);
    all:=all and allx;

    -- dal¨¡ vˆtev
    sub:=pblif_cond(sub^.next);
    end loop;

  -- povedla se form ln¡ kontrola v¨ech vˆtv¡ ?
  if not all then return; end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_if;



----------------------------------------------------------------------------------------------------
procedure b_opt_loop (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblloop;             -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu LOOP.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- v˜sledek optimalizace bloku

begin
  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,info);

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- nen¡ podm¡nka konstantn¡ ?
  if (bl^.cond<>nil) and x_is_constant(bl^.cond) then
    -- generovat hint
    if ch_constant_condition in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000000,ch_constant_condition);
      bl^.cond^.errpos;
      end if;

    {%%X za©¡dit se podle hodnoty podm¡nky}
    end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_loop;



----------------------------------------------------------------------------------------------------
procedure b_opt_for (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblfor;              -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu FOR.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;

var
  all              : t_logical;                  -- v˜sledek optimalizace bloku

begin
  -- optimalizovat blok
  b_opt_sequence(sym_build_context(curr.entity,bl^.for_region),bl^.sub,all,info);

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_for;



----------------------------------------------------------------------------------------------------
procedure b_opt_while (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblwhile;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu WHILE.
----------------------------------------------------------------------------------------------------
var
  all              : t_logical;                  -- v˜sledek optimalizace bloku

begin
  -- optimalizovat blok
  b_opt_sequence(curr,bl^.sub,all,info);

  -- vyhodnotil se blok ?
  if not all then return; end if;

  -- nen¡ podm¡nka konstantn¡ ?
  if x_is_constant(bl^.cond) then
    -- generovat hint
    if ch_constant_condition in curr.entity^.compv.hints then
      ce^.sethint(curr,{CCERR=}000000,ch_constant_condition);
      bl^.cond^.errpos;
      end if;

    {%%X za©¡dit se podle hodnoty podm¡nky}
    end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_while;



----------------------------------------------------------------------------------------------------
procedure b_opt_case (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblcase;             -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu CASE.
----------------------------------------------------------------------------------------------------
with
  cb_choice;

var
  blwhen           : pblwhen_c;                  -- jedna vˆtev CASE
  pblwhen          : pblwhen_c;                  -- p©edchoz¡ vˆtec CASE
  exp              : pexpnode;                   -- jeden v˜bˆr; pro zjednodu¨en¡ z pisu
  ui1              : tuniint;                    -- v˜bˆry
  ui2              : tuniint;                    -- v˜bˆry
  hasothers        : t_logical;                  -- T-je uvedena varianta OTHERS
  all              : t_logical;                  -- vyhodnocen¡ bloku
  allx             : t_logical;                  -- vyhodnocen¡ bloku

begin
  ----- %%TECH Princip optimalizace a kontroly v˜bˆr– v CASE ---------------------------------------
  -- Pro ka‘d˜ WHEN se transformuje seznam v˜bˆr– do nov‚ho s tˆmito vlastnostmi:
  --   -- v˜bˆry jsou set©¡dˆny vzestupnˆ,
  --   -- sousedn¡ v˜bˆry jsou spojeny do jednoho rozsahu,
  --   -- pro duplicitn¡ v˜bˆry se generuje varov n¡.
  -- V˜bˆry se d le zpracov vaj¡ glob lnˆ. Pro ka‘d˜ v˜bˆr, kter˜ ji‘ byl
  -- uveden v nˆkter‚ z p©edchoz¡ch vˆtv¡ se generuje varov n¡.
  --   Pro zjednodu¨en¡ v˜po‡tu se spojuj¡ i ty intervaly, kter‚ spolu
  -- nesoused¡, ale mezera mezi nimi je pokryta p©edchoz¡mi v˜bˆry.
  --------------------------------------------------------------------------------------------------

  -- p©edpoklad: poda©¡ se optimalizovat v¨echny vˆtve
  all:=true;

  -- zpracovat v¨echny vˆtve
  hasothers:=false;
  blwhen:=pblwhen_c(bl^.sub.first);
  pblwhen:=nil;
  while blwhen<>nil loop

    case blwhen^.ctype

      -- seznam v˜bˆr–
      when bct_choice do
          verify(427,blwhen^.list=nil or else blwhen^.list^:length=0);

          -- pamˆŸ pro optimalizovan˜ seznam v˜bˆr– lze p©edalokovat p©edem,
          -- stejnˆ se vˆt¨inou nic nezoptimalizuje...
          choice_extend(blwhen^.clist,blwhen^.list^:length{lcount});

          -- zpracovat v¨echny v˜bˆry
          for i in blwhen^.list^:range loop

            -- v˜raz; pro zjednodu¨en¡ z pisu
            exp:=blwhen^.list^[i];

            -- p©¡mo jedna hodnota
            if exp^.ntype=nt_imm then
              load_uniint(pexpimm(exp)^.imm,ui1);
              choice_add_single(curr,blwhen^.clist,ui1,exp);

            -- konstantn¡ rozsah
            elsif exp^.ntype=nt_range then
              -- co je to za rozsah ?
              case pexprange(exp)^.rkind
                -- konstantn¡ rozsah
                when erk_static do
                    verify(425,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    load_uniint(pexpimm(exp^.sub^.next)^.imm,ui2);
                    choice_add_range(blwhen^.clist,ui1,ui2,exp);


                -- jeden bod
                when erk_single do
                    verify(426,(exp^.sub^.ntype<>nt_imm) or (exp^.sub^.next^.ntype<>nt_imm));
                    load_uniint(pexpimm(exp^.sub)^.imm,ui1);
                    choice_add_single(curr,blwhen^.clist,ui1,exp);


                -- pr zdn˜ rozsah
                when erk_null   do
                    ce^.setwarning(curr,{CCERR=}000309,cw_null_choice);
                    exp^.errpos;


                when others do verify(424,true);
                end case;

            -- jm‚no typu
            elsif exp^.nclass=nc_type then
              choice_add_range(blwhen^.clist,exp^.t.getlval,exp^.t.gethval,exp);

            else 
              verify(422,true);
              end if;
            end loop;

          -- vylou‡it intervaly duplicitn¡ vzhledem k p©edchoz¡m variant m
          {%%X...}

          -- nezmizely v¨echny v˜bˆry ?
          if blwhen^.clist.list^:length=0

            -- zmizely => variantu lze zru¨it £plnˆ
            then
              -- vy©adit ze seznamu
              if pblwhen=nil
                then bl^.sub.first:=blwhen^.next;
                else pblwhen^.next:=blwhen^.next;
                end if;
              if bl^.sub.last=blwhen then bl^.sub.last:=pblwhen; end if;

              -- PBLWHEN se nemˆn¡

            -- nezmizely => aspo¤ zredukovat po‡et interval–
            else
              {%%X...}

              -- nov‚ PBLWHEN
              pblwhen:=blwhen;
              end if;


      -- OTHERS
      when bct_others do
          -- jen poznamenat, ‘e existuje varianta OTHERS
          hasothers:=true;

          -- nov‚ PBLWHEN
          pblwhen:=blwhen;


      when others do verify(423,true);
      end case;

    -- optimalizovat p©¡kazy
    b_opt_sequence(curr,blwhen^.sub,allx,info);
    all and allx;

    -- dal¨¡ vˆtev
    blwhen:=pblwhen_c(blwhen^.next);
    end loop;

  -- jestli‘e nebylo uvedeno OTHERS, mus¡ b˜t pokryty v¨echny varianty
  if not hasothers then
    {%%X...}
    end if;

  -- povedla se form ln¡ kontrola v¨ech vˆtv¡ ?
  if not all then return end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_case;



----------------------------------------------------------------------------------------------------
procedure b_opt_accept (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblaccept;           -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu ACCEPT
----------------------------------------------------------------------------------------------------
begin

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_accept;



----------------------------------------------------------------------------------------------------
procedure b_opt_catch (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out bllist;              -- p©¡kaz
    all            : out t_logical;              -- T-v¨echny p©¡kazy zkontrolov ny
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace p©¡kazu CATCH
----------------------------------------------------------------------------------------------------
var
  blwhen           : pblwhen_m;
  allx             : t_logical;

begin
  -- optimalizovat v¨echny v˜bˆry
  blwhen:=pblwhen_m(bl.first);
  all:=true;
  while blwhen<>nil loop
    verify(312,blwhen^.ctype=bct_choice and then (blwhen^.list=nil or else blwhen^.list^:length=0));

    -- p©¡kazy
    b_opt_sequence(curr,blwhen^.sub,allx,info);
    allx:=allx and all;

    -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
    if all then blwhen^.zprac:=bp_opt; end if;

    -- dal¨¡ WHEN
    blwhen:=pblwhen_m(blwhen^.next);
    end loop;
  end b_opt_catch;



----------------------------------------------------------------------------------------------------
procedure b_opt_block (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
var
  all1             : t_logical;                  -- zpracov n¡ p©¡kazov‚ ‡ sti
  all2             : t_logical;                  -- zpracov n¡ ‡ sti CATCH
  all3             : t_logical;                  -- zpracov n¡ ‡ sti ROLLBACK
  all4             : t_logical;                  -- zpracov n¡ ‡ sti COMMIT
  all5             : t_logical;                  -- zpracov n¡ ‡ sti LEAVE

begin
  -- p©¡kazov  ‡ st
  b_opt_sequence(curr,bl^.sub,all1,info);

  -- ‡ st CATCH
  b_opt_catch{sequence}(curr,bl^.bcatch,all2,info);

  -- ‡ st ROLLBACK
  b_opt_sequence(curr,bl^.brollback,all3,info);

  -- ‡ st COMMIT
  b_opt_sequence(curr,bl^.bcommit,all4,info);

  -- ‡ st LEAVE
  b_opt_sequence(curr,bl^.bleave,all5,info);

  -- povedla se optimalizace v¨ech vˆtv¡  ?
  if not (all1 and all2 and all3 and all4 and all5) then return; end if;

  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_block;



----------------------------------------------------------------------------------------------------
procedure b_opt_protected (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace protected bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),info);
  end b_opt_protected;



----------------------------------------------------------------------------------------------------
procedure b_opt_sequential (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pblblock;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace sekven‡n¡ho bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
begin
  b_opt_block(curr,pblblock(bl),info);
  end b_opt_sequential;



----------------------------------------------------------------------------------------------------
procedure b_opt_declare (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbldeclare;          -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
with
  cc_base,
  cc_base.cc_sym;

begin
  b_opt_block(sym_build_context(curr.entity,bl^.declare_region),pblblock(bl),info);
  end b_opt_declare;



----------------------------------------------------------------------------------------------------
procedure b_opt_label (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbllabel;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace n vˆ¨t¡.
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_label;



----------------------------------------------------------------------------------------------------
procedure b_opt_asm (
    curr           : in tcontext;                -- p©ekl dan˜ prvek
    bl             : in out pbllabel;            -- p©¡kaz
    info           : in blinfo) =                -- informace o pr–bˆhu anal˜zy
-- Optimalizace k¢du v assembleru
----------------------------------------------------------------------------------------------------
begin
  -- optimalizace p©¡kazu £spˆ¨nˆ dokon‡ena
  bl^.zprac:=bp_opt;
  end b_opt_asm;



----------------------------------------------------------------------------------------------------
procedure b_opt =
-- Optimalizace bloku p©¡kaz–.
----------------------------------------------------------------------------------------------------
begin
  verify(100,bl=nil);

  -- jednou optimalizovan‚ p©¡kazy p©esko‡it
  if bl^.zprac<>pred bp_opt then return; end if;

  -- zkontrolovat v˜raz
  case bl^.btype
    -- p©i©azovac¡ p©¡kaz
    when bt_cmd         do b_opt_cmd(curr,pblcmd(bl),info);

    -- p©¡kaz BREAK
    when bt_break       do b_opt_break(curr,pblbreak(bl),info);

    -- p©¡kaz RETURN
    when bt_return      do b_opt_return(curr,pblreturn(bl),info);

    -- p©¡kaz RAISE
    when bt_raise       do b_opt_raise(curr,pblraise(bl),info);

    -- p©¡kaz SEND
    when bt_send        do b_opt_send(curr,pblsend(bl),info);

    -- p©¡kaz GOTO
    when bt_goto        do b_opt_goto(curr,pblgoto(bl),info);

    -- p©¡kaz NEW
    when bt_new         do b_opt_new(curr,pblnew(bl),info);

    -- p©¡kaz DISCARD
    when bt_discard     do b_opt_discard(curr,pbldiscard(bl),info);

    -- p©¡kaz ADJUST
    when bt_adjust      do b_opt_adjust(curr,pbladjust(bl),info);

    -- p©¡kaz DELAY
    when bt_delay       do b_opt_delay(curr,pbldelay(bl),info);

    -- p©¡kaz IF
    when bt_if          do b_opt_if(curr,pblif(bl),info);

    -- p©¡kaz LOOP
    when bt_loop        do b_opt_loop(curr,pblloop(bl),info);

    -- p©¡kaz FOR
    when bt_for         do b_opt_for(curr,pblfor(bl),info);

    -- p©¡kaz WHILE
    when bt_while       do b_opt_while(curr,pblwhile(bl),info);

    -- p©¡kaz CASE
    when bt_case        do b_opt_case(curr,pblcase(bl),info);

    -- p©¡kaz ACCEPT
    when bt_accept      do b_opt_accept(curr,pblaccept(bl),info);

    -- blok p©¡kaz–
    when bt_block       do b_opt_block(curr,pblblock(bl),info);

    -- protected blok p©¡kazu
    when bt_protected   do b_opt_protected(curr,pblblock(bl),info);

    -- sekven‡n¡ blok p©¡kazu
    when bt_sequential  do b_opt_sequential(curr,pblblock(bl),info);

    -- blok p©¡kaz–
    when bt_declare     do b_opt_declare(curr,pbldeclare(bl),info);

    -- n vˆ¨t¡
    when bt_label       do b_opt_label(curr,pbllabel(bl),info);

    -- k¢d v assmebleru
    when bt_asm         do b_opt_asm(curr,pbllabel(bl),info);

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others do verify(101,true);
    end case;
  end b_opt;



end cb_opt;