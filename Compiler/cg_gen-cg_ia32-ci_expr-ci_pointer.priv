----------------------------------------------------------------------------------------------------
module private ci_pointer =
-- Překladač Flexu.
-- Operace s pointery.
----------------------------------------------------------------------------------------------------
-- Ondra : 18.04.2003 : Vytvořil
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_pointer =
-- Porovnávání pointerů.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
--op1              : c_operand;                  -- operand 1
--op2              : c_operand;                  -- operand 2
--optmp            : c_operand;                  -- operand s porovnávanou hodnotou
  tgend            : itarget;                    -- návěští pro skok na konec porovnávání
  cc               : icond;                      -- kód podmínky
  rest             : typeview;                   -- společný typ operandů
  newcontext       : iexprcontext;               -- kontext generování podvýrazu
  size             : t_unsigned;
  i                : t_unsigned;

begin
  verify({VERIFY=}000325,(expr^.arity<>eoa_2) or expr^.assign);

  -- podvýrazy
  expr^.get(el,er);

  -- vypočítat společný typ operandů
  x_resolve(el^.t,er^.t,false,rest);

  -- podmínka
  cc:=op2cc[expr^.oper,false];

  ----- porovnání na NIL -----
  if x_is_nil(er) then
    declare var
      op1          : c_operand;                  -- operand 1
    begin
      -- vygenerovat a načíst levý podvýraz
      i_newcontext(context,newcontext,lm_pointer_reg,rest.getutype);
      i_load(inst,info,newcontext,context,el,op1);

      -- z pointeru nás zajímá jen adresa
      -- %%X Opravdu ? viz flex@alsoft.cz
      op1.adjust_size(4);

      -- porovnat
      addii(inst,info,ii_cmp,op1,op_0,op0);

    leave
      -- uvolnit operand
      op1.free(info,context);
      end declare;

  ---- porovnání dvou pointerů -----
  else
    -- různé typy pointerů se porovnávají obecně jinak
    case rest.getpclass
      -- přístup k datům
      when pc_data do
          -- zvolit způsob porovnání podle velikosti pointeru
          size:=unidata_size_to_unsigned(rest.getsize);
          case size
            -- pouze adresa
            when 4 do
                declare var
                  op1 : c_operand;               -- operand 1
                  op2 : c_operand;               -- operand 2
                begin
                  -- vygenerovat a načíst operandy
                  i_load_binary_pointer(inst,info,context,expr,rest.getutype,el,er,op1,op2);

                  -- porovnat
                  addii(inst,info,ii_cmp,op1,op2,op0);

                leave
                  -- uvolnit operandy
                  op1.free(info,context);
                  op2.free(info,context);
                  end declare;

            -- pointer s nějakými atributy
            when 8,12,16 do
                declare var
                  op1   : c_operand;             -- operand 1
                  op2   : c_operand;             -- operand 2
                  optmp : c_operand;             -- pracovní operand pro část porovnávané hodnoty
                begin
                  -- vygenerovat a načíst adresu levého operandu
                  i_newcontext(context,newcontext,lm_gen,rest.getutype);
                  i_load(inst,info,newcontext,context,el,op1);

                  -- načíst adresu pravého operandu
                  i_newcontext(context,newcontext,lm_gen,rest.getutype);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registr
                  verify({VERIFY=}000494,op1.optype<>io_mem or op2.optype<>io_mem);
                  op1.refresh(inst,info,context);
                  op2.refresh(inst,info,context);

                  -- pokud už nemáme volné registry, tak zkusit redukovat počet registrů v operandech
                  if not i_reg_are_available(context,4) then
                    i_gen_reduceop(inst,info,context,op1);
                    i_gen_reduceop(inst,info,context,op2);
                    end if;

                  -- budeme potřebovat jeden registr
                  optmp.create_new_register(inst,info,context,edt_unsigned,4);

                { %%TODO(CODEGEN) Tento úsek kódu zase obnovit, až bude správně fungovat
                   veškerá manipulace s tagy včetně modifikátoru CLASS v deklaraci parametru.
                  -- alokovat návěští pro skok na konec
                  newtarget(info,tgend);
                }
                  -- operandy budeme zpracovávat po 4bytových krocích
                  op1.adjust_size(4);
                  op2.adjust_size(4);

                { %%TODO(CODEGEN) Tento úsek kódu zase obnovit, až bude správně fungovat
                   veškerá manipulace s tagy včetně modifikátoru CLASS v deklaraci parametru.

                  -- porovnat
                  for i in 1..size div 4-1 loop
                    -- načíst a porovnat hodnotu
                    addii(inst,info,ii_mov,optmp,op1,op0);
                    addii(inst,info,ii_cmp,optmp,op2,op0);

                    -- podmíněný skok na konec
                    addjump(inst,info,ic_ne{icondneg[cc]},tgend);

                    -- posunout adresy obou operandů
                    shiftop(op1,4);
                    shiftop(op2,4);
                    end loop;
                }
                  -- porovnat poslední dvojici
                  addii(inst,info,ii_mov,optmp,op1,op0);
                  addii(inst,info,ii_cmp,optmp,op2,op0);

                { %%TODO(CODEGEN) Tento úsek kódu zase obnovit, až bude správně fungovat
                   veškerá manipulace s tagy včetně modifikátoru CLASS v deklaraci parametru.
                  -- adresa skoku na toto místo
                  settarget(info,tgend,getaddr(inst));
                }
                leave
                  -- uvolnit operandy
                  optmp.free(info,context);
                  op1.free(info,context);
                  op2.free(info,context);
                  end declare;
 
            when others do verify({VERIFY=}000492,true);
            end case;

      -- přístup k podprogramu
      when pc_subprogram do
          unimplemented({UNIMP=}000167);

      -- přístup k tasku
      when pc_task do
          unimplemented({UNIMP=}000168);

      -- přístup ke zprávě
      when pc_message do
          unimplemented({UNIMP=}000169);

      when others do verify({VERIFY=}000493,true);
      end case;
    end if;

  -- výsledek
  vysl.create_condition(cc);
  end i_gen_op_compare_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_pointer =
-- Přiřazení pointerů.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- levý podvýraz
  er               : pexpnode;                   -- pravý podvýraz
  newcontext       : iexprcontext;               -- kontext generování podvýrazu
  size             : t_unsigned32;               -- velikost pointeru

begin
  verify({VERIFY=}000502,expr^.arity<>eoa_2);

  -- podvýrazy
  expr^.get(el,er);

  -- velikost pointeru
  size:=unidata_size_to_unsigned(el^.t.getsize);

  --- přiřazení NIL ---
  if x_is_nil(er) then
    declare var
      op1          : c_operand;                  -- operand 1
    begin
      -- vygenerovat levý podvýraz
      i_newcontext(context,newcontext,lm_gen,el^.t.getctype);
      i_load(inst,info,newcontext,context,el,op1);

      -- vynulovat
      i_gen_fillz_static(inst,info,context,op1,size);

    leave
      -- uvolnit operand
      op1.free(info,context);
      end declare;

  --- přiřazení jiného pointeru ---
  else
    declare var
      op1 : c_operand;               -- operand 1
      op2 : c_operand;               -- operand 2
    begin
      -- vygenerovat a načíst oba operandy
      i_load_binary_pointer(inst,info,context,expr,el^.t.getctype,el,er,op1,op2);

      -- přiřadit
      case size
        -- půjde to možná jednoduše
        when 4 do
            if op2.optype in t_operand_type_set:[io_imm,io_reg]

              -- hodnota je v registru nebo je to konstanta
              then addii(inst,info,ii_mov,op1,op2,op0)

              -- musíme přes pomocný registr
              else
                declare var
                  optemp : c_operand;            -- pracovní operand pro část přiřazované hodnoty
                begin
                  -- alokovat registr
                  optemp.create_new_register(inst,info,context,edt_unsigned,4);

                  -- přesunout
                  addii(inst,info,ii_mov,optemp,op2,op0);
                  addii(inst,info,ii_mov,op1,optemp,op0);

                leave
                  -- uvolnit operand
                  optemp.free(info,context);
                  end declare;
                end if;

        -- rozhodně musíme přes registry
        when 8,12,16 do
            declare var
              optemp : c_operand;            -- pracovní operand pro část přiřazované hodnoty
            begin
              -- alokovat registr
              optemp.create_new_register(inst,info,context,edt_unsigned,4);

              -- operandy budeme zpracovávat po 4bytových kouscích
              op1.adjust_size(4);
              op2.adjust_size(4);

              -- přesunout
              for i in 1..size div 4 loop
                -- přesunout jednu čtveřici
                addii(inst,info,ii_mov,optemp,op2,op0);
                addii(inst,info,ii_mov,op1,optemp,op0);

                -- posunout adresy obou operandů
                op1.shift_displacement(4);
                op2.shift_displacement(4);
                end loop;

            leave
              -- uvolnit operand
              optemp.free(info,context);
              end declare;

        when others do verify({VERIFY=}000503,true);
        end case;
    leave
      -- uvolnit operandy
      op1.free(info,context);
      op2.free(info,context);
      end declare;
    end if;

  -- výsledek: nic
  --nullop(vysl,io_none);  
  end i_gen_op_assign_pointer;



end ci_pointer;
