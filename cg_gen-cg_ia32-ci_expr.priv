----------------------------------------------------------------------------------------------------
module private ci_expr =
-- P©eklada‡ Flexu.
-- Generov n¡ v˜razu.
----------------------------------------------------------------------------------------------------
-- Ondra : 22.01.2003 : Vytvo©il.
----------------------------------------------------------------------------------------------------
{

-- Dodˆlat p©ejmenov n¡ AH-AL, BH-BL, ..., aby se nemuselo v LOADREG
   dˆlat MOV AL,AH

-- Kam pat©¡ konverze ? M  je tam p©id vat typov  kontrola (resp. nˆjak 
   jin  f ze p©ekladu v˜razu), nebo si je m  dom˜¨let a‘ gener tor k¢du ?

   ad 1) To je asi v˜hodnˆj¨¡, konverze aritmetick˜ch v˜raz– jsou trivi ln¡
         a u manipulac¡ s ©etˆzci/poli/recordy pot©ebuju vˆdˆt na ‡em jsem,
         abych dok zal zvolit speci ln¡ variantu p©ekladu.

   ad 2) V druh‚m p©¡padˆ by to mˆlo asi b˜t sou‡ st¡ LOADREG.


-- Optimalizace:
     * zarovn n¡
     * zmˆna po©ad¡ instrukc¡
     * (‡ ste‡n‚) rozv¡jen¡ cykl–
     * ©¡d¡c¡ promˆnn‚ cykl– do registr–
     * ‡asto pou‘¡van‚ podv˜razy do registr–
     * registry se zn mou konstantn¡ hodnotou (zpravidla 0 nebo 1)
     * v EDX zbyde p©i n soben¡ dostate‡nˆ mal˜ch ‡¡sel nula

     * n soben¡ 3 a 5 a 9 pomoc¡ LEA
     * n soben¡ kombinac¡ ADD/SHL/LEA: nap©¡klad 12*EAX: SHL EAX,2 LEA EAX,[EAX+2*EAX]
     * rozpozn n¡ indexu tvaru X*scale, kde scale=2,4,8
     * "if x>0 then x:=-1 else x:=0" --> "cmp eax,1; sbb eax,eax"
     * registr EBP v–bec nepot©ebuju k adresaci lok ln¡ch promˆnn˜ch - sta‡¡
       mi na to ESP, v‘dyŸ v ka‘d‚m okam‘iku v¡m, co je na stacku
     * m lo pravdˆpodobn˜ k¢d lze s v˜hodou um¡stit do £plnˆ jin‚ oblasti
       code segmentu:

           read(...,chyba);
           if chyba then
             write('chyba');
             return;
             end if;
           ...
           end proc;

       p©elo‘it jako:

           read(...,chyba);
           if chyba then goto x end if  -- zde se eliminuje jeden skok
           ...
         r:
           end proc;

         x:write('chyba');
           goto r;
     * m¡sto "mov exc,[x]; push eax" dˆlat jen "push [x]"
     * ve v˜razu (s1 & s2)[i] fyzicky nespojovat ©etˆzce ale inteligentnˆ
       p©epo‡¡tat index
     * p©¡kaz typu:
          loop
            if invariant_vzhledek k cyklu
              then ...
              else ...
              end if
            end loop
       p©elo‘it jako dva cykly s vyhodnocen¡m IFu vnˆ.
     * pro rozs hl‚ konstantn¡ mno‘iny generovat membership-test funkce
       (podobnˆ by se daly ©e¨it i dal¨¡ operace na velk˜mi konstantn¡mi
       agreg ty)

-- Specifick‚ optimalizace pro procesory AMD:
     * m¡sto SHL EAX,1 generovat ADD EAX,EAX - t©eba procesor AMD K6 m 
       dvˆ s‡¡ta‡ky a jen jednu shiftova‡ku - nicm‚nˆ se t¡m nastav¡
       jin‚ flagy (AF)
     * na procesoru AMD K6 m¡sto XOR EAX,EAX dˆlat MOV EAX,0
     * MUL a IMUL nahrazovat za SHL ADD jen do celkov‚ latence 3, pak
       je na AMD rychlej¨¡ dˆlat MUL
     * m¡sto CDQ dˆlat MOV EDX,EAX SAR EDX,31 - je to rychlej¨¡ na dek¢dov n¡
       (©ekl bych, ‘e pro CBW se to nevyplat¡, proto‘e MOV AH,AL bude zmaten˜
       z pou‘it¡ dvou ‡tvrtek t‚ho‘ registru - ale je to jen domˆnka)
     * m¡sto dˆlen¡ n sobit p©evr cenou hodnotou - viz 21924.PDF str. 75 (65)

-- Odstranit %%OLD

-- Obsluha agreg t– je dost natvrdo (=neoptim lnˆ), proto‘e je to pomˆrnˆ
   komplikovan  z le‘itost a babrat se s t¡m budu a‘ ve 4.0.1.

-- Dodˆlat:
    +I027 - nˆkde to generuje chybn‚ instrukce
    -I099 - inkluze mno‘iny (< <= > >=)
    +I344 - v procedu©e i_gen_load_string_and_last se zd , ‘e v˜raz nem 
            dynamick‚ atributy :size ani :last
    -I349 - uvolnˆn¡ nepou‘it‚ho univerz ln¡ho registru
     I388 - pokus o zji¨tˆn¡ tagu non-tagged typu
    -U115 - konkatenace unconstrained string– jej¡m‘ v˜sledkem je opˆt
            unconstrained string
     U122 - vol n¡ virtu ln¡ metody
    +U132 - mno‘inov‚ + - a * na operandech o nep©¡zniv‚ velikosti
    +U154 - agreg t mno‘iny
    +U170 - porovn n¡ bin rn¡ho bloku na NIL
    -U173 - nˆjak˜ v˜po‡et :last pro "pchararray:=pchar:unchecked;"

     I027 - nˆkde to generuje chybn‚ instrukce
     I093
     I107
     I148 - vol n¡ metody p©edka
     U118
     U140
}
----------------------------------------------------------------------------------------------------



with
  standard,
  cc_def.cc_codes,
  cc_def.cc_var,
  cc_base,
  cc_base.cc_debug,
  cc_base.cc_type,
  cc_base.cc_util,
  cc_attr,
  cx_expr,
  cx_expr.cx_util,
  cx_expr.cx_imm,
  ci_code,
  ci_code.ci_oper,
  ci_code.ci_instr,
  ci_code.ci_stack,
  ci_code.ci_relo,
  ci_code.ci_rtl,
  ci_context,
  ci_reg,
  ci_fragment,
  ci_struct,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_ia32.ci_instr,
  cp_cpu.cp_ia32.ci_abi,
  cp_cpu.cp_32.cp_util;

----- %%TECH Re‘imy generov n¡ v˜razu ------------------------------------
-- Gener tor v˜raz– dok ‘e pracovat v nˆkolika re‘imech, resp. p©ed vat
-- v˜sledek v˜po‡tu v˜razu v nˆkolika r–zn˜ch tvarech.
--   Procedury pro generov n¡ r–zn˜ch druh– uzl– (I_GEN_*) pracuj¡ v jak‚msi
-- z kladn¡m re‘imu, kter˜ standardnˆ generuje v˜sledek v jak‚msi p©irozenˆ
-- minim ln¡m tvaru - sou‡et dvou celo‡¡seln˜ch v˜raz– vr t¡ v registru,
-- agreg t pole v do‡asn‚ promˆnn‚ apod.
--   Procedura I_LOAD nav¡c dovoluje v˜sledek p©ev‚st do po‘adovan‚ho tvaru
-- nebo s n¡m prov‚st po‘adovanou operaci (nap©¡klad ulo‘it na stack).
--   Po‘adovan˜ tvar v˜sledku je specifikov n kontextem generov n¡ v˜razu,
-- zejm‚na promˆnnou CONTEXT.MODE:
--   - lm_gen        -- v˜sledek je v p©irozen‚m tvaru bez £prav
--   - lm_addr       -- adresa objektu ur‡en‚ho podv˜razem (p©edpokl d  se,
--                      ‘e podv˜raz ur‡uje objekt; je-li to hodnota, bude
--                      v˜sledkem pravdˆpodobnˆ chybn  interpretace hodnoty)
--                        Pokud je nastaven preferovan˜ registr (v m¢du
--                      IRM_ADDR), na‡te adresu do nˆj.
--   - lm_addr_attr  -- adresa objektu obsahuj¡c¡ho dynamick‚ atributy (pokud
--                      je podv˜raz parametr p©ed van˜ hodnotou (promˆnn 
--                      s implicitn¡ dereferenc¡), je v˜sledkem adresa
--                      pointeru na tento objekt; podrobnˆji viz d le)
--   - lm_conv       -- v˜sledek v p©irozen‚m tvaru je konvertov n na
--                      po‘adovan˜ typ
--   - lm_reg        -- v˜sledek je na‡ten do registru (mimo p©¡m˜ch hodnot)
--   - lm_reg_all    -- v˜sledek je na‡ten do registru i kdy‘ je to p©¡m 
--                      hodnota
--   - lm_imm8_cl    -- v˜sledek je konvertov n na osmibitovou p©¡mou hodnotu
--                      nebo ulo‘en do CL (s o©¡znut¡m)
--   - lm_reg_eax    -- v˜sledek je ulo‘en do EAX
--   - lm_imm_to_rel -- je-li v˜sledkem p©¡m  hodnota, je interpretov na jako
--                      relativn¡ adresa
--   - lm_push_value -- hodnota v˜razu je ulo‘ena na stack
--   - lm_push_addr  -- adresa hodnoty v˜razu je ulo‘ena na stack
--   - lm_push_and_load_addr -- adresa hodnoty v˜razu je ulo‘ena na stack
--                      a sou‡asnˆ vr cena jako v˜sledek v˜po‡tu v˜razu
--   - lm_temp_value -- hodnotu v˜razu ulo‘¡ do temporary promˆnn‚, kromˆ
--                      p©¡m‚ hodnoty, kterou nech  v p–vodn¡m stavu
--   - lm_temp_addr  -- adresu objektu ulo‘¡ do temporary promˆnn‚
--   - lm_pointer,   -- hodnotu v˜razu typu pointer normalizuje podle
--                      dodan‚ho typu pointer (=p©id /odstran¡/konvertuje
--                      dynamick‚ atributy) a vr t¡ buƒ p–vodn¡ operand, nebo
--                      ulo‘¡ do temporary promˆnn‚ a vr t¡ jej¡ adresu
--   - lm_pointer_reg-- jako p©edchoz¡, ale lze-li to, tak vr t¡ pointer
--                      v registru
--
-- P©i generov n¡ mus¡ b˜t zvl ¨tn¡ pozornost vˆnov na dynamick˜m atribut–m.
-- Po‘adovan‚ dynamick‚ atributy jsou ulo‘eny v promˆnn‚ CONTEXT.RTA a jsou
-- p©¡pustn‚ pouze v re‘imech LM_ADDR_ATTR a LM_PUSH_ADDR.
--   Obsluha dynamick˜ch atribut– vy‘aduje p©¡mo £pravy v procedur ch
-- I_GEN_*, nelze ji zahrnout pouze do I_LOAD. Na¨tˆst¡ je vy‘adov na jen
-- u konkr‚tn¡ch typ– podv˜raz. Obecnˆ lze dynamick‚ atributy vy‘adovat
-- u tˆchto typ– v˜raz–:
--   - promˆnn  libovoln‚ho typu  -- pokud je to parametr s dynamick˜mi
--                                   atributy, p©evezmou se; ostatn¡ atributy
--                                   se ur‡¡ staticky
--   - dereferencovan˜ pointer    -- nˆkter‚ atributy jsou sou‡ st¡ pointeru,
--                                   ostatn¡ se ur‡¡ staticky
--   - v˜raz kompozitn¡ho typu, konkr‚tnˆ:
--     - z©etˆzen¡ pol¡/©etˆzc–   -- :last a :size se vypo‡¡taj¡ bˆhem
--                                   z©etˆzov n¡, :tag je ur‡en staticky
--     - mno‘inov‚ operace + - *  -- smysl m  pouze atribut :tag a ten je
--                                   ur‡en staticky
--     - agreg t                  -- :last a :size se vypo‡¡taj¡ p©i
--                                   konstrukci agreg tu, nebo jsou ur‡eny
--                                   staticky
--------------------------------------------------------------------------

----- %%TECH Generov n¡ zkr cen˜ch p©i©azen¡ -----------------------------
-- Podle definice jazyka se kr cen‚ p©i©azen¡ tvaru "A1 op ... op An" chov 
-- stejnˆ jako p©i©azen¡ tvaru "A1 := A1 op ... op An". Z toho vypl˜vaj¡
-- omezen¡ pro gener tor k¢du - kdy‘ je nap©¡klad op=+, nelze k A1 p©i‡¡tat
-- hodnoty ostatn¡ch operand–, ale mus¡ se hodnota A1 zkop¡rovat do registru.
--   Podobnˆ t©eba p©i spojov n¡ ©etˆzc– se mus¡ d t pozor na p©¡pad "s & s".
-- Lze sice postupnˆ p©ipojovat operandy vpravo k operandu vlevo, ale nesm¡
-- se p©i tom zmˆnit hodnota :length lev‚ho operandu.
--------------------------------------------------------------------------


var
  op2cc            : const array op_eq..op_ge,t_logical of icond := [
      -- oper tor --- UNSIGNED -- SIGNED --
      for op_eq  use [ic_e,       ic_e      ],
      for op_ne  use [ic_ne,      ic_ne     ],
      for op_lt  use [ic_b,       ic_l      ],
      for op_le  use [ic_be,      ic_le     ],
      for op_gt  use [ic_a,       ic_g      ],
      for op_ge  use [ic_ae,      ic_ge     ]];


----------------------------------------------------------------------------------------------------
procedure i_gen (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpnode;                -- strom
    vysl           : out ioper);                 -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------



type
  -- generovac¡ metoda
  topergen         = procedure (
      inst         : in out icodeinst;           -- instance
      info         : in out igeninfo;            -- informace o pr–bˆhu generov n¡
      context      : in out iexprcontext;        -- kontext generov n¡ v˜razu
      expr         : in pexpoper;                -- strom
      vysl         : out ioper);                 -- v˜sledek
  popergen         = ^topergen;

  -- ©¡d¡c¡ tabulka generov n¡ bin rn¡ch oper tor–
  topertab         = array expopertype,tdatatype of popergen;

var
  opertab          : topertab;



----------------------------------------------------------------------------------------------------
procedure oset11 (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertype;             -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
begin
  tab[op,stype]:=method;
  end oset11;



----------------------------------------------------------------------------------------------------
procedure oset1s (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertype;             -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
var
  j                : tdatatype;

begin
  for j in tdatatype loop
    if j in stype then
      tab[op,j]:=method;
      end if;
    end loop;
  end oset1s;



----------------------------------------------------------------------------------------------------
procedure osets1 (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertypeset;          -- oper tor
    stype          : in tdatatype;               -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
var
  i                : expopertype;

begin
  for i in expopertype loop
    if i in op then
      tab[i,stype]:=method;
      end if;
    end loop;
  end osets1;



----------------------------------------------------------------------------------------------------
procedure osetss (
    tab            : in out topertab;            -- ©¡d¡c¡ tabulka
    op             : in expopertypeset;          -- oper tor
    stype          : in tdatatypeset;            -- typ v˜razu
    method         : in popergen) =              -- metoda
-- TAB[OP,EL,ER]:=METHOD.
----------------------------------------------------------------------------------------------------
var
  i                : expopertype;
  j                : tdatatype;

begin
  for i in expopertype loop
    if i in op then
      for j in tdatatype loop
        if j in stype then
          tab[i,j]:=method;
          end if;
        end loop;
      end if;
    end loop;
  end osetss;



----------------------------------------------------------------------------------------------------
procedure i_load (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    subcontext     : in out iexprcontext;        -- kontext podv˜razu
    supercontext   : in out iexprcontext;        -- kontext v˜razu
    sub            : in pexpnode;                -- generovan˜ podv˜raz
    vysl           : out ioper) =                -- v˜sledek
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
var
  size             : t_unsigned;                 -- po‘adovan  velikost operandu
  op1              : ioper;                      -- operandy
  op2              : ioper;                      -- operandy
  sattrib          : rtattribset;                -- staticky ur‡en‚ atributy
  attrib           : rtattrib;
  ui               : tuniint;

begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('    -- i_load.begin: ' & sub^.dump);
    end if;
#end if;

  -- nastavit preferenci registr–
  case subcontext.mode
    -- do ECX/CX/CL
    when lm_imm8_cl     do i_setrpref(subcontext,in_ecx,irm_int);

    -- do EAX/AX/AL
    when lm_reg_eax     do i_setrpref(subcontext,in_eax,irm_int);

    -- v ostatn¡ch p©¡padech preference nen¡ (resp. podle p–vodn¡ho kontextu)
    end case;

  -- vygenerovat podv˜raz
  i_gen(inst,info,subcontext,sub,vysl);

  -- na‡¡st hodnotu
  case subcontext.mode
    -- pouze generovat
    when lm_gen         do -- nic nedˆlat

    -- na‡¡st adresu
    when lm_addr        do
        if (subcontext.rpref.reg<>in_none) and (subcontext.rpref.mode=irm_addr)
          then i_gen_lea(inst,info,subcontext,vysl,subcontext.rpref.reg);
          else i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;


    -- adresa objektu s dynamick˜mi atributy
    when lm_addr_attr   do -- nic nedˆlat

    -- konvertovat na typ v˜sledku
    when lm_conv        do
        -- li¨¡-li se od velikosti podv˜razu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak zmˆnit velikost konstanty
            then vysl.size:=subcontext.rsize
            -- ... jinak na‡¡st do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,(vysl.optype=io_cc) and (subcontext.outpref<>iop_cc){false},irm_int);
            end if;
          end if;


    -- konvertovat a na‡¡st do registru
    when lm_reg         do i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,false,irm_int);

    -- konvertovat a na‡¡st do registru (i p©¡mou hodnotu)
    when lm_reg_all     do i_gen_loadreg(inst,info,subcontext,sub^.t.getctype,vysl,true,irm_int);

    -- konvertovat a na‡¡st do CL nebo ponechat const.
    when lm_imm8_cl     do i_gen_loadimm8cl(inst,info,subcontext,vysl);

    -- konvertovat a na‡¡st do EAX
    when lm_reg_eax     do i_gen_loadeax(inst,info,subcontext,vysl);

    -- konvertovat p©¡mou hodnotu na relativn¡ adresu
    when lm_imm_to_rel  do if vysl.optype=io_imm then
        vysl.optype:=io_rel;
        vysl.rel:=vysl.imm;
        end if;

    -- na‡¡st hodnotu a ulo‘it na stack
    when lm_push_value  do
        -- na‡¡st a normalizovat pointer
        if subcontext.outtyp.stype=dt_pointer then
          i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);
          end if;

        -- ulo‘it na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

        -- uvolnit nepot©ebn˜ v˜sledek
        --i_free(info,subcontext,vysl);

        -- ‘ dn˜ v˜sledek se vracet nebude
        nullop(vysl,io_none);

    -- na‡¡st adresu a ulo‘it na stack, pop©¡padˆ vr tit kopii v registru
    when lm_push_addr, lm_push_and_load_addr do
        -- Ondra 15.5.2002 : Pro dereferenci se na‡ten¡ adresy mˆn¡ na na‡ten¡ hodnoty pointeru,
        -- proto‘e v takov‚ p©¡padˆ dereference nic nedereferencuje, ale maxim lnˆ transformuje
        -- dereferencovan˜ pointer na v˜sledn˜ pointer.
        if sub^.ntype<>nt_deref then
          -- na‡¡st adresu
          i_gen_lea(inst,info,subcontext,vysl,in_none);
          end if;

        -- ulo‘it na stack
        i_gen_pushstack(inst,info,subcontext,vysl);

        -- pokud nen¡ v˜sledek ‘ d n, tak se ho zbavit
        if subcontext.mode<>lm_push_and_load_addr then
          -- uvolnit nepot©ebn˜ v˜sledek
          --i_free(info,subcontext,vysl);

          -- ‘ dn˜ v˜sledek se vracet nebude
          nullop(vysl,io_none);
          end if;

    -- ulo‘it hodnotu do temporary promˆnn‚, nebo nechat imm
    when lm_temp_value  do
        -- li¨¡-li se od velikosti podv˜razu...
        if subcontext.rsize<>vysl.size then
          if vysl.optype=io_imm
            -- .. tak zmˆnit velikost konstanty
            then vysl.size:=subcontext.rsize
            -- ... jinak na‡¡st do registru
            else i_gen_loadreg(inst,info,subcontext,sub^.t.getctype{ptyp},vysl,false,irm_int);
            end if;
          end if;

        -- na‡¡st do temporary promˆnn‚
        i_gen_loadtemp(inst,info,subcontext,vysl);

    -- ulo‘it adresu do temporary promˆnn‚
    when lm_temp_addr   do ;

    -- na‡¡st a normalizovat pointer
    when lm_pointer     do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,false,vysl);

    -- na‡¡st a normalizovat pointer, preferovanˆ ulo‘it do registru
    when lm_pointer_reg do i_gen_loadpointer(inst,info,subcontext,sub^.t.getctype,true,vysl);

    when others do verify(415,true);
    end case;

  -- p©ev‚st operand z kontextu podv˜razu do kontextu v˜razu
  -- %%X tahle konstrukce se se mi teda v–bec nel¡b¡, ale zat¡m jsem to tak
  -- nechal, pozdˆji odstranit. Dˆlalo to probl‚m p©i I_LOAD_EXPR.
  if ^subcontext<>^supercontext then
    i_retrieve(inst,info,subcontext,supercontext,vysl);
    end if;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('    -- i_load.end');
    end if;
#end if;
  end i_load;



----------------------------------------------------------------------------------------------------
procedure i_load_binary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    outpref        : in ioutputpref;             -- pref. zp–sob p©ed n¡ prav‚ho op.
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- po‘adovan˜ typ podv˜raz–
    el             : in pexpnode;                -- podv˜razy
    er             : in pexpnode;                -- podv˜razy
    op1            : out ioper;                  -- v˜sledek
    op2            : out ioper) =                -- v˜sledek
-- Vygeneruje a na‡te hodnotu dvojice podv˜raz–.
-- (sv zan˜ch bin rn¡m oper torem)
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(134,expr^.arity<>eoa_2);

  if expr^.assign
    -- p©i©azen¡    : opa‡n‚ po©ad¡ operand–
    -- %%X Chybnˆ, mus¡ se vyhodnocovat zleva --> doprava; nebo ne ?
    -- Asi ne: v AARM je to zd–vodnˆn˜: X^:=F(...) a pokud F uvoln¡
    -- X, tak to mus¡ zp–sobit chybu (NIL^)
    then
      -- vygenerovat a na‡¡st prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_reg,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg,typ}{expr^.t.getctype},er,op2);

      -- vygenerovat lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,typ}{expr^.t.getctype},el,op1);

    -- norm ln¡ po©ad¡ operand–
    -- %%X Rozli¨it r–zn‚ p©¡pady
    -- I kdy‘, v˜razy typu IMM+VAR by na VAR+IMM mˆl p©ehazovat optimaliz tor
    else
      -- vygenerovat a na‡¡st lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_reg_all,typ{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_reg_all,typ}{expr^.t.getctype},el,op1);

      -- vygenerovat prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_conv,typ{expr^.t.getctype});
      i_setoutpref(context,outpref);
      i_load(inst,info,newcontext,context{lm_conv,typ}{expr^.t.getctype},er,op2);
      end if;

  -- obnovit registry
  i_refresh(inst,info,context,op1);
  i_refresh(inst,info,context,op2);
  end i_load_binary;



----------------------------------------------------------------------------------------------------
procedure i_load_binary_pointer (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpoper;                -- strom
    typ            : in pentity_type;            -- po‘adovan˜ typ podv˜raz–
    el             : in pexpnode;                -- podv˜razy
    er             : in pexpnode;                -- podv˜razy
    op1            : out ioper;                  -- v˜sledek
    op2            : out ioper) =                -- v˜sledek
-- Vygeneruje a na‡te hodnotu dvojice podv˜raz– (sv zan˜ch bin rn¡m
-- oper torem) typu pointer. Pointery normalizuje podle dodan‚ho typu
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(433,expr^.arity<>eoa_2);
  verify(484,typ^.stype<>dt_pointer);

  if expr^.assign

    -- p©i©azen¡    : opa‡n‚ po©ad¡ operand–
    then
      -- vygenerovat a na‡¡st prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,er,op2);

      -- vygenerovat lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,el,op1);

    -- norm ln¡ po©ad¡ operand–
    else
      -- vygenerovat a na‡¡st lev˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer_reg,typ);
      i_load(inst,info,newcontext,context,el,op1);

      -- vygenerovat prav˜ podv˜raz
      i_newcontext(context,newcontext,lm_pointer,typ);
      i_load(inst,info,newcontext,context,er,op2);
      end if;

  -- obnovit registry
  i_refresh(inst,info,context,op1);
  i_refresh(inst,info,context,op2);
  end i_load_binary_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_integer_mul : topergen =
-- Celo‡¡seln‚ n soben¡.
----------------------------------------------------------------------------------------------------

----- %%TECH N soben¡ ----------------------------------------------------
-- N soben¡ o‡ek v  na vstupu v˜raz tvaru A1 * ... * Ak [ *C ], kde Ai jsou
-- v˜razy a C konstanta. Je-li n soben¡ p©i©azovac¡, je A1 promˆnn  V.
-- Pro £‡ely optimalizace v˜po‡tu se v˜razy transformuj¡ takto:
--
-- Obecn‚ sch‚ma pro n soben¡:
--        A1 * ... * Ak      -->     A1 * ... * Ak
--    V * A2 * ... * Ak      -->     A2 * ... * Ak * V
--        A1 * ... * Ak * C  --> C * A1 * ... * Ak
--    V * A2 * ... * Ak * C  --> C * A1 * ... * Ak * V
-- Pro po‘adovanou velikost v˜sledku 8 bit– se pou‘ije jednooperandov  verze
-- instrukce MUL/IMUL, pro 16 a 32 bit– se pou‘ije dvouoperandov  verze.
--
-- Nˆkter‚ speci ln¡ p©¡pady n soben¡ lze d le optimalizovat:
--   -- n soben¡ konstantou 3, 5, 9 pou‘it¡m instrukce LEA (bez ohledu na
--      po‘adovanou velikost v˜sledku v‘dy 32-bitov‚; pro zkr cen‚ p©i©azen¡
--      je jednodu¨¨¡ pou‘¡t dvouoperandov˜ IMUL s konstantou v registru),
--   -- p©i n soben¡ s p©esnost¡ na 16/32 bit– lze pou‘¡t IMUL i pro
--      unsigned operandy,
--   -- dvouoperandov‚ n soben¡ konstantou
--        imul eax,A1,C
--      pro zkr cen‚ p©i©azen¡:
--        imul eax,A1,C
--        mov  A1,eax
--   -- n soben¡ s konstantou:
--        mov  eax,A1
--        imul eax,A2
--        ...
--        imul eax,Ak
--        imul eax,C
--      pro zkr cen‚ p©i©azen¡ nav¡c:
--        mov  eax,A2
--        imul eax,A3
--        ...
--        imul eax,Ak
--        imul eax,C
--        imul eax,A1
--        mov  A1,eax
--   -- n soben¡ na 16/32 bit– s operandy Ai a Aj ¨¡©ky 8 bit–:
--        mov  al,Ai
--        mul  Aj
--        [ and eax,$0000FFFF -- konverze 16 --> 32 bit– ]
--        imul [e]ax,A1
--        ...
--        imul [e]ax,Ak
--        imul [e]ax,C
--      (se stejnou optimalizac¡ zkr cen‚ho p©i©azen¡ jako v p©edchoz¡m
--      p©¡padˆ)
--------------------------------------------------------------------------

var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  x1               : pexpnode;                   -- dva 8-mi bitov‚ operandy
  x2               : pexpnode;                   -- dva 8-mi bitov‚ operandy
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  opcnt            : t_unsigned;                 -- po‡et operand– (kromˆ konstanty)
  rsize            : t_unsigned32;               -- po‘adovan  velikost v˜sledku
  c                : pexpnode;                   -- konstantn¡ operand
  ii               : iinstr;                     -- n sob¡c¡ instrukce

begin
  verify(136,expr^.arity<>eoa_n);

  -- po‘adovan  velikost v˜sledku
  rsize:=unidata_size_to_unsigned(expr^.t.getsize);

  -- spo‡¡tat operandy a naj¡t konstantu (bude na konci)
  c:=expr^.sub;
  opcnt:=0;
  x1:=nil; x2:=nil;
  loop
    -- zapo‡¡tat operand
    succ opcnt;

    -- nen¡ to n hodou 8-mi bitov˜ operand ?
    if c^.t.getsize=uds_1 and ((x1=nil) or (x2=nil)) and (c^.ntype<>nt_imm) then
      if x1=nil
        then x1:=c;
        else x2:=c;
        end if;
      end if;

    -- na¨el se posledn¡ operand
    if c^.next=nil then break; end if;

    -- dal¨¡ operand
    c:=c^.next;
    end loop;

  -- na¨la se nˆjak  konstanta ?
  if c^.ntype=nt_imm

    -- na¨la
    then
      pred opcnt;

    -- nena¨la
    else
      c:=nil
      end if;

  -- prvn¡ operand
  el:=expr^.sub;
  er:=el;

  -- je-li to p©i©azen¡, tak se na prvn¡ operand zat¡m vyka¨leme
  if expr^.assign then er:=er^.next; end if;

  ----- n soben¡ konstantou -----
  if (opcnt=1) {and (rsize in [2,3])} {and (k in [3,5,9])} and not expr^.assign then
    -- vygenerovat a na‡¡st lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_reg,expr^.t.getctype);
    i_load(inst,info,newcontext,context{lm_reg,expr^.t.getctype},el,op1);

    -- obnovit registry
    i_refresh(inst,info,context,op1);

    -- vyn sobit
    i_gen_mul_reg(inst,info,context,op1,uniint_to_imm32(pexpimm(c)^.imm.ui));

    -- v˜sledek
    vysl:=op1;

  ----- 8-mi bitov˜ v˜sledek, nen¡ co ©e¨it -----
  elsif rsize=1 then
    -- n sob¡c¡ instrukce
    if expr^.t.stype=dt_signed
      then ii:=ii_imul;
      else ii:=ii_mul;
      end if;

    -- m me konstantu ?
    if c<>nil
      -- ano, zpracujeme ji p©ednostnˆ
      then
        i_newcontext(context,newcontext,lm_reg_eax,expr^.t.getctype);
        i_load(inst,info,newcontext,context{lm_reg_eax,expr^.t.getutype},c,op1)

      -- ne, vezmeme prvn¡ operand
      else
        i_newcontext(context,newcontext,lm_reg_eax,expr^.t.getctype);
        i_load(inst,info,newcontext,context{lm_reg_eax,expr^.t.getutype},er,op1);
        er:=er^.next;
        end if;

    -- zpracovat v¨echny operandy (a‘ na konstantu)
    while er<>c loop
      -- na‡¡st v˜raz
      i_newcontext(context,newcontext,lm_conv,expr^.t.getctype);
      i_load(inst,info,newcontext,context{lm_convgen,expr^.t.getutype},er,op2);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op2);

      -- vyn sobit
      addii(inst,info,ii,op2,op0,op0);

      -- uvolnit operand
      i_free(info,context,op2);

      -- dal¨¡ operand
      er:=er^.next;
      end loop;

    -- nen¡ to zkr cen‚ p©i©azen¡ ?
    if expr^.assign then
      -- vygenerovat
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,expr^.t.getutype},el,op2);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op2);

      -- vyn sobit
      addii(inst,info,ii,op2,op0,op0);

      -- p©i©adit
      addii(inst,info,ii_mov,op2,op1,op0);
      end if;

    -- v˜sledek
    vysl:=op1;
{
  ----- dvouoperandov‚ 16-ti nebo 32-ti bitov‚ n soben¡ konstantou -----
  elsif (opcnt=1) and (c<>nil) then
    -- na‡¡st lev˜ operand
    if expr^.assign
      then i_load(inst,info,lm_gen,expr^.t.typ,el,op2);
      else i_load(inst,info,lm_conv,expr^.t.typ,el,op2);
      end if;

    -- na‡¡st konstantu do registru
    i_load(inst,info,lm_reg_all,expr^.t.typ,c,op1);

    -- aktivovat lev˜ operand
    restoreop(inst,info,op1);

    -- vyn sobit
    addii(inst,info,ii_imul,op1,op2,op0);

    -- p©i©azen¡
    if expr^.assign then
      addii(inst,info,ii_mov,op2,op1,op0);
      end if;

    -- uvolnit prav˜ operand
    freeop(info,op2);

    -- v˜sledek
    vysl:=op1;
}
  ----- 16-ti nebo 32-ti bitov˜ v˜sledek -----
  else
    -- Tvrzen¡: RSIZE in [2,4] and X1<>nil => el<>X1 or not expr^.assign
    -- D–kaz: Sporem. NechŸ el=X1 and expr^.assign
    --        => expr^.t=el^.t => RSIZE=1 SPOR. C.B.D.

    -- n sob¡c¡ instrukce: cel‚ to sjedeme IMULem

    ---- zvolit prvn¡ operand ---
    if x2<>nil -- Z©ejmˆ plat¡: X2<>NIl => X1<>NIL

      -- m me dva 8-mi bitov‚ operandy, mal  finta
      then
        -- na‡¡st prvn¡ operand
        i_newcontext(context,newcontext,lm_reg_eax,x1^.t.getctype);
        i_load(inst,info,newcontext,context{lm_reg_eax,x1^.t.getutype},x1,op1);

        -- na‡¡st druh˜ operand
        i_newcontext(context,newcontext,lm_conv,x2^.t.getctype);
        i_load(inst,info,newcontext,context{lm_conv,x2^.t.getutype},x2,op2);

        -- obnovit registry
        i_refresh(inst,info,context,op1);
        i_refresh(inst,info,context,op2);

        -- vyn sobit
        if expr^.t.stype=dt_signed
          then addii(inst,info,ii_imul,op2,op0,op0);
          else addii(inst,info,ii_mul,op2,op0,op0);
          end if;

        -- v˜sledek
        op1.reg.reg:=resizereg(op1.reg.reg,rsize);
        op1.size:=rsize;

        -- z AX udˆlat EAX
        if rsize=4 then
          if expr^.t.stype=dt_signed
            then addii(inst,info,ii_cwde,op0,op0,op0);
            else addii(inst,info,ii_and,op1,op_0000FFFF,op0);
            end if;
          end if;

        -- konstanta se bude zpracov vat jako ka‘d˜ jin˜ operand
        c:=nil;

      -- na‡¡st prvn¡ operand
      else
        -- zbavit se alespo¤ toho jednoho
        x1:=nil;

        -- m me konstantu ?
        if c<>nil

          -- na‡¡st p©ednostnˆ
          then
            -- na‡¡st
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context{lm_reg_all,expr^.t.getutype},c,op1);

          -- na‡¡st prvn¡ operand
          else
            -- na‡¡st
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context{lm_reg_all,expr^.t.getutype},er,op1);

            -- dal¨¡ operand
            er:=er^.next;
            end if;
        end if;

    ---- zpracovat zbyl‚ operandy ----

    -- zpracovat
    while er<>c loop
      -- zpracov vat jen operandy, kter‚ jsem nevy©¡dil p©ednostnˆ
      if (er<>x1) and (er<>x2) then
        -- na‡¡st v˜raz
        i_newcontext(context,newcontext,lm_conv,expr^.t.getctype);
        i_load(inst,info,newcontext,context{lm_conv,expr^.t.getutype},er,op2);

        -- obnovit registry
        i_refresh(inst,info,context,op1);
        i_refresh(inst,info,context,op2);

        -- vyn sobit
        addii(inst,info,ii_imul,op1,op2,op0);

        -- uvolnit operand
        i_free(info,context,op2);
        end if;

      -- dal¨¡ operand
      er:=er^.next;
      end loop;

    ---- nen¡ to zkr cen‚ p©i©azen¡ ? ----
    if expr^.assign then
      -- vygenerovat
      i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
      i_load(inst,info,newcontext,context{lm_gen,expr^.t.getutype},el,op2);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op2);

      -- vyn sobit
      addii(inst,info,ii_imul,op1,op2,op0);

      -- p©i©adit
      addii(inst,info,ii_mov,op2,op1,op0);
      end if;

    -- v˜sledek
    vysl:=op1;
    end if;
  end i_gen_op_integer_mul;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_integer_div_mod : topergen =
-- Celo‡¡seln‚ dˆlen¡ a zbytek po dˆlen¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  op3              : ioper;                      -- operand 3
  rsize            : t_unsigned32;               -- velikost v˜sledku
  newcontext       : iexprcontext;               -- kontext podv˜raz–

    ------------------------------------------------------------------------------------------------
    procedure adjust_high =
    -- P©¡prava horn¡ poloviny operandu.
    ------------------------------------------------------------------------------------------------
    begin
      if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]}

        -- EDX
        then
          if expr^.t.stype=dt_signed
            -- znam‚nkovˆ roz¨¡©it EAX --> EDX:EAX
            then
              -- CDQ nebo MOV EDX,EAX SAR EDX,31 - rychlej¨¡ na dek¢dov n¡
              addii(inst,info,ii_mov,op_edx,op_eax_,op0);
              addii(inst,info,ii_sar,op_edx,op_31,op0);
            -- vynulovat EDX
            else
              addii(inst,info,ii_mov,op_edx,op_0,op0)
              end if;

        -- AH
        else
          if expr^.t.stype=dt_signed
            -- znam‚nkovˆ roz¨¡©it AL --> AX
            then addii(inst,info,ii_cbw,op0,op0,op0)
            -- vynulovat AH
            else addii(inst,info,ii_mov,op_ah,op_0,op0);
            end if;
          end if;
      end adjust_high;

begin
  -- prvn¡ dva operandy
  expr^.get(el,er);

  -- velikost v˜sledku
  rsize:=unidata_size_to_unsigned(expr^.t.getsize);

  -- prvn¡ operand na‡¡st do EAX
  i_newcontext(context,newcontext,lm_reg_eax,expr^.t.getctype);
  i_load(inst,info,newcontext,context{lm_reg_eax,expr^.t.getutype},el,op1);

  -- rezervovat EDX
  if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]} then newopuse(inst,info,context,op3,rsize,resizereg(ir_edx,rsize)); end if;

  -- p©ipravit horn¡ polovinu operandu
  adjust_high;

  -- zpracovat zb˜vaj¡c¡ operandy
  while er<>nil loop
    -- na‡¡st operand
    i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
    i_load(inst,info,newcontext,context{lm_reg_all,expr^.t.getutype},er,op2);

    -- obnovit registry
    i_refresh(inst,info,context,op1);
    i_refresh(inst,info,context,op2);
    if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]} then i_refresh(inst,info,context,op3); end if;

    -- vydˆlit
    if expr^.t.stype=dt_signed
      then addii(inst,info,ii_idiv,op2,op0,op0);
      else addii(inst,info,ii_div,op2,op0,op0);
      end if;

    -- uvolnit operand
    i_free(info,context,op2);

    -- dal¨¡ operand
    er:=er^.next;

    -- korekce dal¨¡ho operandu
    if er<>nil then
      -- p©ipravit obˆ poloviny operandu sou‡asnˆ (znam‚nkov‚ modulo)
      if (expr^.oper=op_imod) and (expr^.t.stype=dt_signed) then
        if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]}
          -- EAX := EDX, SAR EDX,31
          then
            addii(inst,info,ii_mov,op_eax_,op_edx,op0);
            addii(inst,info,ii_sar,op_edx,op_31,op0);
          -- SAR AX,8
          else
            addii(inst,info,ii_sar,op_ax_,op_8,op0)
            end if;

      -- p©ipravit obˆ poloviny zvl ¨Ÿ (neznam‚nkov‚ modulo)
      elsif expr^.oper=op_imod then
        -- p©ipravit doln¡ polovinu
        if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]}
          -- EAX := EDX, EDX:=0
          then
            addii(inst,info,ii_mov,op_eax_,op_edx,op0);
            addii(inst,info,ii_mov,op_edx,op_0,op0);
          -- AL := AH, AH:=0
          else
            addii(inst,info,ii_shr,op_eax_,op_8,op0);
            addii(inst,info,ii_mov,op_ah,op_0,op0);
            end if;

      -- p©ipravit jen horn¡ polovinu operandu (norm ln¡ dˆlen¡)
      else
        adjust_high;
        end if;
      end if;
    end loop;

  -- zkr cen‚ p©i©azen¡
  if expr^.assign then
    -- vygenerovat lev˜ operand
    i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
    i_load(inst,info,newcontext,context{lm_gen,el^.t.getutype},el,op2);

    -- obnovit registry
    i_refresh(inst,info,context,op1);
    i_refresh(inst,info,context,op2);
    if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]} then i_refresh(inst,info,context,op3); end if;

    -- p©i©adit
    if expr^.oper=op_imod
      -- modulo
      then
        if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]}
          -- zbytek je v EDX
          then addii(inst,info,ii_mov,op2,op3,op0)
          -- zbytek je v AH
          else
            addii(inst,info,ii_mov,op2,op_ah,op0)
            end if;

      -- dˆlen¡
      else
        addii(inst,info,ii_mov,op2,op1,op0)
        end if;

    -- uvolnit operand
    i_free(info,context,op2);
    end if;

  -- uvolnit nepot©ebn‚ operandy a p©edat v˜sledek
  if expr^.oper=op_imod

    -- modulo
    then
      if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]}

        -- modulo je v EDX
        then
          -- uvolnit EAX
          i_free(info,context,op1);

          -- v˜sledek
          vysl:=op3;

        -- modulo je v AH, p©edat do AL
        else
          -- shiftnout
          addii(inst,info,ii_shr,op_eax_,op_8,op0);

          -- v˜sledek
          vysl:=op1;
          end if;

    -- dˆlen¡
    else
      -- uvolnit EDX
      if rsize=2 or rsize=4{%%TODO(SET) rsize in [2,4]} then i_free(info,context,op3); end if;

      -- v˜sledek
      vysl:=op1;
      end if;
  end i_gen_op_integer_div_mod;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_integer : topergen =
-- Celo‡¡seln‚ operace (s‡¡t n¡, od‡¡t n¡, bitov‚ operace).
-- Tato procedura se pou‘¡v  i na implementaci principi lnˆ ekvivalentn¡ch
-- operac¡ nad jin˜mi datov˜mi typy p©¡zniv‚ velikosti. Nap©¡klad pro mno‘iny
-- velikosti 1, 2 nebo 4 byty ‡i logick‚ XOR.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  er_mode          : iexprloadmode;              -- re‘im generov n¡ v˜razu napravo
  er_typ           : pentity_type;               -- po‘adovan˜ typ v˜razu napravo

    ------------------------------------------------------------------------------------------------
    procedure genop (
        op1        : ioper;
        op2        : ioper) =
    -- Generov n¡ vlastn¡ operace.
    ------------------------------------------------------------------------------------------------
    begin
      -- instrukce
      case expr^.oper
        -- s‡¡t n¡
        when op_add     do addii(inst,info,ii_add,op1,op2,op0);

        -- od‡¡t n¡
        when op_sub     do addii(inst,info,ii_sub,op1,op2,op0);

        -- bitov‚ AND
        when op_bitand  do addii(inst,info,ii_and,op1,op2,op0);

        -- bitov‚ OR
        when op_bitor   do addii(inst,info,ii_or ,op1,op2,op0);

        -- bitov‚ XOR
        when op_bitxor  do addii(inst,info,ii_xor,op1,op2,op0);

        -- logick‚ XOR
        when op_xor     do addii(inst,info,ii_xor,op1,op2,op0);

        -- SHL
        when op_shl     do
            if expr^.t.stype=dt_signed
              then addii(inst,info,ii_sal,op1,op2,op0);
              else addii(inst,info,ii_shl,op1,op2,op0);
              end if;


        -- SHR
        when op_shr     do
            if expr^.t.stype=dt_signed
              then addii(inst,info,ii_sar,op1,op2,op0);
              else addii(inst,info,ii_shr,op1,op2,op0);
              end if;


        -- mno‘inov‚ + --> OR
        when op_union   do addii(inst,info,ii_or,op1,op2,op0);

        -- mno‘inov‚ - --> NOT AND
        when op_diff    do
            addii(inst,info,ii_not,op2,op0,op0);
            addii(inst,info,ii_and,op1,op2,op0);


        -- mno‘inov‚ * --> AND
        when op_isect   do addii(inst,info,ii_and,op1,op2,op0);

        when others do verify(48,true);
        end case;
      end genop;



    ------------------------------------------------------------------------------------------------
    procedure genops (
        op1       : in out ioper) =
    -- Generov n¡ vlastn¡ operace pro n operand–.
    ------------------------------------------------------------------------------------------------
    var
      newcontext   : iexprcontext;               -- kontext podv˜raz–
      op2          : ioper;                      -- druh˜ operand

    begin
      -- zpracovat prav‚ podv˜razy
      loop
        -- vygenerovat a na‡¡st prav˜ podv˜raz
        i_newcontext(context,newcontext,er_mode,er_typ{lm_conv,expr^.t.getctype});
        i_load(inst,info,newcontext,context{lm_conv,expr^.t.getctype},er,op2);

        -- obnovit registry
        i_refresh(inst,info,context,op1);
        i_refresh(inst,info,context,op2);

        -- vygenerovat operaci
        genop(op1,op2);

        -- uvolnit prav˜ operand
        i_free(info,context,op2);

        -- dal¨¡ operand
        er:=er^.next;
        if er=nil then break; end if;
        end loop;
      end genops;

var
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  optemp           : ioper;                      -- meziv˜sledek
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(138,expr^.arity<>eoa_n);

  -- podv˜razy
  expr^.get(el,er);

  -- p©ipravit typ a re‘im generov n¡ v˜razu napravo
  case expr^.oper
    -- SHL, SHR
    when op_shl, op_shr do
        er_mode:=lm_imm8_cl;
        er_typ:=nil;


    -- mno‘inov‚ -
    when op_diff do
        er_mode:=lm_reg_all;
        er_typ:=expr^.t.getctype;


    -- logick‚ XOR
    when op_xor do
        er_mode:=lm_reg_all;
        er_typ:=expr^.t.getctype;


    -- ostatn¡ oper tory
    when others do
        er_mode:=lm_conv;
        er_typ:=expr^.t.getctype;
    end case;

  -- zkr cen‚ p©i©azen¡ se dvˆma operandy jin‚ ne‘ logick‚ XOR
  if expr^.assign and (expr^.oper<>op_xor) and (er^.next=nil) then
    -- vygenerovat a na‡¡st prav˜ podv˜raz
    if er_mode=lm_conv then er_mode:=lm_reg; end if;
    i_newcontext(context,newcontext,er_mode,er_typ{lm_reg,typ}{expr^.t.getctype});
    i_load(inst,info,newcontext,context{lm_reg,typ}{expr^.t.getctype},er,op2);

    -- vygenerovat lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
    i_load(inst,info,newcontext,context{lm_gen,typ}{expr^.t.getctype},el,op1);

    -- obnovit registry
    i_refresh(inst,info,context,op1);
    i_refresh(inst,info,context,op2);

    -- vygenerovat operanci
    genop(op1,op2);

    -- uvolnit prav˜ operand
    i_free(info,context,op2);

    -- v˜sledek
    vysl:=op1;

  -- zkr cen‚ p©i©azen¡ s N operandy (nebo logick‚ XOR se dvˆma operandy)
  elsif expr^.assign then
    -- vygenerovat lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_gen,nil);
    i_load(inst,info,newcontext,context,el,op1);

    -- registr na meziv˜sledek
    newopreg(inst,info,context,optemp,op1.size,irm_int,op0);

    -- po‡ te‡n¡ hodnota
    addii(inst,info,ii_mov,optemp,op1,op0);

    -- prov‚st operaci
    genops(optemp);

    -- obnovit registry
    i_refresh(inst,info,context,op1);

    -- p©i©adit
    addii(inst,info,ii_mov,op1,optemp,op0);

    -- uvolnit meziv˜sledek
    i_free(info,context,optemp);

    -- v˜sledek
    vysl:=op1;

  -- norm ln¡ oper tor
  else
    -- vygenerovat lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
    i_load(inst,info,newcontext,context{lm_reg_all,expr^.t.getctype},el,op1);

    -- prov‚st operaci
    genops(op1);

    -- v˜sledek
    vysl:=op1;
    end if;
  end i_gen_op_integer;



----------------------------------------------------------------------------------------------------
procedure i_gen_logical_chain (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpoper;                -- strom
    ttarget_ext    : in itarget;                 -- c¡l skoku p©i True
    ftarget_ext    : in itarget;                 -- c¡l skoku p©i False
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ ©etˆzu konjunkc¡/disjunkc¡.
----------------------------------------------------------------------------------------------------
var
  sub              : pexpnode;                   -- podv˜raz
  op1              : ioper;                      -- operand
  opassign         : ioper;                      -- lev˜ strana p©i©azen¡
  fallthru         : itarget;                    -- c¡l skoku fall-thru
  innerjmp         : itarget;                    -- c¡l vnit©n¡ho skoku
  ttarget          : itarget;                    -- c¡l skoku p©i True
  ftarget          : itarget;                    -- c¡l skoku p©i False
  cc               : icond;                      -- k¢d podm¡nky skoku
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(135,expr^.arity<>eoa_n);

  ----- %%TECH Strategie generov n¡ ©etˆzu konjunkc¡/disjunkc¡ -----------
  --
  --   AND THEN             OR ELSE
  --   -----------------    -----------------
  --   CMP <v˜raz 1>,1      CMP <v˜raz 1>,1
  --   JNE ftarget          JE  ttarget
  --   CMP <v˜raz 2>,1      CMP <v˜raz 2>,1
  --   JNE ftarget          JE  ttarget
  --   ...
  --   CMP <v˜raz n>,1      CMP <v˜raz n>,1
  --   JNE ftarget          JE  ttarget
  --   JMP ttarget          JMP ftarget
  --
  --   AND                  OR
  --   -----------------    -----------------
  --   MOV reg,<v˜raz 1>    MOV reg,<v˜raz 1>
  --   AND reg,<v˜raz 2>    OR  reg,<v˜raz 2>
  --   ...                  ...
  --   AND reg,<v˜raz n>    OR  reg,<v˜raz n>
  --   JZ  ftarget          JZ  ftarget
  --   JMP ttarget          JMP ttarget
  --
  -- P©i vyhodnocov n¡ AND/OR se nav¡c zji¨Ÿuje slo‘itost podv˜razu a je-li
  -- p©¡li¨ vysok  (obsahuje nap©. vol n¡ procedury), pou‘ije se strategie
  -- pro sekven‡n¡ formu (AND THEN/OR ELSE). Zbytek v˜razu (jednoduch˜) se
  -- pak dojede standardn¡ formou. T‚‘ pokud je v˜raz hodnˆ dlouh˜ (des¡tky
  -- instrukc¡), vlo‘¡ se na vhodn  m¡sta testy na meziv˜sledek.
  -- -------------------------------------------------------------------------
  -- %%X ---------------------- ^^^^^ dodˆlat ^^^^^ --------------------------

  --- zvolit n vˆ¨t¡ pro skok p©i True resp. False ---
  -- oba skoky fall-thru => vytvo©it dva c¡le skoku
  if (ttarget_ext=tgfallthru) and (ftarget_ext=tgfallthru) then
    newtarget(info,ttarget);
    newtarget(info,ftarget);

  -- aspo¤ jeden skok fall-thru => alokovat n vˆ¨t¡ pro skok fall-thru
  elsif (ttarget_ext=tgfallthru) or (ftarget_ext=tgfallthru) then
    ttarget:=ttarget_ext;
    ftarget:=ftarget_ext;
    newtarget(info,fallthru);

  -- ‘ dn˜ fall-thru => jen p©evz¡t n vˆ¨t¡
  else
    ttarget:=ttarget_ext;
    ftarget:=ftarget_ext;
    end if;

  -- Pozn mka: Nyn¡ je jist‚, ‘e nikdy nenastane p©¡pad, ‘e by skoky p©i True i p©i False
  -- byly oba typu fall-thru. Situace, kdy obˆ z venku dodan  n vˆ¨t¡ jsou fall-thru, se
  -- o¨et©uje a‘ p©i sestavov n¡ kone‡n‚ho v˜sledku.

  --- vygenerovat v˜raz ---
  if expr^.oper in expopertypeset:[op_and_then,op_or_else{%%X},op_and,op_or]

    -- sekven‡n¡ forma
    then
      --- zvolit c¡l vnit©n¡ho skoku ---
      -- z le‘¡ na oper toru
      if expr^.oper in expopertypeset:[op_and_then{%%X},op_and]
        -- AND [ THEN ] => skok p©i prvn¡m nepravdiv‚m operandu
        then innerjmp:=ftarget
        -- OR [ ELSE ] => skok p©i prvn¡m pravdiv‚m operandu
        else
          innerjmp:=ttarget
          end if;

      -- nevy¨el n hodou fall-thru skok => korekce hodnoty n vˆ¨t¡
      if innerjmp=tgfallthru then
        innerjmp:=fallthru;
        end if;

      --- zpracovat v¨echny podv˜razy ---
      sub:=expr^.sub;
      while sub<>nil loop
      { Ondra 1.7.2002 : Oprava byla chybn . Zru¨eno.

        -- Ondra 28.6.2002 : Posledn¡ operand v ©adˆ, kter˜ je opˆt ©etˆzec konjunkc¡/disjunkc¡ se
        -- mus¡ zpracov vat standardnˆ bez ohledu na tuto skute‡nost, proto‘e nap©¡klad u v˜razu:
        --     (c>="a" and c<="z") or (c>="A" and c<="Z") or c="_" or (c>="0" and c<="9")
        -- je v˜sledek posledn¡ho v˜razu chybnˆ interpretov n. Jedin  mo‘nost, jak tento p©¡pad
        -- optimalizovat, je p©ed vat do I_GEN_LOGICAL_CHAIN informaci, ‘e se jedn  o posledn¡
        -- podv˜raz nad©azen‚ho ©etˆzu konjunkc¡/disjunkc¡ (ovˆ©it!).
      }
        if (sub^.ntype=nt_operator) and (pexpoper(sub)^.oper in expopertypeset:[op_and_then,op_or_else,op_and,op_or]) -- (* and (sub^.next<>nil) *)

          -- podv˜raz je opˆt ©etˆz konjunkc¡/disjunkc¡
          then
          -- (*
            if sub^.next=nil

              -- posledn¡ v˜raz, sou‡asnˆ provede z vˆre‡n˜ skok
              then i_gen_logical_chain(inst,info,context,pexpoper(sub),ttarget,ftarget,vysl)

              -- mezilehl˜ v˜raz
              else
          -- *)
                if expr^.oper in expopertypeset:[op_and_then{%%X},op_and]

                  -- A and then (B and/or C)
                  then i_gen_logical_chain(inst,info,context,pexpoper(sub),tgfallthru,innerjmp,op1)

                  -- A or else (B and/or C)
                  else i_gen_logical_chain(inst,info,context,pexpoper(sub),innerjmp,tgfallthru,op1)
                  end if;
          -- (*
                end if;
          -- *)

          -- ostatn¡ p©¡pady
          else
            -- vygenerovat v˜raz (rozhoduj¡c¡ je typ podv˜razu, proto‘e typ
            -- nad©azen‚ho v˜razu je t‚mˆ© v‘dy univerz ln¡ logical a stejnˆ
            -- v˜sledek podv˜razu ihned porovn m na nulu a zahod¡m)
            i_newcontext(context,newcontext,lm_gen,nil{sub^.t.getctype});
            i_load(inst,info,newcontext,context{lm_gen,expr^.t.getutype},sub,op1);
            -- %% Nemˆlo by zde b˜t expr^.nattyp ?
            -- Ona mi ho ale asi optimalizace zni‡¡...

            -- obnovit registry
            i_refresh(inst,info,context,op1);

            -- vygenerovat porovn n¡
            case op1.optype
              -- p©¡mo k¢d podm¡nky
              when io_cc do
                  -- podm¡nka skoku
                  if expr^.oper in expopertypeset:[op_and_then{%%X},op_and]
                    then cc:=icondneg[op1.cc];
                    else cc:=op1.cc;
                    end if;


              -- pamˆŸ/registr
              when io_mem,io_reg do
                  -- test na nulu
                  addii(inst,info,ii_cmp,op1,op_0,op0);

                  -- podm¡nka skoku
                  if expr^.oper in expopertypeset:[op_and_then,{%%X}op_and]
                    then cc:=ic_z;
                    else cc:=ic_nz;
                    end if;


              when others do verify(96,true);
              end case;

            if sub^.next<>nil
              -- vnit©n¡ skok
              then addjump(inst,info,cc,innerjmp)
              -- z vˆre‡n˜ skok
              else i_gen_logical_jump(inst,info,context,expr^.oper in expopertypeset:[op_and_then{%%X},op_and],cc,ttarget,ftarget,vysl)
              end if;

            -- nen¡ to prvn¡ operand zkr cen‚ho p©i©azen¡ ?
            if expr^.assign and (sub=expr^.sub) then
              -- schovat si operand
              cloneop(inst,info,context,op1,opassign);
              end if;

            -- uvolnit operand
            i_free(info,context,op1);
            end if;

        -- dal¨¡ podv˜raz
        sub:=sub^.next;
        end loop;

      -- Ondra 1.7.2002 : Kompletnˆ p©edˆl no zpracov n¡ v˜sledku. P–vodn¡ ©e¨en¡ nefungovalo.

      --- nebyly n hodou oba extern¡ c¡le skoku fall-thru ? ---
      if (ttarget_ext=tgfallthru) and (ftarget_ext=tgfallthru)

        -- ano => vygenerovat p©i©azen¡ v˜sledku
        then
          -- budeme pot©ebovat fall-thru n vˆ¨t¡
          newtarget(info,fallthru);

          -- nebylo to zkr cen‚ p©i©azen¡ ?
          if expr^.assign

            -- ano => rovnou p©i©adit do v˜sledku
            then
              -- p©¡pad True: dosadit adresu n vˆ¨t¡ pro skok na toto m¡sto
              settarget(info,ttarget,getaddr(inst));

              -- p©i©adit True
              addii(inst,info,ii_mov,opassign,op_1,op0);

              -- skok na konec
              addjump(inst,info,ic_ucond,fallthru);

              -- p©¡pad False: dosadit adresu n vˆ¨t¡ pro skok na toto m¡sto
              settarget(info,ftarget,getaddr(inst));

              -- p©i©adit False
              addii(inst,info,ii_mov,opassign,op_0,op0);

              -- uvolnit operand
              i_free(info,context,opassign);

              -- v˜sledek je nezaj¡mav˜, p©i©azen¡ nem  hodnotu
              nullop(vysl,io_none);

            -- ne => podle v˜sledku nastavit Carry Flag
            else
              -- p©¡pad True: dosadit adresu n vˆ¨t¡ pro skok na toto m¡sto
              settarget(info,ttarget,getaddr(inst));

              -- nastavit Carry Flag
              addii(inst,info,ii_stc,op0,op0,op0);

              -- skok na konec
              addjump(inst,info,ic_ucond,fallthru);

              -- p©¡pad False: dosadit adresu n vˆ¨t¡ pro skok na toto m¡sto
              settarget(info,ftarget,getaddr(inst));

              -- shodit Carry Flag
              addii(inst,info,ii_clc,op0,op0,op0);

              -- v˜sledek
              nullop(vysl,io_cc);
              vysl.cc:=ic_c;
              end if;

          -- v˜sledn˜ fall-thru: dosadit adresu n vˆ¨t¡ pro skok na toto m¡sto
          settarget(info,fallthru,getaddr(inst));

        -- ne => v˜sledek je celkem nezaj¡mav˜, proto‘e je obsa‘en v proveden˜ch skoc¡ch
        else
          verify(602,expr^.assign);

          -- dosadit c¡l skoku fall-thru
          if (ttarget=tgfallthru) or (ftarget=tgfallthru) then
            settarget(info,fallthru,getaddr(inst));
            end if;

          -- v˜sledek ve¨ker˜ ‘ dn˜, to za n s za©¡dily ji‘ ty skoky
          nullop(vysl,io_none);
          end if;

    -- standardn¡ forma
    else
      unimplemented(30);
      end if;
  end i_gen_logical_chain;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_logical : topergen =
-- P©i©azen¡ logick‚ hodnoty.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(133,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  -- vygenerovat a na‡¡st podv˜razy
  i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);
{
  -- vygenerovat lev˜ podv˜raz
  i_newcontext(context,newcontext,lm_gen,nil{expr^.t.getctype});
  i_load(inst,info,newcontext,context{lm_gen,expr^.t.getctype},el,op1);

  -- vygenerovat prav˜ podv˜raz
  i_newcontext(context,newcontext,lm_reg,expr^.t.getctype);
  i_load(inst,info,newcontext,context{lm_reg,expr^.t.getctype},er,op2);

  -- obnovit registry
  i_refresh(inst,info,context,op1);
  i_refresh(inst,info,context,op2);
}
  -- ulo‘it
  if op2.optype=io_cc

    -- podle podm¡nky
    then addset(inst,info,op2.cc,op1)

    -- p©¡mo hodnota
    else
      addii(inst,info,ii_mov,op1,op2,op0)
      end if;

  -- uvolnit operand
  i_free(info,context,op2);

  -- p©edat v˜sledek
  vysl:=op1;
  end i_gen_op_assign_logical;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_logical_and_or : topergen =
-- Logick‚ operace AND, OR, AND THER a OR ELSE.
----------------------------------------------------------------------------------------------------
begin
  -- generovat ©etˆz konjunkc¡/disjunkc¡
  i_gen_logical_chain(inst,info,context,pexpoper(expr),tgfallthru,tgfallthru,vysl);
  end i_gen_op_logical_and_or;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_logical_xor : topergen =
-- Logick  operace XOR.
----------------------------------------------------------------------------------------------------
begin
  -- algoritmus je toto‘n˜ s bitov˜m XOR, proto je implementov n
  -- v r mci celo‡¡seln˜ch operac¡
  i_gen_op_integer(inst,info,context,expr,vysl);
  end i_gen_op_logical_xor;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_ordinal : topergen =
-- Porovn v n¡ diskr‚tn¡ch v˜raz–.
-- Tato procedura se pou‘¡v  i pro porovn n¡ (pouze = <>) obecn˜ch birn tn¡
-- blok– p©¡zniv‚ velikosti (1,2,4; viz I_GEN_OP_COMPARE_BINARY).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  op3              : ioper;                      -- operand 3  
  cc               : icond;                      -- k¢d podm¡nky
  rest             : typeview;                   -- spole‡n˜ typ operand–

begin
  verify(139,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  -- vypo‡¡tat spole‡n˜ typ operand–
  x_resolve(el^.t,er^.t,true,rest);

  -- vygenerovat a na‡¡st operandy
  i_load_binary(inst,info,context,iop_none,expr,rest.getutype,el,er,op1,op2);

  -- porovnat
  addii(inst,info,ii_cmp,op1,op2,op0);

  -- podm¡nka
  cc:=op2cc[expr^.oper,rest.stype=dt_signed{(el^.t.stype=dt_signed) or (er^.t.stype=dt_signed)}];

  -- zkr cen‚ p©i©azen¡ ?
  if expr^.assign then addset(inst,info,cc,op1); end if;

  -- uvolnit operandy
  i_free(info,context,op1);
  i_free(info,context,op2);

  -- v˜sledek
  nullop(vysl,io_cc);
  vysl.cc:=cc;
  end i_gen_op_compare_ordinal;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_pointer : topergen =
-- Porovn v n¡ pointer–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  optmp            : ioper;                      -- operand s porovn vanou hodnotou
  tgend            : itarget;                    -- n vˆ¨t¡ pro skok na konec porovn v n¡
  cc               : icond;                      -- k¢d podm¡nky
  rest             : typeview;                   -- spole‡n˜ typ operand–
  newcontext       : iexprcontext;               -- kontext generov n¡ podv˜razu
  size             : t_unsigned;
  i                : t_unsigned;

begin
  verify(325,(expr^.arity<>eoa_2) or expr^.assign);

  -- podv˜razy
  expr^.get(el,er);

  -- vypo‡¡tat spole‡n˜ typ operand–
  x_resolve(el^.t,er^.t,false,rest);

  -- podm¡nka
  cc:=op2cc[expr^.oper,false];

  ----- porovn n¡ na NIL -----
  if x_is_nil(er) then
    -- vygenerovat a na‡¡st lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_pointer_reg,rest.getutype);
    i_load(inst,info,newcontext,context,el,op1);

    -- z pointeru n s zaj¡m  jen adresa
    -- %%X Opravdu ? viz flex^alsoft.cz
    op1.size:=4;

    -- prav˜ operand je NIL
    nullop(op2,io_imm);

    -- porovnat
    addii(inst,info,ii_cmp,op1,op2,op0);

  ---- porovn n¡ dvou pointer– -----
  else
    -- r–zn‚ typy pointer– se porovn vaj¡ obecnˆ jinak
    case rest.getpclass
      -- p©¡stup k dat–m
      when pc_data do
          -- zvolit zp–sob porovn n¡ podle velikosti pointeru
          size:=unidata_size_to_unsigned(rest.getsize);
          case size
            -- pouze adresa
            when 4 do
                -- vygenerovat a na‡¡st operandy
                i_load_binary_pointer(inst,info,context,expr,rest.getutype,el,er,op1,op2);

                -- porovnat
                addii(inst,info,ii_cmp,op1,op2,op0);


            -- pointer s nˆjak˜mi atributy
            when 8,12,16 do
                -- vygenerovat a na‡¡st adresu lev‚ho operandu
                i_newcontext(context,newcontext,lm_gen,rest.getutype);
                i_load(inst,info,newcontext,context,el,op1);

                -- na‡¡st adresu prav‚ho operandu
                i_newcontext(context,newcontext,lm_gen,rest.getutype);
                i_load(inst,info,newcontext,context,er,op2);

                -- obnovit registr
                verify(494,(op1.optype<>io_mem) or (op2.optype<>io_mem));
                i_refresh(inst,info,context,op1);
                i_refresh(inst,info,context,op2);

                -- pokud u‘ nem me voln‚ registry, tak zkusit redukovat po‡et registr– v operandech
                if not areavailregs(context,4) then
                  i_gen_reduceop(inst,info,context,op1);
                  i_gen_reduceop(inst,info,context,op2);
                  end if;

                -- budeme pot©ebovat jeden registr
                newopreg(inst,info,context,optmp,4,irm_int,op0);

                -- alokovat n vˆ¨t¡ pro skok na konec
                newtarget(info,tgend);

                -- operandy budeme zpracov vat po 4bytov˜ch kroc¡ch
                op1.size:=4;
                op2.size:=4;

              { %%TODO(CODEGEN) Tento £sek k¢du zase obnovit, a‘ bude spr vnˆ fungovat
                 ve¨ker  manipulace s tagy v‡etnˆ modifik toru CLASS v deklaraci parametru.

                -- porovnat
                for i in 1..size div 4-1 loop
                  -- na‡¡st a porovnat hodnotu
                  addii(inst,info,ii_mov,optmp,op1,op0);
                  addii(inst,info,ii_cmp,optmp,op2,op0);

                  -- podm¡nˆn˜ skok na konec
                  addjump(inst,info,ic_ne{icondneg[cc]},tgend);

                  -- posunout adresy obou operand–
                  shiftop(op1,4);
                  shiftop(op2,4);
                  end loop;
              }
                -- na‡¡st porovnat posledn¡ dvojici
                addii(inst,info,ii_mov,optmp,op1,op0);
                addii(inst,info,ii_cmp,optmp,op2,op0);

                -- adresa skoku na toto m¡sto
                settarget(info,tgend,getaddr(inst));

                -- uvolnit pomocn˜ operand
                i_free(info,context,optmp);


            when others do verify(492,true);
            end case;


      -- p©¡stup k podprogramu
      when pc_subprogram do
          unimplemented(167);


      -- p©¡stup k tasku
      when pc_task do
          unimplemented(168);


      -- p©¡stup ke zpr vˆ
      when pc_message do
          unimplemented(169);


      when others do verify(493,true);
      end case;
    end if;

  -- uvolnit oba operandy
  i_free(info,context,op2);
  i_free(info,context,op1);

  -- v˜sledek
  nullop(vysl,io_cc);
  vysl.cc:=cc;
  end i_gen_op_compare_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_order_string : topergen =
-- Porovn v n¡ ©etˆzc– (< <= > >=).
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  el_uniarray      : t_logical;                  -- true, je-li lev˜ operand konstanta typu univerz ln¡ pole
  er_uniarray      : t_logical;                  -- true, je-li prav˜ operand konstanta typu univerz ln¡ pole
  op1              : ioper;                      -- adresa lev‚ho ©etˆzce v ESI
  op1mem           : ioper;                      -- [ESI]
  op1length        : ioper;                      -- po‡et prvk– lev‚ho ©etˆzce v registru
  op2              : ioper;                      -- adresa prav‚ho ©etˆzce v EDI
  op2mem           : ioper;                      -- [EDI]
  op2length        : ioper;                      -- po‡et prvk– prav‚ho ©etˆzce v registru
  opecx            : ioper;                      -- min(op1length,op2length) v ECX
  rest             : typeview;                   -- spole‡n˜ typ operand–
  base             : pentity_type;               -- typ b ze
  basesize         : t_unsigned32;               -- velikost b ze ©ˆtˆzc–
  tg_cmplength     : itarget;                    -- n vˆ¨t¡ pro skok na porovn n¡ d‚lek
  tg_end           : itarget;                    -- n vˆ¨t¡ pro skok na konec porovn n¡
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(466,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  -- vypo‡¡tat spole‡n˜ typ operand–
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost b ze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- diskr‚tn¡ b ze -----
  if base^.stype in dts_ordinal then
    if basesize=1 or basesize=2 or basesize=4{%%TODO(SET) basesize in [1,2,4]}

      -- p©¡zniv  velikost b ze => p©es REPE CMPS
      then
        -- nen¡ n hodou nˆkter˜ operand konstanta typu univerz ln¡ pole ?
        el_uniarray:=(el^.ntype=nt_imm) and t_is_stype(el^.t,dt_uniarray);
        er_uniarray:=(er^.ntype=nt_imm) and t_is_stype(er^.t,dt_uniarray);

        if el_uniarray or er_uniarray then
          -- %%X Pozor, sou‡ st¡ konstanty typu univerz ln¡ pole nen¡ informace o d‚lce,
          -- co‘ se mus¡ zohlednit p©i zji¨Ÿov n¡ a porovn v n¡ velikost¡ n¡‘e.
          -- Srovnej s procedurou I_GEN_OP_COMPARE_STRING.
          unimplemented(197);
          end if;

        -- na‡¡st lev˜ operand do ESI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_esi,irm_addr);
        i_load(inst,info,newcontext,context,el,op1);

        -- na‡¡st prav˜ operand do EDI
        i_newcontext(context,newcontext,lm_addr,nil);
        i_setrpref(newcontext,in_edi,irm_addr);
        i_load(inst,info,newcontext,context,er,op2);

        -- obnovit registry
        i_refresh(inst,info,context,op1);
        i_refresh(inst,info,context,op2);

        -- kromˆ ESI pot©ebujeme i [ESI]
        nullop(op1mem,io_mem);
        i_use(inst,info,context,op1.reg.reg,op1mem.base,idefregsize);

        -- kromˆ EDI pot©ebujeme i [EDI]
        nullop(op2mem,io_mem);
        i_use(inst,info,context,op2.reg.reg,op2mem.base,idefregsize);

        -- rezervovat ECX
        nullop(opecx,io_reg);
        opecx.size:=lstrisize32;
        i_use(inst,info,context,ir_ecx,opecx.reg,lstrisize32);

        -- registr na velikost ©etˆzce vlevo
        newopreg(inst,info,context,op1length,lstrisize32,irm_int,op0);

        -- registr na velikost ©etˆzce vpravo
        newopreg(inst,info,context,op2length,lstrisize32,irm_int,op0);

        -- na‡¡st velikost ©etˆzce vlevo
        op1mem.size:=lstrisize32;
        addii(inst,info,ii_mov,op1length,op1mem,op0);

        -- na‡¡st velikost ©etˆzce vpravo
        op2mem.size:=lstrisize32;
        addii(inst,info,ii_mov,op2length,op2mem,op0);

        -- do ECX d t p©ednostnˆ velikost ©etˆzce vlevo
        addii(inst,info,ii_mov,opecx,op1length,op0);

        -- posunout ESI a EDI o LSTRISIZE32
        addopimm(inst,info,ii_add,op1,lstrisize32);
        addopimm(inst,info,ii_add,op2,lstrisize32);

        -- porovnat velikosti ©etˆzc–
        addii(inst,info,ii_cmp,op1length,op2length,op0);

        -- el:length>er:length => ECX:=er:length
        addcmov(inst,info,ic_be,opecx,op2length);

        -- alokovat n vˆ¨t¡
        newtarget(info,tg_cmplength);
        newtarget(info,tg_end);

        -- ECX=0 => porovn n¡ se redukuje na porovn n¡ d‚lek
        -- %%X neum¡m JECXZ
        addii(inst,info,ii_cmp,opecx,op_0,op0);
        addjump(inst,info,ic_e,tg_cmplength);

        -- shodit Direction Flag - porovn v  se zdola nahoru
        addii(inst,info,ii_cld,op0,op0,op0);

        -- REPE CMPS
        addip(inst,info,ip_repe);
        case basesize
          when 1 do addii(inst,info,ii_cmpsb,op0,op0,op0);
          when 2 do addii(inst,info,ii_cmpsw,op0,op0,op0);
          when 4 do addii(inst,info,ii_cmpsd,op0,op0,op0);
          when others do verify(468,true);
          end case;

        -- je jednozna‡nˆ zn m v˜sledek ? => skok na konec porovn n¡
        addjump(inst,info,ic_ne,tg_end);

        -- c¡l skoku na toto m¡sto
        settarget(info,tg_cmplength,getaddr(inst));

        -- porovn n¡ se redukuje na porovn n¡ d‚lek ©etˆzc–
        addii(inst,info,ii_cmp,op1length,op2length,op0);

        -- c¡l skoku na toto m¡sto
        settarget(info,tg_end,getaddr(inst));

        -- uvolnit operandy
        i_free(info,context,op1);
        i_free(info,context,op1mem);
        i_free(info,context,op1length);
        i_free(info,context,op2);
        i_free(info,context,op2mem);
        i_free(info,context,op2length);
        i_free(info,context,opecx);

        -- v˜sledek
        nullop(vysl,io_cc);
        vysl.cc:=op2cc[expr^.oper,base^.stype=dt_signed];

      -- nˆjak  nestandardn¡ velikost b ze
      else
        unimplemented(148);
        end if;

  ----- re ln  b ze -----
  elsif base^.stype in dts_real then
    unimplemented(149);

  -- jin‚ typy b ze nelze porovn vat
  else 
    verify(467,true);
    end if;
  end i_gen_op_order_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_string : topergen =
-- Porovn v n¡ ©etˆzc– (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : in pexpnode) =
    -- Porovn  zadan˜ uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      op1       : ioper;                         -- po‡et prvk– ©ˆtˆzce
      newcontext: iexprcontext;                  -- kontext podv˜raz–

    begin
      -- na‡¡st po‡et prvk– ©ˆtˆzce
      i_newcontext(context,newcontext,lm_reg,x^.t.getctype^.srange.getctype);
      i_load(inst,info,newcontext,context,x,op1);

      -- obnovit registry
      i_refresh(inst,info,context,op1);

      -- porovnat na nulu
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- uvolnit operand
      i_free(info,context,op1);

      -- v˜sledek
      nullop(vysl,io_cc);
      vysl.cc:=op2cc[expr^.oper,false];
      end cmpnil;

var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  er_uniarray      : t_logical;                  -- true, je-li prav˜ operand konstanta typu univerz ln¡ pole
  op1              : ioper;                      -- adresa lev‚ho ©etˆzce v ESI
  op1mem           : ioper;                      -- [ESI]
  op2              : ioper;                      -- adresa prav‚ho ©etˆzce v EDI
  op2mem           : ioper;                      -- [EDI]
  op2len           : ioper;                      -- kosntantn¡ velikost prav‚ho operandu
  opecx            : ioper;                      -- min(op1length,op2length) v ECX
  rest             : typeview;                   -- spole‡n˜ typ operand–
  base             : pentity_type;               -- typ b ze
  basesize         : t_unsigned32;               -- velikost b ze ©ˆtˆzc–
  tg_end           : itarget;                    -- n vˆ¨t¡ pro skok na konec porovn n¡
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  ii               : iinstr;                     -- zvolen  porovn vac¡ instrukce
  imm              : timm32;
  ui               : tuniint;

begin
  verify(466,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podv˜razy
  expr^.get(el,er);

  -- vypo‡¡tat spole‡n˜ typ operand–
  x_resolve(el^.t,er^.t,false,rest);

  -- zjistit velikost b ze
  base:=rest.getctype^.base.getctype;
  basesize:=unidata_size_to_unsigned(base^.size);

  ----- (non)ekvivalence s pr zdn˜m ©etˆzcem zleva -----
  if x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s pr zdn˜m ©ˆtˆzcem zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecn˜ch ©etˆzc– -----
  else
    verify(624,el^.ntype=nt_imm);

    -- %%X Optimalizace: Kdy‘ je velikost b ze rovna LSTRISIZE32, tak nemus¡m
    -- zvl ¨Ÿ testovat shodnost d‚lek - sta‡¡ udˆlat INC ECX a REPE CMPS

    -- %%X Pozor ! Pro nˆkter‚ typy b ze ©etˆzce se to mus¡ dˆlat jinak
    if not (base^.stype in dts_ordinal) then
      unimplemented(166);
      end if;

    -- nen¡ n hodou prav˜ operand konstant typu univerz ln¡ pole ?
    er_uniarray:=(er^.ntype=nt_imm) and t_is_stype(er^.t,dt_uniarray);

    -- na‡¡st lev˜ operand do ESI
    i_newcontext(context,newcontext,lm_addr,nil);
    i_setrpref(newcontext,in_esi,irm_addr);
    i_load(inst,info,newcontext,context,el,op1);

    -- na‡¡st prav˜ operand do EDI
    i_newcontext(context,newcontext,lm_addr,nil);
    i_setrpref(newcontext,in_edi,irm_addr);
    i_load(inst,info,newcontext,context,er,op2);

    -- obnovit registry
    i_refresh(inst,info,context,op1);
    i_refresh(inst,info,context,op2);

    -- kromˆ ESI pot©ebujeme i [ESI]
    nullop(op1mem,io_mem);
    i_use(inst,info,context,op1.reg.reg,op1mem.base,idefregsize);

    -- kromˆ EDI pot©ebujeme i [EDI]
    nullop(op2mem,io_mem);
    i_use(inst,info,context,op2.reg.reg,op2mem.base,idefregsize);

    -- rezervovat ECX
    nullop(opecx,io_reg);
    opecx.size:=lstrisize32;
    i_use(inst,info,context,ir_ecx,opecx.reg,lstrisize32);

    -- do ECX na‡¡st velikost lev‚ho operandu
    op1mem.size:=lstrisize32;
    addii(inst,info,ii_mov,opecx,op1mem,op0);

    -- porovnat s velikost¡ ©etˆzce vlevo
    if er_uniarray

      -- vpravo je konstanta typu univerz ln¡ pole => informace o d‚lce nen¡ jej¡ sou‡ st¡
      then
        -- p©ipravit konstantn¡ operand d‚lky
        nullop(op2len,io_imm);
        imm_get_length(pexpimm(er)^.imm,ui);
        op2len.imm:=uniint_to_imm32(ui);

        -- porovnat
        addii(inst,info,ii_cmp,opecx,op2len,op0);

      -- vpravo je nˆco jin‚ho => informace o d‚lce je jej¡ sou‡ st¡
      else
        op2mem.size:=lstrisize32;
        addii(inst,info,ii_cmp,opecx,op2mem,op0);
        end if;

    -- alokovat n vˆ¨t¡
    newtarget(info,tg_end);

    -- jsou rozd¡ln‚ ? => pak je porovn n¡ hotov‚
    addjump(inst,info,ic_ne,tg_end);

    -- Nyn¡ jsou jistˆ d‚lky ©etˆzc– shodn‚ (Zero Flag=0). P–vodnˆ jsem toho
    -- chtˆl vyu‘¡t, abych nemusel je¨tˆ testovat ECX na nulu, jen‘e po‡et
    -- prvk– ©etˆzce se za chv¡li bude n sobit velikost¡ b ze a tato operace
    -- m–‘e ZF zmˆnit.

    -- porovnat ECX na nulu
    addii(inst,info,ii_cmp,opecx,op_0,op0);
    addjump(inst,info,ic_e,tg_end);

    -- posunout ESI a EDI o LSTRISIZE32
    addopimm(inst,info,ii_add,op1,lstrisize32);
    if not er_uniarray then
      addopimm(inst,info,ii_add,op2,lstrisize32);
      end if;

    -- zvolit, jak budeme porovn vat (podle velikosti b ze)
    -- dˆliteln‚ 4 ? => po ‡tve©ic¡ch
    if basesize mod 4=0 then
      ii:=ii_cmpsd;
      imm:=unsigned_to_imm32(basesize div 4);
    -- dˆliteln‚ 2 ? => po dvojic¡ch
    elsif basesize mod 2=0 then
      ii:=ii_cmpsw;
      imm:=unsigned_to_imm32(basesize div 2);
    -- mus¡me po bytech
    else
      ii:=ii_cmpsb;
      imm:=unsigned_to_imm32(basesize);
      end if;

    -- vyn sobit po‡et prvk– ©etˆzce reziduem velikosti b ze
    i_gen_mul_reg(inst,info,context,op1,imm);

    -- shodit Direction Flag - porovn v  se zdola nahoru
    addii(inst,info,ii_cld,op0,op0,op0);

    -- REPE CMPS
    addip(inst,info,ip_repe);
    addii(inst,info,ii,op0,op0,op0);

    -- a t¡m by to mˆlo b˜t hotovo

    -- c¡l skoku na toto m¡sto
    settarget(info,tg_end,getaddr(inst));

    -- uvolnit operandy
    i_free(info,context,op1);
    i_free(info,context,op1mem);
    i_free(info,context,op2);
    i_free(info,context,op2mem);
    i_free(info,context,opecx);

    -- v˜sledek
    nullop(vysl,io_cc);
    vysl.cc:=op2cc[expr^.oper,false];
    end if;
  end i_gen_op_compare_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_binary : topergen =
-- Porovn v n¡ dvou obecn˜ch bin rn¡ch blok– (e.g. array, record, set) (= <>).
----------------------------------------------------------------------------------------------------

    ------------------------------------------------------------------------------------------------
    procedure cmpnil (
        x          : pexpnode) =
    -- Porovn  zadan˜ uzel na NIL.
    ------------------------------------------------------------------------------------------------
    var
      newcontext: iexprcontext;                  -- kontext podv˜raz–
      op1          : ioper;                      -- adresa lev‚ho ©etˆzce v ESI
      opecx        : ioper;                      -- min(op1length,op2length) v ECX
      opsize       : ioper;                      -- velikost pole
      size         : t_unsigned32;               -- velikost pole
      tgloop       : itarget;                    -- n vˆ¨t¡ za‡ tku cyklu
      tgend        : itarget;                    -- n vˆ¨t¡ konce cyklu

    begin
      -- jak jsme na tom s velikost¡ operandu ?
      if x_has_dynamic_size(x)

        -- dynamick  velikost
        then
          unimplementedx(170,expr^.pos);

        -- statick  veliksot
        else
          -- na‡¡st lev˜ operand
          i_newcontext(context,newcontext,lm_gen,nil);
          i_load(inst,info,newcontext,context,x,op1);
          verifyx(524,op1.optype<>io_mem,x^.pos);

          -- redukovat po‡et registr–
          i_gen_reduceop(inst,info,context,op1);

          -- rezervovat ECX
          nullop(opecx,io_reg);
          opecx.size:=4;
          i_use(inst,info,context,ir_ecx,opecx.reg,4);

          -- obnovit registry
          i_refresh(inst,info,context,op1);
          i_refresh(inst,info,context,opecx);

          -- zjistit velikost pole
          size:=unidata_size_to_unsigned(x^.t.getsize);

          -- zvolit, jak budeme porovn vat
          nullop(opsize,io_imm);
          -- dˆliteln‚ 4 ? => po ‡tve©ic¡ch
          if size mod 4=0 then
            opsize.imm:=unsigned_to_imm32(size div 4);
            shiftopindex(inst,info,context,op1,in_ecx,4);
            unshiftop(op1,4);
            op1.size:=4;
          -- dˆliteln‚ 2 ? => po dvojic¡ch
          elsif size mod 2=0 then
            opsize.imm:=unsigned_to_imm32(size div 2);
            shiftopindex(inst,info,context,op1,in_ecx,2);
            unshiftop(op1,2);
            op1.size:=2;
          -- mus¡me po bytech
          else
            opsize.imm:=unsigned_to_imm32(size);
            shiftopindex(inst,info,context,op1,in_ecx,1);
            unshiftop(op1,1);
            op1.size:=1;
            end if;

          -- naplnit ECX
          addii(inst,info,ii_mov,opecx,opsize,op0);
          end if;

      -- alokovat c¡le skoku
      newtarget(info,tgloop);
      newtarget(info,tgend);

      -- c¡l skoku na toto m¡sto
      settarget(info,tgloop,getaddr(inst));

      -- CMP <prvek pole>,0
      addii(inst,info,ii_cmp,op1,op_0,op0);

      -- JNE <tgend>
      addjump(inst,info,ic_ne,tgend);

      -- LOOP <tgloop>
      addloop(inst,info,tgloop);

      -- c¡l skoku na toto m¡sto
      settarget(info,tgend,getaddr(inst));

      -- v˜sledek
      nullop(vysl,io_cc);
      vysl.cc:=op2cc[expr^.oper,false];
          {
              mov   ecx,x:size div 4
          ^2: cmp   [esi+ecx*4-4],0
              jne   ^1
              loop  ^2
          ^1: x=nil  => ic_ne
              x<>nil => ic_e
          }
      end cmpnil;

var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  op1              : ioper;                      -- adresa lev‚ho ©etˆzce v ESI
  op2              : ioper;                      -- adresa prav‚ho ©etˆzce v EDI
  opecx            : ioper;                      -- min(op1length,op2length) v ECX
  opsize           : ioper;                      -- velikost pole
  ii               : iinstr;                     -- zvolen  porovn vac¡ instrukce
  size             : t_unsigned32;               -- velikost pole

begin
  verify(501,(expr^.arity<>eoa_2) or not (expr^.oper in expopertypeset:[op_eq,op_ne]));

  -- podv˜razy
  expr^.get(el,er);

  -- porovn n¡ operand– s p©¡znivou statickou velikost¡
  if x_has_static_size(el) and x_has_static_size(er)
  and (el^.t.getsize=uds_1 or el^.t.getsize=uds_2 or el^.t.getsize=uds_4) then
    -- porovnat principi lnˆ stejnˆ jako ordin ln¡ typy
    i_gen_op_compare_ordinal(inst,info,context,expr,vysl);

  ----- (non)ekvivalence s NIL zleva -----
  elsif x_is_nil(el) then
    cmpnil(er);

  ----- (non)ekvivalence s NIL zprava -----
  elsif x_is_nil(er) then
    cmpnil(el);

  ----- (non)ekvivalence obecn˜ch pol¡ -----
  else
    -- oba operandy maj¡ statickou velikost
    if x_has_static_size(el) and x_has_static_size(er) then
      -- na‡¡st lev˜ operand do ESI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_esi,irm_addr);
      i_load(inst,info,newcontext,context,el,op1);

      -- na‡¡st prav˜ operand do EDI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_edi,irm_addr);
      i_load(inst,info,newcontext,context,er,op2);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op2);

      -- rezervovat ECX
      nullop(opecx,io_reg);
      opecx.size:=lstrisize32;
      i_use(inst,info,context,ir_ecx,opecx.reg,4);

      -- zjistit velikost pol¡
      size:=unidata_size_to_unsigned(el^.t.getsize);

      -- zvolit, jak budeme porovn vat
      nullop(opsize,io_imm);
      -- dˆliteln‚ 4 ? => po ‡tve©ic¡ch
      if size mod 4=0 then
        ii:=ii_cmpsd;
        opsize.imm:=unsigned_to_imm32(size div 4);
      -- dˆliteln‚ 2 ? => po dvojic¡ch
      elsif size mod 2=0 then
        ii:=ii_cmpsw;
        opsize.imm:=unsigned_to_imm32(size div 2);
      -- mus¡me po bytech
      else
        ii:=ii_cmpsb;
        opsize.imm:=unsigned_to_imm32(size);
        end if;

      -- naplnit ECX
      addii(inst,info,ii_mov,opecx,opsize,op0);

      -- shodit Direction Flag - porovn v  se zdola nahoru
      addii(inst,info,ii_cld,op0,op0,op0);

      -- REPE CMPS
      addip(inst,info,ip_repe);
      addii(inst,info,ii,op0,op0,op0);

      -- a t¡m by to mˆlo b˜t hotovo

      -- uvolnit operandy
      i_free(info,context,op1);
      i_free(info,context,op2);
      i_free(info,context,opecx);
      i_free(info,context,opsize);

      -- v˜sledek
      nullop(vysl,io_cc);
      vysl.cc:=op2cc[expr^.oper,false];

    -- jeden z operand– m  dynamickou velikost
    elsif x_has_dynamic_size(el) xor x_has_dynamic_size(er) then
      unimplemented(171);

    -- oba maj¡ dynamickou velikost
    else
      unimplemented(172);
      end if;
    end if;
  end i_gen_op_compare_binary;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_array : topergen =
-- Porovn v n¡ record– (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vy‘aduj¡ komponenty pole zvl ¨tn¡ porovn vac¡ algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimaliz tor IF s konstantn¡ podm¡nkou neo¨et©¡

    -- ano => porovnat po ‡ stech
    then
      unimplemented(177);

    -- ne => porovnat jako bin rn¡ bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_array;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_record : topergen =
-- Porovn v n¡ mno‘in (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- vy‘aduj¡ komponenty recordu zvl ¨tn¡ porovn vac¡ algoritmus ?
  {if false -- %%X %%TODO(OPT) Optimaliz tor IF s konstantn¡ podm¡nkou neo¨et©¡

    -- ano => porovnat po ‡ stech
    then
      unimplemented(178);

    -- ne => porovnat jako bin rn¡ bloky
    else}
      i_gen_op_compare_binary(inst,info,context,expr,vysl);
      {end if;}
  end i_gen_op_compare_record;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_compare_set : topergen =
-- Porovn v n¡ pol¡ (= <>).
----------------------------------------------------------------------------------------------------
begin
  -- mno‘iny lze v‘dy porovn vat jako bin rn¡ bloky
  i_gen_op_compare_binary(inst,info,context,expr,vysl);
  end i_gen_op_compare_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_load_string_and_last (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpnode;                -- v˜raz
    op             : out ioper;                  -- adresa ©etˆzce
    oplast         : out ioper) =                -- a jeho :last
-- Na‡te adresu ©etˆzce do EDI a zjist¡ jeho :last.
----------------------------------------------------------------------------------------------------
var
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  opedi            : ioper;                      -- registr EDI

begin
  if expr^.t.stype=dt_ustring

    -- unconstrained string s dynamickou d‚lkou
    then
      -- pak mus¡ m¡t dynamick˜ :last nebo :size
      verify(344,not x_has_dynamic_size(expr));

      -- vygenerovat lev˜ operand
      i_newcontext(context,newcontext,lm_addr_attr,nil);
      i_load(inst,info,newcontext,context,expr,op);

      -- obnovit registry
      i_refresh(inst,info,context,op);

      -- pro atribut bude pot©eba registr
      newopreg(inst,info,context,oplast,lstrisize32,irm_int,op0);

      -- je k dispozici p©¡mo :last
      if rta_last in expr^.rta_used{%%ATTR} then
        -- na‡¡st :last
        i_gen_load_rtattrib_value(inst,info,context,expr^.rta_used{%%ATTR},op,rta_last,oplast);

      -- je k dispozici jen :size
      elsif rta_size in expr^.rta_used{%%ATTR} then
        -- na‡¡st :size
        i_gen_load_rtattrib_value(inst,info,context,expr^.rta_used{%%ATTR},op,rta_size,oplast);

        -- ode‡¡st velikost intern¡ ‡ sti ©etˆzce
        addii(inst,info,ii_sub,oplast,op_lstrisize32,op0);

        -- vydˆlit velikost¡ prvku
        i_gen_div_reg(inst,info,context,oplast,unidata_size_to_imm32(expr^.t.getctype^.base.getctype^.size));

      -- co si m me po‡¡t bez dynamick‚ho atributu ?
      else
        verify(516,true)
        end if;

      -- registr EDI
      newopuse(inst,info,context,opedi,idefregsize,ir_edi);

      -- na‡¡st adresu ©etˆzce do EDI
      op.size:=lpointer32;
      addii(inst,info,ii_mov,opedi,op,op0);

      -- uvolnit p–vodn¡ operand
      i_free(info,context,op);

      -- p©edat v˜sledek
      op:=opedi;

    -- ©etˆzec se statickou d‚lkou
    else
      -- p©ipravit konstantn¡ atribut :last
      nullop(oplast,io_imm);
      oplast.imm:=uniint_to_imm32(expr^.t.getctype^.srange.getctype^.hval);

      -- na‡¡st adresu lev‚ho operandu do EDI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_edi,irm_addr);
      i_load(inst,info,newcontext,context,expr,op);
      end if;
  end i_gen_load_string_and_last;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_concat_string : topergen =
-- Spojov n¡ ©etˆzc–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- lev˜ operand: EDI
  op1mem           : ioper;                      -- lev˜ operand: [EDI]
  op1length        : ioper;                      -- :length lev‚ho operandu
  op1last          : ioper;                      -- :last lev‚ho operandu
  opbasesize       : ioper;                      -- konstantn¡ velikost b ze ©etˆzce

    ------------------------------------------------------------------------------------------------
    procedure appendall =
    -- P©ikop¡rov n¡ v¨ech operand– po‡¡naje ER k OP1.
    ------------------------------------------------------------------------------------------------
    var
      op2          : ioper;                      -- prav˜ operand: ESI
      op2mem       : ioper;                      -- prav˜ operand: [ESI]
      op2length    : ioper;                      -- :length prav‚ho operandu
      optemp       : ioper;                      -- pomocn˜ operand
      newcontext   : iexprcontext;               -- kontext podv˜raz–
      tg_end       : itarget;                    -- n vˆ¨t¡ pro skok na konec z©etˆzen¡
      basesize     : t_unsigned32;

    begin
      -- n vˆ¨t¡ pro skok na konec z©etˆzen¡
      newtarget(info,tg_end);

      -- shodit Direction Flag - kop¡ruje se zdola nahoru
      addii(inst,info,ii_cld,op0,op0,op0);

      -- velikost b ze
      basesize:=imm32_to_unsigned(opbasesize.imm,);

      loop
        -- vygenerovat z©etˆzen¡
        case er^.concatkind
          -- pod©etˆzec
          when nck_substring do
              -- na‡¡st prav˜ operand do ESI
              i_newcontext(context,newcontext,lm_addr,nil);
              i_setrpref(newcontext,in_esi,irm_addr);
              i_load(inst,info,newcontext,context,er,op2);

              -- obnovit registry
              i_refresh(inst,info,context,op1);
              i_refresh(inst,info,context,op1mem);
              i_refresh(inst,info,context,op1length);
              i_refresh(inst,info,context,op2);

              -- kromˆ ESI pot©ebujeme i [ESI]
              nullop(op2mem,io_mem);
              i_use(inst,info,context,op2.reg.reg,op2mem.base,idefregsize);

              -- po‡et prvk– ©etˆzce do ECX
              newopuse(inst,info,context,op2length,lstrisize32,ir_ecx);
              op2mem.size:=lstrisize32;
              addii(inst,info,ii_mov,op2length,op2mem,op0);

              -- posunout pointer na za‡ tek datov‚ ‡ sti
              addii(inst,info,ii_add,op2,op_lstrisize32,op0);

              -- nen¡ to moc ? (op2length:=min(op2length,op1last-op1length)
              newopreg(inst,info,context,optemp,lstrisize32,irm_int,op0);
              addii(inst,info,ii_mov,optemp,op1last,op0);
              addii(inst,info,ii_sub,optemp,op1length,op0);
              addii(inst,info,ii_cmp,op2length,optemp,op0);
              addcmov(inst,info,ic_be,op2length,optemp);
              i_free(info,context,optemp);

              -- aktualizovat :length lev‚ho operandu (v registru)
              addii(inst,info,ii_add,op1length,op2length,op0);

              -- vlastn¡ p©esun dat
              i_gen_movsd_array(inst,info,context,op2,op1,op2length,basesize);

              -- uvolnit operandy vztahuj¡c¡ se k prav‚mu operandu
              i_free(info,context,op2);
              i_free(info,context,op2mem);
              i_free(info,context,op2length);


          -- podpole
          when nck_subarray do
              unimplemented(121);


          -- komponenta
          when nck_component do
              -- vejde se je¨tˆ komponenta do ©etˆzce ?
              addii(inst,info,ii_cmp,op1length,op1last,op0);
              addjump(inst,info,ic_ae,tg_end);

              -- inkrementovat :length
              addii(inst,info,ii_inc,op1length,op0,op0);

              -- nem  b ze p©¡znivou velikost ?
              if basesize=1 or basesize=2 or basesize=4{%%TODO(SET) basesize in [1,2,4]}

                -- m  => pou‘¡t registr
                then
                  -- na‡¡st prav˜ operand do registru
                  i_newcontext(context,newcontext,lm_reg,expr^.t.getctype^.base.getctype{nil});
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registry
                  i_refresh(inst,info,context,op1);
                  i_refresh(inst,info,context,op1mem);
                  i_refresh(inst,info,context,op1length);
                  i_refresh(inst,info,context,op2);

                  -- p©i©adit
                  op1mem.size:=basesize;
                  addii(inst,info,ii_mov,op1mem,op2,op0);

                  -- posunout EDI (je-li to t©eba)
                  if er^.next<>nil then addii(inst,info,ii_add,op1,opbasesize,op0); end if;

                -- nem  => standardn¡ p©esun
                else
                  -- na‡¡st prav˜ operand do ESI
                  i_newcontext(context,newcontext,lm_addr,nil);
                  i_setrpref(newcontext,in_esi,irm_addr);
                  i_load(inst,info,newcontext,context,er,op2);

                  -- obnovit registry
                  i_refresh(inst,info,context,op1);
                  i_refresh(inst,info,context,op1mem);
                  i_refresh(inst,info,context,op1length);
                  i_refresh(inst,info,context,op2);

                  -- p©esun
                  i_gen_movsd_static(inst,info,context,op2,op1,basesize);
                  end if;

              -- uvolnit operandy vztahuj¡c¡ se k prav‚mu operandu
              i_free(info,context,op2);


          when others do verify(376,true);
          end case;

        -- dal¨¡ operand
        er:=er^.next;
        until er=nil;

      -- c¡l skoku na toto m¡sto
      settarget(info,tg_end,getaddr(inst));
      end appendall;

var
  op1org           : ioper;                      -- p–vodn¡ adresa lev‚ho operandu
  optemp           : ioper;                      -- pomocn˜ operand
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- p©ipravit operand s velikost¡ b ze ©etˆzce
  nullop(opbasesize,io_imm);
  opbasesize.imm:=unidata_size_to_imm32(expr^.t.getctype^.base.getctype^.size);

  -- podv˜razy
  expr^.get(el,er);

  if expr^.assign

    -- zkr cen‚ p©i©azen¡
    then
      -- na‡¡st adresu lev‚ho operandu do EDI
      i_gen_load_string_and_last(inst,info,context,el,op1,op1last);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op1last);

      -- schovat si p–vodn¡ adresu lev‚ho operandu
      -- %%X Nˆkdy mohu m¡t k dispozici voln˜ registr, kter˜ by ¨el vyu‘¡t
      newoptemp(inst,info,context,op1org,idefregsize);
      addii(inst,info,ii_mov,op1org,op1,op0);

      -- kromˆ EDI pot©ebujeme i [EDI]
      nullop(op1mem,io_mem);
      i_use(inst,info,context,op1.reg.reg,op1mem.base,idefregsize);

      -- :length ©etˆzce vlevo um¡stit do registru
      newopreg(inst,info,context,op1length,lstrisize32,irm_int,op0);
      op1mem.size:=lstrisize32;
      addii(inst,info,ii_mov,op1length,op1mem,op0);

      -- vypo‡¡tat :length*:base:size (index -> offset)
      newopreg(inst,info,context,optemp,idefregsize,irm_int,op0);
      addii(inst,info,ii_imul,optemp,op1length,opbasesize);

      -- posunout pointer na za‡ tek voln‚ho m¡sta
      addii(inst,info,ii_add,op1,op_lstrisize32,op0);
      addii(inst,info,ii_add,op1,optemp,op0);

      -- uvolnit pracovn¡ registr
      i_free(info,context,optemp);

      -- p©ikop¡rovat v¨e po‡¡naje ER
      appendall;

      -- aktualizovat fyzick‚ :length lev‚ho operandu
      op1.size:=idefregsize;
      op1mem.size:=lstrisize32;
      addii(inst,info,ii_mov,op1,op1org,op0);
      addii(inst,info,ii_mov,op1mem,op1length,op0);

      -- uvolnit temporary prostor
      freetemp(inst,info,op1org.disp);

      -- uvolnit operandy
      i_free(info,context,op1);
      i_free(info,context,op1mem);
      i_free(info,context,op1length);
      i_free(info,context,op1last);

    -- norm ln¡ &
    else
      -- alokovat pracovn¡ prostor pro meziv˜sledek
      if expr^.t.stype=dt_ustring

        -- v˜sledek m  dynamickou velikost
        then
          unimplemented(115);

        -- v˜sledek m  statickou velikost
        else
          -- %%X Nem–‘e se st t, ‘e bude meziv˜sledek p©¡li¨ velk˜ na to,
          -- aby se neve¨el na stack ? Mysl¡m, ‘e klidnˆ m–‘e ...

          -- alokovat pracovn¡ prostor na stacku
          newoptemp(inst,info,context,op1org{mem},unidata_size_to_unsigned(expr^.t.getsize));

          -- p©ipravit konstantn¡ atribut :last
          nullop(op1last,io_imm);
          op1last.imm:=uniint_to_imm32(expr^.t.getctype^.srange.getctype^.hval);

          -- po‡ te‡n¡ nulov‚ :length meziv˜sledku
          newopreg(inst,info,context,op1length,lstrisize32,irm_int,op0);
          addii(inst,info,ii_mov,op1length,op_0,op0);

          -- adresu za‡ tku datov‚ ‡ sti um¡stit do EDI
          cloneop(inst,info,context,op1org,op1);
          op1.disp+imm32_lstrisize32;
          i_gen_lea(inst,info,context,op1,in_edi);

          -- kromˆ EDI pot©ebujeme i [EDI]
          nullop(op1mem,io_mem);
          i_use(inst,info,context,op1.reg.reg,op1mem.base,idefregsize);

          -- p©ikop¡rovat v¨echny operandy
          er:=el;
          appendall;

          -- obnovit registry
          i_refresh(inst,info,context,op1org);

          -- aktualizovat :length
          op1org.size:=lstrisize32;
          addii(inst,info,ii_mov,op1org,op1length,op0);

          -- uvolnit operandy
          i_free(info,context,op1);
          i_free(info,context,op1mem);
          i_free(info,context,op1last);
          i_free(info,context,op1length);

          -- v˜sledek
          vysl:=op1org;
          vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
          end if;
      end if;
  end i_gen_op_concat_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_string : topergen =
-- P©i©azen¡ ©etˆzc–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- lev˜ operand: EDI
  op1mem           : ioper;                      -- lev˜ operand: [EDI]
  op1last          : ioper;                      -- :last lev‚ho operandu
  op2              : ioper;                      -- prav˜ operand: ESI
  op2mem           : ioper;                      -- prav˜ operand: [ESI]
  op2length        : ioper;                      -- :length prav‚ho operandu
  opbasesize       : ioper;                      -- konstantn¡ velikost b ze ©etˆzce
  optemp           : ioper;                      -- pomocn˜ operand
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  verify(199,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  if x_is_nil(er) {er^.t.stype=dt_uninil}

    -- p©i©azen¡ pr zdn‚ho ©etˆzce
    then
      -- adresa lev‚ho operandu
      i_newcontext(context,newcontext,lm_gen,nil);
      i_load(inst,info,newcontext,context,el,op1);

      -- obnovit registry
      i_refresh(inst,info,context,op1);

      -- lev˜ operand teƒ ukazuje na intern¡ ‡ st ©etˆzce
      op1.size:=4;

      -- p©i©adit nulu do :length
      addii(inst,info,ii_mov,op1,op_0,op0);

      -- uvolnit lev˜ operand
      i_free(info,context,op1);

    -- ostatn¡ p©¡pady
    else
      -- %%X Kdy‘ je na prav‚ stranˆ konstanta a el:last je t‚‘   
      -- konstantn¡, lze to cel‚ zjednodu¨it:
      --   -- do ECX se ¨oupne konstanta,
      --   -- do [EDI] se ¨oupne konstanta,
      --   -- nemus¡ se testovat o©¡znut¡.
      -- Kdy‘ je nav¡c konstanta vpravo dostate‡nˆ mal ,
      -- nemus¡m se obtˆ‘ovat s REP MOVSD ale mohu to rozvinout.

      -- na‡¡st adresu prav‚ho operandu do ESI
      i_newcontext(context,newcontext,lm_addr,nil);
      i_setrpref(newcontext,in_esi,irm_addr);
      i_load(inst,info,newcontext,context,er,op2);

      -- na‡¡st adresu lev‚ho operandu do EDI
      i_gen_load_string_and_last(inst,info,context,el,op1,op1last);

      -- obnovit registry
      i_refresh(inst,info,context,op1);
      i_refresh(inst,info,context,op1last);
      i_refresh(inst,info,context,op2);

      -- kromˆ EDI pot©ebujeme i [EDI]
      nullop(op1mem,io_mem);
      i_use(inst,info,context,op1.reg.reg,op1mem.base,idefregsize);

      -- kromˆ ESI pot©ebujeme i [ESI]
      nullop(op2mem,io_mem);
      i_use(inst,info,context,op2.reg.reg,op2mem.base,idefregsize);

      -- shodit Direction Flag - kop¡ruje se zdola nahoru
      addii(inst,info,ii_cld,op0,op0,op0);

      -- po‡et prvk– ©etˆzce vpravo do ECX
      newopuse(inst,info,context,op2length,lstrisize32,ir_ecx);
      op2mem.size:=lstrisize32;
      addii(inst,info,ii_mov,op2length,op2mem,op0);

      -- nen¡ to moc ? (op2length:=min(op2length,op1last)
      addii(inst,info,ii_cmp,op2length,op1last,op0);
      addcmov(inst,info,ic_be,op2length,op1last);

      -- ulo‘it :length do lev‚ho operandu
      op1mem.size:=lstrisize32;
      addii(inst,info,ii_mov,op1mem,op2length,op0);

      -- posunout pointer na za‡ tek datov‚ ‡ sti
      addii(inst,info,ii_add,op1,op_lstrisize32,op0);
      addii(inst,info,ii_add,op2,op_lstrisize32,op0);

      -- vlastn¡ p©esun dat
      i_gen_movsd_array(inst,info,context,op2,op1,op2length,unidata_size_to_unsigned(expr^.t.getctype^.base.getctype^.size));

      -- uvolnit operandy
      i_free(info,context,op1);
      i_free(info,context,op1mem);
      i_free(info,context,op1last);
      i_free(info,context,op2);
      i_free(info,context,op2mem);
      i_free(info,context,op2length);
      end if;
  end i_gen_op_assign_string;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_set : topergen =
-- Mno‘inov‚ operace.
----------------------------------------------------------------------------------------------------
var
  size             : t_unsigned32;               -- velikost operand–

begin
  -- zjistit velikost operand–
  size:=unidata_size_to_unsigned(expr^.t.getsize);

  if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}

    -- p©¡zniv  velikost => optimalizovan  verze celo‡¡selnou aritmetikou
    then begin
      -- prov‚st coby integerovou operaci
      i_gen_op_integer(inst,info,context,expr,vysl);
      verify(625,vysl.optype not in ioptypeset:[io_reg,io_mem]);

      -- mno‘ina je agreg tn¡ typ, tak‘e se od n s o‡ek v  adresa a ne rovnou hodnota
      if vysl.optype=io_reg then
        -- ulo‘it do temporary promˆnn‚
        i_gen_loadtemp(inst,info,context,vysl);
        end if;
      end

    -- nep©¡zniv  velikost => slo‘itˆ
    else
      unimplementedx(132,expr^.pos);
      end if;
  end i_gen_op_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_in_set : topergen =
-- Test n le‘en¡ do mno‘iny.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  optemp           : ioper;                      -- pomocn˜ operand
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  pbase            : pentity_type;               -- typ b ze mno‘iny
  lval             : timm32;                     -- doln¡ mez b ze mno‘iny
  bitsize          : t_unsigned;                 -- velikost mno‘iny v bitech zaokrouhlen  na 32
  size             : t_unsigned;

begin
  -- podv˜razy
  expr^.get(el,er);

  -- bude pot©eba typ b ze mno‘iny
  pbase:=er^.t.getctype^.base.getctype;

  -- doln¡ mez b ze mno‘iny
  lval:=uniint_to_imm32(pbase^.lval);

  -- na‡¡st testovanou hodnotu do registru
  -- %%X Zde jsem z mˆrnˆ nep©edal o‡ek van˜ typ v˜razu i kdy‘ je re‘im
  -- generov n¡ LM_REG. Nikde jinde se to takhle nedˆl , ale j  pot©ebuji,
  -- aby byl v˜sledek 32-bitov˜ (aby spr vnˆ fungovalo BT). Nemˆlo by se
  -- to dˆlat nˆjak jinak (nap©¡klad dodate‡nˆ registr roz¨¡©it) ?
  i_newcontext(context,newcontext,lm_reg,nil{pbase});
  i_load(inst,info,newcontext,context,el,op1);

  -- na‡¡st mno‘inu (prav˜ operand)
  i_newcontext(context,newcontext,lm_gen,er^.t.getctype);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  i_refresh(inst,info,context,op1);
  i_refresh(inst,info,context,op2);

  -- co je prav˜ operand za‡
  case op2.optype

    -- registr
    when io_reg do
       -- rozhodnˆ ho p©ev‚st na 32 bit–
       op2.size:=4;
       op2.reg.reg:=resizereg(op2.reg.reg,4);

       -- a co lev˜ operand ?
       case op1.optype

         -- p©¡m  hodnota
         when io_imm do
             -- ode‡¡st doln¡ mez b ze mno‘iny
             op1.imm-lval;

             -- hodnota je jistˆ 8-mi bitov  v rozsahu 0..31
             verify(434,op1.imm>31);
             op1.size:=1;

             -- BT <registr>,<p©¡m  hodnota>
             addii(inst,info,ii_bt,op2,op1,op0);


         -- registr
         when io_reg do
             -- p©ev‚st i druh˜ operand na 32 bit–
             op1.size:=4;
             op1.reg.reg:=resizereg(op1.reg.reg,4);

             -- ode‡¡st doln¡ mez
             if lval<>timm32(0) then
               nullop(optemp,io_imm);
               optemp.imm:=lval;
               addii(inst,info,ii_sub,op1,optemp,op0);
               i_free(info,context,optemp);
               end if;

             -- BT <registr>,<registr>
             addii(inst,info,ii_bt,op2,op1,op0);


         when others do verify(431,true);
         end case;

    -- pamˆŸ
    when io_mem do
       size:=unidata_size_to_unsigned(er^.t.getsize);

       -- a co lev˜ operand ?
       case op1.optype
         -- p©¡m  hodnota
         when io_imm do
             -- ode‡¡st doln¡ mez b ze mno‘iny
             op1.imm-lval;

             -- vypo‡¡tat velikost mno‘iny v bitech smˆrem dol– zarovnanou na 32 bit–
             bitsize:=(op2.size div 4)*32;

             -- mno‘ina m  1, 2 nebo 3 byty
             if op2.size<4 then
               -- pot©ebujeme pracovn¡ registr
               newopreg(inst,info,context,optemp,4,irm_int,op0);

               -- 3 byty
               if op2.size=3 then
                 -- na‡¡st horn¡ byte
                 shiftop(op2,2);
                 op2.size:=1;
                 addii(inst,info,ii_movzx,optemp,op2,op0);
                 addii(inst,info,ii_shl,optemp,op_16,op0);

                 -- na‡¡st doln¡ dva byty
                 unshiftop(op2,2);
                 op2.size:=2;
                 optemp.size:=2;
                 op1.reg.reg:=resizereg(op1.reg.reg,4);
                 addii(inst,info,ii_mov,optemp,op2,op0);
                 optemp.size:=4;
                 op1.reg.reg:=resizereg(op1.reg.reg,4);

               -- 1 nebo 2 byty
               else
                 -- na‡¡st doln¡ dva byty
                 addii(inst,info,ii_movzx,optemp,op2,op0);
                 end if;

               -- uvolnit p–vodn¡ operand
               i_free(info,context,op2);

               -- a nahradit ho hodnotou v registru
               op2:=optemp;

             -- index spad  pod hranici 32bitovˆ zaokrouhlen‚ velikosti mno‘iny
             elsif op1.imm<bitsize then
               -- vypo‡¡tat offset do mno‘iny
               op2.disp+op1.imm shr timm32(5);

               -- z ‡¡sla bitu n s od teƒ zaj¡m  jen spodn¡ch 5 bit–
               op1.imm and timm32(2$1_1111);

               -- z cel‚ mno‘iny n s nyn¡ zaj¡maj¡ jen ‡ty©i byty
               op2.size:=4;

             -- index spad  nad hranici 32bitovˆ zaokrouhlen‚ velikosti mno‘iny
             elsif op1.imm>=bitsize then
               verify(495,op2.size<4);

               -- vypo‡¡tat ‡¡slo bitu v r mci posledn¡ch ‡ty© byt–
               op1.imm-unsigned_to_imm32(op2.size-4)*timm32(8);

               -- vypo‡¡tat offset na posledn¡ ‡ty©i byty mno‘iny
               shiftop(op2,t_signed(op2.size-4));

               -- z cel‚ mno‘iny n s nyn¡ zaj¡maj¡ jen ‡ty©i byty
               op2.size:=4;

             -- jin˜ p©¡pad by nemˆl nastat
             else
               verify(496,true);
               end if;

             -- ‡¡slo bitu je teƒ 8-mi bitov‚ mezi 0..31
             op1.size:=1;

             -- BT <pamˆŸ>,<p©¡m  hodnota>
             addii(inst,info,ii_bt,op2,op1,op0);


         -- registr
         when io_reg do
             -- procesor p©istupuje k pamˆti po 32bitov˜ch slovech,
             -- tak‘e mus¡me opravit velikost operandu
             -- if op2.size mod 4<>0 then unimplemented(134);

             -- p©ev‚st i druh˜ operand na 32 bit–
             op1.size:=4;
             op1.reg.reg:=resizereg(op1.reg.reg,4);

             -- ode‡¡st doln¡ mez
             if lval<>timm32(0) then
               nullop(optemp,io_imm);
               optemp.imm:=lval;
               addii(inst,info,ii_sub,op1,optemp,op0);
               i_free(info,context,optemp);
               end if;

             -- instrukce BT akceptuje jen 32bitov‚ operandy, i kdy‘ pracuje s libovolnˆ dlouh˜mi
             op2.size:=4;

             -- %%X N sleduj¡c¡ instrukce m–‘e obecnˆ zp–sobit Access Violation, pokud
             -- bude konec mno‘iny, jej¡‘ velikost nebude n sobkech 4, le‘et na hranici
             -- str nky. Spr vnˆ by mˆla zavolat nˆjak  RTL funkce, kter  provede stejn˜
             -- rozhodovac¡ proces jako v p©edchoz¡ variantˆ OP1.OPTYPE=IO_IMM.

             -- BT <pamˆŸ>,<registr>
             addii(inst,info,ii_bt,op2,op1,op0);


         when others do verify(433,true);
         end case;

    when others do verify(430,true);
    end case;

  -- uvolnit operandy (OPTEMP u‘ je uvolnˆn˜)
  i_free(info,context,op1);
  i_free(info,context,op2);

  -- v˜sledek
  nullop(vysl,io_cc);
  if expr^.oper=op_notin
    then vysl.cc:=ic_nc;
    else vysl.cc:=ic_c;
    end if;
  end i_gen_op_in_set;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign_pointer : topergen =
-- P©i©azen¡ pointer–.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  newcontext       : iexprcontext;               -- kontext generov n¡ podv˜razu
  op1              : ioper;                      -- lev˜ operand
  op2              : ioper;                      -- prav˜ operand
  optemp           : ioper;                      -- pomocn˜ registr
  size             : t_unsigned32;               -- velikost pointeru
  i                : t_unsigned;

begin
  verify(502,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  -- velikost pointeru
  size:=unidata_size_to_unsigned(el^.t.getsize);

  --- p©i©azen¡ NIL ---
  if x_is_nil(er) then
    -- vygenerovat lev˜ podv˜raz
    i_newcontext(context,newcontext,lm_gen,el^.t.getctype);
    i_load(inst,info,newcontext,context,el,op1);

    -- vynulovat
    i_gen_fillz_static(inst,info,context,op1,size);

    -- uvolnit operand
    i_free(info,context,op1);

  --- p©i©azen¡ jin‚ho pointeru ---
  else
    -- vygenerovat a na‡¡st oba operandy
    i_load_binary_pointer(inst,info,context,expr,el^.t.getctype,el,er,op1,op2);

    -- p©i©adit
    case size
      -- p–jde to mo‘n  jednodu¨e
      when 4 do
          if op2.optype in ioptypeset:[io_imm,io_reg]

            -- hodnota je v registru nebo je to konstanta
            then addii(inst,info,ii_mov,op1,op2,op0)

            -- mus¡me p©es pomocn˜ registr
            else
              -- alokovat registr
              newopreg(inst,info,context,optemp,4,irm_int,op0);

              -- p©esunout
              addii(inst,info,ii_mov,optemp,op2,op0);
              addii(inst,info,ii_mov,op1,optemp,op0);

              -- uvolnit operand
              i_free(info,context,optemp);
              end if;


      -- rozhodnˆ mus¡me p©es registry
      when 8,12,16 do
          -- alokovat registr
          newopreg(inst,info,context,optemp,4,irm_int,op0);

          -- operandy budeme zpracov vat po 4bytov˜ch kousc¡ch
          op1.size:=4;
          op2.size:=4;

          -- p©esunout
          for i in 1..size div 4 loop
            -- p©esunout jednu ‡tve©ici
            addii(inst,info,ii_mov,optemp,op2,op0);
            addii(inst,info,ii_mov,op1,optemp,op0);

            -- posunout adresy obou operand–
            shiftop(op1,4);
            shiftop(op2,4);
            end loop;

          -- uvolnit operand
          i_free(info,context,optemp);


      when others do verify(503,true);
      end case;
    end if;

  -- v˜sledek: nic
  nullop(vysl,io_none);  
  end i_gen_op_assign_pointer;



----------------------------------------------------------------------------------------------------
procedure i_gen_op_assign : topergen =
-- Univerz ln¡ p©i©azen¡.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- lev˜ operand
  op1size          : ioper;                      -- :size lev‚ho operandu
  op1edi           : ioper;                      -- adresa lev‚ho operandu v EDI
  op2              : ioper;                      -- prav˜ operand
  op2size          : ioper;                      -- :size prav‚ho operandu
  size             : t_unsigned32;               -- velikost operandu
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  tg_ok            : itarget;                    -- c¡l skoku po porovn n¡ velikost¡

begin
  verify(140,expr^.arity<>eoa_2);

  -- podv˜razy
  expr^.get(el,er);

  if x_has_dynamic_size(el)

    -- lev˜ operand m  dynamickou velikost
    then
      {verify(517,not (rta_size in el^.rta_used{%%ATTR}));}

      -- vygenerovat lev˜ operand
      i_newcontext(context,newcontext,lm_addr_attr,nil);
      i_setrpref(newcontext,in_edi,irm_addr);
      i_load(inst,info,newcontext,context,el,op1);

      -- obnovit registry
      i_refresh(inst,info,context,op1);

      -- pro atribut bude pot©eba registr ECX
      nullop(op1size,io_reg);
      op1size.size:=idefregsize;
      i_use(inst,info,context,ir_ecx,op1size.reg,idefregsize);
    {
      -- na‡¡st :size
      i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);
    }
      -- je k dispozici p©¡mo :size
      if rta_size in el^.rta_used{%%ATTR} then
        -- na‡¡st :size
        i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_size,op1size);

      -- je k dispozici jen :last
      elsif rta_last in el^.rta_used{%%ATTR} then
        -- na‡¡st :last
        i_gen_load_rtattrib_value(inst,info,context,el^.rta_used{%%ATTR},op1,rta_last,op1size);

        -- vyn sobit velikost¡ prvku
        i_gen_mul_reg(inst,info,context,op1size,unidata_size_to_imm32(el^.t.getctype^.base.getctype^.size));

      -- co si m me po‡¡t bez dynamick‚ho atributu ?
      else
        verify(517,true)
        end if;

      -- registr EDI
      newopuse(inst,info,context,op1edi,idefregsize,ir_edi);

      -- na‡¡st adresu promˆnn‚ do EDI
      op1.size:=lpointer32;
      addii(inst,info,ii_mov,op1edi,op1,op0);

      if x_is_nil(er) {er^.t.stype=dt_uninil}

        -- p©i©azen¡ NIL
        then
          -- ulo‘it NIL
          i_gen_fillz_dynamic(inst,info,context,op1edi,op1size);

          -- uvolnit operandy
          i_free(info,context,op1);
          i_free(info,context,op1edi);
          i_free(info,context,op1size);

        -- p©i©azen¡ konkr‚tn¡ hodnoty
        else
          ---- kontrola velikosti ----
          -- na‡¡st adresu :size prav‚ho operandu
          if x_has_dynamic_size(er)

            -- prav˜ operand m  t‚‘ dynamickou velikost
            then
              verify(518,not (rta_size in er^.rta_used{%%ATTR}));

              -- vygenerovat prav˜ operand
              i_newcontext(context,newcontext,lm_addr_attr,nil);
              i_setrpref(newcontext,in_esi,irm_addr);
              i_load(inst,info,newcontext,context,er,op2);

              -- obnovit registry
              i_refresh(inst,info,context,op2);

              -- ur‡it adresu :size

              -- pro atribut bude pot©eba registr ECX
              nullop(op1size,io_reg);
              op1size.size:=idefregsize;
              i_use(inst,info,context,ir_ecx,op1size.reg,idefregsize);

              -- na‡¡st :size
              i_gen_load_rtattrib_addr({inst,info,context,}er^.rta_used{%%ATTR},op2,rta_size,op2size);

            -- prav˜ operand m  statickou velikost
            else
              -- na‡¡st velikost prav‚ho operandu
              nullop(op2size,io_imm);
              op2size.imm:=unidata_size_to_imm32(er^.t.getsize);
              end if;

          -- alokovat c¡l skoku
          newtarget(info,tg_ok);

          -- porovnat s ECX
          addii(inst,info,ii_cmp,op1size,op2size,op0);
          addjump(inst,info,ic_e,tg_ok);

          -- vyvolat v˜jimku Constraint_Error
          -- %%X

          -- c¡l skoku na toto m¡sto
          settarget(info,tg_ok,getaddr(inst));


          ---- p©i©azen¡ hodnoty ----
          if x_has_dynamic_size(er)

            -- prav˜ operand s dynamickou velikost¡ => ji‘ zn me jeho adresu
            then
              -- nic nedˆlat, verifikace 518 na "rta_size in er^.rta" u‘ probˆhla v˜¨e

            -- prav˜ operand se statickou velikost¡ => vygenerovat
            else
              -- vygenerovat prav˜ operand
              i_newcontext(context,newcontext,lm_addr_attr,nil);
              i_load(inst,info,newcontext,context,er,op2);
              end if;

          -- obnovit registry
          i_refresh(inst,info,context,op1);
          i_refresh(inst,info,context,op2);

          -- operandy by nemˆly spot©ebovat moc registr–
          i_gen_reduceop(inst,info,context,op1);
          i_gen_reduceop(inst,info,context,op2);

          -- p©esunout (jako pole o prvc¡ch velikosti 1)
          i_gen_move_array(inst,info,context,op2,op1,op1size,1);

          -- uvolnit operandy
          i_free(info,context,op1);
          i_free(info,context,op1edi);
          i_free(info,context,op1size);
          i_free(info,context,op2);
          i_free(info,context,op2size);

          --unimplemented(151);
          end if;

    -- lev˜ operand m  statickou velikost
    else
      -- velikost operandu
      size:=unidata_size_to_unsigned(expr^.t.getsize);

      ----- %%X P©ipom¡nky ---------------------------------------------------
      -- -- Co kdy‘ se lev˜ a prav˜ operand p©ekr˜vaj¡ ?
      -- -- Kdy‘ zb˜vaj¡ t©i byty, mohu p©eci kop¡rovat p©edchoz¡ byte podruh‚
      --    (u¨et©¡ se 4 instrukce, tak‘e penalta za nezarovanan˜ p©¡stup nevad¡)
      -- -- Pokud to jde, tak zkusit REP MOVSD - od nˆjak‚ velikosti bloku by to
      --    mohlo b˜t rychlej¨¡, i kdybych musel ‡arovat s registrama (PUSH).
      -- -------------------------------------------------------------------------

      if x_is_nil(er)

        -- p©i©azen¡ NIL
        then
          -- vygenerovat lev˜ podv˜raz
          i_newcontext(context,newcontext,lm_gen,nil);
          i_setrpref(newcontext,in_edi,irm_addr);
          i_load(inst,info,newcontext,context,el,op1);

          -- obnovit registry
          i_refresh(inst,info,context,op1);

          -- ulo‘it NIL
          i_gen_fillz_static(inst,info,context,op1,size);

          -- uvolnit operandy
          i_free(info,context,op1);

        -- p©i©azen¡ konkr‚tn¡ hodnoty
        else
          if size=1 or size=2 or size=4{%%TODO(SET) size in [1,2,4]}

            -- p©¡zniv  velikost
            then
              -- vygenerovat a na‡¡st operandy
              i_load_binary(inst,info,context,iop_cc,expr,expr^.t.getctype,el,er,op1,op2);

              -- p©i©azen¡
              -- Ondra 11.9.2002 : Hodnota m–‘e b˜t reprezentov na i k¢dem podm¡nky
              if op2.optype=io_cc
                then addset(inst,info,op2.cc,op1);
                else addii(inst,info,ii_mov,op1,op2,op0);
                end if;

              -- uvolnit prav˜ operand
              i_free(info,context,op2);

              -- v˜sledek
              vysl:=op1;

            -- nˆco jin‚ho
            else
              -- vygenerovat a na‡¡st prav˜ podv˜raz (m–‘e b˜t i na stacku)
              i_newcontext(context,newcontext,lm_gen,nil);
              i_setoutpref(newcontext,iop_stack);
              i_load(inst,info,newcontext,context,er,op2);

              -- vygenerovat lev˜ podv˜raz
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,el,op1);

              -- obnovit registry
              i_refresh(inst,info,context,op1);
              i_refresh(inst,info,context,op2);

              -- operandy by nemˆly spot©ebovat moc registr–
              i_gen_reduceop(inst,info,context,op1);
              i_gen_reduceop(inst,info,context,op2);

              -- kop¡rovat
              case op2.optype
                when io_stack do i_gen_pop_static(inst,info,context,op1,size);
                when io_mem   do i_gen_move_static(inst,info,context,op2,op1,size);
                when others   do verify(488,true);
                end case;

              -- uvolnit operandy
              i_free(info,context,op1);
              i_free(info,context,op2);

              -- %%X A co v˜sledek ??
              end if;
          end if;
      end if;
  end i_gen_op_assign;



----------------------------------------------------------------------------------------------------
procedure i_gen_operator (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpoper;                -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
var
  stype                : tdatatype;      -- spole‡n˜ typ operand–

begin
  case expr^.t.tview
    -- Partial view/Unchecked view
    when tview_partial, tview_unchecked do
        case expr^.oper
          -- p©i©azen¡
          when op_assign    do i_gen_op_assign(inst,info,context,expr,vysl);

          when others do verify(187,true);
          end case;


    -- Full view
    when tview_full     do
        -- zjistit typ spole‡n˜ typ operand–
        stype:=x_resolve_opdtype(expr,true);

        -- vygenerovat
        verifyx(99,^opertab[expr^.oper,stype]=nil,expr^.pos);
        opertab[expr^.oper,stype]^(inst,info,context,expr,vysl);


    when others do verifyx(186,true,expr^.pos);
    end case;
  end i_gen_operator;



----------------------------------------------------------------------------------------------------
procedure i_gen_unary (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpunary;               -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  op1              : ioper;                      -- operand
  ii               : iinstr;                     -- instrukce
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el);

  -- "architektura" Intel t¡hne k nep©¡jemn˜m v˜jimk m,
  -- tak‘e ka‘d  instrukce vy‘aduje jin‚ zpracov n¡
  case expr^.oper
    -- inkrementace/dekrementace, un rn¡ m¡nus, bitov  negace
    when un_succ,un_pred,un_minus,un_bitnot do
        -- vygenerovat podv˜raz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        i_refresh(inst,info,context,op1);

        -- instrukce
        case expr^.oper
          when un_minus  do ii:=ii_neg;
          when un_succ   do ii:=ii_inc;
          when un_pred   do ii:=ii_dec;
          when un_bitnot do ii:=ii_not;
          when others do verify(47,true);
          end case;
        addii(inst,info,ii,op1,op0,op0);

        -- v˜sledek
        vysl:=op1;


    -- logick  negace
    when un_not do
        -- vygenerovat podv˜raz
        if expr^.assign
          then
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,el,op1)
          else
            i_newcontext(context,newcontext,lm_reg_all,expr^.t.getctype);
            i_load(inst,info,newcontext,context,el,op1);
            end if;

        -- obnovit registry
        i_refresh(inst,info,context,op1);

        -- co je operand za‡ ?
        case op1.optype
          -- podm¡nka => znegovat
          when io_cc  do op1.cc:=icondneg[op1.cc];

          -- registr => xornout hodnotou (true xor false)
          -- %%X Pro typ se specifikac¡ reprezentace True a False se negace
          -- dˆl  takhle: xor op1,(true xor false)
          when io_reg, io_mem do addii(inst,info,ii_xor,op1,op_1,op0);

          when others do verify(470,true);
          end case;

        -- v˜sledek
        vysl:=op1;


    -- absolutn¡ hodnota
    when un_abs do
        unimplemented(29);


    when others do verify(46,true);
    end case;
  end i_gen_unary;



----------------------------------------------------------------------------------------------------
procedure i_gen_rtattrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpnode{component};     -- strom
    vysl           : in ioper) =                 -- v˜sledek v˜po‡tu v˜razu (adresa)
-- Generov n¡ dynamick˜ch atribut–.
-- VYSL obsahuje adresu bloku tvaru:
--     +----------+
--     | atributy | +4 a‘ +n
--     +----------+
--     | adresa   | +0
--     +----------+
-- Atributy jsou z t‚to struktury zkop¡rov ny do obdobn‚ (bez pole adresa),
-- kter  le‘¡ na b zov‚ adrese dan‚ registrem CONTEXT.RTABASE.
----------------------------------------------------------------------------------------------------
var
  opsrc            : ioper;                      -- ukazatel na zdrojovou oblast
  optemp           : ioper;                      -- pracovn¡ registr
  dattrib          : rtattribset;                -- dynamick‚ atributy v˜razu
  attrib           : rtattrib;                   -- pr vˆ zpracov van˜ atribut
  srange           : pentity_type;               -- rozsah pole/©etˆzce
  x                : timm32;

begin
  -- chce to v–bec nˆjak‚ atributy ?
  if context.rta=rtattribset:[] then return; end if;

  -- jak‚ atributy jsou k dispozici ?
  dattrib:=context.rta*expr^.rta_used{%%ATTR};

  -- %%TECH Nepou‘¡v  se COMPOSEOP, mˆn¡ se jen DISP

  -- p©ipravit ukazatel do zdrojov‚ oblasti
  verify(333,vysl.optype<>io_mem);
  opsrc:=vysl;
  opsrc.disp+imm32_lpointer32;
  getrtattribsetsize(expr^.rta_used{%%ATTR},x);
  opsrc.disp+x;

  -- stack roste shora --> dol–
  for attrib in reverse rtattrib loop
    -- posunout offset ve zdrojov‚ oblasti
    if attrib in expr^.rta_used{%%ATTR} then
      opsrc.disp-unidata_size_to_imm32(cpu32_rtattribsize[attrib]);
      end if;

    -- ur‡it velikost atributu
    opsrc.size:=unidata_size_to_unsigned(cpu32_rtattribsize[attrib]);

    -- zkop¡rovat dynamick˜ atribut
    if attrib in dattrib then
      -- sta‡¡ jeden PUSH
      -- %%X Nebude se ten PUSH chovat divnˆ,
      -- kdyby n hodou bylo OPSRC.SIZE<>4 ?
      addii(inst,info,ii_push,opsrc,op0,op0);

    -- ur‡it staticky
    elsif attrib in context.rta then
      -- p©ipravit druh˜ operand
      case attrib
        -- ^instance
        when rta_instance do
            -- statick˜ pointer na instanci je z©ejmˆ NIL
            optemp:=op_0;


        -- :tag
        when rta_tag      do
            -- je to tagged typ ?
            if tf_tagged in expr^.t.getctype^.tflags

              -- ano => pou‘¡t re ln˜ tag
              then
                nullop(optemp,io_imm);
                optemp.rtype:=irt_symbol;
                optemp.psym:=expr^.t.getctype;
                optemp.size:=opsrc.size;

              -- ne => ulo‘it pr zdn˜ tag
              else
                optemp:=op_0;
                end if;


        -- :size
        when rta_size     do
            nullop(optemp,io_imm);
            optemp.size:=opsrc.size;
            optemp.imm:=unidata_size_to_imm32(expr^.t.getsize);


        -- :last
        when rta_last     do
            -- p©ipravit operand
            nullop(optemp,io_imm);
            optemp.size:=opsrc.size;

            -- li¨¡ se pro pole a pro ©etˆzce
            verify(335,not t_is_sts(expr^.t,dts_index));
            srange:=expr^.t.getctype^.srange.getctype;
            case expr^.t.stype
              -- pole
              when dt_array, dt_uarray do
                  -- :last odpov¡d  :length-1
                  optemp.imm:=uniint_to_imm32(uniint_length(srange^.lval,srange^.hval))-timm32(1);


              -- ©etˆzec
              when dt_string, dt_ustring do
                  -- :last je :last
                  optemp.imm:=uniint_to_imm32(srange^.hval);


              when others do verify(336,true);
              end case;


        when others do verify(332,true);
        end case;

      -- ulo‘it
      addii(inst,info,ii_push,optemp,op0,op0);
      end if;
    end loop;
  end i_gen_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_component (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpcomponent;           -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du komponenty.
----------------------------------------------------------------------------------------------------
var
  pcode            : pentity_code;               -- nad©azen˜ podprogram
  pvar             : pentity_var;                -- promˆnn  pro zjednodu¨en¡
  ofs              : timm32;                     -- offset promˆnn‚
  optemp           : ioper;                      -- pracovn¡ operand
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  nindex           : t_unsigned;                 -- index vno©en¡ promˆnn‚

begin
  case expr^.nclass
    -- nic (kvalifik tor) => jen vygenerovat podv˜raz
    when nc_none do
        if expr^.sub=nil
          -- nem me ani podv˜raz
          then nullop(vysl,io_none)

          -- podv˜raz je k dispozici => vygenerovat
          else
            -- vygenerovat podv˜raz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            i_refresh(inst,info,context,vysl);
            end if;


    -- promˆnn 
    when nc_var do
        if (expr^.sub=nil) or {not} (expr^.sub^.nclass {in ncs_value}<>nc_var)

          -- p©¡mo promˆnn 
          then
            verify(91,expr^.s.psym=nil);

            -- promˆnn  pro zjednodu¨en¡
            pvar:=pentity_var(expr^.s.psym);

            case pvar^.mclass
              -- automatick 
              when mc_auto do
                  -- nemohla by to b˜t promˆnn  z nad©azen‚ho podprogramu ?
                  nindex:=0;
                  if inst.nested.nlist<>nil and then inst.nested.nlist^:length<>0 then
                    nindex:=inst.nested.nlist^:length;
                    while nindex<>0 and then inst.nested.nlist^[nindex]<>pvar^.context.entity loop
                      pred nindex;
                      end loop;
                    end if;

                  -- p©ipravit operand
                  if nindex=0

                    -- je to p©¡mo lok ln¡ promˆnn 
                    then
                      -- frame pointer jako z klad adresy
                      nullop(vysl,io_mem);
                      vysl.base.reg:=istackframereg[inst.frame];

                      -- zjistit adresu promˆnn‚
                      getvaraddr(inst,info,pvar,vysl.disp);

                    -- je z nad©azen‚ho podprogramu
                    else
                      -- adresa ulo‘en‚ho frame pointeru
                      nullop(optemp,io_mem);
                      optemp.base.reg:=istackframereg[inst.frame];
                      optemp.size:=4;
                      optemp.disp:=signed_to_imm32(-t_signed(nindex*4));

                      -- budeme pot©ebovat registr na frame pointer
                      newopreg(inst,info,context,vysl,4,irm_addr,op0);

                      -- na‡¡st frame pointer
                      addii(inst,info,ii_mov,vysl,optemp,op0);

                      -- zmˆnit operand na adresn¡
                      vysl.base:=vysl.reg;
                      vysl.optype:=io_mem;
                    { %%X
                      Dva z sadn¡ probl‚my:
                        -- ENTER akceptuje pouze 16bitovou velikost prostoru na stacku -> nutn‚
                           minim lnˆ o¨et©it p©¡pad s v¡ce ne‘ 64 KB lok ln¡ch promˆnn˜ch a tak‚
                           zpˆtn‚ nastavov n¡ hodnoty - nˆkdy 32 jindy 16 bit–,
                        -- v dobˆ generov n¡ vno©en‚ procedury nen¡ je¨tˆ vygenerovan  nad©azen 
                           procedura -> generovat v opa‡n‚m po©ad¡ a pro vno©enou volit default
                           konvence.
                    }
                      -- nad©azen˜ podprogram
                      pcode:=inst.nested.nlist^[nindex];
                      verify(501,picodegen_subprog(pcode^.codegen)^.ifirst<>picodegen_subprog(pcode^.codegen)^.ilast);

                      -- zjistit adresu promˆnn‚
                      getvaraddr(picodegen_subprog(pcode^.codegen)^.ifirst^,info,pvar,vysl.disp);
                      end if;

                  -- je to parametr ? => pak mus¡me upravit mno‘inu
                  -- pou‘iteln˜ch run-time atribut–
                  -- %%X Tohle je trochu Black Magic a z plata. Spr vnˆ by se
                  -- to mˆlo dˆlat v dvoupr–chodov‚ glob ln¡ anal˜ze, jen‘e
                  -- tu zat¡m nem me a takhle to kupodivu taky funguje.
                  --   Nestane se, ‘e by v CONTEXT.RTA byly i atributy, kter‚
                  -- touto £pravou ztrat¡m, proto‘e p©i po‘adavku na takov‚
                  -- atributy by se vy‘ daly i pro tento parametr (aspo¤ by
                  -- to tak mˆlo b˜t).
                  verify(334,context.rta*(pvar^.rta_avail{allrta}-pvar^.rta_used{usedrta})<>rtattribset:[]);
                  expr^.rta_used{%%ATTR}:=pvar^.rta_used{usedrta};

                  -- chceme ulo‘it i dynamick‚ atributy ?
                  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                    i_gen_rtattrib(inst,info,context,expr,vysl);
                    end if;

                  ----- %%TECH Implicitn¡ dereference --------------------
                  --
                  --------------------------------------------------------
                  if (pvar^.vmode=vm_ref)
                  and (context.mode<>lm_addr_attr) then
                    newopreg(inst,info,context,optemp,4,irm_addr,vysl);
                    vysl.size:=4;
                    addii(inst,info,ii_mov,optemp,vysl,op0);
                    i_free(info,context,vysl);
                    nullop(vysl,io_mem);
                    vysl.base:=optemp.reg;
                    end if;

                  -- velikost operandu
                  if expr^.t.hassize
                    then vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
                    else vysl.size:=0;
                    end if;


              -- statick 
              when mc_static do
                  -- adresa promˆnn‚
                  nullop(vysl,io_mem);
                  vysl.rtype:=irt_symbol;
                  vysl.psym:=expr^.s.psym;
                  vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);

                  -- chceme ulo‘it i dynamick‚ atributy ?
                  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                    i_gen_rtattrib(inst,info,context,expr,vysl);
                    end if;


              -- promˆnn  t©¡dy
              when mc_class do
                  -- na‡¡st adresu slo‘ky
                  i_gen_this_addr(inst,info,context,expr^.t.getsize,pvar^.addr,vysl);
              {
                  -- na‡¡st pointer na t©¡du
                  nullop(optemp,io_mem);
                  optemp.base.reg:=istackframereg[inst.frame];
                  imm32load(optemp.disp,inst.profile.thisofs);
                  optemp.size:=lpointer32;
                  i_gen_loadreg(inst,info,context,optemp,true,irm_addr);

                  -- p©i‡¡st offset slo‘ky
                  nullop(vysl,io_mem);
                  i_use(inst,info,context,optemp.reg.reg,vysl.base,idefregsize);
                  udtoimm32(pvar^.addr,vysl.disp);
                  vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);

                  -- uvolnit pomocn˜ operand
                  i_free(info,context,optemp);
              }
                  -- chceme ulo‘it i dynamick‚ atributy ?
                  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
                    i_gen_rtattrib(inst,info,context,expr,vysl);
                    end if;


              -- %%X
              when others do verify(71,true);
              end case;

          -- selektor
          else
            verify(90,(expr^.s.psym=nil) or{and} not (pentity_var(expr^.s.psym)^.mclass in mcs_offset));

            -- vygenerovat podv˜raz
            i_newcontext(context,newcontext,lm_gen,nil);
            i_load(inst,info,newcontext,context,expr^.sub,vysl);

            -- obnovit registry
            i_refresh(inst,info,context,vysl);
            verify(92,vysl.optype<>io_mem);

            -- adresa
            vysl.disp+unidata_addr_to_imm32(pentity_var(expr^.s.psym)^.addr{pivarlink(pentity_var(expr^.s.psym)^.codegen)^.addr});

            -- velikost operandu
            vysl.size:=unidata_size_to_unsigned(pentity_var(expr^.s.psym)^.typ.getctype^.size);

            -- chceme ulo‘it i dynamick‚ atributy ?
            if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
              i_gen_rtattrib(inst,info,context,expr,vysl);
              end if;
            end if;


    -- procedura
    when nc_proc do
        -- p©¡padn˜ podv˜raz ur‡uje instanci, ale co s n¡ ?
        -- to aŸ si vy©e¨¡ volaj¡c¡ procedura

        -- vr tit adresu procedury
        i_gen_subprogram_address(pentity_subprogram(expr^.getsymbol),false,vysl);


    -- zpr va
    when nc_message     do
        -- na p©¡padn˜ podv˜raz se ka¨le, nem  v˜znam

        -- vr tit ‡¡slo zpr vy
        nullop(vysl,io_imm);
        vysl.rtype:=irt_symbol;
        vysl.psym:=expr^.s.psym;


    when others do verify(621,true);
    end case;
  end i_gen_component;



----------------------------------------------------------------------------------------------------
procedure i_gen_imm (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpimm;                 -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du p©¡m‚ hodnoty.
----------------------------------------------------------------------------------------------------
var
  x                : t_unsigned;

begin
  if context.mode in lms_addr

    -- zaj¡m  n s adresa hodnoty
    then
      -- adresa
      nullop(vysl,io_mem);
      vysl.rtype:=irt_imm;
      vysl.pexpr:=expr;
      vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);

      -- chceme ulo‘it i dynamick‚ atributy ?
      if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
        i_gen_rtattrib(inst,info,context,expr,vysl);
        end if;

    -- zaj¡m  n s hodnota samotn 
    else
      case expr^.imm.ic
        -- ordin ln¡ hodnota
        when ic_ordinal do
            nullop(vysl,io_imm);
            -- %%X
            --udtouint(expr^.t.typ^.size,vysl.size);
            if t_is_sts(expr^.t,dts_unitype)
              then vysl.size:=0;
              else vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
              end if;
            vysl.imm:=uniint_to_imm32(expr^.imm.ui);

         { No a to je pr vˆ ten omyl. Tohle se mus¡ ©e¨it s vyu‘it¡m NATTYP
            o £rove¤ v˜¨ (v I_LOAD).

            {..TECH U ordin ln¡ch hodnot mi na velikosti nijak zvl ¨Ÿ nesejde.   }
            -- Emitor instrukc¡ se p©izp–sob¡ a kompatibilitu by mˆly zajistit
            -- p©edchoz¡ f ze p©ekladu. Nicm‚nˆ stejnˆ by po‘adovan  velikost
            -- konstanty mˆla b˜t alespo¤ takov , jako je jej¡ skute‡n  velikost.
            {..X Bohu‘el nem m jak to otestovat... }
            {verify(129,not (expr^.t.stype in dts_unitype) and uishrink(expr^.imm.ui,,));}
            vysl.size:=0;
          { P–vodn¡, m lo funk‡n¡ verze
            (var(unsigned 32)<=imm(unsigned 16) --> cmp reg32,imm16)

            if expr^.t.stype in dts_unitype
              then vysl.size:=0;
              else udtouint(expr^.t.typ^.size,vysl.size);
              end if;
          }
         }


        -- NIL
        when ic_nil     do
            x:=unidata_size_to_unsigned(context.outtyp.size);
            verifyx(556,x<>1 and x<>2 and x<>4{%%TODO(SET) not (x in [1,2,4])},expr^.pos);
            nullop(vysl,io_imm);
            vysl.size:=0;
            -- %%X No a tady bych pot©eboval vˆdˆt po‘adovan˜ typ, nebo ne ?


        -- kondenzovan‚ pole nebo agreg t
        when ic_condensed,ic_array,ic_set,ic_record do
            {verifyx(530,((expr^.imm.ic=ic_set) and (expr^.imm.sitems^.lcount>expr^.imm.sitems^.lsize))
                     or ((expr^.imm.ic=ic_array) and (expr^.imm.aitems^.lcount>expr^.imm.aitems^.lsize))
                     or ((expr^.imm.ic=ic_record) and (expr^.imm.ritems^.lcount>expr^.imm.ritems^.lsize)),expr^.pos);}
            {!!}
            nullop(vysl,io_mem);
            vysl.rtype:=irt_imm;
            vysl.pexpr:={^}expr{^.imm};
            vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);


        -- %%X
        when others do verify(72,true);
        end case;
      end if;
  end i_gen_imm;



----------------------------------------------------------------------------------------------------
procedure i_gen_aggregate (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpaggregate;           -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ agreg tu.
-- Pozn mka: Obsluha agreg t– je dost natvrdo (=neoptim lnˆ), proto‘e je to
-- pomˆrnˆ komplikovan  z le‘itost a babrat se s t¡m budu a‘ ve 4.0.1.
----------------------------------------------------------------------------------------------------
var
  opaggr           : ioper;                      -- pracovn¡ prostor pro agreg t
  optemp           : ioper;                      -- pracovn¡ operand
  arglist          : pexpitem;                   -- seznam argument–

begin
  -- %%TECH Optimaliz tor zajistil, ‘e agreg t, kter˜ se dostane a‘ sem, m 
  -- zcela jistˆ alespo¤ jednu nekonstantn¡ slo‘ku (aŸ u‘ hodnotu, ‡i index),
  -- v¨echny ostatn¡ p©¡pady jsou konvertov ny na NT_IMM.

  case expr^.t.stype
    -- record
    when dt_record do unimplemented(152);

    -- pole
    when dt_array do
      {
        -- alokovat pracovn¡ prostor pro agreg t
        nullop(optemp,io_mem);
        optemp.base.reg:=istackframereg[inst.frame];
        optemp.size:=expr^.t.size;
        alloctemp(inst,info,optemp.size,optemp.disp);

        -- do pracovn¡ho prostoru nacpat konstantn¡ ‡ st agreg tu

        -- seznam argument–
        expr^.getarglist(arglist);

        -- zpracovat v¨echny slo‘ky agreg tu
        while arglist<>nil loop

          end loop;
      }
        unimplemented(165);


    -- neomezene pole
    when dt_uarray do unimplemented(155);

    -- ©etˆzec
    when dt_string,dt_ustring do unimplemented(153);

    -- mno‘ina
    when dt_set do unimplementedx(154,expr^.pos);

    -- ostatn¡ typy tu nemaj¡ co dˆlat
    when others do verify(473,true);
    end case
  end i_gen_aggregate;



----------------------------------------------------------------------------------------------------
procedure i_gen_call_subprogram (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- strom
    pproc          : in pentity_subprogram;      -- volan  procedura
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du vol n¡ procedury.
----------------------------------------------------------------------------------------------------
var
  arg              : pexpitem;                   -- skute‡n˜ parametr
  call             : icallconvention;            -- volac¡ konvence

    ------------------------------------------------------------------------------------------------
    procedure firstarg =
    -- Prvn¡ argument procedury (podle volac¡ konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;

    begin
      -- %%X ‡asem doplnit do stromu dvousmˆrnej seznam 

      -- prvn¡ argument v seznamu
      expr^.get(el,arg);

      -- dojet na konec
      if call in iccs_reverse then
        while (arg<>nil) and (arg^.next<>nil) loop arg:=pexpitem(arg^.next); end loop;
        end if;
      end firstarg;



    ------------------------------------------------------------------------------------------------
    procedure nextarg =
    -- Dal¨¡ argument procedury (podle volac¡ konvence).
    ------------------------------------------------------------------------------------------------
    var
      el           : pexpnode;
      a            : pexpitem;

    begin
      -- %%X ‡asem doplnit do stromu dvousmˆrnej seznam

      if call in iccs_reverse

        -- hledat p©edchoz¡
        then
          expr^.get(el,a);
          if arg=a
            then arg:=nil
            else
              while a^.next<>arg loop a:=pexpitem(a^.next); end loop;
              arg:=a;
              end if;

        -- dal¨¡
        else 
          arg:=pexpitem(arg^.next);
          end if;
      end nextarg;



var
  el               : pexpnode;                   -- lev˜ podv˜raz
  instance         : pexpnode;                   -- v˜raz ur‡uj¡c¡ instanci t©¡dy
  op1              : ioper;                      -- operand
  opnone           : ioper;                      -- pr zdn˜ v˜sledek
  ii               : iinstr;                     -- instrukce
  pinst            : picodeinst;                 -- instance volan‚ procedury
  ptyp             : pentity_type;               -- typ procedury
  resultsize       : t_unsigned;                 -- velikost n vratov‚ hodnoty
  alignedsize      : t_unsigned32;               -- zarovnan  velikost n vratov‚ hodnoty
  addr             : timm32;                     -- adresa z¡skan‚ho prostoru
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  optemp           : ioper;                      -- pracovn¡ operand
  tgcall           : itarget;                    -- c¡l skoku na vol n¡ procedury
  nclass           : nodeclass;                  -- p©evzat /ur‡en  t©¡da jm‚na procedury

begin
  -- pro neur‡it‚ p©¡pady p©edpokl dejme default volac¡ konvenci
  call:=icc_default;

  -- zvolit instanci procedury
  pinst:=nil;
  if (pproc<>nil) and (pproc^.etype=et_procedure) and (pproc^.codegen<>nil) then
    -- %%X zvolit instanci procedury
    pinst:=picodegen_subprog(pproc^.codegen)^.ifirst;

    -- volac¡ konvence
    if pinst<>nil
      -- podle zvolen‚ instance
      then call:=pinst^.profile.call;
      -- default konvence pro tuto proceduru
      else call:=picodegen_subprog(pproc^.codegen)^.def_call;
      end if;
    end if;

  -- lze-li to, tak z¡skat typ procedury, bude se hodit
  if pproc<>nil

    -- m me k dispozici konkr‚tn¡ proceduru
    then ptyp:=pproc^.typ.getutype

    -- z©ejmˆ je to pointer na proceduru
    else
      verify(510,expr^.sub^.ntype<>nt_deref);
      ptyp:=expr^.sub^.t.getctype;
      end if;
  verify(511,(ptyp<>nil) and (ptyp^.stype<>dt_procedure));

  -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUT ** z plata !!
  -- P©esunut¡m SAVEREGS tˆsnˆ p©ed instrukci CALL zabra¤uju rekurzivn¡mu
  -- pushov n¡ stejn˜ch registr–, kter‚ je zap©¡‡inˆno nˆjakou nedokonalost¡
  -- alok toru registr–, kterou se mi zat¡m nepoda©ilo vy©e¨it. Probl‚m spo‡¡v 
  -- v tom, ‘e schov n¡m registru se ztr c¡ informace o jeho (ne)pou‘it¡, tak‘e
  -- p©i rekurzivn¡m vol n¡ I_GEN_CALL_SUBPROGRAM se schov v  znova, co‘ m  za
  -- n sledek unimplemented(118) v I_RETRIEVE.
{
  -- ulo‘it v¨echny pou‘it‚ registry
  -- %%X Omezit jen na registry skute‡nˆ pou‘it‚ ve volan‚ procedu©e
  saveregs(inst,info,context);
}

  ---- rezervovat m¡sto pro n vratovou hodnotu ----
  if (expr^.t.tview<>tview_null) and (call in iccs_ret_stack) then
    if ptyp^.result^.pass in pps_ref
      -- odkazem
      then
        -- velikost n vratov‚ hodnoty
        resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

        -- alokovat, t©eba nˆkde na stacku, prostor pro n vratovou hodnotu
        newoptemp(inst,info,context,op1,resultsize);

        -- z¡skanou adresu p©ev‚st na absolutn¡
        i_gen_lea(inst,info,context,op1,in_none);

        -- ulo‘it na stack
        addii(inst,info,ii_push,op1,op0,op0);

        -- uvolnit operand
        i_free(info,context,op1);

      -- hodnotou
      else
        -- velikost v˜sledku
        resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

        -- zarovnat
        addalign(alignedsize,0,resultsize,istackalign);

        -- zkonvertovat na operand
        nullop(op1,io_imm);
        op1.imm:=unsigned_to_imm32(alignedsize);

        -- sn¡‘it hodnotu ESP o velikost promˆnn‚
        addii(inst,info,ii_sub,op_esp,op1,op0);

        -- uvolnit operand
        i_free(info,context,op1);
        end if;
    end if;

  ---- zpracovat argumenty ----
  firstarg;
  while (arg<>nil) loop
    if arg^.sub<>nil

      -- hodnota je explicitnˆ uvedena
      then
        if (pentity_param(arg^.sym)^.pass=pp_value) and x_is_nil(arg^.sub)

          -- speci ln¡ p©¡pad: p©ed v  se NIL hodnotou
          then
            i_gen_pushnil(inst,info,context,arg^.t.getctype^.size);

          -- v¨echny ostatn¡ p©¡pady
          else
            -- p©ipravit kontext
            case pentity_param(arg^.sym)^.pass
              -- hodnotou
              when pp_value     do
                  i_newcontext(context,newcontext,lm_push_value,arg^.t.getutype);
                  i_setoutpref(newcontext,iop_stack);


              -- odkazem
              when pp_ref       do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});

              -- odkazem, bez typov‚ kontroly
              when pp_unchecked do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});

              -- odkazem, v‡etnˆ odvozen˜ch typ–
              when pp_class     do i_newcontext(context,newcontext,lm_push_addr,nil{arg^.t.getutype});--unimplemented(74);

              -- odkazem, ©¡d¡c¡ parametr virtu ln¡ho vol n¡
              when pp_virtual   do unimplemented(82);

              when others do verify(63,true);
              end case;

            -- jak‚ dynamick‚ atributy n s zaj¡maj¡ ?
            newcontext.rta:=pentity_param(arg^.sym)^.rta_used{usedrta};

            -- parametr p©edan˜ hodnotou nem  dynamick‚ atributy
            verify(327,(pentity_param(arg^.sym)^.pass=pp_value) and (newcontext.rta<>rtattribset:[]));

            -- vygenerovat parametr
            i_load(inst,info,newcontext,context,arg^.sub,opnone);
            end if;

      -- pou‘¡t implicitn¡ hodnotu
      else
        unimplemented(176);
        end if;

    -- dal¨¡ parametr
    nextarg;
    end loop;

  ---- ulo‘it pointer na instanci a na‡¡st adresu procedury ----
  expr^.get(el,arg);
  if el=nil
    then nclass:=nc_proc
    else nclass:=el^.nclass;
    end if;
  case {el^.}nclass
    -- p©¡mo procedura
    when nc_proc do
        verify(380,{(el^.ntype<>nt_component) or (pexpcomponent(el)^.s.psym=nil)
                   or} not (pproc^.etype{pexpcomponent(el)^.s.psym^.etype} in ets_subprogram));

        ---- jak je to s pointerem na instanci ? ----
        case pproc^.instance {pentity_subprogram(pexpcomponent(el)^.s.psym)^.instance}
          -- nep©ed vat
          when tip_none     do { d l ji‘ nic nedˆlat };

          -- volitelnˆ p©edat, nen¡-li, pak NIL
          when tip_optional do
              -- naj¡t instanci
              x_classinstance(el^.sub,instance);

              if instance<>nil

                -- je k dispozici => vygenerovat podv˜raz
                then
                  i_newcontext(context,newcontext,lm_push_addr,nil);
                  i_load(inst,info,newcontext,context,instance,opnone);

                -- nen¡ k dispozici => ulo‘it aspo¤ NIL
                else
                  nullop(op1,io_imm);
                  op1.imm:=timm32(0);
                  op1.size:=4;
                  addii(inst,info,ii_push,op1,op0,op0);
                  end if;


          -- p©edat
          when tip_pass     do
              -- naj¡t instanci
              x_classinstance(el^.sub,instance);
              verify(381,instance=nil);

              -- vygenerovat podv˜raz
              i_newcontext(context,newcontext,lm_push_addr,nil);
              i_load(inst,info,newcontext,context,instance,op1);
              i_free(info,context,op1);


          -- virtu ln¡ vol n¡
          when tip_dispatch do
              verify(527,(el^.ntype<>nt_component) or (pexpcomponent(el)^.s.psym=nil) or (pexpcomponent(el)^.s.psym^.etype<>et_virtual));

              -- naj¡t instanci
              x_classinstance(el^.sub,instance);
              verify(526,instance=nil);

              -- vygenerovat podv˜raz
              i_newcontext(context,newcontext,lm_addr,nil);
              i_load(inst,info,newcontext,context,instance,op1);

              -- obnovit registry
              i_refresh(inst,info,context,op1);

              -- ulo‘it pointer na instanci na stack
              addii(inst,info,ii_push,op1,op0,op0);

              -- na‡¡st pointer na instanci do registru
              i_gen_loadreg(inst,info,context,nil,op1,true,irm_addr);

              -- sestavit adresn¡ operand ukazuj¡c¡ na tag
              op1.optype:=io_mem;
              op1.base:=op1.reg;
              op1.size:=4;
              shiftop(op1,imm32_to_signed(cpu32_class_tag));

              -- na‡¡st tag (=adresu deskriptoru typu) do registru
              i_gen_loadreg(inst,info,context,nil,op1,true,irm_addr);

              -- sestavit adresn¡ operand
              op1.optype:=io_mem;
              op1.base:=op1.reg;
              op1.size:=4;
              shiftop(op1,t_signed(iclassdesc:size+(pentity_virtual(pexpcomponent(el)^.s.psym)^.vindex-1)*4));

              --unimplemented(122);


          when others do verify(509,true);
          end case;

        ---- adresa procedury ----
        if pproc^{pentity_subprogram(pexpcomponent(el)^.s.psym)^}.instance<>tip_dispatch then
          -- m me podv˜raz specifikuj¡c¡ podprogram ?
          if el<>nil

            -- ano => pou‘ijeme ten
            then
              -- vygenerovat podv˜raz
              i_newcontext(context,newcontext,lm_imm_to_rel,nil);
              i_load(inst,info,newcontext,context,el{expr^.sub},op1);

              -- obnovit registry
              i_refresh(inst,info,context,op1);

            -- ne => adresu procedury si vygenerujeme p©¡mo
            else
              i_gen_subprogram_address(pproc,true,op1);
              end if;
          end if;


    -- pointer na proceduru
    when nc_var,nc_value do
        -- vygenerovat podv˜raz
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,el{expr^.sub},op1);

        -- obnovit registry
        i_refresh(inst,info,context,op1);

        -- pointer budeme zpracov vat po 4bytov˜ch kousc¡ch
        op1.size:=4;

        -- bude se hodit jeden registr
        newopreg(inst,info,context,optemp,4,irm_addr,op0);

        -- na‡¡st pointer na instanci
        shiftop(op1,4);
        addii(inst,info,ii_mov,optemp,op1,op0);
        unshiftop(op1,4);

        -- alokovat n vˆ¨t¡ skoku
        newtarget(info,tgcall);

        -- zjistit, zda je to platn˜ pointer na instanci
        addii(inst,info,ii_cmp,optemp,op_FFFFFFFF,op0);
        addjump(inst,info,ic_e,tgcall);

        -- ulo‘it instanci
        addii(inst,info,ii_push,optemp,op0,op0);

        -- adresa skoku na toto m¡sto
        settarget(info,tgcall,getaddr(inst));

        -- uvolnit pomocn˜ operand
        i_free(info,context,optemp);


    when others do verify(379,true);
    end case;

  -- Ondra 14.5.2002 : Tak tohle je %%X %%TODO(REGALLOC) ** KRUT ** z plata !!
  -- Podrobnˆji viz zakomentovan‚ vol n¡ SAVEREGS na za‡ tku t‚to procedury
  -- ulo‘it v¨echny pou‘it‚ registry
  -- %%X Omezit jen na registry skute‡nˆ pou‘it‚ ve volan‚ procedu©e
  saveregs(inst,info,context);

  -- instrukce
  addii(inst,info,ii_call,op1,op0,op0);

  -- uvolnit operand
  i_free(info,context,op1);

  ---- p©evz¡t v˜sledek ----
  if expr^.t.tview<>tview_null{stype<>dt_undef} then

    -- na stacku
    if call in iccs_ret_stack then
      if ptyp^.result^.pass in pps_ref

        -- odkazem
        then
          -- velikost v˜sledku
          resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

          -- adresa v˜sledku
          nullop(vysl,io_mem);
          i_alloc(inst,info,context,vysl.base,idefregsize,irm_addr);
          vysl.size:=resultsize;
          --newopreg(inst,info,context,vysl,4,irm_addr,op0);

          -- vyzvednout adresu v˜sledku (nem me n hodou kopii?)
          nullop(optemp,io_reg);
          i_use(inst,info,context,vysl.base.reg,optemp.reg,idefregsize);
          addii(inst,info,ii_pop,optemp,op0,op0);
          i_free(info,context,optemp);

          -- uvolnit prostor na stacku se d  a‘ ve chv¡li kdy bude vyzvednuta
          -- hodnota na kterou pr vˆ vrac¡me pointer

        -- na stacku je hodnota
        else
          -- velikost v˜sledku
          resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

          -- nepreferuje volaj¡c¡ ur‡itou metodu p©ed n¡ ?
          if context.outpref=iop_stack

            -- m me ¨tˆst¡, nad©azen  procedura chce v˜sledek na stacku
            then
              newopstack(inst,info,context,vysl,resultsize);

            -- jinak s t¡m nˆco udˆlat
            else
              -- zarovnat
              addalign(alignedsize,0,resultsize,istackalign);

              -- neve¨el by se v˜sledek do registru ?
              if resultsize=1 or resultsize=2 or resultsize=4{%%TODO(SET) resultsize in [1,2,4]}

                then
                  -- vyzvednout adresu v˜sledku (nem me n hodou kopii ?)
                  newopreg(inst,info,context,vysl,resultsize,irm_int,op0);

                  -- zmˆnit velikost registru na maxim ln¡ (nelze tak p©¡mo alokovat q–li ESI, EDI
                  vysl.reg.reg:=resizereg(vysl.reg.reg,alignedsize);
                  vysl.size:=alignedsize;

                  -- p©evz¡t v˜sledek, a uvolnit z sobn¡k
                  addii(inst,info,ii_pop,vysl,op0,op0);

                  -- zmˆnit velikost registru na skute‡nou
                  vysl.reg.reg:=resizereg(vysl.reg.reg,resultsize);
                  vysl.size:=resultsize;

                else
                  -- alokovat, t©eba nˆkde na stacku, prostor pro v˜sledek
                  newoptemp(inst,info,context,vysl,resultsize);

                  -- zkop¡rovat ze stacku do v˜sledku
                  i_gen_pop_static(inst,info,context,vysl,resultsize);
                  {unimplemented(34);}
                  end if;
              end if;
          end if;

    -- v EAX
    elsif call in iccs_ret_eax then
      -- velikost v˜sledku
      resultsize:=unidata_size_to_unsigned(expr^.t.getsize);

      -- v˜sledek
      newopuse(inst,info,context,vysl,resultsize,resizereg(ir_eax,resultsize));

    -- nˆjak  chyba
    else 
      verify(104,false);
      end if;

    -- chceme ulo‘it i dynamick‚ atributy ?
    if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
      i_gen_rtattrib(inst,info,context,expr,vysl);
      end if;
    end if;
  end i_gen_call_subprogram;



----------------------------------------------------------------------------------------------------
procedure i_gen_call (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du vol n¡ procedury.
----------------------------------------------------------------------------------------------------
var
  pproc            : pentity_subprogram;         -- volan  procedura

begin
  -- nal‚zt proceduru
  pproc:=pentity_subprogram(expr^.sub^.getsymbol);
  verify(513,(pproc<>nil) and not (pproc^.etype in ets_callable));

  -- vygenerovat k¢d
  i_gen_call_subprogram(inst,info,context,expr,pproc,vysl);
  end i_gen_call;



----------------------------------------------------------------------------------------------------
procedure i_gen_index (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpindex;               -- strom
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du indexov n¡ pole.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  optemp           : ioper;                      -- pracovn¡ operand
  lval             : timm32;                     -- doln¡ mez pole
  size             : timm32;                     -- velikost prvku
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  tg_end           : itarget;                    -- n vˆ¨t¡ pro skok na konec v˜po‡tu indexu

begin
  -- podv˜razy
  expr^.get(el,er);

  -- vygenerovat lev˜ podv˜raz
  i_newcontext(context,newcontext,lm_gen,nil);
  i_load(inst,info,newcontext,context,el,op1);
  verify(106,op1.optype<>io_mem);

  -- vygenerovat prav˜ podv˜raz
  -- je t©eba hodnota velikosti IDEFREGSIZE, tak‘e se typ neuv d¡
  i_newcontext(context,newcontext,lm_reg,nil);
  i_load(inst,info,newcontext,context,er,op2);

  -- obnovit registry
  i_refresh(inst,info,context,op1);
  i_refresh(inst,info,context,op2);

  -- doln¡ mez pole
  lval:=uniint_to_imm32(el^.t.getutype^.srange.getctype^.lval);

  -- velikost prvku
  size:=unidata_size_to_imm32(el^.t.getutype^.base.getctype^.size);

  -- z klad v˜sledku
  vysl:=op1;
  vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
  verify(490,vysl.optype<>io_mem);
  -- Pozor: nutn˜ p©edpoklad pro spr vn‚ o¨et©en¡ IO_CC

  -- sestavit v˜slednou adresu
  case op2.optype
    -- registr
    when io_reg do
        -- doplnit jako scale*index
        if (vysl.index.reg=ir_none) and (size=timm32(1) or size=timm32(2) or size=timm32(4) or size=timm32(8)) then
          i_use(inst,info,context,op2.reg.reg,vysl.index,idefregsize);
          vysl.scale:=imm32_to_unsigned(size);

        -- doplnit jako index
        elsif (vysl.index.reg=ir_none) then
          -- vyn sobit velikost¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako index
          i_use(inst,info,context,op2.reg.reg,vysl.index,idefregsize);
          vysl.scale:=1;

        -- dosadit jako b zi
        elsif (vysl.base.reg=ir_none) then
          -- vyn sobit velikostn¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- dosadit jako b zi
          i_use(inst,info,context,op2.reg.reg,vysl.base,idefregsize);

        -- p©i‡¡st k b zi
        else
          -- vyn sobit velikost¡ b ze
          i_gen_mul_reg(inst,info,context,op2,size);

          -- p©i‡¡st k b zi
          addopreg(inst,info,ii_add,op1.base.reg,op2);
          end if;

        -- opravit doln¡ mez
        vysl.disp-lval*size;


    -- p©¡m  hodnota
    when io_imm do
        -- offset
        op2.imm-lval;
        op2.imm*size;
        vysl.disp+op2.imm;


    -- promˆnn 
    when io_mem do
        unimplemented(71);


    -- podm¡nka
    when io_cc do
        -- z verify 490 je jasn‚, ‘e VYSL je IO_MEM

        -- n vˆ¨t¡ pro skok na konec v˜po‡tu adresy
        newtarget(info,tg_end);

        -- je sou‡ st¡ adresy nˆjak˜ registr ?
        if (vysl.base.reg<>ir_none) or ((vysl.scale=1) and (vysl.index.reg<>ir_none))

          -- ano => p©i‡¡st k nˆmu
          then
            -- skok na konec p©i nesplnˆn¡ podm¡nky
            addjump(inst,info,icondneg[op2.cc],tg_end);

            -- vyseparovat registr
            separateopreg(inst,info,context,vysl,optemp);

            -- jedenkr t p©i‡¡st velikost b ze
            addaddimm(inst,info,optemp,imm32_to_unsigned(size));

            -- uvolnit pracovn¡ registr
            i_free(info,context,optemp);

            -- adresa skoku na toto m¡sto
            settarget(info,tg_end,getaddr(inst));

          -- ne => vymyslet registr a zakomponovat ho do adresy
          else
            -- alokovat registr
            newopreg(inst,info,context,optemp,4,irm_int,op0);

            -- nacpat do nˆj velikost
            addopimm(inst,info,ii_mov,optemp,0);

            -- skok na konec p©i nesplnˆn¡ podm¡nky
            addjump(inst,info,icondneg[op2.cc],tg_end);

            -- nacpat do registru velikost b ze
            addopimm(inst,info,ii_mov,optemp,imm32_to_unsigned(size));

            -- adresa skoku na toto m¡sto
            settarget(info,tg_end,getaddr(inst));

            -- sestavit v˜sledn˜ operand
            composeop(inst,info,context,vysl,optemp,op1);
            vysl:=op1;

            -- uvolnit pracovn¡ registr
            i_free(info,context,optemp);
            end if;


    when others do verify(107,true);
    end case;

  -- posunout o intern¡ ‡ st ©etˆzce
  if el^.t.stype in dts_string then
    shiftop(vysl,lstrisize32);
  {
    verify(207,vysl.optype<>io_mem);
    imm32load(size,lstrisize32);
    imm32add(vysl.disp,size);
  }
    end if;

  -- Ondra 18.12.2002 : chceme ulo‘it i dynamick‚ atributy ?
  if (context.mode=lm_push_addr) and (context.rta<>rtattribset:[]) then
    i_gen_rtattrib(inst,info,context,expr,vysl);
    end if;

  -- uvolnit prav˜ operand
  i_free(info,context,op2);
  end i_gen_index;



----------------------------------------------------------------------------------------------------
procedure i_gen_ref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpref;                 -- reference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du reference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜razy
  instance         : pexpnode;                   -- v˜raz ur‡uj¡c¡ instanci t©¡dy
  pproc            : pentity_subprogram;         -- referencovan˜ podprogram
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  oppart           : ioper;                      -- ‡ st pointeru
  optemp           : ioper;                      -- pracovn¡ promˆnn  pro zkonstruovan˜ pointer

begin
  -- podv˜razy
  expr^.get(el);

  case expr^.t.getpclass
    -- pointer na data
    when pc_data do
        -- vygenerovat podv˜raz
        i_newcontext(context,newcontext,lm_addr,nil);
        i_load(inst,info,newcontext,context,el,vysl);

        -- obnovit registry
        i_refresh(inst,info,context,vysl);

        -- doplnit p©¡padn‚ runtime atributy
        if {context.outtyp.pattrib}expr^.t.getpattrib<>rtattribset:[] then
          -- alokovat pracovn¡ promˆnnou
          newoptemp(inst,info,context,optemp,unidata_size_to_unsigned(expr^.t.getsize));

          -- zkonstruovat cel˜ pointer
          i_gen_compose_pointer(inst,info,context,vysl,expr^.t.getctype^.base.getutype,expr^.t.getctype^.base.getutype,{context.outtyp.pattrib}expr^.t.getpattrib,optemp);

          -- uvolnit meziv˜sledek
          i_free(info,context,vysl);

          -- p©edat v˜sledek
          vysl:=optemp;
          end if;


    -- pointer na proceduru
    when pc_subprogram  do
        verify(512,(el^.ntype<>nt_component) or (el^.getsymbol=nil));

        -- referencovan˜ podprogram
        pproc:=pentity_subprogram(el^.getsymbol);
        verify(514,not (pproc^.etype in ets_callable));
        if pproc^.etype=et_virtual then unimplemented(174); end if;

        -- naj¡t instanci t©¡dy
        x_classinstance(el^.sub,instance);

        -- alokovat pracovn¡ promˆnnou
        newoptemp(inst,info,context,vysl,unidata_size_to_unsigned(expr^.t.getsize));

        -- ulo‘it adresu na podprogram do pointeru
        oppart:=vysl;
        oppart.size:=4;
        nullop(optemp,io_imm);
        optemp.size:=4;
        optemp.rtype:=irt_symbol;
        optemp.psym:=pproc;
        addii(inst,info,ii_mov,oppart,optemp,op0);

        -- adresa pointeru na instanci
        i_gen_load_rtattrib_addr({context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_instance,oppart);

        -- podprogram se nev ‘e na instanci => ulo‘it FFFFFFFF
        if pproc^.instance=tip_none then
          nullop(optemp,io_imm);
          optemp.size:=4;
          optemp.imm:=unsigned_to_imm32($FFFF_FFFF);

        -- podprogram se v ‘e na instanci, ale nem me ji => ulo‘it NIL
        elsif (pproc^.instance=tip_optional) and (instance=nil) then
          nullop(optemp,io_imm);
          optemp.size:=4;

        -- m me instanci
        elsif (instance<>nil) and (pproc^.instance<>tip_none) then
          -- vygenerovat podv˜raz
          i_newcontext(context,newcontext,lm_addr,nil);
          i_load(inst,info,newcontext,context,instance,optemp);
          
          -- obnovit registry
          i_refresh(inst,info,context,optemp);

          -- na‡¡st do registru
          i_gen_loadreg(inst,info,context,inttype_machine_pointer,optemp,false,irm_addr);
          
          --unimplemented(43);

        -- jin‚ p©¡pady nemohou nastat
        else
          verify(515,true)
          end if;

        -- nacpat do pointeru
        addii(inst,info,ii_mov,oppart,optemp,op0);

        -- pop©¡padˆ ulo‘it :tag
        if rta_tag in {context.outtyp.pattrib}expr^.t.getpattrib then
          -- adresa atributu
          i_gen_load_rtattrib_addr({context.outtyp.pattrib}expr^.t.getpattrib,vysl,rta_tag,oppart);

          -- vypo‡¡tat a ulo‘it
          i_gen_compute_rtattrib(inst,info,context,oppart,rta_tag,expr^.t.getctype^.base.getctype,expr^.t.getctype^.base.getctype);
          end if;

    -- pointer na task
    when pc_task do unimplemented(64);

    -- pointer na zpr vu
    when pc_message     do unimplemented(83);

    when others do verify(112,true);
    end case;
  end i_gen_ref;



----------------------------------------------------------------------------------------------------
procedure i_gen_deref (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpref;                 -- dereference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  newcontext       : iexprcontext;               -- kontext podv˜raz–
  ptrsize          : tunidata_size;              -- velikost vykonstruovan‚ho pointeru

begin
  -- podv˜razy
  expr^.get(el);

  -- pro nˆkter‚ re‘imy na‡ten¡ v˜razu dereference moc nedereferencuje
  case context.mode

    -- ulo‘en¡ adresy a atribut– na stack => na‡¡st kompletn¡ hodnotu pointeru
    when lm_push_addr do
        -- p©ipravit kontext
        i_newcontext(context,newcontext,lm_pointer,nil);

        -- zkonstruovat charakteristiku typu v˜sledku
        cpu^.getptrsize(context.rta,ptrsize);
        i_compose_outtyp(newcontext,dt_pointer,ptrsize,context.rta,expr^.t.getctype);

        -- vygenerovat podv˜raz
        i_load(inst,info,newcontext,context,el,vysl);


    -- adresa pointeru s ulo‘en˜mi atributy => na‡¡st adresu pointeru
    when lm_addr_attr do
        -- vygenerovat podv˜raz
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,el,vysl);


    -- cokoliv jin‚ho => dereferencovat
    when others do
        verifyx(558,context.mode in lms_addr-iexprloadmodeset:[lm_addr],expr^.pos);

        case el^.t.getpclass
          -- pointer na data
          when pc_data  do
              -- vygenerovat podv˜raz (jako unchecked machine pointer, aŸ se zbav¡me runtime atribut–)
              i_newcontext(context,newcontext,lm_pointer_reg,inttype_machine_pointer{el^.t.getutype});
              i_load(inst,info,newcontext,context,el,op1);

              -- adresa
              nullop(vysl,io_mem);
              vysl.base:=op1.reg;
              if expr^.t.hassize then
                vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
                end if;


          -- pointer na proceduru
          when pc_subprogram do
              -- vygenerovat podv˜raz
              i_newcontext(context,newcontext,lm_pointer,el^.t.getutype);
              i_load(inst,info,newcontext,context,el,vysl);

              {unimplemented(44);}


          -- pointer na task
          when pc_task  do unimplemented(65);

          -- pointer na zpr vu
          when pc_message do unimplemented(84);

          when others do verify(112,true);
          end case;

    end case;
  end i_gen_deref;



----------------------------------------------------------------------------------------------------
procedure i_gen_attrib (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpattrib;              -- atribut
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du atributu.
----------------------------------------------------------------------------------------------------
var
  op1              : ioper;                      -- operand 1
  op2              : ioper;                      -- operand 2
  newcontext       : iexprcontext;               -- kontext podv˜raz–

    ------------------------------------------------------------------------------------------------
    procedure loadrtattrib (
        rta        : in rtattrib) =
    -- Na‡ten¡ konkr‚tn¡ho run-time atributu.
    ------------------------------------------------------------------------------------------------
    begin
      -- na‡¡st adresu promˆnn‚
      i_newcontext(context,newcontext,lm_addr_attr{lm_gen},nil);
      i_load(inst,info,newcontext,context,expr^.sub,vysl);

      -- udˆlat z operandu atribut :"rta"
      i_gen_adjust_rta_position(rta,expr^.sub,vysl);

      -- na‡¡st hodnotu do registru
      i_gen_loadreg(inst,info,newcontext,nil,{nil,}vysl,false,irm_int);
      end loadrtattrib;



begin
  case expr^.aclass
    -- statick‚ atributy
    when atc_static  do
        case expr^.ata
        ---- :unchecked
        --ata_var_unchecked : i_load(inst,info,lm_gen,nil,expr^.sub,vysl);

          -- :tag
          when ata_type_tag{ata_expr_tag} do
              nullop(vysl,io_imm);
              vysl.rtype:=irt_symbol;
              vysl.psym:=expr^.sub^.t.getctype;
              --vysl.size:=ltag32;


          when others do verifyx(148,true,expr^.pos);
          end case;


    -- dynamick‚ atributy
    when atc_dynamic do
        case expr^.ata
          -- :unchecked
          when ata_var_unchecked do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);


          -- :length
          when ata_string_length do
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);

              -- zmˆnit velikost
              vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);


          -- :ord
          when ata_ord_ord do
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,expr^.sub,vysl);


          -- :last
          when ata_expr_last do loadrtattrib(rta_last);

          -- :size
          when ata_expr_size do loadrtattrib(rta_size);

          -- :length neomezen‚ho pole
          when ata_array_length do
              -- na‡¡st atribut :last
              loadrtattrib(rta_last);

              -- p©i‡¡st 1
              addii(inst,info,ii_inc,vysl,op0,op0);


          -- :tag
          when ata_expr_tag do loadrtattrib(rta_tag);

          -- :tagged
          when ata_expr_tagged do
              -- na‡¡st atribut :tag
              loadrtattrib(rta_tag);

              -- porovnat
              addii(inst,info,ii_cmp,vysl,op_0,op0);

              -- uvolnit operand
              i_free(info,context,vysl);

              -- v˜sledek je podm¡nka
              nullop(vysl,io_cc);
              vysl.cc:=ic_ne;


          when others do verify(282,true);--unimplemented(59);
          end case;

    when others do verify(147,true);
    end case;
  end i_gen_attrib;



----------------------------------------------------------------------------------------------------
procedure i_gen_typecast (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- dereference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du dereference.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- lev˜ podv˜raz
  er               : pexpnode;                   -- prav˜ podv˜raz
  arg              : pexpitem;                   -- argument
  newcontext       : iexprcontext;               -- kontext podv˜raz–

begin
  -- podv˜razy
  expr^.get(el,arg);
  er:=arg^.sub;

  -- konverze z ...
  case er^.t.tview
    -- ... unchecked na cokoliv
    when tview_unchecked do
        -- vygenerovat
        i_newcontext(context,newcontext,lm_gen,nil);
        i_load(inst,info,newcontext,context,er,vysl);

        -- velikost operandu
        vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);


    -- ... Full view ...
    when tview_full     do
        case el^.t.tview
          -- ... na Full view
          when tview_full do
              -- ordin ln¡ --> ordin ln¡
              if (er^.t.stype in dts_ordinal) and (el^.t.stype in dts_ordinal) then
                -- na‡¡st hodnotu
                i_newcontext(context,newcontext,lm_conv,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- pointer -> pointer
              elsif (er^.t.stype=dt_pointer) and (el^.t.stype=dt_pointer) then
                -- na‡¡st hodnotu
                i_newcontext(context,newcontext,lm_pointer,el^.t.getctype);
                i_load(inst,info,newcontext,context,er,vysl);

              -- jin‚ konverze neum¡me
              else 
                verifyx(611,true,expr^.pos);
                end if;
            {
              -- vygenerovat
              i_newcontext(context,newcontext,lm_gen,nil);
              i_load(inst,info,newcontext,context,er,vysl);

              -- %%X Tady chyb¡ konverze !

              -- velikost operandu
              vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);
            }


          -- ... Partial view

          when others do verify(272,true);
          end case;

    when others do verify(149,true);
    end case;

  -- vygenerovat podv˜raz
  --i_load(inst,info,,arg^.sub^.t.typ,el,op1);

  --unimplemented(56);
  end i_gen_typecast;



----------------------------------------------------------------------------------------------------
procedure i_gen_message_send (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexplist;                -- dereference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du odesl n¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  el               : pexpnode;                   -- podv˜raz
  arg              : pexpitem;                   -- argument
  opnone           : ioper;                      -- pr zdn˜ v˜sledek
  newcontext       : iexprcontext;               -- kontext v˜razu

begin
  -- podv˜razy
  expr^.get(el,arg);

  -- parametry
  if arg<>nil

    -- m  parametry
    then
      unimplemented(104);

    -- nem  parametry => na stack d t NIL
    else
      i_gen_pushstack(inst,info,context,op_0);
      end if;

  -- ‡¡slo v˜jimky
  i_newcontext(context,newcontext,lm_push_value,nil);
  i_load(inst,info,newcontext,context,el,opnone);

  -- tag
  -- %%X
  i_gen_pushstack(inst,info,context,op_0);
  end i_gen_message_send;



----------------------------------------------------------------------------------------------------
procedure i_gen_callspec (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpcallspec;            -- dereference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du odesl n¡ zpr vy.
----------------------------------------------------------------------------------------------------
var
  opnone           : ioper;                      -- pr zdn˜ v˜sledek
  newcontext       : iexprcontext;               -- kontext v˜razu
  el               : pexpnode;                   -- instance t©¡dy (je-li to metoda t©¡dy)
  arglist          : pexpitem;                   -- seznam parametr–
  op1              : ioper;                      -- operand

begin
  -- oddˆlit instanci t©¡dy/modul a parametry
  expr^.get(el,arglist);

  -- je speci ln¡ metoda ji‘ pevnˆ ur‡ena ?
  if (expr^.spec<>nil) and (el=nil)

    -- ano => zavolat ji p©¡mo
    then
      verify(581,(arglist=nil) or (el<>nil));

      -- zavolat jako norm ln¡ podprogram
      i_gen_call_subprogram(inst,info,context,expr,expr^.spec,vysl);

    -- ne => vybrat metodu podle tagu instance t©¡dy/modulu
    else
      verify(582,(el=nil) or (arglist<>nil));

      case el^.nclass
        -- podv˜raz je instance t©¡dy
        when nc_var     do
            verify(583,not el^.t.isclass);

            -- adresu instance ulo‘it na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,el,opnone);

            -- zavolat speci ln¡ metodu
            if expr^.spec=nil

              -- a to prvn¡ dostupnou
              then
                i_dispatch_special(inst,info,expr^.spectype);

              -- jinak tu pevnˆ ur‡enou
              else
                -- vr tit adresu procedury
                i_gen_subprogram_address(expr^.spec,true,op1);

                -- zavolat
                addii(inst,info,ii_call,op1,op0,op0);

                -- uvolnit operand
                i_free(info,context,op1);
                end if;


        -- podv˜raz je modul
        when nc_module  do
            unimplemented(194);


        when others do verify(406,true);
        end case;
      end if;

  -- v˜sledek ve¨ker˜ ‘ dn˜
  nullop(vysl,io_none);

{ P–vodn¡ verze pouze pro speci ln¡ metody t©¡dy:

  if expr^.sub<>nil

    -- m me podv˜raz, pod¡vat se, co je za‡
    then
      case expr^.sub^.nclass
        -- podv˜raz je instance t©¡dy
        when nc_var     do
            -- adresu instance ulo‘it na stack
            i_newcontext(context,newcontext,lm_push_addr,nil);
            i_load(inst,info,newcontext,context,expr^.sub,opnone);

            -- zavolat speci ln¡ metody
            i_dispatch_special(inst,info,expr^.spectype);


        -- podv˜raz je modul
        when nc_module  do
            unimplemented(407);


        when others do verify(406,true);
        end case;

    -- podv˜raz nem me, tud¡‘ mus¡me m¡t adresu entry rovnou k dispozici
    when others do
      unimplemented(125);
      end if;

  -- v˜sledek ve¨ker˜ ‘ dn˜
  nullop(vysl,io_none);
 }
  end i_gen_callspec;



----------------------------------------------------------------------------------------------------
procedure i_gen_this (
    inst           : in out icodeinst;           -- instance
    info           : in out igeninfo;            -- informace o pr–bˆhu generov n¡
    context        : in out iexprcontext;        -- kontext generov n¡ v˜razu
    expr           : in pexpthis;                -- dereference
    vysl           : out ioper) =                -- v˜sledek
-- Generov n¡ k¢du THIS.
----------------------------------------------------------------------------------------------------
{
var
  optemp           : ioper;                      -- pomocn˜ operand
}
begin
  -- vygenerovat adresu instance t©¡dy
  i_gen_this_addr(inst,info,context,expr^.t.getsize,uda_0,vysl);
{
  -- na‡¡st pointer na t©¡du
  nullop(optemp,io_mem);
  optemp.base.reg:=istackframereg[inst.frame];
  imm32load(optemp.disp,inst.profile.thisofs);
  optemp.size:=lpointer32;
  i_gen_loadreg(inst,info,context,optemp,true,irm_addr);

  -- udˆlat z registru adresu
  nullop(vysl,io_mem);
  i_use(inst,info,context,optemp.reg.reg,vysl.base,idefregsize);
  vysl.size:=unidata_size_to_unsigned(expr^.t.getsize);

  -- uvolnit pomocn˜ operand
  i_free(info,context,optemp);
}
  end i_gen_this;



----------------------------------------------------------------------------------------------------
procedure i_gen =
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
#if #declared ondra; then;
with
  standard.conversions;
#end if;

begin
  verify(28,(expr=nil) or (expr^.zprac<>expr^.zprac:last));

  -- vygenerovat v˜raz
  case expr^.ntype
    -- bin rn¡ oper tor
    when nt_operator  do i_gen_operator(inst,info,context,pexpoper(expr),vysl);

    -- un rn¡ oper tor
    when nt_unary     do i_gen_unary(inst,info,context,pexpunary(expr),vysl);

    -- komponenta
    when nt_component do i_gen_component(inst,info,context,pexpcomponent(expr),vysl);

    -- p©¡m  hodnota
    when nt_imm       do i_gen_imm(inst,info,context,pexpimm(expr),vysl);

    -- agreg t
    when nt_aggregate do i_gen_aggregate(inst,info,context,pexpaggregate(expr),vysl);

    -- vol n¡ procedury
    when nt_call      do i_gen_call(inst,info,context,pexplist(expr),vysl);

    -- index pole
    when nt_index     do i_gen_index(inst,info,context,pexpindex(expr),vysl);

    -- reference
    when nt_ref       do i_gen_ref(inst,info,context,pexpref(expr),vysl);

    -- dereference
    when nt_deref     do i_gen_deref(inst,info,context,pexpref(expr),vysl);

    -- atribut
    when nt_attrib    do i_gen_attrib(inst,info,context,pexpattrib(expr),vysl);

    -- p©etypov n¡
    when nt_typecast  do i_gen_typecast(inst,info,context,pexplist(expr),vysl);

    -- odesl n¡ zpr vy
    when nt_send      do i_gen_message_send(inst,info,context,pexplist(expr),vysl);

    -- vol n¡ speci ln¡ metody
    when nt_callspec  do i_gen_callspec(inst,info,context,pexpcallspec(expr),vysl);

    -- THIS
    when nt_this      do i_gen_this(inst,info,context,pexpthis(expr),vysl);

    -- jin‚ symboly tu nemaj¡ co dˆlat
    when others do
      #if #declared ondra; then;
        dumptree(expr);
        debug_dump(unsigned_to_string(expr^.ntype:ord));
      #end if;
        verify(29,true);

    end case;
  end i_gen;



----------------------------------------------------------------------------------------------------
procedure i_gen_expr =
-- Generov n¡ k¢du v˜razu.
----------------------------------------------------------------------------------------------------
var
  vysl             : ioper;                      -- v˜sledek
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- p©ipravit kontext
    i_createcontext(context,lm_gen,nil);

    -- vygenerovat v˜raz
    i_gen(inst,info,context,expr,vysl);

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_gen_expr;



----------------------------------------------------------------------------------------------------
procedure i_gen_cond =
-- Generov n¡ k¢du v˜razu.
-- Pokud je c¡l skoku nastaven na TGFALLTHRU, tak nesko‡¡ nikam.
----------------------------------------------------------------------------------------------------
var
  op1              : ioper;                      -- operand
  vysl             : ioper;                      -- v˜sledek
  cc               : icond;                      -- podm¡nka
  context          : iexprcontext;               -- kontext v˜razu
  newcontext       : iexprcontext;               -- kontext podv˜razu

begin
  verify(601,(ttarget=tgfallthru) and (ftarget=tgfallthru));

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Generovani podminky ------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat podm¡nku
    if (expr^.ntype=nt_operator) and (pexpoper(expr)^.oper in expopertypeset:[op_and,op_or,op_and_then,op_or_else])

      -- generovat ©etˆz konjunkc¡/disjunkc¡
      then
        -- p©ipravit kontext
        i_createcontext(context,lm_gen,nil);

        -- vygeneovat
        i_gen_logical_chain(inst,info,context,pexpoper(expr),ttarget,ftarget,vysl);

      -- generovat jako oby‡ejn˜ v˜raz
      else
        -- p©ipravit kontext
        i_createcontext(context,lm_gen{reg},expr^.t.getctype);

        -- vygenerovat a na‡¡st v˜raz
        i_newcontext(context,newcontext,lm_reg,nil);
        i_load(inst,info,newcontext,context,expr,op1);

        -- obnovit registry
        i_refresh(inst,info,context,op1);

        if op1.optype=io_cc

          -- p©¡mo podm¡nka
          then cc:=op1.cc

          -- je¨tˆ porovnat
          else
            -- porovnat
            addii(inst,info,ii_cmp,op1,op_0,op0);

            -- podm¡nka
            cc:=ic_nz;
            end if;

        -- uvolnit operand
        i_free(info,context,op1);

        -- v˜sledn˜ skok
        i_gen_logical_jump(inst,info,context,false,cc,ttarget,ftarget,vysl);
        end if;
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_gen_cond;



----------------------------------------------------------------------------------------------------
procedure i_load_message_code =
-- Na‡te k¢d zpr vy do EAX.
----------------------------------------------------------------------------------------------------
var
  vysl             : ioper;                      -- v˜sledek
  context          : iexprcontext;               -- kontext v˜razu
  newcontext       : iexprcontext;               -- kontext podv˜razu

begin
  verify(310,(expr^.ntype<>nt_accept) or not (expr^.sub^.nclass in ncs_message_code));

  begin
    -- p©ipravit kontext
    i_createcontext(context,lm_reg_eax,nil);

    -- vygenerovat v˜raz
    i_newcontext(context,newcontext,lm_reg_eax,nil);
    i_load(inst,info,newcontext,context,expr^.sub,vysl);

    -- obnovit registry
    i_refresh(inst,info,context,vysl);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;
  end i_load_message_code;



----------------------------------------------------------------------------------------------------
procedure i_load_expr =
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Nacteni vyrazu -----------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a na‡¡st v˜sledek
    i_load(inst,info,{new}context,context,expr,vysl);

    -- obnovit registry
    i_refresh(inst,info,context,vysl);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_expr;



----------------------------------------------------------------------------------------------------
procedure i_load_subexpr =
-- Vygeneruje a na‡te hodnotu podv˜razu.
----------------------------------------------------------------------------------------------------
begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Nacteni podvyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- vygenerovat a na‡¡st v˜sledek
    i_load(inst,info,subcontext,supercontext,expr,vysl);

    -- obnovit registry
    i_refresh(inst,info,supercontext,vysl);
  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_subexpr;



----------------------------------------------------------------------------------------------------
procedure i_load_rtattrib =
-- Na‡te po‘adovan˜ run-time atribut dan‚ho v˜razu.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_createcontext(context,lm_addr_attr,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- udˆlat z operandu atribut ":rta"
    i_gen_adjust_rta_position(rta,expr,vysl);
  {
    -- na‡¡st hodnotu do registru
    i_gen_loadreg(inst,info,context,{nil,}vysl,false,irm_int);
  }
    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int);
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_rtattrib;



----------------------------------------------------------------------------------------------------
procedure i_load_length =
-- Na‡te run-time atribut :length dan‚ho v˜razu.
-- %%X Nˆco jako z plata. Vymyslet sjednocen¡ s I_LOAD_RTATTRIB asi na b zi
-- slou‡en¡ s I_GEN_ATTRIB.
----------------------------------------------------------------------------------------------------
var
  context          : iexprcontext;               -- kontext v˜razu

begin
#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('---- Generovani vyrazu --------------------------------------------------------');
    dumptree(expr);
    end if;
#end if;

  begin
    -- na‡¡st adresu promˆnn‚
    i_createcontext(context,lm_gen,nil);
    i_load(inst,info,context,context,expr,vysl);

    -- zmˆnit velikost
    vysl.size:=4;

    -- na‡¡st do temporary promˆnn‚
    if reg
      then i_gen_loadreg(inst,info,context,nil,vysl,false,irm_int)
      else i_gen_loadtemp(inst,info,context,vysl);
      end if;

  catch
    when resume_error do
        expr^.errpos;
        raise;

    when compiler_error do
        expr^.errpos;
        raise;

    end;

#if dump then;
  if opt_dump_code in info.compv.opts then
    debug_dump('-------------------------------------------------------------------------------');
    end if;
#end if;
  end i_load_length;



----------------------------------------------------------------------------------------------------
procedure initopertab =
-- Inicializace ©¡d¡c¡ tabulky optimalizace bin rn¡ch oper tor–.
----------------------------------------------------------------------------------------------------
begin
  ---- celo‡¡seln‚ ----
  -- *
  oset1s(opertab,op_mul,dts_integer,^i_gen_op_integer_mul);

  -- div mod
  osetss(opertab,[op_idiv,op_imod],dts_integer,^i_gen_op_integer_div_mod);

  -- + - bitov‚ AND OR XOR SHL SHR
  osetss(opertab,[op_add,op_sub,op_bitand,op_bitor,op_bitxor,op_shl,op_shr],dts_integer,^i_gen_op_integer);

  -- :=
  oset1s(opertab,op_assign,dts_integer,^i_gen_op_assign);


  ---- znakov‚ ----
  -- :=
  oset1s(opertab,op_assign,dts_char,^i_gen_op_assign);


  ---- logick‚ ----
  -- AND OR
  osetss(opertab,[op_and_then,op_or_else,op_and,op_or],dts_u_logical,^i_gen_op_logical_and_or);

  -- XOR
  oset1s(opertab,op_xor,dts_u_logical,^i_gen_op_logical_xor);

  -- :=
  oset1s(opertab,op_assign,dts_logical,^i_gen_op_assign_logical);


  ---- v˜‡tov‚ ----
  -- :=
  oset1s(opertab,op_assign,dts_enum,^i_gen_op_assign);


  ---- ordin ln¡ typy obecnˆ ----
  -- < <= > >= <> =
  osetss(opertab,[op_lt,op_le,op_gt,op_ge,op_ne,op_eq],dts_ordinal,^i_gen_op_compare_ordinal);


  ---- pointery ----
  -- :=
  oset11(opertab,op_assign,dt_pointer,^i_gen_op_assign_pointer);

  -- <> =
  osetss(opertab,[op_ne,op_eq],dts_pointer,^i_gen_op_compare_pointer);


  ---- ©etˆzce ----
  -- :=
  oset1s(opertab,op_assign,dts_string,^i_gen_op_assign_string);

  -- &
  oset1s(opertab,op_concat,dts_string,^i_gen_op_concat_string);

  -- < <= > >=
  osetss(opertab,[op_lt,op_le,op_gt,op_ge],dts_string,^i_gen_op_order_string);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_string,^i_gen_op_compare_string);

  ---- pole ----
  -- :=
  oset1s(opertab,op_assign,dts_array,^i_gen_op_assign);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_array,^i_gen_op_compare_array);


  ---- mno‘iny ----
  -- :=
  oset11(opertab,op_assign,dt_set,^i_gen_op_assign);

  -- + - *
  osetss(opertab,[op_union,op_diff,op_isect],dts_set,^i_gen_op_set);

  -- IN NOT IN
  osetss(opertab,[op_in,op_notin],dts_u_set,^i_gen_op_in_set);

  -- = <>
  osetss(opertab,[op_eq,op_ne],dts_set,^i_gen_op_compare_set);


  ---- recordy ----
  -- :=
  oset11(opertab,op_assign,dt_record,^i_gen_op_assign);

  -- = <>
  osets1(opertab,[op_eq,op_ne],dt_record,^i_gen_op_compare_record);


  ---- tagy ----
  -- :=
  oset1s(opertab,op_assign,dts_tag,^i_gen_op_assign);


  ---- t©¡dy ----
  -- :=
  oset1s(opertab,op_assign,dts_class,^i_gen_op_assign);

  ---- unchecked ----
  --oset11(opertab,op_assign,st_unchecked,^i_gen_op_assign);
  end initopertab;



----------------------------------------------------------------------------------------------------
entry =
-- Inicializace.
----------------------------------------------------------------------------------------------------
begin
  initopertab;
  end entry;



end ci_expr;