----------------------------------------------------------------------------------------------------
module private cl_resolver =
-- P©eklada‡ Flexu.
-- Vyhodnocova‡ cross-referenc¡ a adres.
----------------------------------------------------------------------------------------------------
-- Ondra : 12.04.2002 : Vytvo©il
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
class private {%%TODO(ABSTRACT) abstract} linkresolver =
-- Vyhodnocova‡ cross-referenc¡ a adres.
----------------------------------------------------------------------------------------------------

    with
      cx_expr,
      cx_expr.cx_imm
#if #declared hynek; #and then; hynek then;
      ,standard.console
#end if;
      ;

#if #declared hynek; #and then; hynek then;
        --------------------------------------------------------------------------------------------
        static markmodules (reg  : in pregion) =
        -- Ozna‡en¡ modulu dekl. regionu region a vnorenych regionu
        --------------------------------------------------------------------------------------------
        var
          entity   : pentity;
          region   : pregion;

        begin
          region:=reg;
          while region <> nil loop
            if region^.rtype = rt_component then
              entity:=region^.entities.first;
              while entity <> nil loop
                if entity^.etype=et_program and entity^.linked=ls_undef then 
                  --this.libs.add(entity); 
                  --entity^.linked:=ls_used;
                  mark(entity);
                  end if;
                entity:=entity^.next;
                end loop;
              end if;

            if region^.regions.first<>nil then 
              markmodules(region^.regions.first); 
              end if;
            region:=region^.next;
            end loop;

          end markmodules;
#end if;

    ------------------------------------------------------------------------------------------------
    static mark =
    -- F ze 1: Ozna‡en¡ symbol– pro linkov n¡.
    ------------------------------------------------------------------------------------------------

    with
      cc_base,
      cc_base.cc_sym;

        --------------------------------------------------------------------------------------------
        procedure marktype =
        -- Ozna‡en¡ typu/t©¡dy na vyhodnocen¡.
        --------------------------------------------------------------------------------------------
        var
          ancestor : pentity_type;               -- p©edek vyhodnocovan‚ho typu

        begin
          verify(388,tf_tagged not in pentity_type(curr)^.tflags);

          -- za©adit p©edka na vyhodnocen¡ (pokud je t‚‘ tagged)
          if curr^.ancestor.isset then
            pentity(ancestor):=curr^.ancestor.getcentity;
            if tf_tagged in ancestor^.tflags then mark(ancestor); end if;
            end if;

          -- za©adit na vyhodnocen¡ v¨echny speci ln¡ metody
          for tst in pentity_type(curr)^.stable:range loop
            if pentity_type(curr)^.stable[tst].isset then
              mark(pentity_type(curr)^.stable[tst].getcentity);
              end if;
            end loop;  

          -- za©adit typ na vyhodnocen¡
          this.typedesc.add(curr);
          end marktype;

        
#if #declared hynek; #and then; hynek then;
        --------------------------------------------------------------------------------------------
        procedure markenclosed =
        -- oznaceni exportu
        --------------------------------------------------------------------------------------------
        var
          region       : pregion;
          entity       : pentity;
          
        begin

          -- specialni pripad pro library
          if export<>nil then
            entity:=sym_get_enclosing_or_self(curr, et_module);
              if entity<>nil and then pentity_module(entity)^.lib_info<>nil then
                region:=curr^.regions[rc_primary];
                if region<>nil then 
                  entity:=region^.entities.first;
                  while entity<>nil loop
                    mark(entity);
                    entity:=entity^.next;
                    end loop;
                  end if;
                end if;
            end if;
          end markenclosed;
#end if;

    var
      srch         : tentitysearch;              -- hled tko

    begin

      -- ji‘ ozna‡en˜mi symboly se nezab˜vat
      if curr^.linked<>ls_undef then return; end if;

      -- ozna‡it symbol jako pou‘it˜
      curr^.linked:=ls_used;

      -- promˆnn 
      if curr^.etype=et_var then
        case pentity_var(curr)^.mclass
          -- statick 
          when mc_static do
              -- za©adit do p©¡slu¨n‚ho datov‚ho segmentu
              if pentity_var(curr)^.init.isset and not imm_isnil(pentity_var(curr)^.init.getimm^)
                -- inicializovan  promˆnn 
                then this.idata.add(curr)
                -- neinicializovan  promˆnn 
                else this.data.add(curr)
                end if;

          -- taskov 
          when mc_task do unimplemented(1);

          when mc_class do { nic nedelat }

          when others do verify(191,true);
          end case;

      -- prvek obsahuj¡c¡ k¢d
      elsif curr^.etype in ets_code then
        if (curr^.etype=et_procedure{in ets_subprog}) and (pentity_procedure{subprog}(curr)^.import<>nil)

          -- extern¡ symbol
          then
            this.import.add(curr);

           -- norm ln¡ symbol
          else
            verify(584,pentity_code(curr)^.codegen=nil);

            -- symbol za©adit pro pozdˆj¨¡ vyhodnocen¡
            this.code.add(curr);

            -- trasovat tabulku relokac¡
            this.trace(curr);
            end if;

      -- typ
      elsif curr^.etype=et_type then
        -- za©adit na vyhodnocen¡
        marktype;

      -- t©¡da
      elsif curr^.etype=et_class then
        
        -- za©adit na vyhodnocen¡
        marktype;

        -- za©adit na vyhodnocen¡ v¨echny metody z tabulky virtu ln¡ch metod
        if pentity_type(curr)^.vtable<>nil then
          for i in pentity_type(curr)^.vtable^:range loop
            if pentity_type(curr)^.vtable^[i]<>nil then
              mark(pentity_type(curr)^.vtable^[i]);
              end if;
            end loop;
          end if;  
      {
        -- za©adit na vyhodnocen¡ v¨echny speci ln¡ metody
        srch.find_et_first(curr,et_special,tesearchflagset:[]);
        while srch.psym<>nil loop
          mark(srch.psym);
          srch.find_et_next;
          end loop;
      }

#if #declared hynek; #and then; hynek then;
        markenclosed;
#end if;

      -- zpr va
      elsif curr^.etype=et_message then
        succ this.msgnum;
        pentity_message(curr)^.num:=this.msgnum;
        --unimplemented(3);

      -- dal¨¡ prvky
      elsif curr^.etype in ets_enclosed then
#if #declared hynek; #and then; hynek then;
        markenclosed;
#end if;

      -- nic jin‚ho tu nem  co dˆlat
      else 
        verify(32,true);
        end if;

    {
      -- proj¡t lok ln¡ tabulku symbol–
      p:=curr^.symtab;
      while p<>nil loop
        if p^.etype in ets_code+ets_enclosed{-[et_module]} then mark(p); end if;
        p:=p^.next;
        end loop;
    }

      end mark;



    ------------------------------------------------------------------------------------------------
    virtual link =
    -- F ze 2: Vlastn¡ sestaven¡.
    ------------------------------------------------------------------------------------------------
    begin
      end link;



    ------------------------------------------------------------------------------------------------
    virtual info =
    -- V˜pis souhrnn˜ch informac¡ do listingu.
    ------------------------------------------------------------------------------------------------
    begin
      end info;



    ------------------------------------------------------------------------------------------------
    virtual getaddrbase =
    -- Adresa, ke kter‚ se vztahuj¡ relokace.
    ------------------------------------------------------------------------------------------------
    begin
      end getaddrbase;



    ------------------------------------------------------------------------------------------------
    virtual getentrypoint =
    -- Entrypoint programu.
    ------------------------------------------------------------------------------------------------
    begin
      end getentrypoint;



    ------------------------------------------------------------------------------------------------
    virtual checkseg =
    -- True, pokud se m  zadan˜ segment zahrnout do EXE.
    ------------------------------------------------------------------------------------------------
    begin
      end checkseg;



    ------------------------------------------------------------------------------------------------
    virtual getsegbase =
    -- B zov  adresa segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      end getsegbase;



    ------------------------------------------------------------------------------------------------
    virtual getsegtotal =
    -- Celkov  velikost segmentu.
    ------------------------------------------------------------------------------------------------
    begin
      end getsegtotal;



    ------------------------------------------------------------------------------------------------
    virtual writesegment =
    -- Do v˜stupn¡ho souboru zap¡¨e zadan˜ segment.
    ------------------------------------------------------------------------------------------------
    begin
      end writesegment;



    ------------------------------------------------------------------------------------------------
    virtual trace = 
    -- Projde tabulku relokac¡ symbolu CURR a pro ka‘d˜ symbol zavol¡ MARK.
    ------------------------------------------------------------------------------------------------
    begin
      end trace;



    ------------------------------------------------------------------------------------------------
    virtual linkimport =
    -- P©¡prava pro linkov n¡ importovan˜ch funkc¡.
    ------------------------------------------------------------------------------------------------
    begin
      end linkimport;



#if #declared hynek; #and then; hynek then;
    ------------------------------------------------------------------------------------------------
    virtual linkexport =
    -- P©¡prava pro linkov n¡ exportovan˜ch funkc¡.
    ------------------------------------------------------------------------------------------------
    begin
      end linkexport;
#end if;
    
    end linkresolver;



----------------------------------------------------------------------------------------------------
procedure ffillz (
    os             : in p_output_stream;
    size           : in t_unsigned) =
-- Zap¡¨e do souboru zadan˜ po‡et nulov˜ch byt–.                              
----------------------------------------------------------------------------------------------------
with
  standard.numerics;

var
  -- v˜pl¤: nuly 
  fill_zeros       : const array t_unsigned8 of t_unsigned8 := nil;
                                               
var
  i                : t_unsigned;
  j                : t_unsigned;

begin
  i:=size;
  while i>0 loop
    j:=min_unsigned(i,fill_zeros:size);
    os^.writex(fill_zeros,j);
    i-j;
    end loop;
  end ffillz;



----------------------------------------------------------------------------------------------------
#separate private cl_ia32;
-- Vyhodnocova‡ cross-referenc¡ a adres: IA-32.
----------------------------------------------------------------------------------------------------

end cl_resolver;